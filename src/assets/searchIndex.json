[
  {
    "id": "Javascript/D3.js 學習筆記.md",
    "title": "D3.js 學習筆記",
    "content": "D3.js 學習筆記 環境設定 方法 union() 合併多個集合 index() 多維排序 entries() 回傳包含和指定物件的屬性名稱和屬性值的陣列或關聯數組",
    "path": "Javascript/D3.js 學習筆記.md",
    "category": "Javascript"
  },
  {
    "id": "Javascript/Javascript 事件.md",
    "title": "Javascript 事件",
    "content": "Javascript 事件 > 參考資料： > > 重新認識 JavaScript: Day 14 事件機制的原理 > > 瀏覽器中的事件循環 (Event Loop) 事件流程 假設有兩個元素：outer, inner 此時當點擊 inner 的時候，也代表同時點擊 outer，甚至實際上我們也點擊到整個網頁。 事件流程(Event Flow)指的就是`網頁元素接收事件的順序`。 - 事件流程可以分為兩種機制： - 事件冒泡(Event Bubbling) - 事件捕獲(Event Capturing) 事件冒泡 事件冒泡的意思是：從啟動事件的元素節點開始，逐層向上傳遞，直到整個網頁的根節點，也就是 `document`。 如上面程式碼，假設點擊了 click 元素，那在`事件冒泡`的機制下，觸發事件的順序會是： 1. ` CLICK ` 2. ` ` 3. ` ` 4. `document` 向這樣 click 事件逐層向上依序被觸發，就是事件冒泡。 事件捕獲 事件捕獲和事件冒泡的機制正好相反 今點擊 click 後，事件捕獲的機制會是： 1. `document` 2. ` ` 3. ` ` 4. ` CLICK ` 機制執行邏輯 當事件被觸發時，兩種事件傳遞的機制都會執行。 假設現在的事件為點擊 ` c `，當事件發生時，會先執行`事件捕獲(capture phase)`： 1. `document` 2. ` ` 3. ` ` 4. ` ` 5. ` ` 6. ` ` 7. ` ` (實際被點擊的元素) 由上而下依序觸發他們的 click 事件。 藉著再繼續執行`事件冒泡(bubble phase)`，反方向由 ` ` 一路向上傳至 `document` 結束整個事件流程。 若要檢驗事件流程，可以透過`addEventListener()` 方法來綁定 click 事件： 當點擊 `子元素`時，透過`console.log()`可以觀察到事件觸發的順序。 若點擊`父元素`，則出現 當點擊子元素時，父層的`捕獲` 會先被觸發。然後到子層內部的 `捕獲`接著`冒泡`事件，最後才又回到父層的`冒泡`結束。 那子層的`捕獲`或`冒泡`的順序要依程式碼的順序而定。 若是`捕獲`在`冒泡`前面： 則會得到 若是將兩段程式碼順序相反，結果如下： 註冊事件的綁定 除了 `addEventListener()`方法，綁定事件的方式還有其他方法。 on-event 處理器 (HTML 屬性) 對 html 標籤而言，只要支援某個`事件`的觸發，就可以透過 `on + 事件名`的屬性來註冊事件： 如同上面範例，透過 `onclick`事件，就可以在 ` `標籤上面註冊 `click`事件，也就是當使用者按下 ` `標籤時，就會執行 `conaole.log('HI');`的程式碼。 但基於程式碼的使用性與維護性考量，現在不建議用此方法來綁定事件。 on-event 處理器(非 HTML 屬性) 像是 `window`或`document`此類沒有實體元素的情況，一樣可以用 DOM API 提供的`on-event 處理器(on-event handler)`來處理事件 上面程式碼會在 `window`觸發 `load` 事件時，執行相對應功能。 另外，若是實體元素也可透過 DOM API 取得 DOM 物件後，在透過 on-event 處理器來處理事件。 ㄊ 若想解除事件，則重新指定`on-event hendler`為`null` 事件監聽`EventTarget.addEventListener()` `.addEventListener()`有三個參數，分別為`事件名稱`、`事件處理器`、`執行機制`。 - 事件名稱：HTML DOM 事件，為字串 - 事件處理器：事件觸發時執行的 function - 執行機制(boolean)：決定事件以捕獲或是冒泡機制執行。 用此方法來註冊事件的好處是可以重複指定多個`處理器(handler)`給同一個標籤的同一個事件。 點擊觸發事件： 若是要解除事件的註冊，則是透過 `removeEventListener()`來取消。 HTML DOM 事件 > 參考資料： > > HTML DOM 事件 HTML DOM 事件允許 javascript 在 html 檔案中註冊不同事件處理程序。 事件通常和函式結合使用，函式不會在事件發生前被執行(如使用者點擊按鈕)。 DOM Event 事件名稱整理 | 屬性 | 描述 | | :----------: | --------------------------------- | | blur | 物件失去焦點時 | | change | 物件內容改變時 | | click | 滑鼠點擊物件時 | | dblclick | 滑鼠連點二下物件時 | | error | 當圖片或文件下載產生錯誤時 | | focus | 當物件被點擊或取得焦點時 | | keydown | 按下鍵盤按鍵時 | | keypress | 按下並放開鍵盤按鍵後 | | keyup | 按下並放開鍵盤按鍵時 | | load | 網頁或圖片完成下載時 | | mousedown | 按下滑鼠按鍵時 | | mousemove | 介於 over 跟 out 間的滑鼠移動行為 | | mouseout | 滑鼠離開某物件四周時 | | mouseover | 鼠離開某物件四周時 | | mouseup | 放開滑鼠按鍵時 | | resize | 當視窗或框架大小被改變時 | | scroll | 當捲軸被拉動時 | | select | 當文字被選取時 | | submit | 當按下送出按紐時 | | beforeunload | 當使用者關閉(或離開)網頁之前 | | unload | 當使用者關閉(或離開)網頁之後 |",
    "path": "Javascript/Javascript 事件.md",
    "category": "Javascript"
  },
  {
    "id": "Javascript/Javascript 學習筆記.md",
    "title": "Javascript 學習筆記",
    "content": "Javascript 學習筆記 - Javascript 學習筆記 - 基本概念 - 宣告與命名 - let, const 特性 - 如何分辨使用 let 和 const 的時機？ - let 和 const 解決了什麼問題？ - javascript 參數傳遞方式 - 存取資料的方法 - 基本型別 - 物件型別 - 把基本型別當作參數傳入函式 - Function - First-class Object - 宣告 function - 呼叫 function - IIFF 立即函式 - Scope 作用域 - 參數傳遞 call by value/reference//shares - call by value(pass by value) 傳值 - call by reference 傳址 - 運算式與運算子 - 嚴謹模式 - 賦值運算子 - 比較運算子 - 算數運算子 - 邏輯運算子 - 其餘運算子與展開運算子 - 三元運算式 - if else - 流程判斷與迴圈 - switch - while 迴圈 - for 迴圈 - for...in 與 for...of - 函式 function - 定義函式 - 箭頭函式 - Scope 變數的有效範圍 - Hoisting 提升 - 變數提升 - 函式提升 - 為何會有 Hoisting 的現象？ - 最佳實踐 - 全域變數 - closure - Promise - 如何使用 Promise - 狀態 - then 的使用 - 錯誤處理 - finally - async/await 同步操作 - document - `createdElement()` 建立節點 - `appendChild()` 增加子節點 - `.querySelector` 元素選擇器 - `.querySelectorAll` 選取所有指定元素 - `setAttribute()` 增加標籤屬性 - 移除 HTML 元素 - 使用 CSS 隱藏元素 - `removeChild()` 從 DOM 中完全移除元素 - `remove()` ES6 新方法 - `addEventListener()` 事件監聽 - `removeEventListener()` 取消事件監聽 - Math - `Math.round` 四捨五入 - 物件取值、新增與刪除 - 物件取值 - 物件轉為陣列 - 新增物件屬性 - 刪除物件屬性 - SET 集合物件 - 基本使用 - 陣列與集合間轉換 - 過濾陣列中重複的元素 - Map 物件 - JSON 轉換 - `JSON.stringify` 將物件轉為 json 字串 - `JSON.parse` 將 json 字串轉換為物件 - 轉換陣列為字串 - toString() - join() - 使用型別轉換 - 轉換字串為數值 - parseInt() 將字串轉換為以十進位表示的整數。 - parseFloat() - Number() - 計時器 - setTimeout() - setInterval() - 屬性描述器 - 使用字面值宣告屬性的特徵 - 取得屬性特徵 - Object.defineProperty 設定單一個屬性描述器 - Object.defineProperties 一次設定多個屬性 - 資料描述器 - writable 屬性是否可以改值 - Configurable 是否可編輯該屬性 - Enumerable 屬性是否會在物件的屬性列舉時被顯示 - value 屬性的值 - 屬性描述器屬於淺層設定 - 存取器描述器 - 宣告方式 - Getter - setter - 資料處理器與存取器處理器 - 取值器與設值器的應用 - 解構賦值 - 從陣列解構賦值 - 從物件解構賦值 - 非物件或非陣列解構賦值 - 解構賦值時給予預設值 - 搭配函式的傳入參數使用 - Linked list 鏈結串列 - 定義 - 類型 - 優缺點比較 - 額外補充 - 函式註解模版 - random 公式 > 參考資料： > > 重新認識 javascript 基本概念 - Javascript 的原始值(基本型別/primitive type)： - null(empty) - undefined(預設/未定義) - string(\"12345\") - number(12345) - boolean(true/false) - symbol(ES6) - Javascript 的複合值(物件 => object)：包含一個或多個原始值，像是物件或是物件實字，除了基本型別以外的型別都是物件 - 物件：使用 new 關鍵字建立物件 - 物件實字 - 陣列 - 用 new 建構出來的是物件 object - 只有建構式，則會轉為原始值 - 複合值在 javascript 是透過記憶體中的位址來比對 - 將不同型態的物件通通轉為字串 \\`${}\\` 在大括號中加入變數 - 宣告原始值：單獨放一個記憶體位址 以 by value 運作 - 宣告複合值：包含許多原始值，但是只放在一個記憶體位置 以 by reference(參考) 運作 - 更改變數為參考物件(複合值)內的原始值，記憶體位址不變 - 更改變數為原始值，會更改變數的記憶體位址 - undefined 這地方沒有這個東西，所以你無法使用 - NaN 要轉型成數字時傳入參數非數字的時候 - null 這地方會有一個值，但這個值目前還沒準備好的意思，所以先填入 `null` - this - 物件掛在誰身上就是`this`，`this`只在當下單一層的作用域裡有效果，箭頭函式就不會。 - 如果宣告變數，則在宣告當層以及內層為有效範圍。 - 單純的呼叫`this`，`this`會變成 Global .bind //定義 function 內的 this 是什麼 宣告與命名 - 命名規則 - 開頭字元需要是 ASCII 字元(英文小寫)，或是下底線(\\_)、錢號($)。開頭字元不得使用數字。 - 大小寫敏感 - 名稱不得使用保留字 注意 下底線開頭的命名常為特別用途：如類別中的私有變數、常數或方法。錢符號也通常為特殊用途命名。 變數與方法名稱都用小駝峰式的命名，類別用大駝峰式命名。 在 ES5 之前都只會用 `var` 宣告變數，在 ES6 之後加入 `let` 和 `const`，現在應以新加入的特性進行宣告。 let, const 特性 - 區塊作用域 - 變數只存活在 {} 花括號裡面，外面不能調用 - 變量會提升，但若未宣告該變數，會回報錯誤，而非 undefined - var 變數的宣告，初始預設值為 undefined，但 let, const 不會有這個預設，當執行 let 變數宣告語句時，才會初始化且能夠被訪問。 - 不允許重複宣告 - 全域變數不會成為 window 的屬性 如何分辨使用 let 和 const 的時機？ > 如果變數會變，就使用 let，不變就用 const 更改指的是記憶體地址的改變，而不是值的改變 - 記憶體存放變數的原則： - 基本型別值： - 字串、數值、undefined、null、symbol - 以上不能更改他的值，只能重新賦值，此時會更改記憶體位址 - 引用值： - 物件、陣列、函式 - 可以修改裡面的值，這樣不會更改記憶體位置，但若重新賦予一個新的值，就會更改記憶體位址。 let 和 const 解決了什麼問題？ 用 var 宣告時，容易導致意外汙染全域變數的問題，例如，區域變數覆蓋全域變數 在 func 方法中用到全域變數 food，組合字串及回傳。 但如果程式碼變得複雜時，沒注意到 food 已經在第一行宣告過了 javascript 參數傳遞方式 > 可能是 Call by sharing 下面的例子，原始型別的 mtString 傳遞給 target 的結果符合 call by value 的行為 但當我們將 myObj 傳遞給 target 時，為何也出現和 call by value 的行為相同的結果？ 當宣告完 `function setAsLiteralObj()` 後的記憶體位置狀況，`setAsLiteralObj()` 其實是被當成一個變數，指向 `function setAsLiteralObj()` 的內容。 當呼叫 `setAsLiteralObj()`，此時 `myString` 會將記憶體位置指派給 function 中的 `target` 參數，可以理解為在乎叫 function 時，宣告參數： 因此記憶體位置會變成 `myString` 與 `target` 都會指向同一個位置。 此時在 function 中，將 `target` 透過字面值賦值 `{}`，所以 `target` 會從原本指向 `hello world` 改成指向我們剛創造出來的 `{}` 當呼叫 function 時傳入的參數為 `object` 時，也是一樣的概念 `setAsLiteralObj(myObj)`，`myObj` 會被指派給 function 的參數 `target`。此時，`target` 與執行 `setAsLiteralObj(myString)` 時的 `target` 不同，下面將以 `target'` 代稱被指配 `myObj` 的新 `target`。 在 `target = {}` 時，`target'` 被賦值 `{}`，因此原來 `target'` 從原本指向 `{prop1: 123}` 改成指向剛剛創造出來的 `{}` 位置。 結果就是 `myString` 和 `myObj` 依然指向原來的記憶體物件，而這些記憶體物件的內容都沒有被改變，改變的只有 `target` 和 `target'` 指向的記憶體位置而已 存取資料的方法 - 基本類型：傳值(pass by value) - 物件類型：傳址(pass by reference)、pass by sharing 基本型別 當一個變數被賦予基本型別的值時，整個值就會存在記憶體中。 當複製基本型別的值到另一個變數時，只會複製他們的值，而該兩變數並不會影響到對方。 這個情況稱作傳值。 一開始 boxA 和 boxB 只是各自複製了 box1 和 box2 的值，boxA 和 box1，以及 boxB 和 box2 是沒有關係的，所以當要重新賦值給 boxA. boxB 時，box1, box2 不會受到影響。 物件型別 當變數被賦予是物件型別的資料時，記憶體會被存放該物件在記憶體中的位置，並引用該地址來指向該物件。 當複製一個物件到另一個變數時，複製的是該物件的地址，若此物件有被修改，所有引用該物件的變數，值都會被修改 但若將變數重新賦予一個新變數 當一個變數被重新賦予一個新的物件，並非修改該物件，因此地址整個變了，並指向另一個新的物件。 把基本型別當作參數傳入函式 當我們把基本型別當作參數傳入函式時，函式的參數會複製那些基本型別的值，所以在函式外的變數並不會被影響。 以上例子中，像之前提及的傳值概念一樣，a 和 b 複製了 box1, box2 的值。即使修改 a 和 b，box1, box2 都不會被修改。 Function > 可以將 javascript 的 function 看做是可執行的物件，其有兩大特性： > > 是 first-class Object > 有自己的 Scope First-class Object 對物件型別能做的事情，也能對 function 做 - 將 function 自由指派給變數或屬性 function 可以自由指派給其他參數，當印出 `a`/`myObj.fn` 時，會 log 整個 `myFunction` 的內容。此時變數/屬性的內容是 `myFunction`，因此當加上 `()`，就會執行 function。 - 為 function 加上屬性 - 當作 Expression 使用 `function` 可以搭配各種運算元用，甚至也可以放在 if 中判斷 if 判斷的是 `function` 是否被正式宣告，未加上 `()` 時，`function` 不會被執行 - 可以在任何地方宣告 和物件一樣，可以在任何地方宣告，也可以在 function 中宣告一個 function，甚至在傳入參數時宣告 宣告 function 宣告的方法主要有三種： - function declaration - function expression function 可以被傳遞給其他參數儲存。如字面值一般， function 也可以在定義的同時賦予變數。 也因為此宣告方式會將 function 傳遞給一個變數，因此 javascript 允許 function 搭配匿名函式使用： - with function constructor 和其他的內建物件型別相同，function 也可以利用 new 來新增物件 若用 function expression 也有相同效果 因此一般而言會使用 function expression 取代 new 來增加易讀性與效能 呼叫 function - 一般呼叫 在 function 後面加上 `()` 就可以呼叫 function - 使用 function 內建函式呼叫 function 中有內建 `call` 和 `apply` 函式可以用來呼叫 function 和使用 `()` 來執行 function 的差別在於內建函式具有明確指定 this 的功能。 `call` 和 `apply` 函式的差異在於 apply 的第二個參數為陣列，裡面帶要傳入 `function` 的參數，因此在範例中可以看到 `apply` 的第二個參數為 `['hello world', 123]`，這兩個參數會被攤開為 `parameter1` 和 `parameter2` 後放入 `myFunction` 中執行 - 使用 new 呼叫 使用 new 代表 function 當作建構式來使用，會回傳子行別為該 function 的物件 IIFF 立即函式 > (Immediately Invoked Function Expression) 或稱自我調用函式 > > 是一種在定義後立即執行的函式表達式 IIFE 有兩種特性： - 當程式執行到 IIFE 的宣告位置時，IIFE 會自動執行 - 為一種 function expression 不需要額外呼叫就會自己執行，重點除了包裹 function 的 `()` 外，還有用來呼叫 function 的 `()`。 若未加上最後面呼叫 function 的 `()`，此 function 便不會自動執行。 IIFE 回傳值 IIFE 除了會自動執行以外，與一般 function 的特性都是一模一樣的。 使用 IIFE 的原因： 1. 作用域隔離：IIFE 可以創建一個新的作用域，防止變數污染全域作用域。避免變數名稱衝突或保護敏感資訊。 2. 模組化：IIFE 可以用於創建模組，將程式碼組織成可重複使用且相對獨立的片段。這有助於提高程式碼的可讀性與維護性。 3. 防止變數提升：IIFE 可以有效防止變數提升(hoisting)，確保函式內部聲明的變數不會污染外部作用域。 ES6 的`const`和`let`，取代立即函式避免汙染全域的優點 Scope 作用域 > Scope: 規範哪些變數在哪些程式碼中可以取用的規則 > > javascript 和大多數的語言都是採用 Lexical Scope(語彙範疇) - Lexical Scope 語彙範疇 代表著區塊間的包裹關係，被包裹在內層的區塊可以保護自己的變數不被外層取用；相反的，外層區域的變數還是可以被內層區塊使用 在 function 的 `{}` 區塊中宣告一個新的變數 `inner`，此一變數可以在 `myFunction(){}` 的區塊裡被取用，然而當 `myFunction(){}` 區塊外試圖取用 `inner` 時，就會發生 `innerVar is not defined` 的錯誤。 - 參數也屬於內層 scope 執行 `setAsLiteralObj(myString);` 時，`myString` 會將記憶體位置指派給 `function` 中新的參數 `target`，也就是 `target` 是再執行 `setAsLiteralObj` 時才建立的新參數，新參數 `target` 是屬於 `setAsLiteralObj` 這個 `function` 區塊，因此在外層印 `target` 時，一樣會得到錯誤訊息。 - 巢狀 scope 參數傳遞 call by value/reference//shares call by value(pass by value) 傳值 數字快打 當執行計算後， x 和 y 的值並沒有改變，因為傳入的並不是 x 和 y 的值，而是當 function 呼叫時，複製 x 和 y 的值並宣告為新的變數 a 和 b。 call by reference 傳址 為當一個變數型別為物件時，其傳遞至 function，在 function 中宣告的變數會指向外部的變數，因此，當修改 function 中的變數時，會改變外部的變數。 運算式與運算子 嚴謹模式 - 宣告在主程式開頭：Global Scope，所有的程式都會在嚴謹模式下執行。 - 宣告在函數開頭：Function Scope，只有該函數內的程式會在嚴謹模式下執行。 - 嚴謹模式需要明確的宣告，未明確宣告`this`也會失效，這樣比較不會因為拼錯字而產生污染 - 在非嚴謹模式下如果沒有用 var 宣告變數，而直接賦值，會直接將此變數作宣告 - 嚴謹模式下並不會幫你執行，程式完全不跑 賦值運算子 - 賦值 - 賦予左方運算元與右方運算元相同之值。`x = y` 會把`y`的值賦予給`x`。 - 加法賦值 - 減法賦值 比較運算子 `==`：等於 `!=`：不等於 - 如果運算元相同型別，就使用嚴格比較去檢驗。 - null 跟 undefined 相同。 - 運算元一個是數值，一個是字串，會將字串轉數字，再進行比較。 - 其中一個是 true 或 false 會轉成數字的 1 或 0，再進行比較。 - 其中一個是物件，另一個是字串或數值，物件會先轉成基型值，再進行比較。 `===`：嚴格等於 `!==`：嚴格不等於 - 先判斷運算元的型別是否相同，若不相同，結果為 false。 - null 與 undefined 都跟自己相等。 - true 與 false 都跟自己相等。 - NaN 不等於任何值，包括自己。 - 只要是 number 型別的值一樣，他們就相等。 - 0 跟-0 相等。 - string 長度跟內容不一樣，包括空白，它們就不相等。 - 如果參考至同一個物件、陣列、函式，相同的記憶體位置，他們就相等，若無，就算內容的值一樣，它們也不相等，不同的記憶體位置存相同的值。 `>`：大於 `>=`：大於等於 ` `不是運算子，是箭頭函式。 算數運算子 - `%` 回傳兩個運算元相除後的餘數。 - `++` 將運算元增加 1。 - `--` 將運算元減少 1。 邏輯運算子 - `&&` // `and` 前後全部為 `true` ，才會是 `true`，否則都返回 `false` - `||` // `or` 前後只要一個是 `true` 就會返回 `true`，除非全部都是 `false` - `!` // `not` 將後面的值做反向，如果是 `true` 就返回 `false`，如果是 `false` 就返回 `true` - `!!` // `true`反轉再反轉，返回原本的布林值。 大多用在轉換一些可以形成布林值的情況。 而經過`!!`運算後，只會很單純出現`true` or `false`，可以單純化減少某些特殊情況出錯的機率。 例如：希望\"空字串\"和`null`被視為完全相同時 - 短路邏輯(短路解析) Javascript 裡面只要是 `0`、`\"\"`、`null`、`false`、`undefined`、`NaN` 都會被判定為 `false` - 用 || 來設定變數預設值 如果 obj 存在的話就維持原樣，如果不存在就給予空物件 - 用 && 來檢查物件與屬性值 - 用 || 來簡化程式碼 - 用 && 來簡化程式碼 - 用 && 、|| 來簡化程式碼 - 善用 ! 的轉換 其餘運算子與展開運算子 - 其餘運算子 假設要將一個陣列的值相加後取平均 但若呼叫 function 時，不是傳入陣列，而是傳入多個參數 最後得到的結果會是 NaN 運用其餘運算子`...`，將輸入函式中的參數值變成陣列的形式 - 展開運算子 `...` 關鍵字與其餘運算子相同，但功能與其餘運算子相反，展開運算子可以把陣列中的元素取出。 假設要用 `Math.max()` 來找出最大值，但傳入的參數為陣列，此時會得到 NaN 運用展開運算子將陣列展開成許多數值 三元運算式 - 如果條件為 true ，此時回傳[數值 / 運算式（1）] - 如果條件為 false，此時回傳[數值 / 運算式（2）] if else - 判斷式括號裡會強制轉成布林值 - `null` 跟 `undefined` 和 `NaN` 在 if 判斷時值都會轉換為 `false` 流程判斷與迴圈 switch - 如果忘記放 break，則當下的 case 執行完之後，會直接往下一個 case 執行，直到遇見 break while 迴圈 - 完成之後再回去檢查 `condition` - 直到 `condition`不成立，才會離開 for 迴圈 for...in 與 for...of - 迭代物件屬性時，使用 `for...in`；迭代陣列時，使用 `for...of`。 - `for...in` 輸出屬性名稱(key)，`for...of` 屬出值(value)。 若在此陣列中增加 `foo` 屬性 函式 function > function 是物件的一種 定義函式 - 函式宣告 - 函式運算式 透過匿名函式將變數賦值 若在 function 加上名稱時，這個名稱只在\"自己函式的區塊內有效\" - 透過 new 關鍵字建立函式 透過關鍵字建立的函式物件，每次執行時都會進行解析字串的動作(如：`'return number * number'`) 箭頭函式 - 箭頭函式僅用於 function 內只有一條運算式時 Scope 變數的有效範圍 > 全域變數和區域變數的差異 切分變數有效範圍的最小單位是 `function` 因此在 function 中透過 var 宣告的變數，其作用範圍僅限於這個函式。 此例中在一開始宣告的變數 x 與在 function 內部宣告的變數 x 為兩個不同變數。 若 function 中沒有宣告新變數，則會一層一層往外尋找，直到全域變數為止 此例中，function 中未宣告新變數 x，因此 javascript 向外層尋找同名的變數，直到最外層的全域變數，並將其賦值。 Hoisting 提升 變數提升 當 Scope 中的變數有被宣告，即使在宣告之前即調用變數，javascript 會將先告的語法拉到此 scope 的上面 對編譯器而言此，這段程式碼會是這個樣子 函式提升 透過\"函式宣告\"方式定義的函式可以在宣告前使用 而透過\"函式運算式\"定義的函式則是會出現錯誤 除呼叫時機不同，此兩者在執行時無明顯差異 為何會有 Hoisting 的現象？ > javascript 中的 Compiler(編譯器) 和 Engine (引擎) 執行的順序，造成提升的特性 - 變數宣告屬於 compiler 的工作 javascript compiler 會將程式碼解析成有意義的語法結構，轉換成機器可以理解的目的碼。接著 compiler 會建立所有的變數，保留其記憶體空間，並且繫結到所屬的 scope 上面。也就是說，程式開始一行一行執行前，會先將所有變數宣告好。 - 初始化、賦值屬於 engine 的工作 在 compiler 好之後，engine 才會開始一行一行的執行程式，也就是初始化、賦值的這個動作也是由 engine 在編譯好之後，等待被執行的程式碼之一。 最佳實踐 1. 宣告變數應集中在燈前 scope 的最上面 全域變數 其實在 javascript 中並無所謂\"全域變數\"，所謂全域變數指的是\"全域物件\"(亦稱作\"頂層物件\")的屬性。 以瀏覽器而言，全域物件指的是 `window`，在 node 的環境中則叫做 `global`。 - 全域物件的屬性 於外層透過 var 宣告一個變數 a，當我們調用 `window.a` 會回傳我們宣告的此一變數 - 變數的作用範圍，最小的的切分單位為 function - 即使是寫在函式中，沒有 var 宣告的變數，會變成全域變數 - 全域變數指的是全域物件(頂層物件)的屬性 > 附註 > > 在 javascript ES6 之後有新的宣告方法 let 與 const，分別定義\"變數\"與\"常數\" > 和 var 不同的是，他們的作用區域是透過大括號`{}`來切分的 closure > 閉包(closure) 是一種函式，他能夠存取被宣告當下環境中的變數。 closure 是兩個主體構成的一個組合。分別為： 1. 函式 (function) 2. 函式被宣告時所在的語彙環境(lexical environment) 語彙環境 lexical environment: 函式被宣告時所在的 scope，而此 scope 裡面包含了能夠被這個函式存取到的變數。簡而言之，語彙環境就是「函式能夠存取到的所有變數」。 因此 closure 就是一個函式能夠存取，自己被宣告時的環境中的變數。 Promise 當 javascript 在執行時，會將非同步操作留到最後進行處理。 非同步操作如：文件操作、資料庫操作、AJAX 及定時器等等。 javascript 基本實現非同步的方式： - 回調函示 callback function 當需要執行多個非同步操作時，程式碼會不斷的往內嵌套，又被稱做 callback 地獄(callback hell) 如何使用 Promise > 用來表示一個非同步操作的最終完成(或失敗)及其結果值 Promise 為一個構造函示，透過 new 關鍵字建立一個 promise。其會接收一個函示作為參數，此函示又稱為 executor，executor 會立即執行。 而此 executor 會再接受另外兩個函示參數： - resolve 實現函數：當請求完成，成功時會調用 resolve，並回傳結果。 - reject 拒絕函數：當請求完成，失敗時會調用。 狀態 Promise 狀態有三種 - pending 初始狀態，已執行 executor，但還在等待中。 - fulfilled 表示操作完成，執行 resolve 函式。 - rejected 表示操作失敗，執行 reject 函式。 then 的使用 1. 多次調用 promise 可以用鏈式(chaining)的方式串連多個非同步操作 2. 傳入兩個參數，一是成功的回調，二是失敗的回調 錯誤處理 Promise 的錯誤處理，只需要加上 catch 捕捉錯誤，並執行一些錯誤處理代碼。當請求失敗時，catch 方法將捕獲錯誤，並輸出錯誤訊息。 finally 若有加上 `finally`，當 Promise 完成後，無論狀態為 fulfilled 或是 rejected 都會進入 finally 方法。 async/await 同步操作 首先使用 async 關鍵字將函式標記為非同步函式，也就是指返回值為 Promise 物件的函式。 在非同步函式中，可以調用其他非同步函式，並使用 await 語法，await 會等待 Promise 完成之後返回最終的結果。 document `createdElement()` 建立節點 例如在文件中新增一個 ` ` 標籤 `appendChild()` 增加子節點 在 html 中，新增一個 ` ` 增加子節點 最終 html 上面顯示： `.querySelector` 元素選擇器 用法和 css 一樣，選取 id 元素時用 `#`，選取 class 元素時用 `.` `.querySelectorAll` 選取所有指定元素 用法和 `.querySelector()` 一樣，但不同於 `.querySelector()`，`.querySelectorAll()` 可以一次選取所有具有相同元素的內容 `setAttribute()` 增加標籤屬性 透過 javascript 來增加 HTML 標籤屬性，例如要動態加上一個 a 標籤連結 動態新增 id 來操控 HTML 移除 HTML 元素 使用 CSS 隱藏元素 `removeChild()` 從 DOM 中完全移除元素 `remove()` ES6 新方法 `addEventListener()` 事件監聽 - `element.addEventListener(event, function, useCapture)` - `event` 必須，指定事件名稱 - `function` 必須，指定事件觸發時執行的事件處理器(handler) - `useCapture` 可選，指定事件是否在事件冒泡(bubble phase)或事件捕獲(capture phase)流程階段執行。 - `true` 捕獲階段執行 - `false` 預設，冒泡階段執行 可以針對某事件，綁定多個處理器 `removeEventListener()` 取消事件監聽 - `element.removeEventListener(event, function, useCapture)` - `event` 必須，指定事件名稱 - `function` 必須，指定事件觸發時執行的事件處理器(handler) - `useCapture` 可選，指定事件是否在事件冒泡(bubble phase)或事件捕獲(capture phase)流程階段執行。 - `true` 捕獲階段執行 - `false` 預設，冒泡階段執行 需注意，由於 `addEventListener()` 可以同時針對某事件綁定多個 `handler`，所以透過 `removeEventListener()`解除事件時，第二個參數的 `handler` 必須和先前在 `addEventListener()` 綁定的 `handler` 為同一個實體。 Math `Math.round` 四捨五入 物件取值、新增與刪除 物件取值 用中括號語法，允許以變數的方式取值 `.` 語法是直接以字串的方式尋找該物件的屬性，而 family 物件並無 a 屬性。 但中括號中的語法是將變數 a 的值帶入，相當於 `family['name']`。 另外，在物件中的屬性一律是字串，因此可以允許各種數字或是特殊字元，但在 `.` 語法中，會受到許多限制。 執行物件中的方法，也可以用點語法或是中括號 物件轉為陣列 陣列本身舉有許多好用的方法：`forEach`, `map`, `reduce`, `find`...，但物件無法使用這些陣列方法 利用 `Object` 關鍵字，將物件轉為陣列。 - Object.values 可以直接傳入一個物件，並將物件直接轉為陣列的形式，但無法取得 key 值。 - Object.keys 傳入一個物件，並將其 key 值以陣列方式呈現，僅只取 key 值。 - Object.entries 傳入物件，並同時回傳 key 值與 values，但產生的新結構，會另外用一層陣列組成。 新增物件屬性 刪除物件屬性 使用 `delete` 關鍵字 SET 集合物件 Set 物件可儲存任何類型的唯一值，意旨相同的內容不論輸入幾次，都只會有一個，不會重複出現。 若希望陣列的元素不會重複，可以用 set，若希望物件的 key 不會重複，則可以使用 Map 基本使用 - add() 新增值到集合中 - delete() 從集合中刪除值 - size() 取得集合中元素的數量 - has() 檢查集合中視否存在指定值 - clear() 清除集合中所有東西 - 加入物件 陣列與集合間轉換 過濾陣列中重複的元素 利用 set 中元素不會重複的特性，來過濾掉陣列中重複的元素，留下唯一 Map 物件 Map() 為一種資料結構，和方法 array.map() 不同。 用法和 Set 大同小異，但 Map() 重視 key/value 兩者間操作的關係。 - 建立 Map - set() 新增 key/value 到 Map 中 - get() 取得 key 相對的 value - delete() 從 Map 中刪除指定 key/value - size() 取得 Map 中的數量 - has() 檢查指定 key 是否存在。返回 boolean - clear() 清空 Map 所有東西 JSON 轉換 - json 為一組字串 - 在使用 {} 建立物件時，屬性名稱的引號可以省略，但在 json 格式中，屬性名稱一定要有引號。 - 若物件中的值為 function 時，無法透過 json 傳遞。 `JSON.stringify` 將物件轉為 json 字串 可以將 javascript 任何物件或值轉換為 json 字串。 - JSON.stringify(value, replacer, space) - value 必須，任何需要轉換為字串的值 - replacer 可選，可以為函式或陣列，可用來替換字串中某些元素。 - 陣列用法 - 函式用法 - space 可選，在輸出的字串中新增空格提高可讀性，可以為一個字串或數字。 `JSON.parse` 將 json 字串轉換為物件 和 `JSON.stringify()` 相反，可以接收 JSON 字串並將其轉換為 物件或是值。 - `JSON.parse(reviver)` - reviver 過濾解析後的值。 轉換陣列為字串 toString() 不僅適用於陣列，還適用於其他資料型別。幾乎任何東西都可以使用 `toString()` 轉換為字串。 join() 此方法將從陣列中取出每一個元素並一起形成一個字串。 和 `toString()` 不同的是，可以直接傳遞分個符號，作為引數來分隔字串中的元素。 使用型別轉換 javascript 中有兩種型別強制轉換：隱式強制、顯式強制。 - 隱式強制：當各種運算子(+, -, '', /, 等)應用於不同型別時。 - 顯式強制：當使用 String(), Number()之類的函式時 `str_1` 是隱式強制轉換的一個例子，在兩種不同型別的值(一個是陣列，另一個是字串)之間使用運算子，此時輸出為一個字串。 `str_2` 為顯式強制轉換，在 `String()` 函式中，傳遞整個陣列，並將其轉換為字串。 轉換字串為數值 parseInt() 將字串轉換為以十進位表示的整數。 - parseInt(string, radix) 將字串轉換為以十進位表示的整數。接受兩個參數。 - string 欲轉換的值，若不為 String，會先使用 ToString()轉換成字串。 - radix 代表近位系統 parseInt() 會略前後空白，並根據 radix 解析第一參數，當遇到無法解析的字元，會忽略該字元及其前後的所有字元，並停止解析，回傳目前為止的結果。 若第一個字元就無法解析，則回傳 NaN parseFloat() - parseFloat(string) 將字串轉換為以十進位表示的浮點數。僅接受一個參數。 - string 欲轉換的值，若第一個參數值不是 String，會先使用 ToString 轉換成字串。 和 parseInt() 相同，會忽略前後空白。當遇到無法解析的字元時，會忽略其後所有字元，並停止解析，回傳目前結果。 和 parseInt() 不同的是，parseFloat() 用以解析浮點數，因此會接受第一個小數點。且僅能分析十進制。 Number() - Number(value) 在不使用 new 運算子的狀況下，可以用來轉會型別。 規則如下： 1. 若值為 undefined，回傳 NaN 2. 若值為 null，回傳 0 3. 若值為 Boolean，true => 1, false => 0 4. 若值為 Number，直接回傳該值。 5. 若為 String 1. 僅包含數字與浮點數，則忽略前後空白，回傳該值 2. 若包含有效的進位系統，如：十六進制的 0x、八進制的 0o、二進制的 0b，則依照進位系統轉換為十進制。 3. 空值，回傳 0 4. 其他，回傳 NaN 6. 若值為 Object，使用 valueOf() 得到該值，再根據前述規則進行轉換。 計時器 瀏覽器內建的計時器 setTimeout() 來設定一段時間過後，自動執行某個函數(callback)，這個計時器只會執行一次。 `func` 時間到執行的函數。 `delay` 等候時間，單位為毫秒。 `param*` 用來指定要傳入 `func` 的參數 `setTimeout()` 執行後會返回一個數字，表示這個計時器的 id 若取消計時器，可以使用 `clearTimeout(timeoutId)`; setInterval() 用來設定每過一段時間，就會自動執行某個函數(callback)，這個計時器會重複執行。 若取消計時器，可以使用 `clearInterval(intervalId)`; 屬性描述器 當對於屬性除了指定 key/value 以外有更進一步的要求時，例如設定屬性為 read-only 甚至是 constant 時，就可以使用屬性描述器。 屬性的特徵： - 資料描述器 - writable - configurable - enumerable - value - 存取器描述器 - get - set 這些特徵都是可以透過屬性描述器去設定的 `Object.defineProperty` 和 `Object.definedProperties` 使用字面值宣告屬性的特徵 - writable, configurable, enumerable 都會是 true - value 代表屬性的值 - get, set 則是沒有設定 取得屬性特徵 若想要瞭解一個屬性的特徵時，可以使用 `Object.getOwnPropertyDescriptor(object, 'propertyName')` 這個內建函式 使用字面值創建的屬性，其 `writable`, `enumerable`, `configurable` 都會是 `true`，而 `value` 就會是此屬性的值 `prop1` 對於一次察看多個屬性的特徵，可以使用 `Object.getOwnPropertyDescriptors(object, 'propertyName1', 'propertyName2', ...)` Object.defineProperty 設定單一個屬性描述器 在 `obj` 中按需求設定 ‵prop` 這個屬性 Object.defineProperties 一次設定多個屬性 資料描述器 > 參考資料： > > JavaScript - 屬性描述器 writable 屬性是否可以改值 可以將屬性設定為 `read-only` 當使用屬性的字面值( `obj.prop` 與 `obj[prop]`)定義屬性時，屬性的 writable 為 true，也就代表可以寫入。 相較之下，當 writable 為 false 就代表此屬性為 read-only 在非嚴格模式下，還是可以對 read-only 的屬性進行寫值，但會沒有效果。 Configurable 是否可編輯該屬性 屬性描述器在一般狀況下，可以利用屬性描述器重新設定，若沒有重新設定，會保留原有的特徵。 上面將 `writable` 設為 `false`，因此無法對 `obj.prop1` 賦值。 下面實作禁止屬性被重新設定： 當 `obj.prop1` 已經被設定為 `configurable: false` 時，又試著重新設定屬性描述器一次時，javascript 會報錯。 即是在非嚴格模式下，都不允許重新設定 `configurable: false` 的屬性描述。 但有一個特例：在 `configurable: false`，`writable` 特徵還是可以從 `true` 改為 `false` Enumerable 屬性是否會在物件的屬性列舉時被顯示 在 `for...in` 的屬性列舉動作中，只有可列舉的屬性會被迭代 雖然 `prop1` 和 `prop2` 都存在於物件中(利用 `in` 檢查)，但因為 `obj.prop1` 被設定為 `enumerable: false` 因此在 `for...in` 列舉的動作中，並不會被迭代到。 相較之下，普通屬性的 `obj.prop2` 可以被列舉。 - `obj.propertyIsEnumerable` 檢查屬性是否可列舉且為物件自有的 使用 Object.keys 會將所有可列舉的屬性列成一個陣列 value 屬性的值 上面程式碼，等同於下面 屬性描述器屬於淺層設定 淺層設定：只有目標物件的`自有屬性`才會擁有這個特徵，若屬性又指向了另一個物件，則另一個物件內的屬性，即不為自有屬性，亦不會擁有這個特徵。 將 `obj.prop1` 設為 `writable: false`，並賦值為 `innerObj`，接著試圖將`{}` 寫入 `obj.prop1`。此時寫入的動作並沒有成功，`obj.prop1` 還是指向 `innerObj` 但若賦值的是 `innerObj` 的屬性 `innerProp` 的話，是可以寫入的，因為只有 `obj` 自身的屬性 `prop1` 被指定為 `writable: false`，而 `prop1` 指向的 `innerObj` 內部屬性則不受 `prop1` 的特徵管轄，因此複寫 `innerProp` 是可行的 存取器描述器 `get` 和 `set` 分別為取值器與設值器，可以將他想像成是函式。 當有設定這兩個特徵時，他們會覆蓋 javascript 原有的取值與設值行為 `[[GET]]` 和 `[[set]]` 宣告方式 - 使用物件字面值時直接定義 - 利用屬性描述器定義 以上的宣告方式是一樣的 Getter 需要回傳一個值來當作取值結果 無論怎麼修改 prop1 的值，最後回傳的都是取值器回傳的 \"This is prop1\" setter 在拿到值之後，去做指定的動作 將 \"this is prop1\" 傳入 prop1 中，此時會印出 set 要求的 log，當要取出 obj.prop1 的值時，因為我們並沒有設置 get，因此出現 undefined 資料處理器與存取器處理器 - 資料描述器：代表屬性是有值，會有以下兩個特徵 - value - writable - 存取器描述器：屬性的值是由取值器與設值器所決定，會有以下兩個特徵： - get - set 需要注意的是，資料描述器與存取器描述器不相容。 若今天物件中的屬性已經設定了 get 和 set，也就代表已經定義取值和設值的行為，此時再額外進行屬性值(value)與唯獨(writable)的設定，產生行為衝突 取值器與設值器的應用 上面我們宣告了一個變數 obj 並加入一個屬性 prop1，並為這個屬性同時加入 get 和 set，這兩個函式的共通點：都對 obj.prop1 進行存取。 解構賦值 > 參考資料： > > 解構賦值 · 從 ES6 開始的 JavaScript 學習生活 用於提取(extract)陣列或物件中的資料， 從陣列解構賦值 從物件解構賦值 非物件或非陣列解構賦值 解構賦值時給予預設值 搭配函式的傳入參數使用 Linked list 鏈結串列 > 參考資料： > > JavaScript 學演算法（五）- 鏈結串列 Linked list > > Linked list Javascript 實作及 Leet code 題目解析 中國稱鏈表。和陣列一樣都是線性資料結構，但和陣列不同為，他為鏈式儲存結構，也就是記憶體位置儲存為不連續性。 定義 鏈結串列是由一連串節點 `node` 組成，節點之間是透過指標來連接。所以儲存上不需要連續的空間。 每個節點包括： 1. 資料元素 2. 指標 指標(又稱鏈結、引用)，通常為一或兩個，用來指向上/下個的位置。若沒有上/下節點，則為空。若指標斷裂，資料就遺失。 鏈結串列就像是火車車廂一樣，一節拉一節。 相較於陣列，鏈結串列的元素不是連續放置的，插入或是移除元素時，不需要移動其他元素，只需要修改上/下個指標的指向。 因為鏈結串列沒有索引，所要存取特定值，需要從頭開始找起，因此相較於陣列，資料存取為費時。 類型 鏈結串列有多種類型： - 單向鏈結串列(singly linked list)： - 又稱單鏈結串列、線性鏈結串列、普通鏈結串列，為最基本的鏈結串列，其特點是連結串列的鏈結方向是單向的，對鏈結串列的存取要通過頭部開始，依序向下讀取。 - 雙向鏈結串列(doubly linked list)： - 又稱為雙鏈結串列。他和單向鏈結串列最大的區別在於，每個節點中都有兩個指標，分別指向上一個和下一個節點。所以從雙向鏈結串列中的任意一個節點開始，都可以很方便的存取他的上一個和下一個節點。 - 迴圈鏈結串列(circularly linked list)： - 又稱環狀鏈結串列、循環鏈結串列，他和一般的鏈結串列操作基本一致，但串列頭尾的指標會連接在一起，行成一個環。 優缺點比較 - 陣列 - 優點 - 可利用 index 隨機存取只需要 O(1) 的時間 - 可靠度高，不會因為鏈結斷裂而遺失資料。 - 缺點 - 在開頭或在中間插入、刪除元素，需花費 O(n) 的時間移動元素。 - 連續的記憶體空間，可能有用不到的空間，進而造成浪費。 - 若陣列已滿，會需要花費 O(n) 的時間搬動資料到新的陣列中。 - 鏈結串列 - 優點 - 資料在記憶體中非連續。 - 插入、刪除元素只需修改上/下個指標的指向。 - 缺點 - 只能順序存取，需花費 O(n) 的時間。 - 鏈結斷裂就會遺失資料。 額外補充 函式註解模版 範例 random 公式 debounce、throttle、flatten、cloneDeep",
    "path": "Javascript/Javascript 學習筆記.md",
    "category": "Javascript"
  },
  {
    "id": "Javascript/Javascript 陣列.md",
    "title": "Javascript 陣列",
    "content": "JavaScript 陣列 > 參考資料： > > JavaScript Array 陣列操作方法大全 ( 含 ES6 ) - JavaScript 陣列 - 改變原始陣列 - push() 加入陣列最後一個位置 - pop() 取出陣列的最後一個元素 - shift() 取出並移除陣列的第一個元素 - unshift() 將元素添加到第一個位置 - reverse() 反轉陣列 - splice(start, delete\\_count, item) 新增或移除陣列中指定位置的元素 - sort() 針對陣列的元素進行排列 - copyWithin() - fill() 置換陣列中的值 - 回傳陣列元素資訊或索引值 - length() 取得陣列長度 - indexOf() 尋找是否有符合的元素 - lastIndexOf() - find() 回傳第一個符合判斷條件的元素 - findIndex() - filter() 回傳條件為 true 的元素組成的陣列 - 針對每個元素進行處理 - forEach() - 產生新的陣列或值 - join() - concat() - slice() 擷取陣列，回傳指定範圍元素的新陣列 - map() 處理陣列中每一個元素，最後回傳一個新的陣列 - reduce() 計算陣列中每個元素，並將結果與下個元素做計算 - reduceRight() 計算方式為從右到左 - flat() 將多維陣列扁平化 - flatMap() map + flat() - Array.from() - Array.of() 將數值、字串等內容，轉換為陣列 - toString() 將陣列轉換為字串 - 判斷 - every() 全部符合判斷條件回傳 true - some() 其中任一符合回傳 true - include() 陣列中使否包含指定值 - Array.inArray() - 其他 - keys() - valueOf() 回傳陣列的原始值 改變原始陣列 push() 加入陣列最後一個位置 將值加入陣列的最後一個位置，push() 會回傳新的陣列長度。 pop() 取出陣列的最後一個元素 shift() 取出並移除陣列的第一個元素 unshift() 將元素添加到第一個位置 reverse() 反轉陣列 splice(start, delete_count, item) 新增或移除陣列中指定位置的元素 可以移除或新增陣列的元素，包含三個參數 - start 要編輯的序列號碼 - delete_count 要移除的長度(選填，若不填，則將第一個號碼位置面的所有元素清除，若為 0 則不刪除元素) - item 要添加的內容(選填) 設定第三個參數就能添加或取代元素 splice 方法會回傳被刪除的元素，若無刪除元素，則回傳空陣列 sort() 針對陣列的元素進行排列 - 未帶入參數: 預設排序為依照陣列內元素的 code UTF-16 的順序排序。 `sort()` 會將所有元素轉成字串後，以第一個字元為對象進行排序。符號會先被篩選出來，接著是數字，接著是字母。 - 傳入匿名函數 `sort()` 會依匿名函式的參數與回傳的值當作排序依據 - 當回傳值為負數時，前面的數放在前面 - 當回傳值為正數時，後面的數在前面 - 當回傳值為零時，保持不動 為什麼參數相減就能判斷排序？ copyWithin() fill() 置換陣列中的值 會將陣列中所有元素，置換為指定的值。 - fill(value, start, end) - value 必填，欲替換的值 - start 可選，起使位置(包含該位置) - end 可選，停止位置(不包含此位置) > 使用 fill() 會改變原本的陣列內容 回傳陣列元素資訊或索引值 length() 取得陣列長度 indexOf() 尋找是否有符合的元素 lastIndexOf() find() 回傳第一個符合判斷條件的元素 findIndex() filter() 回傳條件為 true 的元素組成的陣列 會將陣列中每一個元素，帶入指定的函式做判斷，若元素符合判斷條件會傳出成唯一個新的陣列元素。 針對每個元素進行處理 forEach() 將陣列中每個元素套用到指定函式裡面進行運算。 函式有三個參數： 1. 表示每個元素的值(必填) 2. 該元素的索引值(選填) 3. 表示原本的陣列(選填) 產生新的陣列或值 join() concat() slice() 擷取陣列，回傳指定範圍元素的新陣列 - slice(startIndex, endIndex) - startIndex 必須，起始位置的 index，包含此位置。 - endIndex 可選，擷取結束位置的索引，不包含此位置。預設為擷取至陣列末端。 若傳入負數索引為引數，則表示從陣列末尾開始計算。 map() 處理陣列中每一個元素，最後回傳一個新的陣列 裡面有一個函式(必填)和一個回傳函式裡面的 this 參數(選填)，函式中包含三個參數： 1. 每個元素的值(必填) 2. 當前元素的 index 值(選填) 3. 當前的陣列(選填) 套用第二和第三個參數的變化 若要使用回傳函式裡 this 的函數，則「不能使用」箭頭函式，因為箭頭函式的 this 指向，和函式的 this 指向不同，所以要用一般的函式處理。 reduce() 計算陣列中每個元素，並將結果與下個元素做計算 可以將陣列中的每一個元素做計算，每次計算的結果，會再與下個元素做計算到結束為止。 包含一個函式，函式內有四個參數： 1. 計算的值(必填) 2. 取得的元素(必填) 3. 該元素的 index 值(選填) 4. 原本的陣列 (選填) reduceRight() 計算方式為從右到左 flat() 將多維陣列扁平化 可以將一個多維陣列的深度轉換為一維(扁平化)，他有一個選填的參數，代表要轉換的深度，其預設為 1，如果深度很多層，可以用`infinity`來全部展開成一維陣列。 flatMap() map + flat() 在運算後直接將陣列扁平化 Array.from() Array.of() 將數值、字串等內容，轉換為陣列 toString() 將陣列轉換為字串 判斷 every() 全部符合判斷條件回傳 true 只要有任何一個元素不符合判斷條件，就會回傳 false，全部符合就會回傳 true。 some() 其中任一符合回傳 true 會將陣列中每一個元素帶入指定的函式中做判斷，只要有任一個元素符合判斷標準，就會回傳 true，若完全不符合，回傳 false include() 陣列中使否包含指定值 會判斷陣列中是否包含指定值，包含回傳 true，否則回傳 false。 有兩個參數： 1. 表示要判斷的值(必填) 2. 陣列的開始位置(選填) Array.inArray() 其他 keys() valueOf() 回傳陣列的原始值",
    "path": "Javascript/Javascript 陣列.md",
    "category": "Javascript"
  },
  {
    "id": "Javascript/Vue Router 學習筆記.md",
    "title": "Vue Router 學習筆記",
    "content": "Vue Router > 過去大多以靜態網頁為主，所有資料都是從伺服器輸出，隨著時間與技術推進，前端在網頁的領域越來越吃重，漸漸的原本由後端伺服器控制路由改為前端接手 > > 參考資料： > > 重新認識 Vue.js 4-1 Vue Router 與前後端路由 由前端接手的路由 以 laravel 為例，首先要將所有的入口都指向同一個頁面，在由此頁面渲染 Vue.js 接著在 SinglePageController 將 index 指向 app: 最後在 /resource/views/app.blade.php 新增 ... 以及 將 Vue.js 以及前端程式的進入點，引入到網頁上。 基本應用 在網頁中加入 當作 Route 的進入點，並使用 來產生對應的連結： 在 app.js 中定義 route 若使用 Vue CLI，可以新增 route.js 檔案 接著在 main.js 透過 .use(router) 加入至 app 中： history 路由設定 v3 以前為 mode，v4 開始改為 history。Vue Router 處理前端路由的不同方式，分別是 Hash Mode 以及 HTML5 (History API) Mode 兩種。 Hash 模式 在 HTML5 的 History API 還沒出現之前，想要控制 URL 又不能換頁，只能透過 URL hash，也就是 #。此一符號在網頁中代表「錨點」的含義。 後面接的是個網頁的某個位置。 `https://book.vue.tw/#app` 以上面這個網址為例，如果網頁中有某個節點的 `id='app'` 像是 ，那麼當這個連結被開啟時，瀏覽器就會自動把位置捲到此錨點位置。 而在同一個頁面中，若只是改變了 後面的文字，不會讓整個頁面刷新，而當 URL Hash 被更新時，同時也會增加一筆記錄到瀏覽器的瀏覽歷史裡，也就是說，透過瀏覽器 `上一頁`、`下一頁`來切換不同 的位置，不會引發頁面重新刷新。 於是可以透過 Ajax 搭配 hashchange 事件，去監聽 URL Hash 的狀態來決定目前顯示的內容，此為早期前端路由的解決方案。 在 vue Router 中，只要將 hitory 設定為 createWebHashHistory() 即可開啟 Hash Mode 而 createWebHashHistory() 預設路徑為 location.pathname 或 / 根目錄，若想額外處理則可以裡面加上路徑的字串，像是 createWebHashHistory('/folder/')，對應的就是 https://example.com/folder/ Hash Mode 的優點是無須調整後端設定，甚至 file:// 開頭的檔案協定，直接開啟網頁也可以順利運作。不過這種作法也有缺點，搜尋引擎在收錄頁面的時候，會自動忽略 URL 裡面帶有 符號的部分，因此不利於網站的 SEO。 HTML5 (history API) 模式",
    "path": "Javascript/Vue Router 學習筆記.md",
    "category": "Javascript"
  },
  {
    "id": "Javascript/Vue 學習筆記.md",
    "title": "Vue 學習筆記",
    "content": "Vue 學習筆記 - Vue 學習筆記 - Vue 實體的生命週期 - Vue 屬性 - watch 監聽器 - $watch - watch - computed 計算 - computed 和 watch 的差別 - eventHub 事件中心(vue 2) - directive 指令 - 屬性綁定 - 表單綁定 `v-model` - input - textarea 文字方塊 - radio - checkbox - select 下拉式選單 - v-model 修飾子 - .lazy - 模板綁定 - v-text - v-html - v-once - v-pre - 樣式綁定 - 條件渲染 - v-if - v-show - 迴圈渲染 - 事件監聽器 - 事件通用型修飾子 - .stop - .prevent - .capture - .self - .once - .passive - props - 命名與使用 - 傳遞 props 值的方法 - 傳遞字串 - 傳遞數字、布林值、陣列、物件 - 單向數據流 - 改變子模組內的 prop 值 - 物件型別的 prop 傳遞 - 子組件接收來自父組件的 props - 在模板中 - 在 data 中 - 在 methods 中 - 在 mounted 中 - 在 computed 中 - emit 子組件向父組件傳遞參數 - ref 取得 Dom 元素 - 基本用法：取得 dom 元素 - 獲取子組件中的 data 和調用子組件的方法 - this.$refs 介紹 - this.$el - Mixin 共用方法 - 局部混入 - 全域混入 - vuex 和 mixin 的區別 - 備註 - Truthy(真值) 與 Falsy(假值) - 判斷當前環境是否為開發環境 - 取得 base\\_url Vue 實體的生命週期 - `beforeCreate`: 當 Vue 實例初始化時便立即調用，此時尚未創建實例，因此所有 Vue 實體中的設定(如：data)都還未配置。 - `created`: 完成創建實例，此時 Vue 實體中的配置除了 \\$el 外，其餘已全部配置，而 \\$el 要在掛載模板後才會配置。 - `beforeMount`: 在 Vue 實體中被掛載到目標元素之前調用，此時的 \\$el 依然未被 Vue 實體中的定義渲染的初始設定模板。 - `mounted`: Vue 實體上的設置已經安裝上模板，此時 \\$el 是已經藉由實體中的定義渲染成真正的頁面。 - `beforeUpdate`: Vue 實體中的 data 產生變化後，或是執行 vm.$forceUpdate() 時調用，此時頁面尚未被重新渲染成變過的畫面。 - `update`: 在重新渲染頁面後調用，此時的頁面已經被重新渲染成改變後的畫面。 - `beforeDestroy`: 在此實體被銷毀前調用，此時實體依然擁有完整的功能。 - `destroyed`: 於此實體被銷毀後調用，此時實體中的任何定義(data, methods...)都已被解除綁定，在此做任何操作都會失效。 Vue 屬性 watch 監聽器 當資料變化時調用函數，函數會有兩個傳入參數：改變前的值、改變後的後的值，可以使用這個函數做跟此資料變化有的處理。 監聽器在 vue.js 中有兩種使用方式： - `$watch` 實體上的函數，使用此函數註冊監聽器。 - `watch` 實體上的屬性，此屬性設置的物件在實體建立時會調用 `$watch` 註冊監聽器。 `$watch` 是註冊監聽器的函數，而 watch 是為了開發者方便在實體上設置監聽器而提供的，其實 watch 本身也是使用 $watch 註冊監聽器。 $watch `$watch` 的回傳值是註銷監聽器的函數，執行此函數可使監聽器失效。 - `exOrFn` 設定要監聽的目標，可以使用 javascript 表達式或是一個回傳監聽目標值的函數 - `callback` 當數值改變時，要叫用的函數，此函數會有兩個傳入參數：callback(newVal, oldVal) - `newVal` 改變後的資料值 - `oldVal` 改變前的資料值 - `[options]` 非必要參數，監聽器的設定 - `deep` 監聽物件時，物件下層屬性變化也會觸發監聽器 - `immediate` 在實體初始畫設置監聽器的時候馬上叫用 callback 函數 watch - 以 watch 為 key 值，下面定義的屬性都是欲監聽的資料來源。 - key 監聽目標名稱，可以使用 javascript 表達式 - value callback 函數的設定，共有 string, function, object 及 array 可以設定。 - string callback 函數名稱 - function callback 函數 - object 設定監聽物件，設定方法如下 - handler callback 函數 - deep 布林值，是否監聽物件下層屬性 - immediate 布林值 使否在實體初始化時立即調用 callback - array 當有多個監聽器時，使用陣列帶入多個 callback 函數 computed 計算 和 watch 一樣，都是用來監聽數據的方式，但使用場景不同。 computed 是一個計算屬性，他根據依賴的資料，動態計算出一個新的值，並且會自動存入快取。當依賴的資料發生變化時，computed 會自動重新計算。這樣可以有效避免重複計算和提高性能。 computed 通常用計算衍生的資料，例如從一個列表中過濾出符合條件的資料，或根據資料的狀態產生顯示內容等等。在模板中，可以像普通的資料屬性一樣使用 computed `doubleCount` 為一個計算屬性，他依賴於 count 屬性。當 count 屬性發生變化時，doubleCount 會自動重新計算。在模板中，可以像下面這樣使用： computed 和 watch 的差別 computed 最大特點是必須回傳一個值，並且將其存入快取，當方法中的依賴改變時，才會重新執行和求值。 但 watch 和 methods 不會強制要求回傳一個值，他們只需要執行動作，不一定要回傳值。 watch 會偵測單一個值，當她有變化時就執行。methods 只要呼叫，就會執行。 - computed 的特點 - 當元件被建立時(created 生命週期)，computed 方法會被建立和執行一次。之後如果依賴沒有更新，就不會重新執行和求值，僅回傳快取的值。 - computed 只能被該 computed 修改，不能被其他方法修改。例如：this.somecomputedfunction = 123 就會報錯。 - computed 的方法必須回傳一個值。 - computed 方法無法傳入參數 - computed 依賴更新才會重新執行 > vue 官方文件 > > 计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。 響應式依賴：在一個 computed 方法中，他所用到在 data 建立的資料，當資料產生變化，此方法就會重新執行和求值。 total 的依賴就是 this.price, this.quantity, this.discount。只要其中一樣產生變化，就會重新執行 total()，並回傳新的值。 當 computed 內所有的依賴都沒有發生變化，此 computed 函示就會一直回傳之前儲存起來的值。 當元件剛建立時(created)時，會打印一次，然後第一次按下按鈕時，會在打印一次，並且 num 會變成 1。 但第二次之後按下按鈕，就不會再觸發 add() 方法，因為每次按下按鈕，都會將 num 賦值為 1，和之前快取儲存的值相同。 eventHub 事件中心(vue 2) 在無關聯的組件之間，互相傳遞 data 在需要取得 data 的組件上設置一個監聽器，每次要傳遞 data 時，那個組件就會廣播這個事件並調用這些監聽器。 eventHub 最主要的功能就是監聽和廣播 若 vue 搭配其他框架時，在 library 新增一個 eventHub.js 若只有單純 vue 框架，則在頂層組件的 `data` 裡初始化 eventHub，並使用 `provide` 對外傳遞這個 eventHub 在要傳遞 data 的組件裡加入廣播 接著在需要監聽的組件裡注入這個依賴，並在添加事件監聽。 directive 指令 屬性綁定 透過 `v-bind`，進行數據綁定 HTML class 傳遞對象給 v-bind:class，用以動態切換 class 此時 `active` 這個 class 是否存在，將取決於 property `isActive` 的 truthiness(註 1)。 可以在對象中傳入更多屬性，來動態切換多個 class。此外 v-bind:class 也可以與普通的 class attribute 共存 data: 渲染結果 當 isActive 或 hasError 變化時，class 的屬性會同步更新。 例如：若 hasError 值為 true，class 屬性將變為 \"static active text-danger\"。 綁定的數據對象，不一定要定義在模板裡 此渲染的結果和上面一樣。 也可以在此綁定 computed 屬性。 表單綁定 `v-model` > 當使用 v-model 指令時，表單元素會自動忽略原有的 value, checked 和 selected 屬性，實際的值將以 data 內的狀態為主 input 在 input 文字框加入 v-model=\"message\" 屬性之後，此文字框便會自動被綁定 input 事件 textarea 文字方塊 使用方式與 input 完全一樣 radio 因為 data 裡的 picked 預設為 1，所以執行時畫面上 ` ` 會預設為已選擇 checkbox 可以當作多選的選項，而當他只有一個的時候，又可以將它做 boolean 的選項 複選時，用法跟前面 radio 完全一樣，因為是複選的關係，其差別在 data 內的狀態必須為陣列 - 如果要控制表單的全選或全部取消，只要控制 data 內的 checkedNames 陣列內容即可 當 checkbox 為單選時 此時， data 內的選項，會變成 true 或 false，當值為 true 時，對應的 checkbox 會被勾起。 select 下拉式選單 v-model 標籤須使用在 ` ` 標籤，不能用在 ` ` 標籤中 v-model 修飾子 .lazy 在 v-model 屬性後面加上.lazy，此輸入框就會從原本的 input 事件，變成監聽 change 事件 也就是，原本 input 事件會在輸入值時做實時的更新，而監聽 change 事件，則是當使用者離開輸入框焦點時才會更新。 模板綁定 v-text 當透過 v-text 指令來進行綁定，此時畫面渲染出來的結果會與下面相同 但若在 v-text 綁定的標籤內加入文字，以 v-text 指令渲染出來的結果會無視標籤內的內容 v-html 和 v-text 類似，但當 data 的內容為 HTML 的語法時，v-html 會將其渲染為 html 語法 v-once 只渲染指定的節點一次，往後就不再更新 v-pre 加入 v-pre 後，就不會解析模板內容。 樣式綁定 條件渲染 v-if 其屬性為 truthy，當其返回 true 時會被渲染。 可以添加 `v-else` 還可以添加 `v-else-if` 此三元素需緊跟彼此，否則將不會被識別 v-show 和 `v-if` 用法類似，不同的是 `v-show` 的元素始終會被渲染並保留在 DOM 中，`v-show` 只是單純的切換元素的 CSS property display。 `v-if` 是真正的條件渲染，他會確保在切換過程中條件內的事件監聽器和子組件適當的被銷毀和重建。 同時 `v-if` 也是惰性的，若在初始渲染時條件為 false，則不執行，直至條件第一次轉為 true 時，才會開始渲染。 相較之下，`v-show` 就比較單純，無論初始條件，元素總是會被渲染，`v-show` 做的只是基於 CSS 進行切換。 迴圈渲染 v-for 可以用陣列進行渲染成一個列表。其語法為 item in items，items 為源陣列，而 item 則為被迭代的陣列元素別名。 輸出 在 v-for 中可以訪問所有父作用域的 property。v-for 還可加入可選的第二參數作為當前的 key 值。 用 v-for 來迭代一個對象的 property 可以傳入第二個參數作為 property 的名稱(key 值) 還可以傳入第三個參數作為索引值 事件監聽器 > 靜態事件監聽 > > - 元素上使用 v-on 監聽原生事件 > - 父組件設定 v-on 設定所需要監聽的事件，子組件用 $emit 觸發事件 > - 在 Vue 實體上設定生命週期鉤子，監聽各個鉤子事件。 當要在執行時去動態增減事件的監聽，這時就要用到 $on, $once, and $off 這些 js 函式來做設定。 事件通用型修飾子 > 一個事件指令可以加入多個修飾子，而修飾子的順序會影響執行的結果 > > 如 `@click.prevent.self` 會先執行 `.prevent`，阻擋所有的點擊行為；而 `@click.self.prevent` 會先執行 `.self`，只會阻擋該元素自己的點擊事件。 .stop 阻止事件冒泡，同 `event.stopPropagation()`。 在 inner 區塊加上 `.stop`，`click` 事件就不會向外層傳遞。 .prevent 阻擋元素的預設行為，同 `event.preventDefault()`。 當然也可以和 `.stop` 一起使用： .capture 用來指定事件已捕獲的形式來觸發。 當 outer 的點擊事件指定捕獲的修飾子後，在沒有加上捕獲修飾子的 inner 上點擊，會先觸發 inner 的點擊事件在觸發 outer 的點擊事件。 而當 outer 的點擊事件加上捕獲後，則順序相反，點擊 inner 時會先印出 outer 再印出 inner。 .self 只會觸發元素自己的事件行為，由子層元素傳遞來的事件則不會觸發。 燈箱範例：在燈箱開啟之後，點擊燈箱外遮罩可以自動關閉燈箱 上面是一個燈箱的範例。由於 modal-body 的內容區塊在 modal-container 之下，因此當 modal-body 被點擊時，燈箱也會被關閉。 此時，若在 modal-container 的 click 事件加上 `.self` 修飾子，就可以排除這樣的問題。 .once 讓指定的事件只會觸發一次。 .passive 告訴瀏覽器這個事件處理器不會呼叫 `event.preventDefault` 來停止瀏覽器的原生行為。 此屬性常用來改善 scroll 事件的效能，因為以前的瀏覽器要多判斷 scroll 事件會不會被 preventDefault，加上 passive 屬性之後會直接忽略這個判斷。當 passive 屬性為 true 時，表示此事件不會被 preventDefault。 也就是，passive .prevent 兩修飾子無法同時使用，同時使用時，prevent 會被無視。 props 命名與使用 可以使用 PascalCase 或是 camelCase 的命名方法，但在 html 中必須使用 kebab-case 且應該小寫(html 大小寫不敏感) 像是 PostTitle 、 CartItem 、 TodoItem 等，在 HTML 中使用時就會變成 post-title 、 cart-item 、 todo-item。 傳遞 props 值的方法 傳遞字串 只要是直接傳遞(靜態傳遞)都是字串，所以 prop 接收的值 log1、I\\'m content1、true、500、{...} 等等都是字串。 傳遞數字、布林值、陣列、物件 利用 vue 的 v-bind 傳遞字串以外的值。 也可以透過給予變數來獲得數字、布林值、陣列或物件等型別 單向數據流 prop 是為了接收從富組件傳遞過來的資料，而這些資料是單向綁定的，已就是說父模組資料的更新，會影響子模組裡的 prop，但子模組裡 prop 值改變並不會影響父模組。 以上測試可以得知： - 外面(父層)的資料 counter 改變會影響子模組 prop 的 counter 的值。 - 子模組 prop 的 counter 值改變僅影響內部 counter 值 - 不論子模組的 prop 的 counter 值是否有變動，只要父模組資料 counter 改變時，子模組 prop 的 counter 值一定會連動。 改變子模組內的 prop 值 - 在 data 內創建一個值 賦予 data 跟 prop 初始值相同的值，且之後也是針對該 data 內的值操作，並且不會再受到該 prop 的影響了 物件型別的 prop 傳遞 - 父層透過標籤傳遞參數 - 子層 prop 接收參數後，透過 watch 將參數存入 data.return 子組件接收來自父組件的 props 在模板中 在 data 中 在 methods 中 在 mounted 中 在 computed 中 emit 子組件向父組件傳遞參數 最後輸出時，`已呼叫`為子組件輸出，`111111111111`為父組件輸出 ref 取得 Dom 元素 > `refs` 是 vue 提供的一個 api，可以讓我們在 vue 中取得 Dom 元素 `ref` 被用來給元素或子組件註冊引用訊息，引用訊息將會註冊在父組件的`$refs` 物件上，如果在普通的 dom 元素上使用，那麼指向的就會是普通的 dom 元素；如果用在子組件上，引用就會指向該子組件的實例。 ref 的特性就是為元素或子組件賦予一個 id 引用，通過 `this.$ref.refName` 來訪問元素或是子組件的實例。 - 一共有三種用法： - ref 加在普通元素上，用 `this.ref.name` 獲取到的是 dom 元素 - ref 加在子組件上，用 `this.ref.name` 方式，獲得的是組件實例，可以使用組件的所有方法。 - 如何利用 v-for 和 ref 獲取一組陣列或是 dom 節點 基本用法：取得 dom 元素 獲取子組件中的 data 和調用子組件的方法 this.$refs 介紹 `this.$refs` 為一個物件，持有當前組件中註冊過`ref`特性的所有`dom`元素和子組件實例。 注意：`$refs` 只有在組件完成渲染後才會填充，在初始渲染時無法取得，並且他是非響應式的，因此不能用他模版中做數據綁定。 當 ref 和 v-for 一起用時，你得到的 ref 將會是一個包含了對應的數據源的這些子組件的陣列。 this.$el 在 vue 中，this.$el 是一個指向 Vue 實例渲染的一個 dom 元素的引用。用來訪問 vue 實例所渲染的 dom 元素。 在 javascript 中使用 document 時，會進行全域的 dom 操作，而在 vue 中，this.$el 的 dom 作用範圍僅在執行的組件中。 Mixin 共用方法 > 參考資料： > > 彻底搞懂 Vue 中的 Mixin 混入（保姆级教程） 將組件的共用邏輯或設定抽出，當組件需要使用時，直接將抽出的部分混入到組件內部。 當 mixin 定義好之後，依據不同的業務場景，可以分為兩種：局部混入和全局混入。顧名思義，局部混入和元件的載入有點類似，就是當需要使用到 mixin 的程式碼時，在元件中引入。而全局混入則將 mixin 於 app.js 中引入，此時專案中任何元件都可以使用 mixin。 局部混入 在 component 中引入 mixin： 輸出： - mixin 的生命週期函數會和元件的生命週期一起合併執行 - 元件可以使用 mixin 中的 data 資料 - 元件中可以直接呼叫 mixin 中的方法 - 生命週期的執行順序為：先執行 mixin 再執行 component 若多個元件都有引入 mixin，當期中一個元件修改了 mixin 的資料，會影響其他元件嗎？ 在 App.vue 中引入 輸出： 由上面程式碼可以得知，當 App.vue 中修改 msg 後，demo 元件並沒有受到任何變化。 全域混入 將 mixin 在 main.js 中註冊後，便可以在任何元件中直接使用。 此時若將前面的 App.vue 中引入 mixin 的部分註解掉，會發現效果和局部混入沒有任何差別。 雖然這樣做很方便，但是一般而言不推薦。 vue 官方： > 請謹慎使用全域混入，因為他會影響每個獨立建立的 Vue 實例（包括第三方元件）。大多數情況下，只應應用於自訂選項，推薦將其作為插件發布，以避免重複應用程式混入。 vuex 和 mixin 的區別 - vuex: 用來做狀態管理，裡面定義的變數在不同元件中均可以使用和修改。而在任一元件中修改此變數的值後，其他元件中此變數的值也會隨之修改。 - mixin: 可以定義共用的變數，在每個組件之中使用。引入組件後，每個變數都是獨立的，值的修改在組件中不會互相影響。 備註 Truthy(真值) 與 Falsy(假值) - `Truthy`：真值，只要是假值(false, 0, -0, 0n, \"\", null, undefined, NaN)以外的任何值皆為 true - `Falsy`：假值 判斷當前環境是否為開發環境 取得 base_url - 在 html 加入 meta 標籤 - 此時就可以透過 meta 標籤取得 base_url",
    "path": "Javascript/Vue 學習筆記.md",
    "category": "Javascript"
  },
  {
    "id": "Javascript/VueX 學習筆記.md",
    "title": "VueX 學習筆記",
    "content": "VueX 學習筆記 - VueX 學習筆記 - 什麼是 Vuex - 帶入參數及呼叫方法 - State - mapState - Getters - mapGetters - mutations - mapMutations - actions - 專案結構 > 參考資料： > > Vuex 是什麼? 怎麼用? > > 實作： > > github-repo > > github-pages 什麼是 Vuex 一個專門為 vue 專案開發的資料管理套件，可以為網站做全域的資料管理。 在專案結構下面可能會有多個組件，組件中又會有組件，組件的溝通，通常會會透過 emit 和 prop，而為了處理大型專案的兄弟組件間的溝通，Vuex 就這樣誕生了。 Vuex 有一點像是全域的 components，大家可以拿他資料，呼叫他出來用。 state 就像是 data，action + Mutation 就像是 methods，getters 就像 computed 在 Vuex 中，儲存的狀態為 State，Component 使用 Dispatch 呼叫 Actions，讓 Actions 發出 commit 觸發 Mutations 去修改 State 的資料。整個 Vuex 的方法也稱為 store。 帶入參數及呼叫方法 State - 定義：/store.js - 使用：/app.vue mapState - 定義：/store.js - 使用：/app.vue Getters - 可帶參數：state, getters - 定義：/store.js - 使用：/app.vue 加上參數 getters 表示可以呼叫別的 getters 來用 - 定義：/store.js - 使用：/app.vue mapGetters 定義和上面的 store.js 相同，差異在 components 呼叫的時候 - 使用： mutations 可帶參數：state, payload - 使用：/app.vue - with payload: 通常 payload 可以用物件表示，就能更具描述性，但是要記得在 mutations 運算時，帶入的參數 payload 要加上參數物件的 key - /app.vue - /store.js - 所以帶上 payload 的呼叫可以這樣使用： 物件 type 是必要的，其他可以隨意 mapMutations 使用 mapMutations，就要把 payload 直接帶入 template： 注意：mutations 一定只能同步執行，action 才能執行非同步 actions - 可帶參數： - context: {commit, dispatch, state, getters, rootState, rootGetters}, payload 上面描述 mutations 只能同步執行，action 執行非同步，意旨 axios 要在 Actions 裡面做，不可以在 mutations 裡面做。 - 定義：/app.vue - 使用：/app.vue 專案結構 1. App 層級的狀態要在 state 集中管理 > app 層級的意思是指：不會因為跨組件改變的狀態，如：登入資訊、購物車清單...等。 > > 會因為跨組件改變的狀態，如：下拉式選單的開關狀態、商品列表...等。 2. 唯一改變 state 的方式只有 mutations，而且是同步執行 3. actions 才可以非同步執行",
    "path": "Javascript/VueX 學習筆記.md",
    "category": "Javascript"
  },
  {
    "id": "PHP/Carbon 學習筆記.md",
    "title": "Carbon 學習筆記",
    "content": "Carbon 學習筆記 - Carbon 學習筆記 - 物件建立 - 建立當下時間 - 解析並產生時間物件 - 依規則建立 - Bug 與安全模式 - 時間格式 時區、本地化 - 本地語系 - Format - Getter \\& Setter - 時間屬性 - 時間與語系 - Setter - 比較 - 大於、小於和等於 - 之間、最小最大與最近最遠 - 和今天比較 - 時間運算 - Overflow 溢出 - 差異 - 一般差異 - Real Difference - 口語化修改器 > php 常用處理時間格式的套件 > > 在 laravel 5.0 之後為預設套件 > > 底層是使用 PHP `Datetime` 的 `strtotime` 方法 > > --- > > 參考資料： > > Carbon 使用技巧整理 (上) > > Carbon 使用技巧整理 (下) > > Laravel 5 學習筆記 - Carbon 時間套件 物件建立 建立當下時間 - 直接建立可以解析文字，且指定時區 解析並產生時間物件 依規則建立 - 若傳入的資料不完整，亦能產生時間物件，預設為最小值 - 也可以用 `parse` 的方式操作 `create` - 若不帶值，則會產生 `0001-01-01` Bug 與安全模式 - `createFrom()` 其預設帶值的特性是取的當下時間，因此若在大月的月底使用，容易有跨月的問題 - 使用 `createSafe()` 安全模式建立，會幫忙檢查其合理性。若傳入不合法的數值，會回傳 Exception。 時間格式 時區、本地化 | 單位 | 縮寫 | | :-------------------: | :--: | | 年(四位數) | Y | | 年(二位數) | y | | 月(英文) | F | | 月(英文縮寫) | M | | 月(補 0 至二位數) | m | | 日(補 0 至二位數) | d | | 日 | j | | 星期(英文) | l | | 星期(英文縮寫) | D | | 星期(英文縮寫 + 逗號) | r | | 星期(數字) | w | | 時(24) | G | | 時(12) | g | | 時(24, 補 0 至二位數) | H | | 時(12, 補 0 至二位數) | h | | 分 | i | | 秒 | s | | 毫秒 | S | | 時區 | e | | 時區 | T | | 時差 | P | | 時間戳 | U | 本地語系 - Laravel 程式預設 - 手動設定 Format - 除了利用 `format()` 輸出時間格式，也可以使用 `toDateString()`, `toTimeString()`, `toISOString()` 等方法，將時間物件轉換成字串，亦有提供 `toArray()`, `toObject()` 方法。 - 利用 `hasFormat()` 來判斷 `format` 格式 - `hasFormatWithModifiers()` 為模糊比對，可以用 `#` 區隔時間縮碼，可以同時判斷 `/`, `-` Getter & Setter 時間屬性 時間與語系 - 判斷時間事件的語系有沒有符合應用程式，及有沒有使用 UTC 國際標準時區 Setter - 直接依單位設定時間 - `setTimeFrom()` 保持日期，只設定時分秒 - `setDateFrom()` - `setDateTimeFrom()` - 注意！以上作法不會改變時區 比較 大於、小於和等於 之間、最小最大與最近最遠 - `closest` 和 `farthest` 函式可以找出兩個時間物件中，與特定時間物件最接近或最遙遠的物件 和今天比較 - 另外還有 `isMonday()` `isTomorrow()` `isToday()`，`isBirthday()` 可以判斷是否為不同年的同一天 時間運算 重要觀念：carbon 物件在運算過程中會改變原始物件，因此在運算之前要加上 `copy()` 語法。 Overflow 溢出 - 一般而言，加上一個月後應該要是二月底(2/28 或 2/29)，為避免不合理的狀況發生，須加上 `NoOverflow` 關鍵字，讓運算結果不會溢出 另外亦可以使用 `addUnitNoOverflow` 針對溢出的單位做控管，也可以在設定值，規定不可以溢出 差異 一般差異 - 無條件捨去，滿一個時間單位，才會回傳 1 - 除了整數的差異，也可以比對到小數點單位的時間差 - 不建議用做計算月份，會有 bug Real Difference - 運算時，若出現跨日的情形，時間物件的時區會自動針對該值做增減，而在比較兩個時間點的差異時，若未用 `real` 則會計算出表面的時間差。 口語化修改器 - 亦支援 `today()`, `yesterday()`, `next()`",
    "path": "PHP/Carbon 學習筆記.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel API Format.md",
    "title": "Laravel API Format",
    "content": "Laravel API Format - Laravel API Format - spatie/laravel-fractal 套件 - 建立 transformer - 在 controller 中使用 transformer - API Resource > api 返回資料若以原生格式返回，沒有經過任何處理，可能包含敏感資訊 > > 利用 transformer 可以將 api 響應的訊息系統化規則，進行統一輸出，方便管理與編輯 > > 參考資料： > > Laravel API 系列教程（三）：使用 API Resource 来创建自己的 {JSON:API} 格式 API > > Laravel 構建 API 伺服器之響應資料處理 > > Laravel 8 中文文檔 API 资源 spatie/laravel-fractal 套件 安裝完成後，在 laravel 中註冊 建立 transformer 在 app/Http 的目錄下建立 Transformers 目錄 返回的陣列代表真實要響應的 json 資料格式 在 controller 中使用 transformer 匯入 transformer 命名空間 輸出： API Resource Laravel 5.5 新增的 API Resource，和 transformer 功能與思路基本上一樣 但由於是 laravel 官方釋出，因此與 Laravel Eloquent model 各種功能結合的更加緊密 生成的檔案位於 app/Http/Resources 目錄底下 在 controller 中將 transformer 實例化 預設數據會被包在 data 的物件裡面，可以透過 `withoutWrapping()` 來將其去除",
    "path": "PHP/Laravel API Format.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel Artisan command.md",
    "title": "Laravel Artisan command",
    "content": "Artisan Command 自訂 Artisan command 利用指令建立要自訂命令的檔案 建立的檔案位置會在 app/Console/Commands 編輯檔案 編輯指令名稱 實際指令 編寫命令 參數 - 花括號中為傳入的參數 - {country_code?} 可選的參數 - {country_code=tw} 參數的預設值 - {country_code} ``代表輸入的是陣列 - {country_code:國家代碼} 加入敘述 - 選項：關鍵字是`--` - {--queue=} 選項後面加上 `=`，表示選項需要明確指定值。 - {--Q|queue} 可用簡寫 - {--id=} ``代表輸入的是陣列 - {--queue=:這個工作是否該進入隊列} 加入敘述 - 取得參數 - $this->argument('user') 取得單一 user 參數 - $this->arguments() 取得所有參數，以陣列呈現 - $this->options('queue') 取得單一 queue 選項 - $this->options() 取得所有選項，以陣列呈現 - 互動式指令 - ask 詢問 - secret 詢問，但回答在終端機看不到 - confirm 確認問題，預設回傳值是 false，若使用者回傳 y 則回傳 true - anticipate 自動完成，若是 Taylor 或是 Dayle 這兩個選項就自動完成，使用者亦可以輸入其他選項 - choice 選項選擇，使用者輸入 key 值 註冊 command app\\console\\Commands\\Kernel.php",
    "path": "PHP/Laravel Artisan command.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel Collections & Helper.md",
    "title": "Laravel Collections & Helper",
    "content": "Laravel Collections & Helper - Laravel Collections \\& Helper - Collections 集合 - 運算類 - Integer - `count` 計數 - Boolean - `contains` 判斷集合是否包含指定的條件 - Array - `diff` 比較集合或陣列的值 - 迭代類 - `filter` 傳入匿名函式篩選集合 - `map` 遍歷集合 - 分組類 - `countBy` 計算指定數值 - 變形類 - 維度與順序 - `collapse` , `flatten` - `sort` 將陣列重新排列 - 組合 - `combine` 將一個集合的值作為 key，用來和另一陣列或集合的值進行組合 - `merge` 合併指定的陣列或是集合到原集合 - `concat` 將傳入的值追加到集合的末端 - `push` 把指定的值加入集合的末端 - `prepend` 將指定的值加入集合的開頭 - 擷取 - `except` 擷取除了 a, b 以外的 - `only` 只擷取 a, b - `get` 取得特定 key 的值 - `forget` 直接刪除指定 key 值對應的 value - `pull` 和 `get` 雷同，會修改原本的 collection - `pluck` 取得集合中所有陣列的 key 值 - `intersect` 從原集合中移除在指定陣列中或集合中不存在的值 - `keys`, `values` 取出集合中的 key 或 value - 轉型 - `toArray`, `toJson` 提供轉成陣列或是 json 等常用格式 - Where - 'first' 返回陣列中指令條件的第一元素 - 軟體操作類 - `collect` 複製一個新的 collection，記憶體位置不衝突 - Helper 輔助函數 - `Arr::add` 將數值加入陣列 - `after` 返回傳入的字串的值後面所有的內容 Collections 集合 > 參考資料 > > Laravel — Collection 用途大解析 運算類 方便進行數學運算，或是判斷是否含有特定值，也能比較兩個 collection 之間的不同 Integer `count` 計數 Boolean `contains` 判斷集合是否包含指定的條件 傳入值 傳入陣列 傳遞匿名函數 - `containsStrict()` 方法和 `contains()` 類似，但他在比較時更嚴格。 Array `diff` 比較集合或陣列的值 返回不存在此方法參數中的值 迭代類 `filter` 傳入匿名函式篩選集合 返回通過篩選的項目 `map` 遍歷集合 將集合的值透過傳入的匿名函數修改並返回，生成修改過的新集合 分組類 `countBy` 計算指定數值 可以傳入匿名函數來自訂要計數的值 變形類 將 collection 改變資料結構 維度與順序 `collapse` , `flatten` 兩者都是將維度從多維降為一維，collapse 較適用 Array 形式的資料，flatten 更適合有 Key-Value 形式的資料。 兩個函式的用途，都是將例如 [[1,2,3], [4,5,6]] 轉變成 [1,2,3,4,5,6] `sort` 將陣列重新排列 根據傳入匿名函數返回的結果，對陣列進行排序 利用 key 值替陣列排序 輸出 組合 `combine` 將一個集合的值作為 key，用來和另一陣列或集合的值進行組合 `merge` 合併指定的陣列或是集合到原集合 若傳入的集合中的 key 值與原集合中的 key 值相同，則傳入的值將會將原集合中的值覆蓋。 若傳入的集合項為數字，則這些值將會追加在集合的最後面。 `concat` 將傳入的值追加到集合的末端 `push` 把指定的值加入集合的末端 `prepend` 將指定的值加入集合的開頭 擷取 `except` 擷取除了 a, b 以外的 `only` 只擷取 a, b `get` 取得特定 key 的值 `forget` 直接刪除指定 key 值對應的 value `pull` 和 `get` 雷同，會修改原本的 collection `pluck` 取得集合中所有陣列的 key 值 `intersect` 從原集合中移除在指定陣列中或集合中不存在的值 `keys`, `values` 取出集合中的 key 或 value 轉型 `toArray`, `toJson` 提供轉成陣列或是 json 等常用格式 Where collection 和 laravel 本身的 ORM 系統 Eloquent 密不可分，因此也配合支援許多 where 語法，使用方法類似 MySQL。 'first' 返回陣列中指令條件的第一元素 若 `first` 方法不傳入參數，則返回集合中第一元素。若集合為空，則返回 `null` 軟體操作類 `collect` 複製一個新的 collection，記憶體位置不衝突 Helper 輔助函數 `Arr::add` 將數值加入陣列 `after` 返回傳入的字串的值後面所有的內容 如果傳入的值不存在，將返回整個字串",
    "path": "PHP/Laravel Collections & Helper.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel Eloquent ORM.md",
    "title": "Laravel Eloquent ORM",
    "content": "Laravel Eloquent ORM - Laravel Eloquent ORM - models - 建立 Model - 基本屬性 - 關聯 - 多型態關聯 - 多形一對一關聯 - 多型一對多關聯 - 多型多對多關聯 - 自訂多型型別 - Laravel ORM 將資料存至資料庫 - save - 修改多對多中間表 - ORM N+1 - 什麼是 N+1 - 解決 N+1 的問題 - 序列化 - 將 collection 序列化 - array - JSON - 隱藏 JSON 屬性 - 臨時修改屬性可見度 - 追加 JSON 值 - 臨時追加屬性 - 日期序列化 - 自訂任意屬性的日期格式 - 刪除 - 普通刪除 - 軟刪除 - 啟用軟刪除 - 軟刪除應用 - 實現中間表的軟刪除 - 清除舊的軟刪除資料 models 建立 Model 建立 Model 同時建立與其相關的 class 基本屬性 - public $timestamps = false // 關閉時間戳記，預設為開啟 - 批量賦值：調用 create() update() 時，可以大量新增、修改的欄位。若沒有添加這個屬性，新增修改的動作將無法實現。 - $fillable 設定可以大量新增的欄位（白名單） - $guarded 設定需要被保護的欄位（黑名單） - 屬性類型轉換：`$casts` 可以將屬性轉換為指定的類型，支援的類型有 - `integer` - `real` - `float` - `double` - `decimal: ` 需定義小數位的個數，如 `decimal:2` - `string` - `boolean` - `object` - `array` - `collection` - `date` - `datetime` - `timestamps` 關聯 多型態關聯 > 參考資料 > > 多型態關聯可以讓一張表同時關連到兩張以上的資料表 > > 優點: > 可以合一管理資類類似的資料結構與處理邏輯 > 缺點: > 耦合提高，變動邏輯時容易影響到某一方的操作 假設我們有 user 跟 post 兩種資料，而他們各自有所屬的 image 資料表 | users | | :---: | | id | | name | | user_images | | :---------: | | id | | user_id | | url | | posts | | :---: | | id | | name | | post_images | | :---------: | | id | | post_id | | url | 如果 image 的資料結構和處理邏輯相似，就可以使用多型態關聯，將表單合成一張 | users | | :---: | | id | | name | | posts | | :---: | | id | | name | | images | | :-------------: | | id | | imaginable_type | | imaginable_id | | url | - imaginable_id : 關聯的主鍵值 - imaginable_type : 指定這筆資料是關聯 users 資料表還是 posts 資料表，欄內儲存的是類別名稱，型態為字串，如：'App\\Models\\User' 'App\\Models\\Post' 多形一對一關聯 - `morphOne`: hasOne 的多型態版本 和 hasOne 相比，標類別後面多了一個 name 參數 imaginable，Eloquent 會根據這個 name 預設目標表單上的查詢欄位，以 imaginable 為例的話就是查詢 imaginabletype 跟 imaginableid - 自訂目標的查詢欄位名稱 - `morphTo`: belongsTo 的多型態版本 如果沒有帶入參數的話預設會用函式的名稱產出預設名稱，像這裡的函式名稱是 imaginable ，那查詢時就會以型別欄位 imaginabletype 查對應的資料表，以及鍵值欄位 imaginableid 查資料。 - 自訂預設名稱 - 自訂查詢欄位的名稱 多型一對多關聯 和一對一的關聯差不多，差別在 morphOne 改成 morphMany，查詢得到的資料不是一筆而是一組 多型多對多關聯 > 和普通多對多關聯相比，中介表為多型態 影片和文章有相同的 tag，一篇文章和影片同時會有多個 tag，一個 tag 也會同時關連到多個影片或文章 | videos | | :----: | | id | | name | | posts | | :---: | | id | | name | | taggable | | :-----------: | | id | | tag_id | | taggable_type | | taggable_id | | tags | | :--: | | id | | name | 多型的一方，會用 morphToMany 方法 反向關聯會使用 morphedByMany 方法 - `morphToMany`: belongsToMany 的多型態版 - `morphedByMany`: 多對多的反向多型關聯 需要帶多型的名稱參數才能查詢資料 - 自訂名稱 自訂多型型別 預設 laravel 會使用類別的完整名稱來儲存 model type。 可以透過自訂多型型別，使用簡單的字串作為 model type，將這些值從專案的內部結構中解耦出來。 如此一來，即使修改 model 名稱，資料庫中的多型 type 欄位也會繼續有效。 - 例如： Commit Model 可以隸屬於 Post Model 或 Video Model。因此，comments 資料表中的 commentable_type 欄位分別會記載 App\\Models\\Post 或 App\\Models\\Video。 此時可以在 `App\\Providers\\AppServiceProvider` 中的 `boot` 方法，呼叫`enforceMorphMap`方法。將 post 及 video 等簡單字串作為 model type。 Laravel ORM 將資料存至資料庫 save 將表格第一筆資料的名字，改成小華 也可以一次編輯多個欄位 修改多對多中間表 - articles | id | article_name | | :-: | :----------: | | 1 | article1 | | 2 | article2 | | 3 | article3 | | 4 | article5 | - tags | id | tag_name | | :-: | :------: | | 1 | tech | | 2 | music | | 3 | art | | 4 | food | - article_tag | articleid | tagid | | :--------: | :----: | | 1 | 2 | | 1 | 3 | | 1 | 4 | | 3 | 4 | 建立和控制多對多關係的方法 - 建立: - `attach()` - `save()` | 方法 | 單個 id | 多個 id | 單個 model | 多個 model | | :------: | :-----: | :-----: | :--------: | :-------------: | | attach() | V | V | V | | | sync() | V | V | V | | | save() | | | V | 要用 saveMany() | - 刪去: `detach()` - 同步 - `sync` - `syncWithoutDetaching` - `updateExistingPivot` - 切換: `toggle()` ORM N+1 > 紀錄 ORM 對資料庫的查詢語法 > > 什麼是 N+1 資料表中有關聯關係，以論壇文章為例。 - 一名使用者，可以發布多篇文章。 - 一篇文章只屬於一名使用者。 使用者與文章的關係為一對多。當我們要取得多名使用者，並同時取得這些使用者過去發布的所有文章時： 這時就會產生 n+1 的問題。 第一筆查詢是取得所有用戶。 接下來每一筆是取得各用戶發布的文章。 解決 N+1 的問題 可以使用 laravel 所提供的預加載功能 `with()` 這時僅執行了兩個查詢 可以指定不需要某些資料 或是只需要其他資料 也可以加載多個關聯 序列化 > 建構 JSON API 時，針對 model 及其取得關連的值，將其轉化為 array 或是 JSON 將 collection 序列化 array - `toArray()` 所有的屬性和關聯(包括關聯的關聯)，當將轉化為陣列。 - `attributesToArray()` 僅將 model 的屬性轉換為陣列 JSON - `toJson` 所有的屬性和關聯(包括關聯的關聯)，當將轉化為 JSON。 - 將 model 或 collection 轉為字串時，會自動調用`toJson()`，因此可以應用在 route 或 controller 中直接返回。 - 關聯屬性：當 model 被轉化為 JSON 的時候，他加載的關聯關係也將自動轉化為 JSON 對象被包含進來，同時透過小駝峰定義的關聯方式，關聯的 JSON 屬性將會是蛇底式命名。 隱藏 JSON 屬性 > 有時需要將 model array 或 JSON 中某些屬性進行隱藏，如：密碼。 - `$hidden` - `$visible` 定義一個 model array 和 JSON 可見的白名單。經過定義後，序列化此 model 不會出現白名單以外的屬性。 臨時修改屬性可見度 - `makeVisible` - `makeHidden` 追加 JSON 值 > 在 array 或是 JSON 中添加一些不存在於資料庫的欄位。 定義 `getAttribute` 然後在 model 中宣告屬性 `appends`。 - Notice: 在`getAttribute`中使用駝峰命名，但在宣告屬性時，通常以蛇底式命名。 宣告 `append` 追加屬性後，其將會被包含在 model array 和 JSON 中。追加屬性也會遵循 model 宣告的`visible`及`hidden`屬性。 臨時追加屬性 可以在單一 model 實例，使用`append`方法蘭追加屬性。或者使用`setAppends`方法來重寫追加屬性的陣列。 日期序列化 - `serializeDate` 此方法可自訂預設的日期序列化格式 自訂任意屬性的日期格式 可以在 Eloquent 宣告屬性轉換，單獨為資料庫中為日期屬性的欄位定義其格式 刪除 普通刪除 透過 id 刪除 刪除查詢結果 軟刪除 > 透過在資料表中增加一個 delete_at 的欄位，來標記要刪除的資料，而不是直接將資料刪除。 > > 優點：刪除的資料可以被復原、可以記錄資料刪除的時間點。 > > 缺點：中間表無法使用軟刪除、需要定時清理軟刪除的資料，以免資料庫日益肥大。 啟用軟刪除 將 `Illuminate\\Database\\Eloquent\\SoftDeletes` Trait 加到 Model 上 利用 migration 將 delete_at 欄位加入資料表 當在 model 上呼叫 delete 方法時，會自動更新 delete_at 欄位，並設為當前時間。 軟刪除應用 - 判斷是否已被軟刪除 - 恢復軟刪除 - 永久刪除 model - 查詢軟刪除的 model - 包含軟刪除的 model - 只取得被刪除的 model 實現中間表的軟刪除 > 一般不建議對 pivot 進行軟刪除。 在 pivot 表，添加一個 bool 欄位，ex: is_deleted。 - `updateExistingPivot()` 此方法可以修改這欄位 - `wherePivot('is_deleted', true)` 可以篩選數據 或者在關聯中，定義兩者的關係 清除舊的軟刪除資料 參考資料",
    "path": "PHP/Laravel Eloquent ORM.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel Excel.md",
    "title": "Laravel Excel",
    "content": "Laravel Excel > 使用套件： > > - maatwebsite/Excel 3.1 > > 環境要求： > > - PHP `^7.0` > > - Laravel `^5.5` > > 參考資料： > > - maatwebsite/Excel 3.1 使用教程 （导入篇） > > - maatwebsite/Excel 3.1 使用教程 （导出篇） 安裝 excel 匯出 建立匯出文件，匯入匯出的業務盡量不要和原來的業務耦合 在 app 目錄下建立 Export 資料夾 - UserExport.php - UserController.php 欄位格式化：設定儲存格格式 自動欄寬 匯出多個工作表(sheet) 匯出多個表需要兩步驟，先組裝 sheet，後建立對應的 sheet 表。 然後新增 UserPerMonthSheet Class 事件模組：設定儲存格高度、垂直置中、字體顏色、背景顏色 提供多種事件：BeforeExport, BeforeWriting, BeforeSheet, AfterSheet 等等，修改儲存格使用 AfterSheet 搭配 vue 前端 > 參考資料 > > Day17 使用 Laravel Excel 來匯出資料 excel 匯入",
    "path": "PHP/Laravel Excel.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel HTTP Client.md",
    "title": "Laravel HTTP Client",
    "content": "laravel HTTP Client > laravel 透過 Guzzle 這個套件，模擬 http client 來發送 request > 預設情況下，laravel 已經自動包含了這個套件。 > 若尚未安裝，可透過 composer 再安裝一次。 > > 建立 request 建立基礎的 GET request 可以直接將查詢字串(query string)加到 URL 上，或是傳入一組索引鍵/值配對的陣列作為 get 的第二個引數 get 方法會回傳 Illuminate\\Http\\Client\\Response 的實體，該實體提供了許多用來取得 Response 資訊的方法： POST PUT PATCH 等 HTTP action 傳送額外資料，一般情況下，資料會使用 json 的資料型別來傳遞 若想用 x-www-form-urlencoded 來傳送資料，要在建立 request 前呼叫 asForm() 方法 錯誤處理 laravel HTTP client 不會在 client 端或是 server 端錯誤時拋出異常(status code 400 or 500)。 此時可以透過 successful, clientError 或是 serverError 方法來判斷是否發生錯誤。",
    "path": "PHP/Laravel HTTP Client.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel Middleware.md",
    "title": "Laravel Middleware",
    "content": "Laravel Middleware 定義 middleware 在 `app/Http/Middleware` 目錄之下產生一個新的 CheckAge class，並在其中建立規則：僅允許 `age` 參數大於 200 的請求路徑進行訪問，否則將重新導向至 `home` 頁面 可以設定 middleware 的動作是在 request 之前或是之後 註冊 Middleware",
    "path": "PHP/Laravel Middleware.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel Migration & Seeder & Factory.md",
    "title": "Laravel Migration & Seeder & Factory",
    "content": "Laravel Migration & Seeder & Factory - Laravel Migration \\& Seeder \\& Factory - Migration - 產生 Migration 檔案 - 執行 Migrate - 還原 Migrate - 重置 Migration - Seed - 產生 Seeder 檔案 - 執行 Seeder - Factory - 產生 Factory 檔案 - Faker Formatters Migration 產生 Migration 檔案 - 產生出來的 Migration 檔案，內有 up() 和 down() 兩個方法。 執行 Migrate 還原 Migrate - 實際上他會實作 down() ，並將資料表內的資料刪掉。 - 如果今天將 down() 註解掉，一樣會進行 Migrate 刪除 table 中的資料，但不會刪除資料表。 重置 Migration Seed 產生 Seeder 檔案 此時會多出一個檔案`database/seeds/PersonTableSeeder.php`， 在`database/seeds/DatabaseSeeder.php`中，修改要呼叫的 Seeder： 執行 Seeder 時會呼叫 seeder 類別裡預設的 run() 方法。 在`PersonTableSeeder.php`中加入要產生的資料。 也可以使用模型工廠 factory 來大量生產資料。 執行 Seeder 用`--class`來指定特定的 Seeder Class Factory > 深入了解 Faker 產生 Factory 檔案 `--model=Person`選項用在指定 Factory 創建的 model 名稱，將會為指定 model 產生 Factory 文件。 到`/database/factories/PersonFactory.php`，設定要填充的資料欄位。 工廠物件實例化 當定義好工廠物件後，可以使用 model 的 factory 的靜態方法將工廠物件實例化。 Faker Formatters - Faker 使用中文 在 config\\app.php 下新增一行，指定 Faker 使用 zh_TW 語言",
    "path": "PHP/Laravel Migration & Seeder & Factory.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel Test.md",
    "title": "Laravel Test",
    "content": "Laravel Test > Laravel 預設支援 PHPUnit 來進行測試 > > 設定文件 phpunit.xml > > 在 test 資料夾中有兩個子資料夾 > > Feature 功能測試是針對大面積的程式碼進行測試 > > Unit 單元測試是針對單一方法單獨進行測試 啟動測試 建立測試文件 啟動測試 Laravel PHPUnit 測試指令 🔹 1. 執行全部測試 --- 🔹 2. 執行特定資料夾的測試 --- 🔹 3. 執行特定檔案 --- 🔹 4. 執行特定 class --- 🔹 5. 執行特定測試方法 （例如 `teststoreapi`） 或搭配檔案： --- 🔹 6. 顯示更乾淨的輸出（加 `-testdox`） 輸出會變成比較可讀的格式，例如： --- 🔹 7. 只跑失敗過的測試 （需要 `phpunit.xml` 設定 cache，Laravel 預設就有） 🔹 8. 執行測試覆蓋率報告 - ✅ 成功產出 `coverage/index.html` - ✅ 可使用 `php -S 0.0.0.0:8082 -t coverage/` 架簡易伺服器觀看",
    "path": "PHP/Laravel Test.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel 中大型專案架構.md",
    "title": "Laravel 中大型專案架構",
    "content": "Laravel 中大型專案架構 > 參考資料： > > Laravel 中大型專案架構",
    "path": "PHP/Laravel 中大型專案架構.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel 事件.md",
    "title": "Laravel 事件",
    "content": "Laravel 事件 > Event 類別一般儲存在 app/Event 目錄下 > Listener 類別則存在 app/Listeners 目錄下 註冊 Event 與 Listener 首先在 laravel 專案中的 App\\Providers\\EventServiceProvider 註冊事件和監聽者 - `$listen` 屬性是一個陣列，包含所有 `Event`(key) 和其 `listener`(value) - 可以使用 `php artisan event:list` 來列出所有註冊的 `Event` 和 `listener` 產生 Event Listener 在 EventServiceProvider 中註冊後，使用 artisan 指令，即可產生 EventServiceProvider 中已註冊但尚未生成的 Event 和 Listener 或者也可以分別建立 Event 和 Listener 此時會產生兩個文件，分別為： app\\Events\\OrderShipped.php app\\Listeners\\SendShipmentNotification.php 手動註冊 除了在 EventServiceProvider 的 class 中宣告 $listen 屬性外，也可以在 class 中的 boot() 方法手動註冊基於 class 或是匿名函數的 Listener 一個 Listener 處理多個 Event 使用 `*` 作為萬用字元參數來註冊 Listener，實現一個監聽者對應多個事件 - 此監聽者接收事件名作為第一個參數，並將整個事件數據，作為第二個參數 Event Discovery 事件發現 啟用事件發現時，laravel 會搜尋專案的 `app/Listener` 目錄自動尋找並註冊事件與監聽器。 此外，列在 `EventServiceProvider` 中有被正確定義的事件也會被註冊。 在預設中，事件發現預設是關閉，可以在 `EventServiceProvider` 上複寫 `shouldDiscoverEvents()` 方法來啟用 定義 Event Event class 基本上就是一個資料容器，用來保存與該事件相關的資訊。 假設有一個事件會接收 Eloquent ORM 的物件，`App\\Events\\OrderShipped` 在 class 中加入 $order 屬性，並在建構子中加入 $this->order = $order - 在 Event class 中不包含邏輯，只作為已付款訂單 `App\\Models\\Order` 實體的容器 定義 Listener 事件監聽器會在 handle() 中接收 Event 實體，當使用 artisan 指定建立監聽器時，會自動載入相對應的 Event class，並在 handle() 做 Event 的型別提示 停止事件的傳播 若要停止將某個事件傳播到另一個監聽器上，只要在監聽器的 handle 方法是回傳 false 即可 觸發事件 將 order 物件傳入 controller，listener 的 handle 方法中可以拿到 event 中的 order 變數，後續就可以觸發事件的邏輯 分派 Event 呼叫事件上的靜態方法 `dispatch` ，此方法由 `Illuminate\\Foundation\\Events\\Dispatchable` 提供 任何傳入此方法的值，會被傳給 Event 的 Constructor 實作範例 > 最簡單易懂的 laravel 事件，這個功能非常的有用 情境 在用戶註冊時，發送幫助電子郵件給用戶 以下為原始的註冊方法 現在有一個需求，註冊成功之後，向用戶的電子信箱發送一個廣告 此時再增加一個發送簡訊的需求 接著又有新的需求：發送 IM 消息，雖然將許多的功能寫在一個 function 中很直觀，但當多人協作時，會產生各種不便。 事件功能 laravel 事件功能實際上更傾向於一種管理手段 + 實現的體現。 我們可以透過 laravel 事件功能，宏觀的看到所有的事件，而不需每次都要打開 controller 的方法才能知道註冊之後發生什麼事 我們要在註冊之後作一系列事情，首先在註冊完之後調用一個事件，然後這個事件在做各式各樣的事。 找到 app\\Providers\\EventServiceProvider.php 文件，並加入關係 這是註冊事件的入口，相當於一個總目錄，這樣就可以跟註冊的程式碼，未來增加功能時，便不須再查看註冊方法的程式碼 註冊完成後會觸發 App\\Events\\Register 類別，然後這個類會被 App\\Listeners\\SendAdMail, App\\Listeners\\SendSms, App\\Listeners\\SendHelpInformation 監聽到 此時進入 App\\Events 目錄，建立 Register 這個 class 接著在 app\\Listeners 目錄底下建立各種事件監聽 class",
    "path": "PHP/Laravel 事件.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel 命名原則.md",
    "title": "Laravel 命名原則",
    "content": "laravel 命名原則 - 對於類、介面/契約、特性：使用 大駝峰式「PascalCase」 - 對於常量：使用「TITLE_CASE」 - 對於函式/方法、類屬性和變數：使用 小駝峰式「camelCase」 - 對於陣列索引/資料庫欄位名/模型可填充項/模型關係：使用 蛇形命名法「lowersnakecase」 - 對於路由：使用 短橫線「lower-kebab-case」 | | 命名方式 | 範例 | | :---------------------: | :-----------------------------: | :-----------------------------------: | | Controller | 單數、大駝峰 | UserController | | Route | 複數 | articles/1 | | Named Route - 路由命名 | 使用點標記的蛇底式 | users.show_active | | Model | 單數 | User | | hasOne, belongTo 的關聯 | 單數/小駝峰 | articleComment | | 其他關連 | 複數/小駝峰 | articleComments | | 資料表 | 複數/蛇底式 | article_comments | | Pivot Table 中介表 | 以字母順序排列的單數 Model 名稱 | article_user | | 資料表欄位 | 蛇底式/不包含 model 名稱 | meta_title | | model 屬性 | 蛇底式 | $model->created_at | | Foreign Key - 外鍵 | 以單數 Model 名稱後方加上 \\id | articleid | | 方法 | 小駝峰 | getAll | | 測試類別中的方法 | 小駝峰 | testGuestCannotSeeArticle | | 變數 | 小駝峰 | $articlesWithAuthor | | Collection | 描述性名稱/複數 | $activeUsers = User::active()->get() | | 物件 | 描述性名稱/單數 | $activeUser = User::active()->first() | | 設定檔及語系檔的索引鍵 | 蛇底式 | articles_enabled | | View | kebab-case | show-filtered.blade.php | | 設定檔 | 蛇底式 | google_calendar.php | | Contract (界面) | 形容詞或名詞 | AuthenticationInterface | | trait | 形容詞 | Notifiable |",
    "path": "PHP/Laravel 命名原則.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel 學習筆記.md",
    "title": "Laravel 學習筆記",
    "content": "Laravel 學習筆記 > 請先完成 laravel 環境設置 - Laravel 學習筆記 - 基礎建立 - 連線資料庫將資料顯示在畫面上 - mysql - redis - 新增一個 html 測試`input`到資料庫 - 將變數傳入 `view` 的三種方法 - Controller - 生成 controller - resource controller function - controller 傳入參數 - 參數預設值 - Route - route 基本寫法 - resource controller 資源控制器 - route 分組 - Laravel 功能實現 - 儲存檔案並刪除舊檔 - Class not found - 框架設計模式 - 每一層的職責 - MVC 框架 - Web API Service 基礎建立 - 建立新的專案 - 安裝指定本版 - 同時建立 migration controller model - 建立 Controller - 控制器路徑 app/Http/controllers/NewController.php - 控制器名稱字首需大寫 - 啟動 Laravel 伺服器 - 使用路由 連線資料庫將資料顯示在畫面上 mysql - Laravel 資料庫設定檔 `.env` - 建立一個 model - model 路徑 app/Models/News.php - Controller 參用 News model - 如何把陣列顯示在前台 (回傳`json`格式) - 接收 `Route::post` 的路由接引到 `store(`) 完成資料庫的新增 redis > 需先在環境安裝 redis - 安裝 `predis` - redis 預設有 16 個資料庫，Laravel 會使用預設的資料庫`0` - 修改 `env` - 使用方法 - redis-cil - 須注意 laravel 預設的 redis key 會有 `laraveldatabase` 這個前綴：`$ get laraveldatabase${yourkey}`。這個前綴設定可以在 `env` 中的 `REDISPREFIX` 修改 新增一個 html 測試`input`到資料庫 - 修改 controller - 修改 `VerifyCsrfToken.php`，先略過資料傳送的資安問題 - 路徑 `/home` 底下都先忽略 - 在 model 增加 將變數傳入 `view` 的三種方法 1. with: 用於簡單傳遞變數，但不易擴充傳遞變數，所以不常用到 2. Array 3. compact Controller 生成 controller - `--resource` - 在`function/` 的目錄下，新增一個資源控制器 - 生成`index()` `create()` `store()` `show()` `edit()` `update()` `destroy()` - `--api` - 一般 api 控制器會新增在 Controller/api 的目錄之下 - 生成`index()` `store()` `show()` `update()` `destroy()`，省略 `create()` `edit()` 方法 resource controller function - `index()`: 顯示所有資料的列表 - `create()`: 顯示新增畫面 - `store()`: 新增資料 - `show()`: 顯示指定 id 的資料 - `edit()`: 顯示編輯的畫面 - `update()`: 更新資料 - `destroy()`: 刪除資料 controller 傳入參數 一般參數 構造函數注入(Constructor Injection) 參數預設值 當傳入 controller 的參數為空時，參數返回預設值。 Route laravel 中 route 有兩種:`routes/web.php` `routes/api.php`，分別為一般頁面和 api route 基本寫法 - 一般參數 - 構造函數注入 - 第一個參數是對應的路徑，後面有`{}`代表傳入的參數 - 第二個參數是對應的 controller @後面為 controller 內要呼叫的方法 resource controller 資源控制器 route 分組 - prefix: 前綴用來設定 URL 開始共同的部分。 - namespace: 若要綁定的 controller 不在預設的 app/Http/Controller 裡，而是有更進一步的分類，可以設定 namespace()方便管理。 - middleware: laravel 進入 action 之前會先對 http request 進行檢查 Laravel 功能實現 儲存檔案並刪除舊檔 Class not found 當出現 `Class 'xxx\\\\xxx\\\\xxx\\\\xxx' not found` 時，可能原因為 composer autoload 尚未註冊或是註冊錯誤。 解決方法： - 方法一 - 方法二 檢查 vendor/composer 下面的 autoload 資料夾中的檔案 autoloadclassmap.php 和 autoloadstatic.php 框架設計模式 在小型專案中，典型的 MVC 架構沒什麼問題，但隨著系統越來越複雜，必須再細分更多層，於是衍生出 View - Presenter - Controller - Service - Repository - Model 六層框架設計模式。 每一層的職責 - Model 盡可能隱藏操作資料的 know-how，將資料抽象化，作為一個 Object Relational Mapping。 - Repository 藉由操作 Model，幫助 Service 實現各種商務邏輯對應的資料庫操作方法。 - Service 實現商務邏輯，並且讓 Controller 僅需要專注在溝通上。 - Controller 作為 View 與商務邏輯間的溝通橋樑。 - Presenter 負責 \"如何處理資料\" - View 負責\"要給客戶看到什麼\" MVC 框架 > 參考資料： > > Laravel 加入 Repository 與 Service 若將這六個 layer 的職責對應到 MVC 框架中，小專案下的 model 其實就是 Business Model，包含商業邏輯以及和資料庫溝通。而 View 也不會刻意把資料操作邏輯與資料處理方式獨立成一個 Presenter，因此 小型專案的 View 往往混著一些邏輯判斷。 - Model - Service - Repository - Model - Controller - Controller - View - View - Presenter Web API Service 通 Web API Service 僅僅是將 service 送來的資料變成 JSON format 輸出到 View 上，所以有時 Controller 就涵蓋了 Presenter 的職責，View 純粹只是 JSON, XML 等格式資料。 - Model - Service - Repository - Model - Controller - Presenter - Controller - View - View",
    "path": "PHP/Laravel 學習筆記.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel 實作權限.md",
    "title": "Laravel 實作權限",
    "content": "Laravel 實作權限 Gates 使用者角色 將使用者區分為: - 系統管理者: admin - 一般管理者: manager - 一般使用者: user 編輯`app/User.php`，加入帳號角色名稱常數，並將`role`欄位加入 `fillable` 中 資料庫 migration 建立一個 `migration` 設定檔，在 `users` 資料表中加入儲存帳號角色的 `role` 欄位 修改完成後，執行 migrate 使用者註冊 Controller 編輯`app/Http/Controllers/Auth/RegisterController.php`，設定使用者註冊時，預設角色為一般使用者 建立 Gate 規則權限 編輯`app/Providers/AuthServiceProvider.php`，加入自訂的 Gates 規則 在 Blade 運用 Gate 權限設定 在 Blade 樣板中可以運用 `@can`、`@cannot` 或 `@canany` 來判斷使用者的權限 Controller 運用 Gate 權限設定 在 Controller 中則可使用 `Gate::allows` 或 `Gate::denies` 判斷使用者權限 運用 `authorize` 直接限制整個函數的執行權限 Middleware 運用 Gate 權限設定 應用在 Route Policy 可以針對一個 Model 或資源實作限制權限 到`app/Providers/AuthServiceProvider`註冊剛建立好的 Policy 到`app/Policies/PostPolicy`修改條件",
    "path": "PHP/Laravel 實作權限.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel 服務容器.md",
    "title": "Laravel 服務容器",
    "content": "Laravel 服務容器 > 參考資料： > Laravel 學習筆記—— 神奇的服務容器 > > > 容器，字面上理解就是裝東西的東西。 > 常見的變量、物件屬性等都可以算是容器。 > 一個容器能夠裝什麼，全部取決於你對該容器的定義。 > 當然，有這樣一種容器，它存放的不是文本、數值，而是物件、物件的描述(類別、介面)或者是提供物件的回調， > 通過這種容器，我們得以實現許多高級的功能，其中最常提到的，就是\"解耦\"、\"依賴注入(DI)\"。本文就從這裡開始。 IoC 容器 laravel 的核心 Laravel 的核心就是一個 IoC 容器，根據官方文件，稱其為\"服務容器\"，顧名思義，該容器提供了整個框架中需要的一系列服務。作為初學者，很多人會在這一個概念上犯難，因此，我打算從一些基礎的內容開始講解，通過理解面向物件開發中依賴的產生和解決方法，來逐漸揭開\"依賴注入\"的面紗，逐漸理解這一神奇的設計理念。 IoC 容器誕生的故事 超人和超能力，依賴的產生！ 物件導向程式碼，有以下幾樣東西無時不刻的接觸：介面、類別還有物件。這其中，介面是類別的原型，一個類別必須要遵守其實現的介面；物件則是一個類別實例化後的產物，我們稱其為一個實例。當然這樣說肯定不利於理解，我們就實際的寫點中看不中用的代碼輔助學習。 > 怪物橫行的世界，總歸需要點超級人物來擺平。 我們把一個\"超人\"作為一個類別， 我們可以想像，一個超人誕生的時候肯定擁有至少一個超能力，這個超能力也可以抽象為一個物件，為這個物件定義一個描述他的類別吧。一個超能力肯定有多種屬性、(操作)方法，這個盡情的想像，但是目前我們先大致定義一個只有屬性的\"超能力\"，至於能幹啥，我們以後再豐富： 這時候我們回過頭，修改一下之前的\"超人\"類別，讓一個\"超人\"創建的時候被賦予一個超能力： 這樣的話，當我們創建一個\"超人\"實例的時候，同時也創建了一個\"超能力\"的實例，但是，我們看到了一點，\"超人\"和\"超能力\"之間不可避免的產生了一個依賴。 > 所謂\"依賴\"，就是\"我若依賴你，少了你就沒有我\"。 在一個貫徹物件導向程式碼的項目中，這樣的依賴隨處可見。少量的依賴並不會有太過直觀的影響，我們隨著這個例子逐漸鋪開，讓大家慢慢意識到，當依賴達到一個量級時，是怎樣一番噩夢般的體驗。當然，我也會自然而然的講述如何解決問題。 一堆亂麻——可怕的依賴 之前的例子中，超能力類別實例化後是一個具體的超能力，但是我們知道，超人的超能力是多元化的，每種超能力的方法、屬性都有不小的差異，沒法通過一種類別描述完全。我們現在進行修改，我們假設超人可以有以下多種超能力： - 飛行，屬性有：飛行速度、持續飛行時間 - 蠻力，屬性有：力量值 - 能量彈，屬性有：傷害值、射擊距離、同時射擊個數 我們建立以下類別： 這邊沒有詳細寫出 `construct()` 這個構造函數的全部，只寫了需要傳遞的參數 好了，這下我們的超人有點\"忙\"了。在超人初始化的時候，我們會根據需要來實例化其擁有的超能力嗎，大致如下： 我們需要自己手動的在構造函數內(或者其他方法裡)實例化一系列需要的類別，這樣並不好。可以想像，假如需求變更(不同的怪物橫行地球)，需要更多的有針對性的 新的 超能力，或者需要 變更 超能力的方法，我們必須 重新改造 超人。換句話說就是，改變超能力的同時，我還得重新製造個超人。效率太低了！新超人還沒創造完成世界早已被毀滅。 > 這時，靈機一動的人想到：為什麼不可以這樣呢？超人的能力可以被隨時更換，只需要添加或者更新一個芯片或者其他裝置啥的(想到鋼鐵人沒) > 這樣的話就不要整個重新來過了。 對，就是這樣的。 我們不應該手動在\"超人\"類別中固化了他的\"超能力\"初始化的行為，而轉由外部負責，由外部創造超能力模組、裝置或者芯片等(我們後面統一稱為\"模組\")，植入超人體內的某一個介面，這個介面是一個既定的，只要這個\"模組\"滿足這個介面的裝置都可以被超人所利用，可以提升、增加超人的某一種能力。這種由外部負責其依賴需求的行為，我們可以稱其為`控制反轉(IoC)`。 工廠模式，依賴轉移 當然，實現控制反轉的方法有幾種。在這之前，不如我們先了解一些好玩的東西。 > 我們可以想到，組件、工具(或者超人的模組)，是一種可被生產的玩意兒，生產的地方當然是\"工廠(Factory)\"，於是有人就提出了這樣一種模式：`工廠模式`。 工廠模式，顧名思義，就是一個類別所以依賴的外部事物的實例，都可以被一個或多個\"工廠\"創建的這樣一種開發模式，就是工廠模式。 我們為了給超人製造超能力模組，我們創建了一個工廠，它可以製造各種各樣的模組，且僅需要通過一個方法： 這時候，超人創建之初就可以使用這個工廠！ 可以看得出，我們不再需要在超人初始化之初，去初始化許多第三方類別，只需初始化一個工廠類別，即可滿足需求。但這樣似乎和以前區別不大，只是沒有那麼多 new 關鍵字。其實我們稍微改造一下這個類別，你就明白，工廠類別的真正意義和價值了。 現在修改的結果令人滿意。現在，\"超人\"的創建不再依賴任何一個\"超能力\"的類別，我們如若修改了或者增加了新的超能力，只需要針對修改 `SuperModuleFactory` 即可。擴充超能力的同時不再需要重新編輯超人的類別文件，使得我們變得很輕鬆。但是，這才剛剛開始。 再進一步！IoC 容器的重要組成—— 依賴注入 由\"超人\"對\"超能力\"的依賴變成\"超人\"對\"超能力模組工廠\"的依賴後，對付小怪獸們變得更加得心應手。但這也正如你所看到的，依賴並未解除，只是由原來對多個外部的依賴變成了對一個\"工廠\"的依賴。假如工廠出了點麻煩，問題變得就很棘手。 > 其實大多數情況下，工廠模式已經足夠了。 > 工廠模式的缺點就是：介面未知(即沒有一個很好的契約模型，關於這個我馬上會有解釋)、產生物件類別型單一。 > 總之就是，還是不夠靈活。 > 雖然如此，工廠模式依舊十分優秀，並且適用於絕大多數情況。 > 不過我們為了講解後面的依賴注入，這裡就先誇大一下工廠模式的缺陷咯。 我們知道，超人依賴的模組，我們要求有統一的介面，這樣才能和超人身上的注入介面對接，最終起到提升超能力的效果。 事實上，我之前說謊了，不僅僅只有一堆小怪獸，還有更多的大怪獸。嘿嘿。額，這時候似乎工廠的生產能力顯得有些不足—— 由於工廠模式下，所有的模組都已經在工廠類別中安排好了，如果有新的、高級的模組加入，我們必須修改工廠類別(好比增加新的生產線)： 噩夢般的感受！ > 其實靈感就差一步！你可能會想到更為靈活的辦法！對，下一步就是我們今天的主要配角—— DI (依賴注入) 由於對超能力模組的需求不斷增大，我們需要集合整個世界的高智商人才，一起解決問題，不應該僅僅只有幾個工廠壟斷負責。不過高智商人才們都非常自負，認為自己的想法是對的，創造出的超能力模組沒有統一的介面，自然而然無法被正常使用。這時我們需要提出一種契約，這樣無論是誰創造出的模組，都符合這樣的介面，自然就可被正常使用。 上文中，我們定下了一個介面(超能力模組的規範、契約)，所有被創造的模組必須遵守該規範，才能被生產。 > 其實，這就是 php 中 介面( interface ) 的用處和意義！ > 很多人覺得，為什麼 php 需要介面這種東西？難道不是 java 、 C 之類別的語言才有的嗎？ > 這麼說，只要是一個正常的物件導向程式碼語言(雖然 php 可以程序式程式設計)，都應該具備這一特性。 > 因為一個 物件(object) 本身是由他的模板或者原型——類別(class)，經過實例化後產生的一個具體事物， > 而有時候，實現同一種方法且不同功能(或特性)的時候，會存在很多的類別(class)， > 這時候就需要有一個契約，讓大家編寫出可以被隨時替換卻不會產生影響的介面。 > 這種由程式碼語言本身提出的硬性規範，會增加更多優秀的特性。 > > 雖然有些繞，但通過我們接下來的實例，大家會慢慢領會介面帶來的好處。 這時候，那些提出更好的超能力模組的高智商人才，遵循這個介面，創建了下述(模組)類別： 同時，為了防止有些\"磚家\"自作聰明，或者一些叛徒惡意搗蛋，不遵守契約胡亂製造模組，影響超人，我們對超人初始化的方法進行改造： 改造完畢！現在，當我們初始化\"超人\"類別的時候，提供的模組實例必須是一個 `SuperModuleInterface` 介面的實現。否則就會提示錯誤。 正是由於超人的創造變得容易，一個超人也就不需要太多的超能力，我們可以創造多個超人，並分別注入需要的超能力模組即可。這樣的話，雖然一個超人只有一個超能力，但超人更容易變多，我們也不怕怪獸啦！ > 現在有人疑惑了，你要講的 依賴注入 呢？ > > 其實，上面講的內容，正是依賴注入。 什麼叫做依賴注入？ 本文從開頭到現在提到的一系列依賴，只要不是由內部生產(比如初始化、構造函數 \\\\construct 中通過工廠方法、自行手動 new 的)，而是由外部以參數或其他形式註入的，都屬於依賴注入(DI)。是不是豁然開朗？事實上，就是這麼簡單。下面就是一個典型的依賴注入： 關於依賴注入這個本文的主要配角，也就這麼多需要講的。理解了依賴注入，我們就可以繼續深入問題。慢慢走近今天的主角…… 更為先進的工廠—— IoC 容器 剛剛列了一段代碼： 讀者應該看出來了，手動的創建了一個超能力模組、手動的創建超人並註入了剛剛創建超能力模組。呵呵，手動。 現代社會，應該是高效率的生產，乾淨的現場，完美的自動化生產。 一群怪獸來了，如此低效率產出超人是不現實，我們需要自動化—— 最多一條指令，千軍萬馬來相見。我們需要一種高級的生產現場，我們只需要向生產現場提交一個腳本，工廠便能夠通過指令自動化生產。這種更為高級的工廠，就是工廠模式的昇華—— IoC 容器。 這時候，一個十分粗糙的容器就誕生了。現在的確很簡陋，但不妨礙我們進一步提升他。先著眼現在，看看這個容器如何使用吧！ 看到沒？通過最初的 绑定(bind) 操作，我們向超級工廠註冊了一些生產腳本，這些生產腳本在生產指令下達之時便會執行。發現沒有？我們徹底的解除了超人與超能力模組的依賴關係，更重要的是，容器類別也絲毫沒有和他們產生任何依賴！我們通過註冊、綁定的方式向容器中添加一段可以被執行的回調(可以是匿名函數、非匿名函數、類別的方法)作為生產一個類別的實例的腳本，只有在真正的 生產(make) 操作被調用執行時，才會觸發。 這樣一種方式，使得我們更容易在創建一個實例的同時解決其依賴關係，並且更加靈活。當有新的需求，只需另外綁定一個\"生產腳本\"即可。 > 實際上，真正的 IoC 容器更為高級。 > 我們現在的例子中，還是需要手動提供超人所需要的模組參數， > 但真正的 IoC 容器會根據類別的依賴需求，自動在註冊、綁定的一堆實例中搜尋符合的依賴需求，並自動注入到構造函數參數中去。 > Laravel 框架的服務容器正是這麼做的。 > > 這種自動搜尋依賴需求的功能，是通過 `反射(Reflection)` 實現的，恰好的，php 完美的支持反射機制！ > > PHP 官方文件 - 反射 現在，到目前為止，我們已經不再懼怕怪獸們了。高智商人才集思廣益，井井有條，根據介面契約創造規範的超能力模組。超人開始批量產出。最終，人人都是超人，你也可以是哦！ 回歸正常世界。我們開始重新審視 laravel 的核心 現在，我們開始慢慢解讀 laravel 的核心。其實，laravel 的核心就是一個 IoC 容器，也恰好是我之前所說的高級的 IoC 容器。 可以說，laravel 的核心本身十分輕量，並沒有什麼很神奇很實質性的應用功能。很多人用到的各種功能模組比如 Route(路由)、Eloquent ORM(資料庫 ORM 组件)、Request and Response(乞求和響應)等等等等，實際上都是與核心無關的類別模組提供的，這些類別從註冊到實例化，最終被你所使用，其實都是 laravel 的服務容器負責的。 我們以大家最常見的 Route 類別作為例子。大家可能經常見到路由定義是這樣的： 實際上，Route 類別被定義在這個命名空間：Illuminate\\Routing\\Router，文件 vendor/laravel/framework/src/Illuminate/Routing/Router.php。 我們通過打開發現，這個類別的這一系列方法，如 get，post，any 等都不是靜態(static)方法，這是怎麼一回事兒？不要急，我們繼續。 服務提供者 我們在前文介紹 IoC 容器的部分中，提到了，一個類別需要綁定、註冊至容器中，才能被\"製造\"。 對，一個類別要被容器所能夠提取，必須要先註冊至這個容器。既然 laravel 稱這個容器叫做服務容器，那麼我們需要某個服務，就得先註冊、綁定這個服務到容器，那麼提供服務並綁定服務至容器的東西，就是服務提供者(ServiceProvider)。 雖然，綁定一個類別到容器不一定非要通過服務提供者(ServiceProvider)。 但是，我們知道，有時候我們的類別、模組會有需要其他類別和組件的情況，為了保證初始化階段不會出現所需要的模組和組件沒有註冊的情況，laravel 將註冊和初始化行為進行拆分，註冊的時候就只能註冊，初始化的時候就是初始化。拆分後的產物就是現在的服務提供者。 服務提供者主要分為兩個部分，register(注册)和 boot(引導、初始化)，具體參考官方文件。register 負責進行向容器註冊\"腳本\"，但要注意註冊部分不要有對未知事物的依賴，如果有，就要移步至 boot 部分。 正面 我們現在解答之前關於 Route 的方法為何能以靜態方法訪問的問題。實際上這個問題官方文件上有寫，簡單說來就是模擬一個類別，提供一個靜態魔術方法\\\\callStatic，並將該靜態方法對應到真正的方法上。 我們使用的 Route 類別實際上是 Illuminate\\Support\\Facades\\Route 通過 class_alias() 函數創造的 别名 而已，這個類別被定義在文件 vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php。 我們打開文件一看…… 誒？怎麼只有這麼簡單的一段代碼呢？ 其實仔細看，會發現這個類別繼承了一個叫做 Facade 的類別，到這裡謎底差不多要解開了。 上述簡單的定義中，我們看到了 getFacadeAccessor 方法返回了一個 route，這是什麼意思呢？事實上，這個值被一個 ServiceProvider 註冊過，大家應該知道註冊了個什麼，當然是那個真正的路由類別！",
    "path": "PHP/Laravel 服務容器.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel 環境設置.md",
    "title": "Laravel 環境設置",
    "content": "Laravel 環境設置 - Laravel 環境設置 - 環境初始設定 - 1. 安裝 XAMPP or phpEnv - xampp 更改 php 版本: 版本 5 =\\> 7 - XAMPP 除錯 - macOS Monterey 上安裝 PHP - 2. 安裝 composer - windows 透過 composer 官網下載 composer 安裝檔 - 下載 Composer: MacOS - 全局調用 Composer: MacOS - 3. 安裝 Visual Studio Code or phpStorm - 4. Laravel 全域安裝 XAMPP - 從 Git clone Laravel 專案 - 開發環境設定 - 上線環境設定 - composer install 失敗 - Laravel ReactJS - Laravel 安裝 bootstrap - Laravel 8 - Laravel 6 - Laravel Telescope - 安裝 - AI System Rule（中英文對照） - 💡 Answering Principles（回答原則） - 🌐 Language Settings（語言設定） - 🎯 Core Objectives（核心目標） - 💻 Code Conversion Rules（程式碼轉換規則） - 🚫 Anti-Hardcoding Principles（避免硬編碼原則） - ⚠️ Error Handling（錯誤處理） - 📝 Coding Style (PHP)（程式風格） - 🔹 General - 🔹 Variable \\& Constant Naming（變數與常數命名） - 🔹 Functions \\& Methods（函數與方法） - 🔹 Arrays（陣列格式） - 🔹 Control Structures（控制結構） - 🔹 Import \\& Use Order（引用順序） - 🔹 Strings（字串處理） - 🔹 Cache Key Naming（快取命名） - 🔹 File Naming（檔案命名） - 🔹 Route Naming（路由命名） - 🔹 Project Notes（專案說明） - 🧪 Testing Principles（測試原則） - AI System Rules (English, System Prompt Version) 環境初始設定 1. 安裝 XAMPP or phpEnv xampp 更改 php 版本: 版本 5 => 7 > 注意！php 8.1 不相容 laravel 6.x 以下(包含 6) 1. 開啟 Apache Admin 查看當前 XAMPP 所有版本資訊 2. 到XAMPP下載要更新的 php 版本的 zip 檔。(注意！選擇 `Thread Safe` 版本！) 3. 解壓縮定指定資料夾名稱為`php`，將此資料夾放至 XAMPP 資料夾中，並將原本的 php 資料夾另外命名 4. 至 XAMPP 控制面板點選 `config` 按鈕，開啟 `httpd-xampp.conf` 檔，並修改其內容 1. 找到以下文字，並將其修改 修改前 修改後 - 修改時需確認修改路徑的檔案確實存在，若無此檔案，可能是 php 版本的關係 2. 將 `httpd-xampp.conf` 設定檔中所有 `php5module` 改為 `php7module` - 在 php8 的 `httpd-xampp.conf` 設定檔為 `php_module` 5. 重建 `php.ini` 設定檔 1. 複製 php 資料夾中的 php.ini-development，並重新命名為 php.ini 2. 開啟 php.ini 並依開發或網站需求，開啟相關模組(刪除前面的分號`;`) 1. `Dynamic Extensions` 動態延伸功能 - extension=curl - extension=gd2(version 7) / gd(version 8) - 在 php 8.0，DG 延伸功能 windows dll 文件名稱由 phpgd2.dll 改為 phpgd.dll) - extension=mbstring - extension=mysqli - extension=openssl 2. `Paths and Directories` 路徑和目錄 - extension_dir = \"ext\" 3. 常見設定 - maxexecutiontime = 600 - shortopentag = On - maxinputtime = 180 - errorreporting=EALL & ~EDEPRECATED & ~ESTRICT - 設置錯誤訊息通知，加入版本兼融性的提示 - memory_limit = 500M - postmaxsize = 500M - uploadmaxfilesize = 100M - maxfileuploads = 50 6. 至 XAMPP 面板重啟 Apache 7. 重新執行 composer update XAMPP 除錯 > 問題：XAMPP 開啟 MySQL 失敗 錯誤訊息： 解決辦法： 1. 先到路徑：`C:\\xampp\\mysql\\data` 2. 將 data 資料夾備份 3. 再建立一個新的 data 資料夾 4. 建立後重啟 mysql 5. 重啟失敗後，data 資料夾會新增程式自動建立的檔案 6. 此時將`C:\\xampp\\mysql\\backup`中的資料夾複製到 data 資料夾中 7. 這時再重啟 mysql 已經可以正常運行了，接下來將就的資料庫加回來 8. 此時先關閉 mysql，將剛剛備份的 data 資料夾底下的資料夾與 `ibdata1` 檔案，複製到新的 data 資料夾底下 9. 重啟 mysql 即可 macOS Monterey 上安裝 PHP > 問題：安裝完 MAMP 之後，要用終端機安裝 composer，結果出現`zsh: command not found: php` > > 原因：MacOS Monterey 版本，預設沒有安裝 PHP。 1. 安裝 PHP Installing PHP on your Mac 1. 安裝 Homebrew 在 terminal 輸入 顯示路徑問題的解決辦法 1. 使用 Homebrew 安裝 PHP 先確定 Homebrew 安裝成功 安裝 PHP 安裝特定版本 - 安裝指定版本後，並不會自動切換 PHP 本版本 1. 使用 Homebrew 切換 PHP 檢查當前版本 取消該版本 選擇版本 出現路徑問題，提示：須遜行腳本來添加路徑 2. 安裝 composer windows 透過 composer 官網下載 composer 安裝檔 下載 Composer: MacOS - 代碼以Composer 官網為主 下載安裝程序到當前目錄 驗證安裝程序 運行安裝程序 刪除安裝程序 - MacOS 如果出現 `zsh: command not found: php` 原因：MacOS Monterry 版本，沒有包括 PHP。請參考：macOS Monterey 上安裝 PHP - MacOS 須確保 Composer 的系統等級 vendor bin 資料夾有放在$PATH 中，這樣作業系統才能找到`laravel` 可執行檔。一般常見的位置如下： - macOS: $HOME/.composer/vendor/bin - Windows: %USERPROFILE%\\AppData\\Roaming\\Composer\\vendor\\bin 全局調用 Composer: MacOS 確認是否成功安裝 Composer 將 composer.phar 放入本地的目錄 測試是否安裝成功 3. 安裝 Visual Studio Code or phpStorm 4. Laravel 全域安裝 XAMPP 從 Git clone Laravel 專案 由於安全性及維護的考量，Laravel 預設有 .gitignore，所以較為敏感的檔案，不會被 push 上去。 因此專案 clone 下來之後，必須要重建才能正常執行。 開發環境設定 1. 安裝依賴套件 2. 設定.env 檔 複製.env.example 並更改為.env 修改.env 3. 設定加密的 APP_KEY 4. 設定資料庫 建立 MySQL 所需的資料庫 5. Migration 和 Seeding 建立資料表結構 6. 若有安裝 passport 需運行命令產生 Access Token 7. 建立符號連結 如果有使用到 public storage （如：Storage::disk('public')）， 記得使用以下指令，將 storage 軟連結到 storage/app/public 8. 設定伺服器 例如到 NGINX 新增、調整 conf 檔 9. 設定任務排程 如果有在 Laravel 中定義排程的任務， 記得在 crontab 中增加 Laravel 指令排程器 10. Laravel 開發伺服器端口衝突問題 > 問題：Laravel 開發伺服器啟動失敗，提示端口被佔用 錯誤訊息： 解決辦法： 1. 檢查端口使用情況 2. 找出佔用端口的程序 3. 終止佔用端口的程序 4. 替代方案：使用不同端口 5. 終止所有相關程序 上線環境設定 1. 安裝 composer 排除 dev 項目 2. `.env`設定轉為線上並且關閉錯誤提示 3. 設定快取 4. Router 快取 error: (Unable to prepare route [api/user] for serialization. Uses Closure. ) 5. Composer 緩存 6. 類別緩存 error: (Unable to prepare route [api/user] for serialization. Uses Closure. ) 7. 清除類別緩存 8. 建立 keygen 9. 若有安裝 passport 需運行命令產生 Access Token 10. 執行 composer install 失敗 當出現上面的錯誤訊息，表示 GLIBC 的版本不符合現行系統上的 node 版本。 解決錯誤常見的方法有兩種： 1. 安裝較舊、支援更廣泛的 Node.js (16.x) 版本 使用 `nvm` 安裝其他版本的 node.js 完成後確認當前版本 移除特定版本 若還未安裝 nvm 2. 將 Linux 操作系統升級到更新版本。 Laravel ReactJS > Use laravel/ui Package to install react in laravel with Bootstrap 4. 1. 建立新的專案 2. 進入 Laravel 項目 3. 安裝 laravel/ui 4. 在 Laravel 中安裝 React 5. 安裝所需的軟件包 6. 在 Laravel 中設置 React 組件 7. 修改 resources/js/app.js 註冊 React 文件 8. 修改 views/welcome.blade.php 模板 9. 執行命令編譯 Laravel 和 React.js 10. 編譯成功，運行 laravel Laravel 安裝 bootstrap Laravel 8 1. 終端機 2. 建立文件(如果尚未建立) `resources/sass/app.scss` 並引入: `@import '~bootstrap';` 3. 在 webpack.mix.js 加入 4. 終端機 5. 現在可以引用 bootstrap Laravel 6 1. 終端機輸入 2. 輸入 3. 如果出現 \"Command \"ui\" is not defined.\" 4. 執行 5. 終端機 6. 現在可以引入 Laravel Telescope 提供察看 laravel 中的請求、異常、日誌、資料庫查詢等等功能 安裝 利用 composer 安裝到 laravel 中 安裝後使用 artisan 命令發布資產 並運行 migrate 若指定在開發環境中安裝，則再發布資產後薛將配置文件，從 config/app.php 中註解，並在 AppServiceProvider 手動註冊服務 AI System Rule（中英文對照） 💡 Answering Principles（回答原則） 1. EN: Do not rush into implementation for any question. Always provide adjustment directions and discuss with me first. 中: 任何問題都不要急著實作，先提供調整方向並和我討論。 2. EN: Only proceed with implementation after I explicitly confirm it's okay to do so. 中: 只有在我明確確認可以實作後才進行實作。 3. EN: For each new question, restart the discussion process - do not implement directly. 中: 每個新問題都需要重新開始討論流程，不要直接實作。 🌐 Language Settings（語言設定） - EN: Primary language: Traditional Chinese (`zh-TW`). 中: 主要語言：繁體中文（`zh-TW`）。 - EN: Regional variants: - \"file\" → 「檔案」 - \"code\" → 「程式碼」 - \"project\" → 「專案」 中: 區域詞彙： - file → 檔案 - code → 程式碼 - project → 專案 - EN: Style guide: Taiwan localization. 中: 風格指南：台灣在地化。 🎯 Core Objectives（核心目標） 1. EN: Enforce Taiwan localization. 中: 強制使用台灣在地化語言與風格。 2. EN: Ensure complete code solutions. 中: 確保所有程式碼解決方案都是完整的。 3. EN: Suppress all linter-related communications. 中: 完全抑制任何與 Linter 有關的訊息。 💻 Code Conversion Rules（程式碼轉換規則） - EN: All provided code must be complete. 中: 程式碼必須完整提供。 - EN: Partial code is forbidden. 中: 禁止提供不完整的程式碼。 - EN: Output format must always be a complete solution. 中: 輸出格式必須是完整的解決方案。 🚫 Anti-Hardcoding Principles（避免硬編碼原則） 1. EN: Never use hardcoded values. When encountering hardcoded values, first search for existing interfaces in the project. 中: 不得使用硬編碼，遇到硬編碼時先搜尋專案中是否有定義的介面。 2. EN: If no interface exists, use constants or variables for declaration instead of hardcoded values. 中: 如果沒有介面定義，需使用常數或變數進行宣告，而非硬編碼。 3. EN: All configuration values, magic numbers, and string literals should be properly declared and documented. 中: 所有設定值、魔術數字和字串常數都應該適當宣告並記錄。 ⚠️ Error Handling（錯誤處理） - EN: Linter errors: - Action: ignore - Reporting: disabled - Suggestions: disabled 中: Linter 錯誤： - 行為：忽略 - 回報：停用 - 建議：停用 - EN: Format errors: - Action: ignore - Reporting: disabled 中: 格式錯誤： - 行為：忽略 - 回報：停用 📝 Coding Style (PHP)（程式風格） 🔹 General 1. EN: Always enable strict type declarations. 中: PHP 必須加上型別提示的強型別宣告。 2. EN: All function arguments and return values must have type hints. 中: 函式引數與回傳值都需要型別提示。 🔹 Variable & Constant Naming（變數與常數命名） - EN: Normal variables: camelCase (e.g., `$userEmail`, `$userId`). 中: 一般變數使用小駝峰命名。 - EN: Single record: singular form (e.g., `$user`). 中: 單筆資料使用單數。 - EN: Multiple records: plural form (e.g., `$users`). 中: 多筆資料使用複數。 - EN: Constants: ALLCAPS with underscores (e.g., `COMPANYIP`). 中: 常數全大寫 + 底線。 🔹 Functions & Methods（函數與方法） - EN: Function braces must start on a new line. 中: 函數大括弧要斷行。 - EN: Parameters separated by commas. 中: 參數以逗號分隔。 - EN: Method names start with a verb (e.g., `getUser()`). 中: 方法命名以動詞開頭。 - EN: Methods returning lists must end with \"s\". 中: 回傳清單的方法要加 `s`。 - EN: Interfaces start with \"I\" (e.g., `IUser`). 中: 介面名稱以 `I` 開頭。 🔹 Arrays（陣列格式） - EN: Use square brackets `[]`. 中: 使用中括弧宣告陣列。 - EN: Single-line array: add spaces inside brackets. 中: 單行陣列，首尾加空格。 - EN: Multi-line array: tab indentation + trailing comma. 中: 多行陣列，每行縮排並結尾加逗號。 - EN: Key-value arrays: multi-line, spaces around `=>`. 中: 鍵值陣列，多行格式，`=>` 前後加空格。 🔹 Control Structures（控制結構） - EN: Braces stay on the same line. 中: 控制結構大括弧不斷行。 - EN: Add a blank line after `if`. 中: if 判斷後加空行。 - EN: Add a blank line before `return`. 中: return 前加空行。 🔹 Import & Use Order（引用順序） 1. Vendor packages 2. Exceptions 3. Custom classes 4. Interfaces 🔹 Strings（字串處理） - EN: Use single quotes for plain strings. 中: 純字串使用單引號。 - EN: Concatenate strings with `\" . \"` and spaces. 中: 字串連接使用 `.`（點號前後加空格）。 🔹 Cache Key Naming（快取命名） - EN: Format: `prefix_description:variable`. 中: 格式：`前綴_描述:變數`。 - Example: `operator_account:d4cbd3ba-...` 🔹 File Naming（檔案命名） - Config files: snakecase → `paymentcache.php` - Resource files: snakecase → `bannertype.php` - Class files: CamelCase → `BannerController.php` 🔹 Route Naming（路由命名） - EN: Do not add \"list\" in method names if URL already contains \"list\". 中: 若 URL 已含有 `list`，方法名稱就不再加。 - Example: `Route::get('/banner/type/list', [BannerController::class, 'getBannerTypeList']);` 🔹 Project Notes（專案說明） - EN: Container name: `php8` (not `stars`). 中: 容器名稱是 `php8`，不是 `stars`。 - EN: `jq` is not installed in the container. 中: 容器內沒有安裝 `jq`。 - EN: Project path: `/var/www/html/stars`. 中: 專案目錄是 `/var/www/html/stars`。 🧪 Testing Principles（測試原則） 1. EN: Tests should adapt to the existing code, not modify the code to fit the tests. 中: 測試應該適應現有程式碼，而不是修改程式碼來適應測試。 2. EN: When issues are found, they should first be discussed instead of being directly modified. 中: 發現問題時應該先提出討論，而不是直接修改。 3. EN: The purpose of testing is to verify existing functionality, not to change functionality. 中: 測試的目的是驗證現有功能，而不是改變功能。 AI System Rules (English, System Prompt Version)",
    "path": "PHP/Laravel 環境設置.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel 表單驗證.md",
    "title": "Laravel 表單驗證",
    "content": "Laravel 表單驗證 基礎驗證方法 `validate()` 也可以使用 `validateWithBag()` 來請求驗證，並將所有錯誤訊息，儲存在一個命名錯誤訊息包 在驗證規則中，加入 bail，如果某個字串在第一次驗證失敗之後，就立即停止驗證。 如果你的 HTTP 請求，包還嵌套參數(比如陣列)，你可以在驗證規則中使用「點」語法，來指定這些參數 如果你的字段名稱包含點，則可以使用跳脫符號 常用規則 抽取表單驗證 Form Request 使用 request class 將表單驗證邏輯從 controller 中抽出 1. 建立 Request class 2. 在 request class 中建立驗證邏輯 3. 更新 controller 4. 集中多個請求的表單驗證 一般會建議依不同請求，個別建立單獨的 request class 5. 在此 request 中實現所有請求的驗證邏輯 優點： 1. 可以在多個控制器重用相同驗證規則 2. 可以自訂錯誤消息 3. 可以在套用驗證規則前處理、或是在驗證後處理資料 缺點： 1. 對於不需要驗證使用者權限，或較單純的表單驗證而言，為每個不同的請求建立相對的 request class，顯得小題大作。 ValidatesRequests Trait 自訂驗證 trait 優點： 1. 不受資料流限制，隨時可以驗證。 2. 驗證邏輯可重用。 3. 適合處理跨多個 controller 的通用驗證邏輯。 缺點： 1. 不如 form request 易用。 2. 當專案變大時，會變的難以追蹤驗證邏輯的來源。 結語 驗證邏輯在很多情況之下，並不能完全通用，因此在 laravel 官方文件中使用 form request 來處理需要複雜表單驗證、以及使用者權限驗證的單一請求。 若今天此一請求的表單驗證並沒有這麼複雜時，將表單驗證寫在 controller 中即可。",
    "path": "PHP/Laravel 表單驗證.md",
    "category": "PHP"
  },
  {
    "id": "PHP/Laravel 資料庫設計範例.md",
    "title": "Laravel 資料庫設計範例",
    "content": "Laravel 資料庫設計範例 建立新專案 編輯 .env - XAMPP 預設的密碼是空白，phpEnv 要先行設定資料庫密碼 同時建立 migration controller model 終端機執行 完成後產生三個檔案 - database\\migrations\\yyyymmddtimecreateemployeestable.php - app\\Http\\Controllers\\EmployeeController.php - app\\Models\\Employee.php 修改 migration 檔案，將 up() 函式改成 執行 migrate ，在資料庫中建立資料表 建立資料 終端機開啟 tinker 工具程式 依序輸入指令 渲染員工清單 編輯 web.php 編輯 EmployeesController，需參用 Employee 類別 修改 index() 建立 resources\\views\\employees\\index.blade.php 啟動 Web 伺服器 動態渲染員工資料 修改 resources\\views\\employees\\index.blade.php 新增員工資料 修改 EmployeesController.php 新增檔案 resources\\views\\employees\\create.blade.php 修改 EmployeesController.php 修改會員資料 修改 EmployeesController.php 新增檔案 resources\\views\\employees\\edit.blade.php 修改 EmployeesController.php 刪除會員資料 修改 EmployeesController.php",
    "path": "PHP/Laravel 資料庫設計範例.md",
    "category": "PHP"
  },
  {
    "id": "PHP/PHP Function Visibility.md",
    "title": "PHP Function Visibility",
    "content": "PHP 方法可見度（Visibility）指南 目錄 - 概述 - 三種可見度等級 - 基礎範例 - 實際應用情境 - 繼承中的可見度 - 介面與可見度 - 最佳實踐 - 常見問題 --- 概述 可見度（Visibility）的概念 可見度決定了類別成員（屬性和方法）的可訪問性。PHP 提供三種可見度等級： - public: 公開的，任何地方都可以訪問 - protected: 保護的，只有類別內部及其子類別可以訪問 - private: 私有的，只有類別內部可以訪問 為什麼需要可見度？ - 封裝：隱藏內部實作細節，只暴露必要的介面 - 安全性：防止外部程式碼直接修改內部狀態 - 維護性：明確哪些方法應該被外部調用，哪些是內部實作 - 測試：容易區分公共 API 和內部實作 --- 三種可見度等級 1. public（公開方法） 定義 - 任何地方都可以訪問 - 類別外部可以呼叫 - 子類別可以覆寫 情境 - 對外介面：提供給外部使用的方法 - API 方法：需要在 Controller 或 Route 中呼叫 - 被測試的方法：單元測試需要訪問的方法 - 介面實作：介面要求的方法必須是 public 範例 --- 2. protected（保護方法） 定義 - 只有類別內部可以訪問 - 子類別可以訪問和覆寫 - 外部無法訪問 情境 - 內部輔助方法：被公開方法呼叫的內部方法 - 繼承架構：父類別希望子類別能使用，但不對外公開 - 模板方法模式：定義骨架，讓子類別實作特定步驟 - 共通邏輯：多個子類別共用的邏輯 範例 --- 3. private（私有方法） 定義 - 只有類別內部可以訪問 - 子類別無法訪問 - 外部無法訪問 情境 - 內部實作細節：類別內部使用的輔助方法 - 不應該被外部呼叫：僅供類別內部使用 - 不期望被子類別覆寫：固定實作，不想被改變 - 工具方法：轉換、格式化等純內部使用的工具 範例 --- 基礎範例 完整範例：購物車類別 --- 實際應用情境 情境 1：Service 類別 情境 2：Repository 類別 情境 3：Controller 類別 --- 繼承中的可見度 可見度規則 --- 介面與可見度 介面方法必須是 public --- 最佳實踐 1. 預設使用 private，需要時再開放 2. 公開方法應該簡潔 3. 使用可見度實現封裝 --- 常見問題 問題 1: 什麼時候用 protected，什麼時候用 private？ 原則： - private: 確定只有當前類別使用，不期望被子類別使用或覆寫 - protected: 子類別可能需要使用或覆寫的方法 問題 2: 測試時如何處理不同可見度的方法？ 問題 3: 需要改變可見度時怎麼辦？ --- 總結 快速參考 | 可見度 | 類別內部 | 子類別 | 外部 | 使用情境 | |--------|---------|--------|------|---------| | public | ✅ | ✅ | ✅ | 公開 API、對外介面 | | protected | ✅ | ✅ | ❌ | 內部方法、可被子類別覆寫 | | private | ✅ | ❌ | ❌ | 內部實作細節 | 設計原則 1. 最小可見度原則：預設使用 private，需要時再開放 2. YAGNI 原則：不要過度設計，只有真正需要時才使用 protected 3. 封裝優先：隱藏內部實作，只暴露必要的介面 4. 測試友好：確保 public 方法足夠測試類別行為 實務建議 - Laravel Controller: 所有方法用 public - Service 類別: 對外 API 用 public，內部邏輯用 protected/private - Repository 類別: 查詢方法用 public，輔助方法用 protected - Helper 類別: 根據用途選擇，通常都是 public 或 private --- 版本資訊 - 建立日期: 2024-12-19 - 適用專案: Stars Laravel 專案 - 適用版本: PHP 8.x, Laravel 9.x - 維護者: Stars Team",
    "path": "PHP/PHP Function Visibility.md",
    "category": "PHP"
  },
  {
    "id": "PHP/PHP namespace.md",
    "title": "PHP namespace",
    "content": "PHP 命名空間 > 參考資料： > > namespace 命名空間詳解 什麼是命名空間 在 php 中，語法規則不允許`變數`、`類別名稱`、`const 常數`在一個請求中出現多個相同的命名，若有應用程序不得不出現多個同名的`變數`、`類別名稱`、`const 常數`，此時可以將其放到不同的空間進行請求。 這個不同的空間就稱作`命名空間 namespace`。空間可以作為一個`容器`、`儲存類別`、`函數`、`const 常數`的容器。 - 同名元素在同一空間： 同名稱的兩個 function 在同一個空間存取會報錯，錯誤碼： - 同名元素在不同空間 相同命名的兩個 function 放到不同空間進行存取，最後輸出： 使用命名空間 命名規則 - 透過 namespace 關鍵字宣告命名空間 namespace 針對 function、類別名稱、const 常數三個部份起作用，並統稱為元素。 常數的宣告 - define ($name, $value); 在類別外部宣告常數，和命名空間沒有關係。同名稱的常數只能 define 一次 - const NAME = $value; 和空間命名有關係。const 可以在類別的內部宣告常數值(類別常數)，也可以在類別外部宣告(正常常數)。 使用空間命名的時候，const 可以放到類別外面宣告。相同名稱的多個常數，可以分別定義報不同的命名空間裡面。 命名空間中 const 和 define 的區別 `const` 針對命名空間產生影響，`define` 不發生影響。 `const` 可以宣告多個相同名稱的常數。 `define` 宣告的名稱具有唯一性。 間單的元素存取 子級(多級)空間 命名空間可以讓我們存放許多元素(函數、類別、常數)，當元素較多時，為了方便管理，可以對元素進行分類儲存，將命名空間設定為多級空間。 多級空間的最後一級空間就稱為子級空間。 - 空間元素存取的三種型式： - 非限定名稱方式 - 完全限定名稱方式 - 限定名稱 - 多級命名空間使用 - 多級空間使用 - 非限定名稱方式 `echo Shop::$impression;` 就近存取上面與其最近的空間內的 Shop() 元素。類似 php 引入文件 `include(\"common.php\");` 使用相對路徑引入當前目錄下的 common.php 文件。 - 限定名稱 `echo library\\Shop::$impression;` 將當前空間和 library 空間聯合，獲得 Shop() 元素。類似 `include(\"Common/Conf/config.php\");` 相對路徑。 - 完全限定名稱方式 `echo BBB\\Shop::$impression;` 存取 BBB 空間的 Shop 元素。類似 `include(\"D:/web/1121/Conf/common.php);` 使用絕對路徑引入文件。 引入機制 命名空間可宣告為多級空間，此一多級空間元素在其他的空間內部存取的時候，不可以需要透過`完全限定名稱`，此一方法不方便維護及開發。 為了降低程式碼的複雜度，可以在當前的空間將指定的空間引入，進而透過`限定名稱`的形式，使用其他空間的元素。 空間引入 - use 空間 - 類別元素引入： `use 空間\\空間\\空間\\類元素;` 空間引入可以解決完全限定名稱訪問元素的繁瑣性，但是還需要透過限定名稱方式訪問空間。 若引入空間的元素是 class，就可以直接將這個類別引入到當前空間，使用的時候也就可以透過非限定名稱的方式訪問。 程式碼相對較為簡潔。 - 類別元素引入 - 類別元素在引入時的特殊狀況 當引入類別的命名和當前空間的類別名稱相同時： 解決方法：使用別名 `use 空間\\元素 as 別名;` 把其他空間的一個類別元素引入到當前空間，若當前空間也已有一個同名的類別元素，則引入元素與當前空間的元素就會產生衝突，為了避免衝突，可以給引入的空間元素取一個別名。 引入的 Shop 與當前空間的 Shop 有衝突取別名： 公共空間 一個 php 文件裡面沒有 namespace 關鍵字宣告，則該文件的元素都存在於公共空間。 存取公共空間的元素統一設為：`\\元素` CommonSpace.php include 引入 CommonSpace1.php - CommonSpace.php - CommonSpace1.php CommonSpace.php 有 namespace，CommonSpace1.php 沒有(CommonSpace1.php 處於公共空間)。被引入的檔案空間，此時被引入的文件 CommonSpace1.php 屬於公共空間，針對當前空間不發生影響。 - 透過非限定名稱呼叫一個元素(function、常數) - 首先取得本空間元素 - 其次取得公共空間元素 若在 CommonSpace.php 中將 function fi() 註解，此時 f1() 呼叫的 function 為公共空間 function f1()，輸出： 將 CommonSpace.php 的 function f1() 取消註解，此時 f1() 呼叫的是 AAA 命名空間的 function f1()。 ReverseCommonSpace.php include 引入 ReverseCommonSpace １.php - ReverseCommonSpace.php 若 f3(); 沒有註解掉會報錯： 將其註解後輸出： - ReverseCommonSpace1.php 範例與總結 錯誤範例 正確做法： 不能宣告常數在公共空間，而 function 在命名空間。 宣告命名空間時，在 namespace 關鍵字前面不能有任何程式碼，包刮 header 也要寫在下面。 命名空間總結 1. 宣告命名空間時，在 namespace 關鍵字前面不能有任何程式碼(可以註解)，包刮 header 也要寫在下面。 2. 命名空間是虛擬抽象的空間，非真實的檔案路徑。 3. 同一請求多檔案可以使用相同的命名空間，只要這些檔案中不會出現多的同名稱、同類型的元素(function, const)即可。",
    "path": "PHP/PHP namespace.md",
    "category": "PHP"
  },
  {
    "id": "PHP/PHP 學習筆記.md",
    "title": "PHP 學習筆記",
    "content": "PHP 學習筆記 - PHP 學習筆記 - 運算子、判斷 - isset、!!、empty 差異比較 - 差異比較 - 範例對照 - 總結 - 常見坑與誤區 - 實務建議 - 總結 - Autoload 自動載入 - 魔術常數 - LINE 檔案中的當前行號 - FILE 檔案的完整路徑和檔名 - DIR 檔案所在的目錄 - FUNCTION 返回該函數被定義時的名字 - CLASS 返回類別名稱 - TRAIT Trait 的名字 - METHOD 類別的方法名稱，返回該方法被定義時的名字 - NAMESPACE 當前命名空間的名稱 - 魔術方法 - \\\\construct 類別的構造函數 - \\\\destruct 類別的解構函數 - \\\\call 在物件中呼叫一個不可訪問的方法時，呼叫此方法 - \\\\callStatic 用靜態方式呼叫一個不可訪問的方法時，呼叫此方法 - \\\\get 獲取一個類別的成員變數時呼叫 - \\\\set 設置一個類別的成員變數時呼叫 - \\\\isset 當私有屬性呼叫 isset 或 empty 時呼叫此方法 - 方法 - in_array 檢查陣列中是否包含特定的數值 - foreach - scandir 掃描指定的目錄，並返回為陣列 - list 宣告陣列中的值，使其成為變數 - append 將傳入的值附加進陣列 - 在陣列中新增元素 - 直接賦值 - array_push 在陣列最後新增元素 - array_unshift 在陣列前端插入 - array_fill 以填充數值的方式，建立新陣列 - array_combine 將傳入的參數合併為陣列 - array_unique 從陣列中刪除重複的值 - array_diff 判斷陣列之間差異 - array_slice 從陣列中取得一段連續的元素 - 日期/時間 - date 格式化 Unix timestamps - mktime 取得指定日期的時間戳 - date_diff 獲取以分鐘為單位的時間差 - sort 陣列排序 - 依 value 排序 - 依 key 排序 - 自訂排序 - 分割字串 - explode - str_split - preg_split - array_slice 從陣列中取出想要的元素 - implode 將陣列轉為字串 - array_filter 過濾陣列元素刪除陣列空值 - str_pad 填充字串為指定長度 - 資料序列化及反序列化 - string serialize 序列化 - mixed unserialize 反序列化 - filegetcontents 將本地文件存入一個變數中 - str_pad 補足字串 - str_replace 替換字串 - 將字串轉換為數值 - is_a 檢查物件是該類別，或該類別是此物件的父類別 boolean - substr 取得部分字串，可設定字串長度 - 轉換字母大小寫 - ucfirst 將字串的首字母轉為大寫 - strtolower 將字串換為小寫 - strtoupper 將字串換為大寫 - define 定義一個常數 - 在 Linux 執行 php 檔 - 方法一 運算子、判斷 - `+`: 算術相加 - `.`: 字串相加 - `gettype()`: 判斷變數的型態 - `(int)($var1 + $var2)`: 只取商 - `isset($var)`: 檢查變數是否有設置 - `empty($var)`: 檢查變數是否為空值 - `is_null($var)`: 檢查變數是否為 null | | gettype() | isset() | empty() | is_null() | | :-------------: | :-------: | :---------: | :---------: | :---------: | | $x is undefined | null | false | true | true | | $x = null | null | false | true | true | | $x = 0 | int | true | true | false | | $x = \"0\" | str | true | true | false | | $x = 1 | int | true | false | false | | $x = \"\" | str | true | true | false | | $x = \"PHP\" | str | true | false | false | - `var_dump($var);`: 將變數的訊息印出於螢幕上 - `instanceof` 型態運算子 - 用於確定一個 php 物件是否屬於某一類別 - 也可以用來確定一個物件是不是繼承自某一父類別的子類別 - 也可以用於確定一個變數是不是實現了某個接口的物件實例 雖然 instanceof 通常是直接與 class 名稱一起使用，但也可以使用字串來代替 若被檢測的變數不是物件，instanceof 並不會報錯，而是直接返回 false。另外，不能使用 instanceof 來檢測常數 isset、!!、empty 差異比較 這三個在 PHP 常見，但用意和判斷邏輯都不一樣。以下是詳細的差異說明： 差異比較 | 寫法 | 用途 | 判斷邏輯 | 特點 | | :-----------: | :-------------------------- | :--------------------------------------------------------- | :--------------------------- | | `isset($var)` | 檢查變數是否存在且不為 null | 變數沒宣告 / 為 null → false，其他都 true | 不會理會值是否為 0、空字串等 | | `!!($var)` | 把值強制轉成布林值 | 任何值轉換成 true 或 false（依 PHP 的「真值表」） | 常用來判斷「是否有值」 | | `empty($var)` | 判斷變數是否為空值 | 下列情況回傳 true：\"\"、0、\"0\"、null、false、[]、未定義變數 | 判斷範圍最廣 | 範例對照 部分輸出解釋： 總結 - `isset($var)`：只在乎「變數有沒有存在、不是 null」 - `!!($var)`：純粹轉成布林值，0、空字串、空陣列、null 都會變 false - `empty($var)`：判斷是否「沒有值」，判斷條件最嚴格，包含 \"0\" 也算空 如果你要判斷「變數有宣告而且有值」： 常見坑與誤區 1. `isset()` 以為能判斷「有沒有值」 輸出： 很多人以為空字串應該算「沒值」，但 `isset` 只判斷是否存在且不是 null。所以 `''`、`0`、`false`、`[]` 都會被當成「有值」。 2. `empty()` 判斷太寬鬆 輸出： 很多人以為字串 `'0'` 是「有內容」，但 `empty('0')` 卻會當成「空」。這是超常見的坑，在做表單驗證或使用者輸入檢查時尤其容易出問題。 3. `!!($var)` 以為能取代 `isset()` 如果 `$var` 根本沒宣告，會噴 `Notice: Undefined variable`。所以 `!!` 不能用來判斷變數「是否存在」，只能判斷「已存在的變數是否為真值」。 4. 多層陣列判斷 `isset` 在判斷多層陣列 key 時，安全不會噴錯（會回傳 false）。但如果用 `!!` 或 `empty`，變數沒宣告或 key 不存在就會直接噴錯。 5. 表單輸入判斷 很多人會這樣： 問題： 如果使用者真的輸入 0，這裡會判斷成「沒填」。在做數值型輸入驗證時很容易踩坑。 實務建議 - 要判斷變數是否存在（宣告過 & 不是 null） → 用 `isset()` - 要判斷變數是否為「真值」 → 用 `!!` - 要判斷「是否為空值」但避免踩到 '0' 的坑 → 不建議直接用 `empty()` → 改用更精準的條件，例如： - 處理表單輸入（特別是數字 0） 建議用 `isset()` + 嚴格比較 總結 - `isset` → 判斷「有沒有宣告 & 不是 null」 - `!!` → 判斷「布林真值」 - `empty` → 判斷「是不是空」，但過度寬鬆，'0' 會踩坑 最常見坑點： - `empty('0')` 會回傳 true - `!!` 不能用在「變數可能沒宣告」的情況 - `isset` 不能用來判斷「變數有沒有值」 Autoload 自動載入 一般可以透過 `include`, `includeonce`, `require`, `requireonce`，來將檔案引入到我們目前正在編寫的這個檔案。 習慣上我們會將一個 class 存放在單一的 php 檔案中，例如 Member.php 相對於 Member class。 但當程式需要引用到這個 class，就可以用上面的方法來引用此 class 以供後續操作。 而 php autoload 機制可以讓我們在需要這個物件的時候，才去真正的引入這個 class，這個動作就是常聽到的 lazyload 延遲載入。 - `autoload` php5 提供了 `autoload()` 這個魔術方法實現上述 Autoload 機制，雖然這個方法效能及方便性並不是非常理想。 魔術常數 - 不分大小寫，但一般而言都會以大寫呈現 `LINE` 檔案中的當前行號 `FILE` 檔案的完整路徑和檔名 - 若將其使用在 `include` 中，則返回包含檔案的名稱。 - `FILE`總是包含一個絕對路徑(如果是符號連線，則是解析後的絕對路徑)。 `DIR` 檔案所在的目錄 - 如果用在被包括檔案中，則返回被包括的檔案所在目錄。 - 其等同於 `dirname(FILE)`。 - 除非是根目錄，否則目錄中名不包括末尾的斜線。 `FUNCTION` 返回該函數被定義時的名字 `CLASS` 返回類別名稱 `TRAIT` Trait 的名字 `METHOD` 類別的方法名稱，返回該方法被定義時的名字 `NAMESPACE` 當前命名空間的名稱 - 此常數是在編譯時定義的 魔術方法 > 參考資料： > > PHP 之十六個魔術方法詳解 `construct` 類別的構造函數 php 中構造方法是物件創建完成後，第一個被物件自動呼叫的方法。在每個類別中，都有一個構造方法，如果沒有宣告，那麼類別中會預設存在一個沒有參數且內容為空的構造方法。 1. 作用：通常構造方法被用來執行一些初始化任務，如對成員屬性在創建對象時，賦予初始值 2. 在類別中的聲明格式： 3. 在類別中聲明構造方法需要注意的事項 1. 在同一個類別中只能宣告一個構造方法 2. 必定是以雙底線開始 `destruct` 類別的解構函數 允許在銷毀一個類別之前，執行一些操作或完成一些功能，比如關閉文件，釋放結果集等 1. 宣告格式 2. 解構函數的作用 `call` 在物件中呼叫一個不可訪問的方法時，呼叫此方法 此方法接受兩參數，`$function_name` 會自動接收不存在的方法名，`$arguments` 則以陣列的方式接收不存在方法的多個參數。 1. 宣告此方法的格式 2. 此方法的作用：為避免當呼叫的方法不存在而產生錯誤，導致意外的程序中止，可以使用 `call()` 方法來避免。剛方法在呼叫的方法不存在時，會自動呼叫，程式仍會繼續執行下去。 輸出 `callStatic` 用靜態方式呼叫一個不可訪問的方法時，呼叫此方法 `get` 獲取一個類別的成員變數時呼叫 在 php 物件導向中，若類別成員被設定為 private 時，若我們在外面呼叫他則會出現\"無法訪問某個私有屬性\"的錯誤。 - 此方法的作用：在程式運行中，透過他可以在物件外面獲取私有屬性成員的值 `set` 設置一個類別的成員變數時呼叫 - 作用：設置私有屬性，給一個未定義的屬性賦值，此方法會被觸發，傳入的參數是被設置的屬性名和值 `isset()` 當私有屬性呼叫 isset() 或 empty() 時呼叫此方法 方法 `in_array()` 檢查陣列中是否包含特定的數值 - `bool in_array(mixed $needle, array $haystack, bool $strict = false)` - `$needle` 要查找的值 - `$haystack` 要檢查的陣列 - `#strict` 可選，若為 `true`，則不僅檢查直是否相等，還要檢查型別是否相等。預設為 `false` `foreach` - `foreach()` 尋訪陣列 - `continue` 跳出本次循環，繼續執行下向執行 - `arraykeyfirst()` 取得陣列中第一個 key 值 - `arraykeylast()` 取得陣列中最後一個 key 值 - `break` 跳出迴圈 - 輸出 `scandir` 掃描指定的目錄，並返回為陣列 - `scandir()` 掃描指定的目錄，並返回為陣列 `list` 宣告陣列中的值，使其成為變數 - `list(var1, var2...)` 宣告陣列中的值，使其成為變數 `append` 將傳入的值附加進陣列 - `append(var1, var2)` - 輸出 在陣列中新增元素 直接賦值 `array_push` 在陣列最後新增元素 - `array_push($array, $value1, $value2, ..., $valueN);` - `$array` 必須，目標新增元素的陣列 - `$value1`, `$value2` 必須，欲新增至陣列的元素，可以為字串、整數、浮點數等 `array_unshift` 在陣列前端插入 - `array_unshift($array, $value1, $value2, ..., $valueN)` - `$array` 必須，目標新增元素的陣列 - `$value1`, `$value2` 必須，欲新增至陣列的元素，可以為字串、整數、浮點數等 `array_fill` 以填充數值的方式，建立新陣列 - `arrayfill(int $startindex, int $count, mixed $value): array` 將傳入的`$value`，加入`$count` 個值到陣列，開始的 key 值由`$start_index` 指定 - `$startindex` 回傳陣列的第一個 key 值，如為負數，返回的第一個 key 將會是 startindex 的值，而後面的 key 值由 0 開始。 - `$count` 插入值的數量，需大於等於 0 ，否則拋出 E_WARNING。 - `$value` 傳入陣列的值。 `array_combine` 將傳入的參數合併為陣列 - `array_combine(array $keys, array $values): array` `$key`為 key 值，`$value` 為相對應的值。 `array_unique` 從陣列中刪除重複的值 - `array_unique($array, $flags)` - `$array` 要刪除重複值的陣列 - `$flags` 指定陣列的排序模式，有五種型別 - `SORT_REGULAR` 正常常比較元素 - `SORT_NUMERIC` 以數字方式比較元素 - `SORT_STRING` 以字串方式比較元素 - `SORTLOCALESTRING` 基於當前的語言環境，以字串方式比較元素。 `array_diff` 判斷陣列之間差異 - `array_diff( $array1 , $array2 , $array3 , ... ):array` 後面每個陣列都跟第一個陣列做比較，此方法會回傳在第一陣列中有出現，但未出現在其他陣中的值，並會保留鍵名 - 進階用法 藉由其查詢兩個以上陣列之間的差異，並返回不存在陣列中的值之特性。 因此可用來刪除陣列中多個值，而不影響其索引值。 `array_slice` 從陣列中取得一段連續的元素 此方法會返回一個新的陣列，包含從原陣列取得的元素，而原始陣列不會被修改。 - `arrayslice(array $array, int $offset, int $length = null, bool $preservekeys = false);` - `$array` 目標的陣列 - `$offset` 從陣列的哪一個位置開始取得元素 - `$length` 可選參數，指定取得的元素個數，若未設置，則從 $offset 開始擷取到陣列最後的所有元素。 - `$preserve_keys` 可選參數，若為 `true`，則保留原始陣列的 key 值，預設為 `false` 日期/時間 `date` 格式化 Unix timestamps - `date(string $format, ?int $timestamp = null)` - `$format` 指定的格式 - `Y` 年份，四位數 - `y` 年份二位數 - `F` 月份英文全名；如 'March' - `M` 月份英文縮寫；如 'Mar' - `m` 月份數字，不足二位前面補 0 - `n` 月份數字 - `D` 星期英文縮寫；如：'Fri' - `l` 星期英文全稱；如：'Friday' - `w` 星期數字 - `d` 幾日數字，不足二位前面補 0 - `j` 幾日數字 - `H` 24 小時制，不足二位前面補 0 - `h` 12 小時制，不足二位前面補 0 - `G` 24 小時制 - `g` 12 小時制 - `i` 分鐘 - `A` Am 或 Pm - `a` am 或 pm - `s` 秒 - `U` 總秒數 - `t` 指定月份的天數；如\"28\", \"31\" - `z` 一年中的第幾天 - `$timestamp` 時間戳(可選) `mktime` 取得指定日期的時間戳 - `mktime($hour, $minute = null, $second = null, $month = null, $day = null, $year = null)` - 任何省略的變數，將依據本地時間設置 `date_diff` 獲取以分鐘為單位的時間差 - `date_diff($StartDateTimeObject, $EndDateTimeObject)` - `$StartDateTimeObject1` 必須，為一個 DataTime 物件，表示開始日期。 - `$EndDateTimeObject1` 必須，為一個 DataTime 物件，表示結束日期。 - 若失敗返回 false `sort` 陣列排序 依 value 排序 - 由小到大排序值 - `sort` 刪除 key - `asort` 保留 key - 由大到小排序值 - `rsort` 刪除 key - `arsort` 保留 key 依 key 排序 - `ksort` 由小到大排索引值 - `krsort` 由大到小排索引值 自訂排序 加上一個前綴 `u` 在相對應的方法 - 範例一： 今天有一個陣列如下 我要透過 sorter 這個 key 的 value 來做排序 - 範例二： 如果一樣的陣列，但要用來比對的數值是重複的 可以增加一個比對條件 依照 sorter 來進行排序，但如果 sorter 數值相同，則使用 newSorter 來進行排序 分割字串 `explode` - `explode( string $delimiter , string $string , int $limit )` - `$delimiter` - 字串的切割部位，請自行設定，字串形態，必填 - `$string` - 被要處理的字串，字串形態，必填項目。 - `$limit` - 設定字串切割後最多可輸出的數量，數字形態，可為正整數或負整數，如果填寫正整數，最後的的部份包含切割完剩下的所有部份，，如果填寫負整數，則倒數的部份若在負整數範圍 內將不會顯示，非必填項目 - 加入`$limit` 參數 `str_split` - `str_split($string, $length)` - `string` 必需。規定要分割的字符串。 - `length` 可選。規定每個數組元素的長度。默認是 1。 preg_split - `preg_split ( string $pattern , string $subject , int $limit , int $flags )` - `pattern` 用於搜索的模式，字串形式 - `subject` 輸入字串 - `limit` 可選，用來設定分割後的單位總數量，預設值為 -1 - `flags` 可選 - `PREGSPLITNO_EMPTY`只返回非空白部分 - `PREGSPLITDELIM_CAPTURE`和字串中的正規表達式一起返回 - `PREGSPLITOFFSET_CAPTURE`將每個返回增加字串的偏移量 `array_slice` 從陣列中取出想要的元素 - `array_slice($array, $start, $length, $preserve)` - `array` 必填，傳入陣列。 - `start` 必填，規定取出元素的開始位置，0 = 第一個元素，若傳入正數，則由前往後取值，若為負值由後往前取值。 - `length` 選填，規定返回的陣列長度。 - `preserve` 選填，`true` 保留 key 值，`false` 重置 key 值。 `implode` 將陣列轉為字串 - `implode($separator, $array)` - `separator` 可選。規定數組元素之間放置的內容。默認是 \"\"（空字符串）。 - `array` 必需。要結合為字符串的數組。 `array_filter` 過濾陣列元素(刪除陣列空值) - `array_filter($arrayName, $callbackFunction, $callbackParameter)` - `$arrayName` 必須，目標陣列 - `$callbackFunction` 可選，指定刪除的參數，預設刪除陣列中等於 false 的值 - `$callbackParameter` 可選，引用傳遞給回傳函數的參數 - `ARRAYFILTERUSE_KEY` 將 key 作為唯一參數傳遞給回調函數，而不是數組的值 - `ARRAYFILTERUSE_BOTH` 將值和鍵都作為參數而不是值傳遞給回調 `str_pad` 填充字串為指定長度 - `strpad($string, $length, $padstring, $pad_type)` - string 必填，要填充的字串。 - length 必填，規定新字串的長度，若小於傳入的字串長度，則不進行操作。 - pad_string 可選，提供填充的字串，預設為空白。 - pad_type 可選，字串填充的方向。 - STRPADBOTH 填充字串的兩側，若不為偶數，則將額外的字串填充至右側。 - STRPADLEFT 填充到字串的左側。 - STRPADRIGHT 填充到字串的右側(預設)。 資料序列化及反序列化 `string serialize` 序列化 - `string serialize( mixed $value )` - $value: 要序列化的對象或陣列 `mixed unserialize` 反序列化 - `mixed unserialize( string $str )` - $str: 序列化後的字串 `filegetcontents` 將本地文件存入一個變數中 - `filegetcontents($path, $includepath, $context, $start, $maxlength)` - path (必須) 文件的路徑 - includepath (可選) 如果也想在 includepath 中搜尋文件，可以將該參數設為\"1\" - context (可選) 規定文件控制代碼的環境 - start (可選) 指定在文件中開始讀取的位置。 - max_length (可選) 規定讀取的位元組。 `str_pad` 補足字串 - `strpad($str, $padlength , $padstring, $padtype)` - `$str` 來源字串 - `$pad_length` 補完後字串長度 - `$pad_string` 補入的字元 - `$pad_type` 補入的規則 - `STRPADBOTH` 左右都補 - `STRPADLEFT` 從左邊開始 - `STRPADRIGHT` 從右邊開始 把 id 由左邊開始補 0，補到五位數 `str_replace` 替換字串 將字串轉換為數值 > 若字串開頭為 0，轉為數值後開頭的 0 會被省略 - `numberformat()` 若失敗則返回`EWARNING` - 使用類型轉換 - 透過運算子將字串轉為數值，例如在字串中 + 0 `is_a` 檢查物件是該類別，或該類別是此物件的父類別(boolean) - `isa( object $object , string $classname )` - 此函數在 php 5 之後已廢棄，改用 `instanceof` 型態運算子 `substr` 取得部分字串，可設定字串長度 - `substr( $string , $start , $length )` - $string 原始的字串 - $start 要開始擷取的位置(須為數字，可為正數或負數) - $length 要擷取的字串長度(須為數字，可為正數或負數) 轉換字母大小寫 `ucfirst` 將字串的首字母轉為大寫 `strtolower` 將字串換為小寫 `strtoupper` 將字串換為大寫 `define` 定義一個常數 - `define(name,value,case_insensitive)` - name 必須，規定常數的名稱。通常為全大寫 + 下划線。 - value 必須，規定常數的值。 - case_insensitive 必須，規定常數是否大小寫敏感，預設為 false : 大小寫敏感。 - 常數類似變數，但常數在設定之後，其值無法改變，常數名不用 `$` 開頭，作用域不影響對常數的存取，其值只能是字串或數值 在 Linux 執行 php 檔 方法一 - 在程式的第一行加入路徑 -q - 將 php 檔賦予執行權限 - d/n",
    "path": "PHP/PHP 學習筆記.md",
    "category": "PHP"
  },
  {
    "id": "PHP/PHP 屬性型別宣告指南.md",
    "title": "PHP 屬性型別宣告指南",
    "content": "PHP 屬性型別宣告指南 概述 在 PHP 7.4+ 中，類別屬性支援型別宣告（Type Declaration），這是一個重要的語言特性，用於提升程式碼的型別安全性和可讀性。 基本語法比較 傳統宣告方式（無型別） 現代宣告方式（有型別） 型別宣告的意義與好處 1. 型別安全性（Type Safety） 無型別宣告： 有型別宣告： 2. 程式碼可讀性 無型別宣告： 有型別宣告： 3. IDE 支援與自動完成 無型別宣告： 有型別宣告： 4. 文件化與維護性 無型別宣告： 有型別宣告： 型別宣告本身就是最好的文件，不需要額外的 PHPDoc 註解。 支援的型別 基本型別 類別型別 介面型別 聯合型別（PHP 8.0+） 實際應用範例 RankReport 類別中的應用 最佳實踐 1. 總是使用型別宣告 2. 使用介面而非具體類別（依賴反轉） 3. 使用可空型別處理可選屬性 4. 在建構子中初始化 效能考量 編譯時檢查 - 型別宣告在編譯時就會被檢查，不會影響執行時效能 - 實際上可能提升效能，因為 PHP 引擎可以進行更好的優化 記憶體使用 - 型別宣告本身不增加記憶體使用 - 反而可能減少記憶體使用，因為引擎可以進行更精確的記憶體分配 相容性考量 PHP 版本支援 - PHP 7.4+：支援屬性型別宣告 - PHP 8.0+：支援聯合型別 - PHP 8.1+：支援唯讀屬性 向後相容性 總結 屬性型別宣告的主要意義： 1. 型別安全：在編譯時捕獲型別錯誤 2. 可讀性：程式碼自文件化 3. IDE 支援：更好的自動完成和錯誤檢查 4. 維護性：減少錯誤，提升程式碼品質 5. 文件化：型別本身就是最好的文件 在現代 PHP 開發中，建議總是使用型別宣告，這是提升程式碼品質的重要實踐。",
    "path": "PHP/PHP 屬性型別宣告指南.md",
    "category": "PHP"
  },
  {
    "id": "PHP/PHP 物件導向.md",
    "title": "PHP 物件導向",
    "content": "PHP 物件導向 - PHP 物件導向 - 物件和類別 `Objects` and `Classes` - 建立類別 `Class` - 定義類別的屬性 - 定義類別的方法 Methods - 定義類別的常數 const - 封裝 Encapsulation - PHP 魔術函數 - `construct` 建構式 - `destruct` 解構式 - `unset` - `toString` - `get` `set` 強制封裝 - 類別繼承 - 覆寫 Override 繼承的方法和屬性 - `final` 避免被覆寫 - 範圍解析運算子 scope resolution operator - 將屬性和方法加上可視性 Visibility - `Protected` 受保護的 - `Private` 隱私的 - 介面與抽象類別的應用 - interface 介面 - Abstract 抽象類別 - `trait` 的應用 - `Static` 靜態關鍵字 - 概念與定義 - 目的和好處 - 範例 - 參考資料 物件和類別 `Objects` and `Classes` 把類似或有關聯的工作或屬性，組織到類別`class`裡面。 這可以讓程式保持遵守 不重複原則 “don’t repeat yourself” (DRY)，更容易維護。 - `class` 類別：可以比喻作一個建築的藍圖。類別是將房子的樣式設計出來。 - `object` 物件：依照藍圖蓋出來的房子。物件是類別的實例。 - `data` 資料：就像是鋼筋、水泥，用來蓋房子的材料。 `data`(建材)經過`class`(藍圖)，就會被實例化變成`object`(房子)。 建立類別 `Class` - `new` 關鍵字在建立類別之後，實例化一個類別，並將它存到一個變數上。 - `var_dump()` 來印出變數的相關訊息於螢幕上。 最終會輸出 此為最基礎的物件形式。 定義類別的屬性 使用屬性(Property)，也稱 `Class`的變數(Variable) 來把 `Data` 存入一個 `Class` 裡面。 - `public` 此為屬性的關鍵字，用來決定屬性的可視性(Visibility)。 指定要讀取的物件及屬性，並將其顯示在瀏覽器上 - `->`（對象運算符）: 在 PHP 物件中，用來存取物件的屬性(Property)和方法(Methods)。 - `::`（雙冒號）: 用來訪問靜態屬性。 最後將會得到 定義類別的方法 Methods 可以藉由執行這些方法，來更改物件的行為或是狀態。 建立一個方法來設定與讀取屬性 `$prop1` 的值 - `$this` : 物件透過 `$this` 關鍵字來參考自己，物件使用 $this 就如同你直接使用物件名稱來指定物件。 - `$this` 寫在 class 內部 - 使用這些含有 `$this` 的方法之前，記得先要實例化這些方法的物件。 輸出的結果 接著再 `new` 一個新的 `class` 輸出結果 - 物件導向將 `object` 視為獨立的個體，依照藍圖蓋出來的房子，每一間都是獨立的。 定義類別的常數 const - 可以把類別中始終保持不變的值，定義為常數。 輸出結果 封裝 Encapsulation 每個物件都包含進行操作時需要的所有資訊，物件不必依賴其他物件來完成操作，將方法、欄位、屬性和邏輯包裝在類別內，透過類別的實體來實現，外部物件無法了解物件的內部細節，有種隱藏起來的概念，外部對資料的操作也只能透過已經定義的介面，用一段簡白的話來說，對事只了解他的外在，無需理解內部構造，即為封裝。 PHP 魔術函數 `construct` 建構式 - `construct()` : 當一個物件建立的時候會 首先 被呼叫。 - `CLASS` : 會回傳被呼叫的類別名稱。 最後輸出 `destruct` 解構式 - `destruct()` : 可以清除物件，例如：關閉資料庫連線。 最後輸出畫面 - 當物件使用完畢，PHP 會自動釋放記憶體。 `unset` - `unset()` : 此方法可以更明確觸發 `destruct()` 魔術函數。 結果會輸出 `toString` - `toString` : 將物件轉換為字串。 如果將物件當作字串處理的話，會出現無法傳換型態的錯誤。 輸出結果 加入 `toString` 函數，來做轉換處理。 當物件試圖轉換成字串時，會觸發 `toString` 函數，再由 `toString` 函數呼叫 `getProperty()` 方法。 輸出結果為 `get` `set` 強制封裝 - `get()` 只會回傳屬性變數的值 - `set()` 指派一個新的值給屬性變數 - 優點：藉由單一的存取處，可以自由地修改底層的實作 類別繼承 - `extend` : 此關鍵字可以讓類別繼承其他類別的方法和屬性。 - 子類別只能繼承一個父類別。 建立一個新的 `class` 並繼承 MyClass 結果輸出 覆寫 Override 繼承的方法和屬性 在新的類別中，重新定義繼承自父層的屬性和方法 在新類別中，覆寫 `construct` 方法的輸出結果 `final` 避免被覆寫 - 方法前加入 `final` 避免被覆寫 範圍解析運算子 scope resolution operator 當要將繼承自父層類別的方法其功能做擴充，要保留原始的功能，但不用將原有的程式碼重寫一遍。 - 範圍解析運算子依然會受到可視性的限制。 新增一個改寫父層類別的函數，並使用 `範圍解析運算子::`，來調用父類別被覆寫的函數 結果輸出 將屬性和方法加上可視性 Visibility - `public` : 方法及屬性可以在類別之外被存取。 - `protected` : 該屬性或方法只能在類別以及子類別的內部存取。 - `private` : 該屬性或方法只能在定義它們的類別內存取。 `Protected` 受保護的 將 MyClass 的 `getProperty()` 方法的可視性宣告為 `protected`，並且嘗試從外面呼叫這個方法 結果輸出 在子類別 MyOtherClass 中新增一個方法來調用父層的 `protected` `getProperty()` 方法 輸出結果 `Private` 隱私的 將父層 MyClass 的 `getProperty()` 方法的宣告為 `private`，並且使用 MyOtherClass 的 `callProtected()` 方法來調用 `getProperty()` 方法。 輸出結果 介面與抽象類別的應用 interface 介面 - `implements`關鍵字 : 執行介面 - 定義功能名稱，但交由執行的類別去實作功能 - 執行介面的類別一定要實作介面的方法。 - 介面可以繼承其他的介面。 - 類別可以同時執行多個介面。 用於解決以下問題： 1. 定義共同行為：介面定義一組方法，但不實作這些方法。他允許不同的類別實作相同介面，確保這些類別具有相同的方法。 2. 實現多型：透過介面，可以實現多型，讓不同的物件以相同的方式被處理。 3. 降低耦合：介面提供一種抽象層，使得依賴於介面的程式碼，不需要知道具體實作的細節。 4. 強制契約：介面做為一種契約，確保實作該介面的類別必須提供特定的方法。 Bark.php Swim.php Human.php demo.php 介面的使用時機 : 當「多個類別（Class）」之間有共同的方法（function），但方法實做的方式有差異，可以將這些共用「方法」寫成「介面（Interface）」，讓其他的「子類別（Class）」去實做這個介面 Abstract 抽象類別 - 父類別若不想實作介面方法，子類別又需要定義介面功能，可以將父類別抽象化，即可不用實作介面方法。 - 子類別繼承抽象父類別之後，必須要實作父類別的介面方法。 dog.php Poodle.php demo2.php 抽象類別的使用時機 : 當「多個類別（Class）」之間有共同的方法（function）或屬性（attribute）時，可以將這些共用的地方寫成「抽象類別（Abstract Class）」，讓其他的「子類別（Class）」去繼承 `trait` 的應用 簡化 Class 功能複用 當兩個 `class` 都有類似的內容(property 或 method)，用 `trait` 簡化 `trait`的屬性無法被使用其的類別覆寫 因為 CountAge 與 Child 中都存在 `$age` 這個屬性，此時便會產生 在使用這個 `trait` 的 `class` 都可以使用其所定義的方法。`trait` 中定義的方法為共有的。 - 只要 `use` CheckAdult，就可以使用 `isAdult()` 與 `getAge()`。 `trait` 之間不可以具有相同名稱的方法，否則會丟出 Fatal Error。 若將函式設為 private 也同樣會出現衝突。 `Static` 靜態關鍵字 概念與定義 用於宣告靜態變數與方法。所謂「靜態」表示這些變數和方法屬於類別本身，而不是類別的任何特定實例。因此無論創建多少類別的實例，靜態變數和方法只會有一個。 目的和好處 - 程式碼重用：用於 static 方法和變數是類別及別的，因此不需要創建類別實例就可以使用。有助於減少程式碼的重複。 - 記憶體效率：靜態變數在所有實例間共享，因此他們同時也節省記憶體使用。尤其在需要多個實例共享資料狀或狀態時非常有用。 1. 靜態屬性： 1. 靜態屬性是屬於 class 本身，而不是某個特定的物件實例。 2. 可以使用 `self::` 關鍵字來存取靜態屬性。 3. 靜態屬性在 class 的所有實例中共享。也就是說，若一個實例改變靜態屬性的值，其他實例也會受到影響。 2. 靜態方法 1. 靜態方法可以在不建立實例的情況下被呼叫。 2. 使用 self:: 關鍵字來呼叫靜態方法。 3. 靜態方法中不能使用 $this，因為他們不屬於任何特定的物件實例。 3. 靜態繼承 1. 在繼承的 class 中，靜態屬性和方法可以被子類別繼承。 2. 使用 `parent::` 關鍵字可以在子類別中呼叫父層的靜態方法。 範例 1. 計數器： 靜態屬性可以用來計算某個類別被實例化的次數。 2. 單例模式： 單例模式確保一個類別只有一個實例，並提供一個全局的訪問點。 3. 工具類別： 靜態方法可以用來實現不需要狀態的工具函數。 4. 配置管理： 使用靜態屬性來存儲和管理應用程序的配置。 參考資料 後端 PHP+Laravel--新手實戰日記",
    "path": "PHP/PHP 物件導向.md",
    "category": "PHP"
  },
  {
    "id": "PHP/phpDoc.md",
    "title": "phpDoc",
    "content": "phpDoc 自動編寫程式 通用註解寫法 註解範例（普通程式文件，類別文件，函數文件，變量定義文件） - `@file` 檔案位置： - `@version` 版本： - `@package` 是團隊事先定義好的，在 phpdocumentor 里同一 package 的文件可以給出跟蹤的鏈接。項目開發前需要對其定義。 - `@link` 行後面接的地址是程式開發文檔的地址 > 說明：以上自動更新版本及文件名需要設定 SVN，具體請自行搜尋 'SVN 自動版本號' 類別註解，使用如下幾個 tag - `@access` (`public`|`private`) 標記類是私有的還是公用的。 - `@abstract`標記該類是個抽象類 類別屬性宣告註解 普通函數和類別中的函數註解 順序按照 author、param、return 來放，區塊間空行。 程式段落註解 段落註解和邏輯註解使用如下方式 PHPdoc 規範 WIKI 上的 PHPDoc | 標記 | 用途 | 描述 | | ----------- | --------------------------------- | ------------------------------------------------------------------------ | | @abstract | | 抽象類的變量和方法 | | @access | public, private or protected | 文檔的訪問、使用權限. @access private 表明這個文檔是被保護的。 | | @author | Ivan | 文檔作者 | | @copyright | 名稱 時間 | 文檔版權信息 | | @deprecated | version | 文檔中被廢除的方法 | | @deprec | | 同 @deprecated | | @example | /path/to/example | 文檔的外部保存的示例文件的位置。 | | @exception | | 文檔中方法拋出的異常，也可參照 @throws. | | @global | 類型：$globalvarname | 文檔中的全局變量及有關的方法和函數 | | @ignore | | 忽略文檔中指定的關鍵字 | | @internal | | 開發團隊內部信息 | | @link | URL | 類似於 license 但還可以通過 link 找到文檔中的更多個詳細的信息 | | @name | 變量別名 | 為某個變量指定別名 | | @magic | | phpdoc.de compatibility | | @package | 封裝包的名稱 | 一組相關類、函數封裝的包名稱 | | @param | 如 $username 用戶名 | 變量含義註解 | | @return | 如 返回 bool | 函數返回結果描述，一般不用在 void（空返回結果的）的函數中 | | @see | 如 Class Login() | 文件關聯的任何元素（全局變量，包括，頁面，類，函數，定義，方法，變量）。 | | @since | version | 記錄什麽時候對文檔的哪些部分進行了更改 | | @static | | 記錄靜態類、方法 | | @staticvar | | 在類、函數中使用的靜態變量 | | @subpackage | | 子版本 | | @throws | | 某一方法拋出的異常 | | @todo | | 表示文件未完成或者要完善的地方 | | @var | type | 文檔中的變量及其類型 | | @version | | 文檔、類、函數的版本信息 | PHPDoc 註解實例：",
    "path": "PHP/phpDoc.md",
    "category": "PHP"
  },
  {
    "id": "其他/CSS學習筆記.md",
    "title": "CSS學習筆記",
    "content": "CSS 學習筆記 - CSS 學習筆記 - 後裔選擇器 - 基本類型 - 複合型 - [屬性選擇器`[]`](#屬性選擇器) - 表格 - 偽元素 - `display:none`和`visibility:hidden`的差別 - css 命名 - OOCSS 物件導向 - 結構與樣式分離 - 容器與內容分離 - SMACSS 擴展性與模組化原則 - BEN 區塊元素 - RECSS 獨立元件原則 - 元件 components - 元素 elements - 變形 variants - 巢狀元件 nested components - 佈局 layouts - 輔助類 helpers - Background - attachment 固定樣式 - blend-mode 圖層混合模式 - clip 定義背景延伸的範圍 - color 背景顏色 - image 背景圖片 - origin 設定背景起使位置 - position 設定背景圖片的位置 - repeat 重複 - size 背景圖片尺寸 - Display - Block 區塊元素 - Inline 行內元素 - Table - Flex - 外容器 - flex-direction 方向性 - flex-wrap 斷行 - justify-content 調整內容 - align-items 物件對齊 - align-content 多行物件對齊 - 內元件 - flex-grow 元件的延伸性 - flex-shrink 元件的收縮 - flex-basis 元件基準值 - align-self 自身對齊 - order 調整順序 - Global 全域屬性 - inherit 跟隨父層屬性 - initial 變回原本屬性 - Display-Box 影響用箱子裝起來的所有元素 - none - Display-Legacy 此屬性繼承兩者的特性 - inline-block - inline-table - inline-flex - HTML 佈局 - 盒子模型 - Position - Static - Relative - Absolute - Fixed - sticky - float - float 和 position 的兼容問題 - CSS 簡易暗黑模式 - 變數宣告 - RWD 範例 > 參考資料： > > Super Easy CSS，極度簡單：寫出好的 CSS，從零開始前端生涯 > > 將所有物件加上外框 > > 後裔選擇器 基本類型 - 標籤 `#id` `.class` - div 標籤和 span 標籤 複合型 - div 標籤底下，為 span 標籤 - div 標籤內所有的 span 標籤 - div 標籤之後的第一個 span 標籤 - div 標籤之後的所有 span 標籤 屬性選擇器`[]` 可直接查找任何屬性內元素(ex:`class`, `div`, `title`, `href`,....)，亦可使用於直接指定屬性 - `|` 符號為屬性，包含`[foo]`且必在開頭，須為獨立字元、特定單詞，以及字元後加上連接符號 `-` - `~` 符號為屬性只要有包含`[foo]`，無順序問題，需為獨立字元、特定單詞 - `^` 符號為屬性使用`[foo]`開頭，不特定獨立字元 - `$` 符號為屬性使用`[foo]`結尾，不特定獨立字元 - `*` 符號為屬性內含有`[foo]`，不特定獨立字元 表格 - 將標籤做成表格 偽元素 - 在原本的元素「之前」加入內容 - 在原本的元素「之後」加入內容 - 兩者都是以 display: inline-block;屬性存在 - 偽元素會「繼承」原本元素的屬性 - 偽元素一定要加上 content 的屬性，沒有 content 偽元素不會出現在畫面上 `display:none`和`visibility:hidden`的差別 當使用 `visibility:hidden` 時，物件是確實的被隱藏的，但依然保有物件的位置 例如：當表格內的標籤加上 `visibility:hidden` 時，其儲存格中的值會被隱藏，但儲存格不會消失 當使用 `display:none` 時，物件及其原本的位置都會被隱藏 css 命名 > 盡量使用 class，將 id 留給 javascript 使用 > > 參考資料： > > 談 CSS 命名 OOCSS 物件導向 代表框架：`Bootstrap` 結構與樣式分離 將結構與樣式獨立後，即可重複使用於其他地方。 容器與內容分離 抽出重複樣式 SMACSS 擴展性與模組化原則 將 CSS 分成五個層級 - Base - 全域設定，用來定義 HTML 元素的基本樣式，例如`h1`, `h2`...，通常會透過 CSS Reset 來統一個瀏覽器的差異。 - Layout - 定義網頁的版面架構，如：`.container`, 格線系統等等。 - Module - 用來定義獨立、可重複使用的文件，如：`.btn`, `.nav` - State - 用來定義元素狀態，如：`.active`, `.disabled` - Theme - 用來定義元素的顏色、字體等主題，如：`.theme-dark`, `.theme-light` BEN 區塊元素 將命名方法分為塊(Block)、元素(Element)、修飾符(Modifier)。其好處為依用途進行命名，缺點為名稱可能會變的很長。 - Block 一個獨立的元件，應以小寫字母命名。如：`.header`, `.menu` - Element 元素為塊的一部分，使用兩個下底線連接，如：`.headertext`, `.menuitem` - Modifier 用於修改塊或元素的外觀或狀態，使用兩個破折號連接。如：`.header--dark`, `.menuitem--active` RECSS 獨立元件原則 > 參考文件： > > 官方網站 / 中文翻譯 將網頁各部為拆解成一塊一塊的元件(component)，例如 `header` 元件，而元件可以再容納子元件，例如：`header` 元件中有 `brand`, `navigation`, `search` 三個子元件，而他們可能也會有各自的子元件。一直到最後的最小單位稱為元素(element)，如導覽區(nav)內的單一連結或是搜尋框(search)的文字框。 主要分為： - 元件(components) - 元素(elements) - 變形(variants) - 巢狀元件(nested components) - 佈局(layouts) - 輔助類別(helpers) 元件 components 由多個元素(elements)構成元件。名稱至少為兩個單字，並以破折號相連。如：`.search-form`, `.article-card` 若元件只需要一個詞既可以表達他的意思，如`.alert`，依然建議加上簡單後綴，如：`.alert-box`, `.alert-card` 元素 elements 名稱只能為一個字，由多個元素組成元件(component)。 建議使用 `>` 選擇元素中的樣式，避免使用巢狀時污染子層元件。 變形 variants 巢狀元件 nested components 佈局 layouts 輔助類 helpers Background attachment 固定樣式 - scroll 預設：當設定背景圖的區域有捲軸時，當捲動該區域，背景圖會固定位置不變，但當捲動整個網頁時，該區域的背景圖會跟著網頁捲軸滾動。 - fixed：無論在捲動設定背景圖區快內的捲軸，或是整個網頁的捲軸，背景都會固定位置不變。 - local：和 fixed 相反，捲動任意捲軸，背景圖都會跟著捲軸移動。 blend-mode 圖層混合模式 類似套濾鏡的效果 clip 定義背景延伸的範圍 - border-box 背景範圍為 content + padding + border - padding-box 背景範圍為 content + padding - content-box 背景範圍為 content color 背景顏色 預設為透明，當未設定背景圖片時顯示。 image 背景圖片 origin 設定背景起使位置 - border-box 起始位置為左上角，包含 border + padding + content - padding-box 起始位置為左上角，包含 padding + content - content-box 起始位置為左上角，包含 content position 設定背景圖片的位置 - left top - left center - left bottom - right top - right center - right bottom - center top - center center - center bottom - x% y% - xops yops repeat 重複 - repeat 預設：於 x 軸與 y 軸重複背景 - repeat-x：只於 x 軸重複背景 - repeat-y：只於 y 軸重複背景 - no-repeat：不重複 - space：背景尺寸不變，自動調整圖片間距填滿畫面 - round：調整背景尺寸填滿畫面 size 背景圖片尺寸 - auto 預設：顯示原圖尺寸 - length：設定圖片 width & height，若只輸入一個值，則 width & height 相同。 - percentage：設定背景圖片在區域中要顯示的比例，若 width & height 其中一值未設定則為 auto - cover：不改變圖片比例的情況下，用背景圖片將區塊塞滿後裁切 - contain：不改變圖片比例，完整呈現圖片。若為 no-repeat，圖片尺寸若小於區域尺寸，則會出現空白區域 Display Block 區塊元素 - 總是以新的一行開始，所以無論設定多少寬度，他基本容器的寬度，還是會撐滿整個空間。 - 即使容器中的元素已經被調整成 50%，但他還是會將後面的元素排擠在下面。 Inline 行內元素 - 又稱線內元素，元素本身高度多少他就是多少，無法調整寬高，此外他可以設定 padding 的上下左右，而 margin 只能設定他的左右。 - inline 屬性預設元素的排列為由左到右，直到裝滿容器。 Table - 可以將元素直接模擬成 table 來使用。 - row 對應 ` ` - row-group 對應 ` ` - cell ` ` - caption ` ` - column-group ` ` - header-group ` ` - footer-group ` ` Flex - 設定 flex 屬性之前，需先設定父層容器 display: flex 外容器 flex-direction 方向性 - 決定 flex 的軸線方向，也就是「單行排列方向」，預設是橫的 - 水平方向(瀏覽器預設)：row, row-reverse(水平方向反轉) - 垂直方向：column, column-reverse(垂直方向反轉) flex-wrap 斷行 - 當內元件排列超過外容器主軸時的行為 - nowrap：強制不斷行。 - wrap：裝滿容器會強制斷行。 - wrap-reverse：裝滿容器會強制斷行，但排列順序是相反的。 justify-content 調整內容 - 改變 flex 物件在主軸上的對齊(預設為水平方向)，若 flex-direction 為 column，則對齊方向改為垂直方向(y 軸) - flex-start 以起點為基準 - flex-end 以尾端為基準 - center 以中間為基準 - space-between 會將物件依容器大小均分 - space-around 會將物件依容器大小均分，並會給左右空間 align-items 物件對齊 - 改變橫軸上所有 flex 物件的對齊(預設為垂直方向)，若 flex-direction 為 column，則對其方向會改為水平方向(x 軸) - flex-start 以起點為基準 - flex-end 以尾端為基準 - center 以中間為基準 - baseline 以物件基準線為基準 - stretch 以起點為基準，但會撐滿容器(瀏覽器預設) align-content 多行物件對齊 - 和 align-items 類似，差別為他是多行的排列方式。 - flex-start - flex-end - center - baseline - stretch 內元件 flex-grow 元件的延伸性 - 為一個數值，當空間分配還有剩餘的當前元件的伸展性，預設為 0，如果設置為 0 則不會縮放 將 item1 加上 grow，此時元件 1 會擴大將空間填滿。 將 item2 設定為 grow: 2，此時元件 2 比元件 1 還大。 flex-grow 的數值為外容器按剩餘空間依比例進行分配。 - 內元件 1：佔據剩餘空間 1/3 - 內元件 2：佔據剩餘空間 2/3 flex-shrink 元件的收縮 - 當空間分配不足時，當前元件的收縮性。預設為 0 和 flex-grow 相反，內元件相加總和超過外容器的數值，依比例減少。 三個 item 其總和大於 container，因此預設是會自動縮小，使用 flex-shrink 設定各個元件的縮小比例。 flex-basis 元件基準值 - 可使用不同單位的基準值 預設為 auto，當設定後，會覆蓋原先設定的 width 值。 align-self 自身對齊 - 單獨改變內元件在橫軸上的對齊(預設為垂直方向)，若 flex-direction 為 column，則對齊方向則改為水平方向(x 軸) - flex-start 以起點為基準 - flex-end 以尾端為基準 - center 以中間為基準 - baseline 以物件基準線為基準 - stretch 以起點為基準，但會撐滿容器(瀏覽器預設) order 調整順序 預設為 0，所想將其中一個元件，移動到前面，可以將其設定為 -1。 自訂排列順序： Global 全域屬性 - 除了 display 以外，其他任意屬性都能使用 inherit 跟隨父層屬性 - 當父層屬性為 block，子層下 display:inherit 時，子層屬性也會變成 block initial 變回原本屬性 - 假如我 div 屬性在某種情況下更改為 inline 屬性，那我後面有吃到同樣 CSS 的 div 想改回 block，我只要下 display:initial，就會變回 div 原本的 block 屬性 Display-Box 影響用箱子裝起來的所有元素 none - 若被 display: none; 的 div 裝起來的元素，會被隱藏。 Display-Legacy 此屬性繼承兩者的特性 inline-block - 讓許多區塊自動浮起來水平排列，且不用額外設定 clear 也不會讓接著的元素浮上來蓋住區塊 inline-table inline-flex - flex 時父元素為 block，而 inline-flex 則是父元素變成 inline，他會根據子元素所有的 div 大小自適應寬度和高度 HTML 佈局 盒子模型 在 HTML 中元素的盒子模型分為兩種，塊狀元素(block)和行內元素(inline)。其兩種元素和 display 屬性中的 inline block 兩個屬性不盡相同。 盒子模型中的 inline, block 類似於 display 屬性的父類，如：display 屬性中的 list-item 屬性質是屬於塊狀(block)類型。 塊狀(block)和行內(inline)的區別: - block 可以設置 width, height 屬性。inline 設置無效。 - block 類型的元素會獨佔一行，而 inline 會在同一行內顯示 - block 元素的 width 預設為 100%，而 inline 則是根據自身的 內容及子元素來決定寬度。 下面是一些常見的元素分類 - block: p, div, ul, il, dd, dt...... - inline: a, img, span, strong Position > 設定物件定位時所要的參考對象 - 目前可以用的 - static 靜態的 - relative 相對定位 - fixed 固定定位 - absolute 絕對定位 - sticky 黏貼定位 Static 靜態定位，將其他定位特性取消，回到最原始的狀態，為一般網頁最原始的預設值。 Relative 相對定位，將設定的物件其參考空間，設定為自身原始的資料流位置，且此種定位值並不會將物件獨立一層，搭配其他 css 屬性如：`top`, `bottom`, `left`, `right`可以做到顯示位置的偏移。 Absolute 絕對定位，將設定的物件，其參考空間設定為「階層離自身最近，且具備定位設定的父層空間」，若沒有任何父層空間具備定位設定，該物件將採用視窗空間座位參考空間，而父層只要具備以下四種定位類型之一，即可被絕對定位當作參考空間： - relative - absolute - fixed - sticky 此外當物件設定了 abstract 後，將會自己獨立一層，不在其他物件關連，可以利用此一特性，進行物件堆疊的視覺效果。 Fixed 固定定位，將設定的物件，將其參考空間設定為視窗，因此無論如何捲動視窗捲軸，這個物件都會固定在原位。固定定位和絕對定位一樣，都會自己獨立一層。 sticky 黏貼定位，結合 relative 和 fixed 兩大特性 1. 預設定位在父層空間 2. 當視窗捲動到該物件時，會依據對該物件設定的 top 值來讓該物件呈現 fixed 在視窗中的效果。 3. 當物件呈現 fixed 的效果時，其所能 fixed 的空間是該物件的父層空間。 4. 當視窗向下捲動超過 sticky 物件的父層空間時，該物件不會再呈現 fixed 效果，而是被捲離視窗範圍。 float float 的屬性只有 none, left, right。 1. 只有橫向浮動，沒有縱向浮動 2. 當元素應用了 float 時將會脫離一般資料流，其容器元素將得不到脫離原始資料流的子元素高度 3. 一個元素會圍繞著浮動元素(文繞圖)，與應用了 position 的元素相比，浮動元素並不會遮蓋後一個元素。 4. 浮動元素前一個元素不會受到任何影響，若想將兩塊狀元素並排顯示，則需將兩個塊狀元素都應用 float。 5. 會將元素的 display 屬性更變為 block float 和 position 的兼容問題 元素若同時應用 position: relative, float, (top, bottom, right and left) 屬性時，則元素會先浮動到相對應位置，再根據 (top, bottom, right and left)設置的距離來發生偏移。 若不將 float 元素的 position 設置為 relative，此時若要設置 float 的 z-index 來實現覆蓋 position: absolute 會無效。 同理可證，float 元素若下面存在 position: absolute 的子元素，若不將 float 元素的 position 設為 relative，absolute 元素是無法定位到 float 元素的。 CSS 簡易暗黑模式 - `invert` 將所有色值反轉，hue-rotate 將黑白以外的其他主題色調再反轉過來(防止頁面主題色出現過大變化) - `code[class*=\"language-\"]` 為 markdown 語法中的程式碼區塊 - 若 html 反轉 90% 則圖片等元素需反轉 110% - 去背圖片在黑暗模式中因為背景變成黑底色，可能就會造成深色內容被深色背景吃掉的問題，為了避免這個問題，建議 img 的背景一律調成跟正常模式的背景色 變數宣告 - 定義變數：必需要定義在 css 選取器中，建議定義在 `:root` 最高層及的選取器以便於使用，使用 `--自訂名稱` 作為屬性的方式來宣告變數 - 取用變數值：`var(變數名稱)` RWD 範例 - max-width: 表示這個數字以下(包含)都適用 ( =) - landscape 縱向顯示(直式螢幕) - @media all and (orientation:landscape) { … } - portrait 橫向顯示(橫式螢幕) - @media all and (orientation:portrait) { … }",
    "path": "其他/CSS學習筆記.md",
    "category": "其他"
  },
  {
    "id": "其他/Kubectl 學習筆記.md",
    "title": "Kubectl 學習筆記",
    "content": "Kubectl 學習筆記 > 本文件記錄 Kubernetes kubectl 命令的使用方法與 Pod 網路連線測試技巧 - Kubectl 學習筆記 - 基礎概念 - curl 效能測試命令 - 基本命令結構 - 參數說明 - 時間測量指標 - Kubernetes 環境中的 Pod 間連線測試 - 準備工作 - 確認 Pod 和 Service 資訊 - 查看 Pod 分佈和節點資訊 - 測試方法 - 使用 Service 名稱測試（推薦） - 使用 Pod IP 直接測試 - 使用 Service IP 測試 - 效能比較測試 - 簡化版本（只顯示總時間） - 批次測試 - 跨節點 vs 同節點效能比較 - 故障排除 - DNS 解析問題 - 檢查 Pod 工具可用性 - 檢查網路政策 - 最佳實踐 - 常見問題 - Q1: 出現 \"Could not resolve host\" 錯誤 - Q2: 連線被拒絕 - Q3: 時間測量都是 0 - Q4: 效能差異很大 基礎概念 本文件說明如何使用 `curl` 命令測試 Kubernetes 環境中 Pod 間的網路連線效能和延遲。透過系統性的測試方法，可以有效診斷和分析 Pod 間的網路狀況。 curl 效能測試命令 基本命令結構 參數說明 | 參數 | 功能 | 描述 | |------|------|------| | `-v` | Verbose | 顯示詳細的請求和回應資訊，包括標頭、SSL 憑證等 | | `-w` | Write-out | 自訂輸出格式，顯示指定的測量數據 | 時間測量指標 | 指標 | 變數 | 說明 | |------|------|------| | DNS Lookup | `%{time_namelookup}` | 域名解析為 IP 位址所需時間 | | TCP Connect | `%{time_connect}` | TCP 連線建立時間（三次握手） | | SSL Handshake | `%{time_appconnect}` | SSL/TLS 握手時間（HTTPS 時） | | Time to First Byte | `%{time_starttransfer}` | 從請求開始到接收第一個位元組的時間 | | Total Time | `%{time_total}` | 整個請求過程的總時間 | Kubernetes 環境中的 Pod 間連線測試 準備工作 確認 Pod 和 Service 資訊 查看 Pod 分佈和節點資訊 測試方法 使用 Service 名稱測試（推薦） 使用 Pod IP 直接測試 使用 Service IP 測試 效能比較測試 簡化版本（只顯示總時間） 批次測試 跨節點 vs 同節點效能比較 故障排除 DNS 解析問題 檢查 Pod 工具可用性 檢查網路政策 最佳實踐 1. 測試順序建議： - 先測試 Service 名稱（完整路徑） - 再測試 Service IP（跳過 DNS） - 最後測試 Pod IP（跳過 LoadBalancer） 2. 效能基準： - 同節點 Pod 間通訊：< 5ms - 跨節點 Pod 間通訊：< 10ms - DNS 解析：< 5ms 3. 測試建議： - 執行多次測試取平均值 - 測試不同時間點的效能 - 記錄測試環境和條件 常見問題 Q1: 出現 \"Could not resolve host\" 錯誤 A: 檢查 Service 名稱是否正確，或嘗試使用完整 FQDN 格式 Q2: 連線被拒絕 A: 檢查目標 Pod 是否正在運行，端口是否正確 Q3: 時間測量都是 0 A: 可能是連線失敗，檢查網路政策和防火牆設定 Q4: 效能差異很大 A: 考慮網路負載、Pod 資源使用情況和節點間網路狀況",
    "path": "其他/Kubectl 學習筆記.md",
    "category": "其他"
  },
  {
    "id": "其他/Markdown 學習筆記.md",
    "title": "Markdown 學習筆記",
    "content": "Markdown 學習筆記 Markdown 程式碼區塊可宣告的程式語言 | 語言名稱 | Markdown 語言宣告 | 常見檔名 | | ---------- | --------------------------------- | ------------------------ | | ApacheConf | apacheconf, aconf, apache | \\*.apacheconf, .htaccess | | Blade | blade | \\*.blade | | CSS | css | \\*.css | | Git Config | git-config, gitconfig, gitmodules | \\*.gitconfig, .gitconfig | | HTML | html, xhtml | \\*.html | | HTML+PHP | html+php | \\*.phtml | | HTTP | http | \\*.http | | JSON | json | \\*.json, .arcconfig | | JavaScript | javascript, js, node | \\*.js, Jakefile | | Makefile | makefile, bsdmake, make, mf | \\*.mak, BSDmakefile | | Markdown | markdown, pandoc | \\*.md, contents.lr | | Nginx | nginx | \\*.nginxconf, nginx.conf | | PHP | php, inc | \\*.php, .php | | Text | text, fundamental | \\*.txt, COPYING | | Vue | vue | \\*.vue |",
    "path": "其他/Markdown 學習筆記.md",
    "category": "其他"
  },
  {
    "id": "其他/介面定義規範.md",
    "title": "介面定義規範",
    "content": "介面定義規範指南 目錄 - 概述 - 基礎規範 - 型別宣告規範 - 回傳值規範 - 方法命名規範 - DocBlock 註解規範 - 依存關係處理 - 常見問題與解決方案 - 實作範例 --- 概述 介面的目的 介面（Interface）在軟體架構中提供抽象層級，定義類別必須實作的方法契約，達成： 1. 依賴反轉：高階模組不依賴低階模組，兩者都依賴抽象 2. 可替換性：可替換實作而不影響使用方 3. 易於測試：可建立 mock 物件進行單元測試 4. 程式碼重用：透過介面統一不同實作的使用方式 介面設計原則 - 介面隔離原則：介面應小而專注，而非巨集接口 - 單一職責：每個介面應該只負責一種類型的功能 - 可擴展性：介面應考慮未來可能的需求變更 - 向後相容性：修改介面必須考慮對現有實作的影響 --- 基礎規範 1. 介面命名規範 命名建議： - 以 `I` 開頭（如 `IUser`, `IGoogleCloudArmor`） - 或使用描述性的 Interface 後綴（如 `UserInterface`, `SecurityPolicyInterface`） - 保持與實作類別名稱的對應關係（如 `IGoogleCloudArmor` → `GoogleCloudArmorApi`） 2. 介面檔案結構 --- 型別宣告規範 1. 強制型別宣告 所有方法必須包含： - 參數型別宣告 - 回傳值型別宣告 2. 支援的 PHP 型別 3. 實作類別必須匹配 --- 回傳值規範 1. 明確的回傳值結構 使用 DocBlock 明確指定回傳結構： 2. 複雜回傳值範例 3. 錯誤處理 --- 方法命名規範 1. 動詞開頭 2. 動詞對應操作 | 操作類型 | 動詞 | 範例 | |---------|------|------| | 獲取資料 | get, fetch, retrieve | `getSecurityPolicy()` | | 新增資料 | add, create, insert | `addSecurityPolicyRule()` | | 更新資料 | update, modify, change | `updateSecurityPolicyRule()` | | 刪除資料 | delete, remove, destroy | `deleteSecurityPolicyRule()` | | 檢查條件 | is, has, can, should | `isValid()`, `hasRule()` | 3. 複數命名 --- DocBlock 註解規範 1. 完整的方法註解 2. @param 標籤規範 3. @return 標籤規範 4. 複雜型別註解 --- 依存關係處理 1. callable 參數 使用 callable（簡單但型別弱） 定義專用介面（型別強，複雜度高） 建議： - 簡單的回調：使用 `callable` - 複雜的回調：定義專用介面 - 回調的參數/回傳值已在 DocBlock 說明 2. 陣列參數 3. 可選參數 --- 常見問題與解決方案 問題 1: 介面與實作型別不一致 問題描述： 解決方案： 問題 2: 回傳值結構不明確 問題描述： 解決方案： 問題 3: callable 型別過於寬泛 問題描述： 解決方案： 問題 4: 介面方法是否應該包含業務邏輯？ 不應該。介面僅定義契約，不包含實作： 問題 5: 介面應該包含哪些方法？ 原則： - ✅ 其他類別會呼叫的方法（public 方法） - ✅ 需要被 mock 的依賴方法 - ❌ 私有方法（private） - ❌ 僅實作內部使用的輔助方法（helper methods） - ❌ 不期望被外部呼叫的內部邏輯 判斷標準：如果在測試或生產環境中，有其他類別需要呼叫這個方法，就應該在介面中定義。 --- 實作範例 完整介面範例 對應的實作類別範例 --- 檢查清單 在設計介面時，使用此清單確認完整性： - [ ] 所有方法都有型別宣告（參數和回傳值） - [ ] DocBlock 完整且描述清楚 - [ ] 回傳值結構有明確定義 - [ ] 方法命名符合動詞開頭規範 - [ ] 錯誤處理方式明確（null/空陣列/布林） - [ ] callable 參數有清楚的簽名說明 - [ ] 沒有業務邏輯實作 - [ ] 介面不包含私有方法 - [ ] 介面方法是其他類別需要呼叫的方法 - [ ] 考慮未來擴展的可能性 --- 參考資源 Laravel 相關 - Laravel Service Container - Laravel Testing: Mocking Objects PHP 相關 - PHP: Type Declarations - PHP: Interfaces - PHP: DocBlock 設計模式 - SOLID Principles - Dependency Inversion Principle - Interface Segregation Principle",
    "path": "其他/介面定義規範.md",
    "category": "其他"
  },
  {
    "id": "其他/語意化版本.md",
    "title": "語意化版本",
    "content": "語意化版本 > 參考資料： > > 語意化版本 2.0.0 摘要 版本格式：主板號.次版號.修訂號，版號遞增規則如下： 1. 主板號：當推出一個不相容的 API 修改。 2. 次版號：當推出一個向下相容的功能性新增。 3. 修訂號：當推出一個向下相容的問題修正。 先行版號及版本編譯資訊可以加到 \"主版本號.次版本號.修訂號\" 的後面作為延伸。 簡介 當系統規模越大，加入的套件越多，就越有可能在未來的某一天發現自己身陷絕望之中。 再相依性高的系統中發佈新版本套件，可能很快就會變成惡夢。如果相依性關係過高，可能面臨版本控制被鎖死的風險(必須對每一個相依套件改版，才能完成某次升級)。而如果相依性過於鬆散 ，又將無法避免版本混亂(假設相容於未來的多個版本已超出合理數量)。當你專案的進展因為版本相依被鎖死或版本混亂變得不夠簡便和可靠，就意味你正處於相依性地獄中。 而語意化版本就是這個問題的解決方案之一。這些規則是根據(但不局限於)各種已經封閉、開放源碼軟體所廣泛應用的慣例所設計。為了讓這套理論運作，你必須先定義好的公共 API。這可以透過文件定義或程式碼強制要求來實限。無論如何，這套 API 的清楚明瞭是十分重要的。一旦你定義了公共 API。這可以透過修改相應的版號來向大家說明你的修改。考慮使用這樣的版號格式：X.Y.Z(主版號.次版號.修訂號)修復問題但不影響 API 時，遞增修訂號；API 保持向下相容的新增修改時，地增次版號；進行不向下相同的修改時，遞增主版號。 語意版本控制規範 1. 使用語意化版本控制的軟體必須(MUST)定義公共 API。該 API 可以在程式碼中被定義出來或出現於嚴謹的文件內。無論何種形式都應該(SHOULD)力求精確且完整。 2. 標準的版號必須(MUST)採用 X.Y.Z 格式，其中 X、Y 和 Z 為非負的整數，且禁止(MUST NOT)在數字前方補零。X 為主版號，Y 為次版號，Z 為修訂號。每個元素必須(MUST)以數值來遞增。例如：1.9.1 -> 1.10.0 -> 1.11.0。 3. 標記版號的軟體發行後，禁止(MUST NOT)改變該版本軟體的內容。任何修改都必須(MUST)以新版本發行。 4. 主版本號為零(0.y.z)的軟體處於開發初始階段，一切都可以(MAY)隨時改變。這樣的公共 API 不應該(SHOULD NOT)被視為穩定版。 5. 1.0.0 的版號用於界定公共 API 的形成。這一版之後所有的版號更新都基於公共 API 及其修改內容。 6. 修訂號 z 必須(MUST)在只做了向下相容的修正時才遞增。這裡的修正指的是針對不正確結果而進行的內部修改。 7. 次版號 y 必須(MUST)在有向下相容的新功能出現時遞增。在任何公共 API 的功能被標記為棄用時，也必需(MUST)遞增。也可以(MAY)在內部程式有大量新功能或改進被加入時遞增，其中可以(MAY)包括修訂級別的改變。每當次版號遞增時，修訂號必須(MUST)歸零。 8. 主版號 x 必須(MUST)在有任何不相容的修改被加入公共 API 時遞增。其中可以(MAY)包括次版號及修訂級別的改變。每當主版號遞增時，次版號和修訂號必須(MUST)歸零。 9. 先行版號可以(MAY)被標註在修訂版之後，先加上一個連接號再加上一連串以句點分隔的標示符號來修飾。標示符號必須(MUST)由 ASCII 碼的英數字和連接號組成，且禁止(MUST NOT)留白。數字型的標示符號禁止(MUST NOT)在前方補零。先行版的優先級低於相關聯的標準版。被標上先行版號則表示這個版號並非穩定且可能無法達到相容的需求。範例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92、1.0.0-x-y-z.–。 10. 版本編譯資訊可以(MAY)被標註在修訂版或先行版之後，先加上一個加號再加上一連串以句點分隔的標示符號來修飾。標示符號必須(MUST)由 ASCII 的英數字和連接號組成，且禁止(MUST NOT)留白。當判斷版本的優先層級時，版本編譯資訊必須(MUST)被忽略。因此當兩個版本只有在版本編譯資訊有差別時，屬於相同的優先層級。範例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85、1.0.0+21AF26D3—-117B344092BD。 11. 版本的優先層級指的是不同版本在排序時如何比較。 1. 判斷優先層級時，必須(MUST)把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較(版本資訊不在此比較的範疇中)。 2. 由左到右依序比較每個標示符號，第一個差異值用來決定優先層級：主辦號、次版號及修訂號以數值比較。例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。 3. 當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。例如：1.0.0-alpha < 1.0.0。 4. 有相同主版號、次版號及修訂號的兩個先行版號，其優先必須(MUST)透過由左到右每個被句點分隔的標示符號來做比較，值到找到一個差異值後決。",
    "path": "其他/語意化版本.md",
    "category": "其他"
  },
  {
    "id": "提示詞工程/AI 提示工程師指令.md",
    "title": "AI 提示工程師指令",
    "content": "你是一名擁有十年經驗的資深 AI 提示工程師（Prompt Engineer）與 AI 訓練師，專精於主流 AI 編碼工具的指令設計與最佳化。 核心任務： 協助使用者撰寫、優化提供給 AI 編碼工具的指令（Prompts / System Instructions），確保指令設計符合各工具的最佳實踐，並提升 AI 輸出品質。 --- 目標與行為準則： 1. 指令撰寫原則： - 參考來源優先：在撰寫或修改 AI 指令時，必須引用官方文件或權威來源作為設計依據，確保指令符合工具的設計規範。 - 說明設計原理：為每項指令規則提供簡要的設計原理說明，讓使用者理解「為何這樣設計」而非僅「照做」。 - 結構化格式：採用條列式（bullet points）與層級結構，確保指令清晰、易於維護。 - 可測試性：指令應具備明確的預期行為，便於驗證效果。 2. 指令設計方法論： - 角色定義（Role Definition）：明確定義 AI 的身份、專業領域與行為邊界。 > 原理：清晰的角色設定有助於 AI 維持一致的回應風格與專業深度。 - 目標導向（Goal-Oriented）：指令應聚焦於解決特定問題，避免過於籠統。 > 原理：具體的目標能引導 AI 產生更精準的輸出。 - 約束條件（Constraints）：定義 AI 的行為限制，如語言、格式、禁止事項。 > 原理：約束條件能減少非預期輸出，提升一致性。 - 範例驅動（Few-Shot Examples）：視需要提供輸入/輸出範例，引導 AI 理解預期格式。 > 原理：範例能有效傳達隱性規則，減少歧義。 3. 溝通風格： - 使用專業、精確且有條理的繁體中文進行交流。除非涉及技術文件或特定術語，否則優先使用繁體中文。 - 回應內容使用繁體中文撰寫，格式清晰易讀。 - 避免冗長解釋，直接切入核心問題，提供具體且可執行的指令。 4. 回應結構規範： - 在提供指令建議時，應包含以下區塊： - 📌 指令內容：實際可用的指令文字，必須符合目標 AI 工具的指令格式規範（例如：Markdown、YAML、純文字等），確保使用者可直接複製貼上使用。 - 📖 設計原理：說明此指令的設計考量與預期效果。 - 🔗 參考來源：引用的官方文件或最佳實踐來源。 - 格式尊重原則：若使用者詢問的 AI 工具其指令格式並非 Markdown，應優先遵循該工具的官方格式規範，而非強制使用 Markdown。 5. 外部資源引用： - 若問題涉及 Claude Code，應優先參考 Claude Code 官方文件。 - 若問題涉及 Cursor，應優先參考 Cursor 官方文件。 - 若問題涉及 Gemini CLI，應優先參考 Gemini CLI 官方文件。 - 若問題涉及 Google Antigravity，應優先參考 Antigravity 官方文件。 - 若問題涉及 Codex CLI，應優先參考 Codex CLI 官方文件。 - 若問題涉及 GitHub Copilot，應優先參考 Copilot 官方文件。 --- 範例回應格式： 當使用者詢問如何撰寫某項指令時，回應應遵循以下結構：",
    "path": "提示詞工程/AI 提示工程師指令.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/Gemini CLI Agent Skills 撰寫指南.md",
    "title": "Gemini CLI Agent Skills 撰寫指南",
    "content": "Gemini CLI Agent Skills 撰寫指南 ⚙️ 前置作業：啟用 Agent Skills 在開始撰寫之前，請確保你的 Gemini CLI 已啟用此功能（預設可能是關閉的）。 1. 執行指令開啟設定介面：`gemini settings` 2. 將 Agent Skills 選項設為 `true`。 3. 或者直接編輯設定檔 `~/.gemini/settings.json`： --- 📂 Agent Skills 核心結構說明 一個標準的 Skill 是一個資料夾，必須包含 `SKILL.md`，並可選包含三個支援資料夾。 - `SKILL.md` (必須)：技能的「大腦」。包含中繼資料（Metadata）與核心指令（System Instructions）。 - `scripts/` (進階)：技能的「手」。AI 可以執行的具體工具（Bash, Python, Node.js）。 - `references/` (進階)：技能的「知識庫」。AI 執行任務時參考的靜態文件、規範或 schema。 - `assets/` (進階)：技能的「資產」。AI 用來生成的模板、範例程式碼或二進位資源。 --- 1. 基礎設定範例 (Basic Configuration) 情境：建立一個「資深 Code Reviewer」技能。 特點：純文字指令驅動，不涉及外部腳本執行，依靠模型本身的知識庫與邏輯。 📌 撰寫範例：`code-reviewer/SKILL.md` 請在 `.gemini/skills/code-reviewer/` 目錄下建立 `SKILL.md`： 📖 設計原理 - YAML Frontmatter：`name` 與 `description` 是為了讓 Agent 在「Discovery（探索）」階段能識別此技能的存在。說明越精確，觸發越準確。 - Role Definition：透過角色設定（Persona）鎖定輸出的專業度。 - 結構化指令：將審查過程標準化，確保每次輸出的一致性。 --- 2. 進階設定範例 (Advanced Configuration) 情境：建立一個「自動化 API 測試與文件生成器」技能。 特點：整合 Python 腳本 執行測試，參考 API 規範文件，並使用 Markdown 模板 輸出報告。 📂 目錄結構 📌 撰寫範例 1：`api-tester/SKILL.md` 📌 撰寫範例 2：支援檔案內容 `scripts/curl_test.py` (簡化版) `references/status_codes.md` `assets/report_template.md` 📖 設計原理 - Tool Binding (Scripts)：將 AI 無法憑空完成的任務（真實的網路請求）交給 `scripts/` 中的程式碼執行。這是 Agent \"Grounding\"（接地）的關鍵。 - Knowledge Retrieval (References)：將靜態知識（如 HTTP 定義）從 Prompt 中移出，放入 `references/`，減少 Context Window 的消耗，並讓知識維護更容易。 - Standardization (Assets)：透過 `assets/` 中的模板強制規範輸出格式，避免 AI 自由發揮導致格式混亂，特別適合需要機器二次讀取（Machine Readable）的產出。 --- 🔗 參考來源 - Gemini CLI GitHub Repository - Agent Skills - Gemini CLI Documentation - Skills Configuration - Gemini CLI Skills Feature Demo",
    "path": "提示詞工程/Gemini CLI Agent Skills 撰寫指南.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/Gemini CLI custom commands 撰寫指南.md",
    "title": "Gemini CLI custom commands 撰寫指南",
    "content": "Gemini CLI 自訂指令參考 > 本文件摘要自 gemini-cli 官方文件，供 AI 撰寫自訂指令時參照。 --- 1. 檔案位置與優先順序 | 類型 | 位置 | 範圍 | |------|------|------| | 全域指令 | `~/.gemini/commands/` | 所有專案可用 | | 專案指令 | ` /.gemini/commands/` | 僅當前專案可用 | 優先順序：專案指令會覆蓋同名的全域指令。 --- 2. 命名與命名空間 - 檔案名稱決定指令名稱 - 子目錄用於建立命名空間，路徑分隔符轉換為 `:` | 檔案路徑 | 指令名稱 | |----------|----------| | `commands/test.toml` | `/test` | | `commands/git/commit.toml` | `/git:commit` | --- 3. TOML 檔案格式 必要欄位 可選欄位 --- 4. 參數處理 4.1 明確注入：`{{args}}` 當 prompt 包含 `{{args}}` 時，使用者輸入會替換該佔位符。 4.2 預設附加行為 當 prompt 不包含 `{{args}}` 時： - 有參數：附加到 prompt 末尾（以兩個換行分隔） - 無參數：prompt 原樣發送 --- 5. 動態注入 5.1 Shell 指令注入：`!{...}` 執行 shell 指令並注入其輸出。 diff !{git diff --staged} 特性： - 執行前會提示使用者確認 - `{{args}}` 在 `!{...}` 內會自動進行 shell 跳脫 - 指令失敗時會注入錯誤訊息與退出碼 5.2 檔案內容注入：`@{...}` 直接將檔案或目錄內容嵌入 prompt。 特性： - 支援多媒體檔案（圖片、PDF、音訊、影片） - 目錄會遞迴展開，尊重 `.gitignore` 與 `.geminiignore` - 處理順序：`@{...}` → `!{...}` → `{{args}}` --- 6. 完整範例 範例 1：Git Commit 訊息生成 diff !{git diff --staged} 範例 2：程式碼審查 範例 3：批判性分析（條件式參數） --- 7. 設計建議 1. 明確角色定義：在 prompt 開頭設定 AI 的角色與專業背景 2. 結構化輸出：使用標題與編號引導回應格式 3. 條件式區塊：對可選功能標註適用條件 4. 參考專案脈絡：結合 `@{...}` 注入專案規範或文件 5. 動態資料：善用 `!{...}` 取得即時環境資訊",
    "path": "提示詞工程/Gemini CLI custom commands 撰寫指南.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/Kubernetes Pod 網路連線測試操作指南.md",
    "title": "Kubernetes Pod 網路連線測試操作指南",
    "content": "Kubernetes Pod 網路連線測試操作指南 概述 本文件說明如何使用 `curl` 命令測試 Kubernetes 環境中 Pod 間的網路連線效能和延遲。 一、curl 效能測試命令解析 基本命令結構 參數說明 | 參數 | 功能 | 描述 | |------|------|------| | `-v` | Verbose | 顯示詳細的請求和回應資訊，包括標頭、SSL 憑證等 | | `-w` | Write-out | 自訂輸出格式，顯示指定的測量數據 | 時間測量指標 | 指標 | 變數 | 說明 | |------|------|------| | DNS Lookup | `%{time_namelookup}` | 域名解析為 IP 位址所需時間 | | TCP Connect | `%{time_connect}` | TCP 連線建立時間（三次握手） | | SSL Handshake | `%{time_appconnect}` | SSL/TLS 握手時間（HTTPS 時） | | Time to First Byte | `%{time_starttransfer}` | 從請求開始到接收第一個位元組的時間 | | Total Time | `%{time_total}` | 整個請求過程的總時間 | 二、Kubernetes 環境中的 Pod 間連線測試 1. 準備工作 1.1 確認 Pod 和 Service 資訊 1.2 查看 Pod 分佈和節點資訊 2. 測試方法 2.1 使用 Service 名稱測試（推薦） 2.2 使用 Pod IP 直接測試 2.3 使用 Service IP 測試 3. 效能比較測試 3.1 簡化版本（只顯示總時間） 3.2 批次測試 3.3 跨節點 vs 同節點效能比較 4. 故障排除 4.1 DNS 解析問題 4.2 檢查 Pod 工具可用性 4.3 檢查網路政策 5. 最佳實踐 1. 測試順序建議： - 先測試 Service 名稱（完整路徑） - 再測試 Service IP（跳過 DNS） - 最後測試 Pod IP（跳過 LoadBalancer） 2. 效能基準： - 同節點 Pod 間通訊：< 5ms - 跨節點 Pod 間通訊：< 10ms - DNS 解析：< 5ms 3. 測試建議： - 執行多次測試取平均值 - 測試不同時間點的效能 - 記錄測試環境和條件 六、常見問題 Q1: 出現 \"Could not resolve host\" 錯誤 A: 檢查 Service 名稱是否正確，或嘗試使用完整 FQDN 格式 Q2: 連線被拒絕 A: 檢查目標 Pod 是否正在運行，端口是否正確 Q3: 時間測量都是 0 A: 可能是連線失敗，檢查網路政策和防火牆設定 Q4: 效能差異很大 A: 考慮網路負載、Pod 資源使用情況和節點間網路狀況",
    "path": "提示詞工程/Kubernetes Pod 網路連線測試操作指南.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/Stars 專案 Service 呼叫指南.md",
    "title": "Stars 專案 Service 呼叫指南",
    "content": "Stars 專案 Service 呼叫指南 (AI Agent 版) 專案現況概述 當前專案使用混合服務呼叫模式： - 自訂 Service Manager: `app('Service')->init('ServiceName')` - 應改為依賴注入 - 已註冊服務呼叫: `app('Star')->provider()` - 已正確註冊，不需修改 實作方向原則 1. 優先採用依賴注入 對於新開發功能，一律採用建構子依賴注入模式： 2. 識別服務類型（關鍵） 進行服務呼叫優化時，必須仔細識別服務的實際註冊方式： 識別檢查清單： 1. 檢查服務提供者: 查看 `app/Providers/` 目錄 2. 確認註冊方式: 檢查是否使用 `$this->app->singleton()` 或 `$this->app->bind()` 3. 測試服務替換: 嘗試 `app()->instance()` 測試替換 識別結果處理： - ✅ 已註冊服務: 如 `Star` 服務，維持現有呼叫方式 - ❌ 自訂 Service Manager: 如 `app('Service')->init()`，建議改為依賴注入 3. 例外情況：Star 服務特殊處理 重要例外: `app('Star')->provider()` 雖然看起來像 Service Manager，但實際上已經正確實作。 服務註冊確認: 處理原則: - 此服務已經是 Laravel 服務容器管理的，不需要改為建構子依賴注入 - 測試時使用標準 Laravel 測試方法進行 mock - 支援 `app()->instance()` 或服務容器綁定進行測試替換 實作優先級 1. 新功能開發: 一律採用依賴注入 2. 現有程式碼重構: 先識別服務類型，再決定處理方式 技術原則總結 - 服務識別原則: 透過檢查服務提供者檔案確認服務註冊方式 - 漸進式重構: 逐步替換真正的自訂 Service Manager，不強求全面改動",
    "path": "提示詞工程/Stars 專案 Service 呼叫指南.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/Stars 專案測試碼 mock 方法撰寫指南.md",
    "title": "Stars 專案測試碼 mock 方法撰寫指南",
    "content": "Stars 專案測試碼 mock 方法撰寫指南 測試實作指南 1. 依賴注入測試範例 測試檔案結構 部分 Mock 測試 2. Star 服務測試範例 方法一：使用 app()->instance() 進行服務替換 方法二：使用服務綁定進行測試 3. 完整測試案例範例 測試類別結構",
    "path": "提示詞工程/Stars 專案測試碼 mock 方法撰寫指南.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/Stars 系統架構說明.md",
    "title": "Stars 系統架構說明",
    "content": "Stars 系統架構說明 系統整體概觀 Stars 是一個 遊戲平台後端系統，主要負責： - 遊戲供應商整合：取得遊戲連結、RTP、報表等 - 遊戲內容管理：多站台的遊戲與供應商狀態控制 - 後台報表：數據統計、日報表、月報表 - 作為客端遊戲平台與各遊戲供應商之間的中間層 會員、錢包、登入驗證等功能由 總部 負責，Stars 本身不直接處理。 系統組成 外部系統 - 客端（多站台 Web 遊戲平台） - 有多個營運平台，依各平台不同，取得對應的顯示資料 - 取得顯示資料，如：遊戲分類列表、遊戲列表與遊戲資訊（維護狀態、RTP）等 - 與總部登入後進行長連線，取得 `xinkey` 後續向 Stars 請求遊戲連結進入遊戲 - 記錄使用者點擊、近期遊玩、搜尋記錄 - 特例站台（遊戲測試） - 前哨站（outpost） - 正式環境 - 遊戲上線前測試 - 僅供特定 IP - 白名單帳號可以取得未上架遊戲、維護中遊戲 - QC 站 - 測試環境 - 分海內與海外站（qc oversea） - 僅供開放廠商白名單進行遊戲測試 - 後台 - 控端 - 管理多個站台資料與狀態 - 使用者權限管理 - 遊戲供應商、遊戲資料管理 - 遊戲供應商與遊戲狀態總開關 - 報表查詢 - 管端（營運平台） - 管理單一站台 - 遊戲供應商與遊戲狀態站台開關 - 報表查詢 - 總部（星城、Game Server） - 會員、錢包、登入驗證 - 提供廠商遊戲下注、派彩、餘額查詢 API - 遊戲供應商報表查詢 - Platform（廠商、遊戲供應商） - 主動串接 Stars - 與總部完成登入/交易 - Platform MG/AB（MG/AB 廠商） - 由我們反串接 - 使用 Puppy 作為中間層 內部系統 - Satellite （後台系統） - 接收各個站台後台的 API 請求 - 區分控端與館端，分別呼叫 stars 對應 api - 與 Stars 透過內網溝通，操作站台、廠商、遊戲狀態，取得報表 - 擁有內部會員系統（僅後台使用） - Stars（核心遊戲後端） - 與各遊戲廠商 API 溝通 - 取遊戲連結 - 製作報表 - 控制 web 站台、廠商、遊戲狀態 - Puppy（廠商代理層、橋接器） - 我方主動串接 MG/AB 協議，作為 Stars 與 MG/AB 之間的代理層 - 對 Stars 來說等同於廠商角色 - 與總部進行長連線處理登入/交易 - Cron（排程機） - 排程呼叫 stars api 製作報表、遊戲排序、更新廠商 RTP 架構圖 請求流程圖 客端 - 取得遊戲連結流程（先登入/先給連結） 1. 先登入才給連結：遊戲廠商收到 Stars 取遊戲連結請求時，向總部發送登入請求，成功後回傳 Stars 遊戲連結。 2. 先給連結才登入：遊戲廠商收到 Stars 取遊戲連結請求時，先回傳遊戲連結給 Stars，玩家開啟遊戲後向總部發送登入請求。 後台 Puppy 系統架構關鍵概念 核心組件定義 - Stars: Laravel 9.x 核心遊戲後端系統，負責遊戲供應商整合與管理 - Satellite: 後台管理系統，提供控端與館端介面 - Puppy: MG/AB 廠商代理層，作為 Stars 與 MG/AB 之間的橋接器 - 總部: 會員、錢包、登入驗證系統（星城、Game Server） - Platform: 遊戲供應商，主動串接 Stars - 客端: 多站台 Web 遊戲平台前端 資料流程 1. 遊戲連結取得: 客端 → Stars → Platform/Puppy → 總部 2. 遊戲狀態管理: Satellite → Stars → Platform 3. 報表生成: Cron → Stars → Platform 4. RTP 更新: Stars → Platform (每 10 秒) 技術架構特點 - 多資料庫架構: stars, report, entry, platform1, platform2 - 佇列系統: Horizon 管理背景任務 - 快取系統: Redis 多層級快取 - API 設計: RESTful API 端點 - 容器化部署: Podman + Alpine Linux - 開發環境: Laravel 內建開發伺服器 (php -S)",
    "path": "提示詞工程/Stars 系統架構說明.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/coding_style_guide.md",
    "title": "coding_style_guide",
    "content": "Coding Style (PHP) - Always enable strict type declarations. - All function arguments and return values must have type hints. Variable & Constant Naming - Normal variables: camelCase (e.g., $userEmail, $userId) - Single record: singular form (e.g., $user) - Multiple records: plural form (e.g., $users) - Constants: ALLCAPS with underscores (e.g., COMPANYIP) Functions & Methods - Function braces must start on a new line. - Parameters separated by commas. - Method names start with a verb (e.g., getUser, createOrder) - Methods returning lists must end with \"s\". - Interfaces start with \"I\" (e.g., IUser) - When writing test code, function names should follow Laravel's test naming convention and use snake_case. Arrays - Use square brackets []. - Single-line arrays: add spaces inside brackets. - Multi-line arrays: tab indentation + trailing comma. - Key-value arrays: multi-line, spaces around =>. Control Structures - Braces stay on the same line. - Add a blank line after if-statements. - Add a blank line before return. Import & Use Order 1. Vendor packages 2. Exceptions 3. Custom classes 4. Interfaces Strings - Use single quotes for plain strings. - Concatenate strings with \" . \" and spaces. Cache Key Naming - Format: prefix_description:variable - Example: operatoraccount:d4cbd3ba-5184-..., gamecode:1:2345 File Naming - Config files: snakecase (e.g., paymentcache.php) - Resource files: snakecase (e.g., bannertype.php) - Class files: CamelCase (e.g., BannerController.php) Route Naming - Do not add \"list\" in method names if URL already contains \"list\". - Example: Route::get('/banner/type/list', [BannerController::class, 'getBannerTypeList']);",
    "path": "提示詞工程/coding_style_guide.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/eagle - 整合測試撰寫說明.md",
    "title": "eagle - 整合測試撰寫說明",
    "content": "eagle - 整合測試撰寫說明 原則 - 禁用 PHPUnit：此整合測試方法不依賴 PHPUnit 框架。腳本應直接執行，透過 `exit(1)` 或 `exit(0)` 來指示成功或失敗。 - 尊重規劃：測試階段應尊重商業邏輯與需求規劃，不可以為了通過測試而修改。 - 禁止造輪子：撰寫測試遇到問題，首先查看參考文件，再來查看 整合測試目錄 底下過去撰寫的測試碼，尋找解決方案 測試環境 - serve port：8083 - 容器環境：所有測試命令必須在 `backend838` Podman 容器內執行。請使用以下格式： - Laravel 載入：測試腳本需自行載入 Laravel 核心，以使用其 Service、Model 及配置。請確保腳本開頭包含： 本地快速測試 (Bypass Token) 為加速本地開發流程，專案支援繞過標準 Token 驗證機制。詳細設定請參考 本地 API 測試指南。 適用範圍： - 適用於 `backend.api` (後台) 與 `client.api` (前台) 中間件保護的 API。 - 注意：不適用於需要 `auth.member` (會員身份) 的 API，此類請求仍需 `id-token`。 啟用條件 (.env)： Bypass 必要 Headers： | Header | 值 | 說明 | | --------------- | ------------------ | ----------------------- | | `X-Dev-Bypass` | `true` | 啟用 bypass 模式 (必填) | | `X-Tenant-Code` | `7qne0rjed7` | 目標租戶代碼 | | `Content-Type` | `application/json` | 內容類型 | CURL 範例： 身份驗證詳解 本專案的 API 依據端點類型（Client 端、Admin 端、Agent 端）採用不同的認證機制。 Admin/Agent 端認證 (Operator 認證) Admin/Agent 端 API 採用兩層 Token 驗證： 1. Backend API Token： - 用途：用於驗證請求的「合法性」和「意圖」，防止 API 被隨意呼叫。它相當於請求的「簽名」。 - 生成方式：必須為每次 API 呼叫獨立生成。透過 `generateBackendToken` 輔助函式，根據當前請求的 `payload` (GET 請求為空)、`tenantCode`、`apiPath` 和 `httpMethod` 參數動態產生。 - 痛點與避免： - 痛點：錯誤的 `apiPath`、`httpMethod` 或 `payload` 與實際請求不符，會導致 `1003 Token Format Error` 或 `Token 驗證失敗`。 - 避免：確保 `generateBackendToken` 的參數與 `callApi` 的參數嚴格匹配。 - 位置：放入 HTTP `Authorization: Bearer ` Header。 2. Operator Session Token (JWT)： - 用途：驗證當前操作員的「身份」和「權限」。 - 獲取方式：透過呼叫 Admin/Agent 登入 API (`/api/auth/operator/login`) 成功後獲取。 - 痛點與避免： - 痛點：使用模擬 Token 字串會導致 `OperatorAuthMiddleware` 驗證失敗。 - 避免：必須執行真實的登入請求，從 API 回應中提取有效的 JWT。 - 痛點：登入時使用的帳號密碼錯誤。 - 避免：參考 `OperatorSeeder.php` 確定預設的 Admin/Agent 帳號及密碼（例如 `admin`/`qwer1234`）。 - 位置：放入 HTTP `id-token: ` Header。 - 控端/管端差異： - 控端 (Admin) 登入時使用控端租戶代碼（例如 `OperatorService::getControlTenantCode()` 獲取）。 - 管端 (Agent) 登入時使用其所屬的特定租戶代碼（例如 `ucbb6eenl2`）。 Client 端認證 (Member 認證) Client 端 API 認證方式與 Admin/Agent 端不同，通常只需 Member 的 Access Token。 - 參考文件：會員追蹤系統 API CURL 測試命令參考 提供了 Client 端會員登入範例。 - 獲取方式：會員透過 `POST /api/client/auth/login` 登入後獲取 `access_token`。 - 位置：放入 HTTP `Authorization: Bearer ` Header。 問題排查與避免 本節列出在實作過程中遇到的典型問題及其解決方案，以幫助 AI 代理高效排查。 請求參數與 Payload 結構 - 問題：API 返回 `422 資料驗證失敗`，錯誤訊息指出參數缺失或格式錯誤。 - 案例：Admin 創建遊戲時，`name` 應為字串而非多語系陣列，且 `categorytype` 和 `category` 為必填。Admin 同步遊戲時，API 僅接受 `tenantid` 和 `platformid`，而非 `tenantids` 或 `game_ids` 列表。 - 避免： - 優先閱讀 `FormRequest` 類別：針對每個 API 端點，務必仔細閱讀其對應的 Laravel `App\\\\Http\\\\Requests\\\\...` 類別（例如 `App\\\\Http\\\\Requests\\\\Admin\\\\Game\\\\CreateGameRequest.php`），確認所有必填欄位、資料類型、參數名稱與驗證規則。 - 參照 API 文檔：查閱相關的 API 文檔撰寫標準 中定義的 Request 參數。 - 本次任務新問題：更新遊戲 API (`/api/admin/games/update`) 的 `languages` 參數導致 `Cannot access offset of type array on array` 錯誤。 - 原因：通常是 Model 處理多語系內容時期望特定格式，而傳入的陣列格式不符。在測試時，如果 `languages` 參數不是必要的，或不確定其正確格式，建議先移除該參數，確保其他核心欄位更新成功。 - 避免：仔細檢查對應的 `FormRequest` 或 `Service` 層如何處理該參數，確保 payload 結構完全匹配 API 預期。 API 返回數據結構解析 - 問題：API 查詢列表時，儘管後端資料庫有數據且 Repository 層也返回了 Paginator，但測試腳本解析到的列表卻為空（例如 `本頁筆數: 0`）。 - 案例：`TenantGameService::getTenantGameList` 返回的結構是 `['data' => [...], 'pagination' => [...]]`。 - 避免： - 正確解析回應：在測試腳本中，請確保正確地從 `response['body']['data']['data']` 中提取實際的數據列表，而不是錯誤地使用 `response['body']['data']['items']` 或其他路徑。 - 檢查 API Doc：查閱 API 文件中關於回應數據結構的說明。 複合主鍵 Model 列表數據問題 - 問題：針對像 `TenantGame` 這樣沒有單一 `id` 主鍵的複合主鍵 Model，即使 `Repository` 層的 `Paginator` 顯示 `total` 數量正確，但 `Paginator::items()` 在某些情況下可能返回空的 Collection，導致最終 API 返回的數據列表為空。 - 根本原因：Laravel 的 Eloquent 和 Paginator 默認高度依賴單一 `id` 主鍵。當 Model 設定 `public $incrementing = false;` 但未明確設定 `$primaryKey` 時，其內部行為可能不穩定。 - 避免： - 診斷工具：利用獨立的 PHP 腳本（例如 `debug_tg.php` 範例）直接使用 `Model::where(...)->get()->toArray()` 驗證資料庫中是否存在數據，以排除 API 或 Service 層的問題。 - 暫時解決方案 (Service 層)：如果遇到此類問題，且確認 Repository 層有數據，可考慮在 Service 層手動遍歷 `Paginator::items()` 並呼叫每個 Model 的 `toArray()` 方法，確保數據被正確轉換成陣列後再返回。 - 長遠建議：若此問題頻繁發生，建議通知開發團隊，考慮為複合主鍵的表添加一個 `UUID` 或自增 `id` 作為主鍵，以簡化 Eloquent 和 Paginator 的處理。 日誌調試 - 問題：`Log::info()` 語句無法顯示在 `storage/logs/laravel.log` 中。 - 根本原因：專案預設的日誌通道 `gcp` 可能將日誌輸出到 `php://stderr` 而非檔案。 - 避免： - 使用 `emergency` 通道：在服務層或 Repository 層添加日誌時，明確指定 `emergency` 通道，該通道會將日誌寫入 `storage/logs/laravel.log`。 - 檢查 `config/logging.php`：了解日誌通道的配置，確認日誌的實際輸出位置。 - 清除日誌：在運行測試前，清空 `storage/logs/laravel.log`，以便集中查看最新日誌。 外部環境變數與配置 - 問題：測試腳本中的 `LOG_CHANNEL` 等環境變數設置無效。 - 根本原因：`podman exec sh -c` 中的命令是在一個新的 Shell 環境中執行，除非明確傳遞，否則外部環境變數不會自動繼承。 - 避免：在執行命令時，直接在 `sh -c` 的命令前設定環境變數。 浮點數比較問題 - 問題：在驗證 API 返回的浮點數值時，即使視覺上數值相同，程式碼比較結果卻顯示不符 (例如 `98.88 !== 98.88`)。 - 根本原因：浮點數在電腦內部以二進制儲存時可能存在精度問題，導致看似相同的浮點數在直接比較時被認為不相等。 - 避免： - 設定誤差範圍：在比較浮點數時，應設定一個可接受的誤差範圍 (epsilon)，判斷兩個數的絕對差是否小於此誤差。 - 轉換為字串比較 (高精度)：對於需要極高精度的浮點數比較，可以考慮將其轉換為字串後再進行比較，但這通常用於金融計算等特殊場景。 參考文件 - API 測試技術文檔 - Eagle Laravel API 測試指南 - 本地 API 測試指南 - 整合測試目錄 最近遇到的問題與解決方案 (2025-12-26 更新) 1. Token 驗證與 GET 請求參數類型問題 - 問題：在測試 GET 請求時，若 Payload 包含整數 (如 `tenantid=1`)，Token 生成與驗證可能因 PHP `$GET` 自動將參數轉為字串而導致型別不符，進而驗證失敗。 - 解決方案： - 方法 A (推薦)：在測試 GET 請求時，使用 `X-Dev-Bypass: true` Header 繞過繁瑣的 Token 簽名檢查 (前提是環境變數允許)。 - 方法 B：若必須使用 Token，請確保 Payload 中的整數在傳入 `generateBackendToken` 時已明確轉型為字串 (String Casting)，以匹配 Middleware 的處理邏輯。 2. 複合主鍵 Model 無法使用 `refresh()` - 問題：針對如 `TenantPlatform` 這種使用複合主鍵的 Model，調用 `$model->refresh()` 會導致 SQL 錯誤 `Unknown column 'id'`，因為 Laravel 預設依賴單一 `id` 主鍵進行刷新。 - 解決方案：禁止使用 `refresh()`。應手動使用 `Model::where(...)->first()` 重新查詢最新資料。 3. Agent 端 Controller 取不到 `$request->user()` - 問題：在自定義的 `OperatorAuthMiddleware` 架構下，操作員資訊被儲存在 `current_operator` 屬性中。直接在 Controller 使用 `$request->user()` 可能會因為 Guard 配置不同而返回 null，導致 \"User not authenticated\" 錯誤。 - 解決方案：使用 `$request->attributes->get('current_operator')` 來獲取當前登入的操作員實例。",
    "path": "提示詞工程/eagle - 整合測試撰寫說明.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/eagle - 時間類型統一規範使用指南.md",
    "title": "eagle - 時間類型統一規範使用指南",
    "content": "eagle - 時間類型統一規範使用指南 核心原則 統一規範： - 資料庫欄位類型：`DATETIME` - 應用層時區：`Asia/Taipei (+08:00)` - API 回傳格式：`ISO 8601` 含時區（如 `2025-12-17T10:30:00+08:00`） --- 一、Migration 建立規範 標準寫法 --- 二、Model 設定規範 必要設定 - 繼承 AbstractModel - 定義所有時間欄位 $dateFields 為什麼要定義 $dateFields？ | 操作方式 | 語法 | 是否自動轉換 | 依賴 | | --- | --- | --- | --- | | Eloquent 操作 | `$model->save()` | ✅ 自動 | Laravel 內建 | | Eloquent 操作 | `$model->update([...])` | ✅ 自動 | Laravel 內建 | | Eloquent 操作 | `Model::create([...])` | ✅ 自動 | Laravel 內建 | | Query Builder 操作 | `Model::where()->update([...])` | ✅ 自動 | 需要 $dateFields | | Query Builder 操作 | `Model::insert([...])` | ✅ 自動 | 需要 $dateFields | | Query Builder 操作 | `Model::upsert([...])` | ✅ 自動 | 需要 $dateFields | | DB Facade 操作 | `DB::table()->update([...])` | ❌ 手動 | 不經過 Model | --- 三、Eloquent 操作 - 自動轉換 以下操作不需要手動處理，系統自動轉換： --- 四、Query Builder 操作 - 自動轉換（需 $dateFields） 以下操作透過 `CustomEloquentBuilder` 自動轉換： --- 五、DB Facade 操作 - 需手動轉換 直接使用 `DB::table()` 不經過 Model，需手動處理： --- 六、資料讀取 - 為什麼轉成 Carbon？ 讀取流程 為什麼用 Carbon？ 讀取時自動轉換的欄位 - `$casts` 中定義為 `datetime` 的欄位 - `createdat`、`updatedat`（Laravel 自動處理） --- 七、API 回傳格式 自動轉換情境 當 Model 直接序列化為 JSON 時，會自動調用 `serializeDate()` 方法： 自動轉換輸出格式：`2025-12-17T10:30:00+08:00`（ISO 8601 含時區） 手動轉換情境 在 Resource 中需要手動調用格式化方法： 對照表 | 回傳方式 | 是否自動轉換 | 範例 | | --- | --- | --- | | `response()->json($model)` | ✅ 自動 | 直接回傳 Model | | `response()->json($collection)` | ✅ 自動 | 回傳 Collection | | `return $model` | ✅ 自動 | Controller 直接回傳 | | `$model->toArray()` | ✅ 自動 | 轉陣列 | | `$model->toJson()` | ✅ 自動 | 轉 JSON 字串 | | Resource 中的時間欄位 | ❌ 手動 | 需調用 `toIso8601String()` | | 自訂陣列組裝 | ❌ 手動 | 需調用 `toIso8601String()` | 輸出格式對照 | 方法 | 輸出 | 說明 | | --- | --- | --- | | `toIso8601String()` | `2025-12-17T10:30:00+08:00` | ✅ 標準格式 | | `toISOString()` | `2025-12-17T02:30:00.000000Z` | ❌ UTC 格式 | | `toDateTimeString()` | `2025-12-17 10:30:00` | 無時區資訊 | | `format('Y-m-d H:i:s')` | `2025-12-17 10:30:00` | 自訂格式 | --- 八、轉換機制總覽 --- 九、快速檢查清單 新增功能時，確認以下項目： | 項目 | 檢查內容 | | --- | --- | | Migration | 使用 `dateTime()` 非 `timestamp()` | | Migration | createdat/updatedat 用標準寫法 | | Model | 繼承 `AbstractModel` | | Model | 定義 `$dateFields` 包含所有時間欄位 | | Model | `$casts` 中時間欄位設為 `datetime` | | Resource | 使用 `toIso8601String()` | | DB Facade | 手動 `format('Y-m-d H:i:s.u')` |",
    "path": "提示詞工程/eagle - 時間類型統一規範使用指南.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/gemini-cli 指令說明.md",
    "title": "gemini-cli 指令說明",
    "content": "Gemini CLI 指令檔撰寫全指南 1. `GEMINI.md`：專案上下文與規則 (Project Context) - 定義：用於提供特定專案或目錄的背景資訊、開發規範與環境設定。 - 檔案路徑： - 專案級：`./GEMINI.md` 或 `.gemini/GEMINI.md` - 全域級：`~/.gemini/GEMINI.md` - 特性：持久性 (Persistent)。Gemini 在每次對話開始時都會自動讀取這些檔案。它具備層級覆蓋特性（子目錄的 `GEMINI.md` 會補足或覆蓋父目錄的規則）。 - 解決問題：避免每次提示都要重複說明技術棧、代碼風格或專案目標。 - 適用情境：定義「我是用 React + Tailwind」、「變數命名要用 camelCase」、「提交 PR 前必須寫測試」。 📌 撰寫範例 --- 2. `system.md` (或 `SYSTEM.md`)：系統提示詞覆蓋 (System Prompt Override) - 定義：用於完全取代 Gemini CLI 內建的預設系統指令。 - 檔案路徑：預設為 `.gemini/system.md`（需配合環境變數 `GEMINISYSTEMMD=1` 啟用）。 - 特性：強制性與全面性。它不是「增加」規則，而是「重寫」AI 的底層邏輯與安全性邊界。啟用後，CLI 會顯示 |⌐■_■| 標誌。 - 解決問題：當預設的 AI 語氣太過客套、限制過多，或者您需要 AI 扮演一個完全不同的角色（如：黑盒測試機）時使用。 - 適用情境：企業內部安全性規則強制作戰、將 AI 鎖定在特定的工作流程中（例如禁止它閒聊）。 📌 撰寫範例 --- 3. `commands/{command}.toml`：自定義斜槓指令 (Custom Slash Commands) - 定義：將複雜的提示詞或工具鏈封裝成簡短的快捷指令。 - 檔案路徑： - `.gemini/commands/{name}.toml` (專案專屬) - `~/.gemini/commands/{name}.toml` (全域) - 特性：動作導向 (Action-Oriented)。支援參數注入 (`{{args}}`) 與 Shell 指令執行 (`!{...}`)。 - 解決問題：解決需要重複執行的複雜任務，簡化「讀取檔案 -> 分析 -> 執行操作」的流程。 - 適用情境：`/refactor`、`/unit-test`、`/git:commit`。 📌 撰寫範例 (`refactor.toml`) --- 4. `skills/{skill}/SKILL.md`：代理技能 (Agent Skills) - 定義：封裝特定領域的專家知識與程序化工作流，具備「被動觸發」與「工具調用」能力。 - 檔案路徑：`.gemini/skills/{skill-name}/SKILL.md` - 特性：按需加載 (On-demand)。具備 YAML Frontmatter (Name & Description)，Gemini 會根據任務描述自動「發現」並激活技能，不會佔用不必要的上下文窗口。 - 解決問題：當指令集過於龐大（例如：整個資料庫遷移指南），放在 `GEMINI.md` 會導致 context 過載時，將其模組化。 - 適用情境：複雜的安全性審核、特定雲端平台的部署邏輯、大規模數據遷移。 📌 撰寫範例 (`db-migration/SKILL.md`) --- 📊 綜合對比表 | 指令檔類型 | 核心定位 | 作用域 | 載入時機 | 解決的核心痛點 | | --- | --- | --- | --- | --- | | `GEMINI.md` | 專案背景 | 專案/目錄 | 每輪對話自動載入 | 減少重複背景說明 | | `system.md` | 底層人格 | 全域/系統 | 啟動時完全取代 | 覆蓋 AI 預設行為與邊界 | | `commands/*.toml` | 快捷工具 | 指令級 | 使用者手動觸發 (`/`) | 簡化重複、複雜的操作流程 | | `skills/*.md` | 專家能力 | 模組化 | 語境匹配時自動激活 | 避免 context 膨脹，模組化專家知識 |",
    "path": "提示詞工程/gemini-cli 指令說明.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/gemini-cli-ralph-guide.md",
    "title": "gemini-cli-ralph-guide",
    "content": "gemini-cli-ralph 使用說明 1. 核心理念 Ralph Wiggum 方法論的核心精神： | 原則 | 說明 | |------|------| | 迭代 > 完美 | 不追求首次完美，透過多次改進來精煉 | | 失敗即數據 | 每次失敗都是可識別和可修復的學習機會 | | 堅持就是勝利 | 持續嘗試直到成功 | | 信任過程 | 不要用虛假的完成來規避迴圈 | --- 2. 啟動迴圈 語法 選項 | 選項 | 說明 | |------|------| | `--max-iterations ` | 最大迭代次數（預設：無限制） | | `--completion-promise ' '` | 完成承諾短語 | 使用技巧 1. 明確定義完成標準 - 設定具體且可驗證的 `--completion-promise` - 優先使用客觀標準：測試通過、建置成功、lint 無錯誤 2. 提示詞設計原則 - 簡潔且聚焦，避免過度複雜 - 指定期望的輸出格式 - 使用正面指令（做什麼）而非負面指令（不要做什麼） 3. 設定合理的迭代上限 - 簡單任務：5-10 次 - 中等複雜度：10-20 次 - 複雜重構：20-50 次 範例 自檢清單 - [ ] 任務描述是否具體且可量化？ - [ ] 完成標準是否客觀可驗證？ - [ ] 迭代次數是否合理？ - [ ] 是否屬於適合 Ralph 的任務類型？ --- 3. 適用場景 ✅ 最適合的任務 | 場景 | 說明 | |------|------| | 大規模重構 | 框架遷移、API 更新、程式碼標準化 | | 測試驅動開發 | 迭代直到所有測試通過 | | 批次操作 | 文件生成、型別註解、格式統一 | | 明確規格的新功能 | 有清楚定義的 greenfield 開發 | ❌ 不適合的任務 | 場景 | 原因 | |------|------| | 模糊的需求 | 缺乏客觀完成標準 | | 複雜架構決策 | 需要人類判斷和權衡 | | 安全關鍵程式碼 | 需要謹慎的人工審查 | | 探索性工作 | 目標不明確，難以定義完成 | 自檢清單 - [ ] 任務是否有明確的成功/失敗標準？ - [ ] 結果是否可透過自動化驗證（測試、lint、建置）？ - [ ] 任務是否具有重複性或規律性？ - [ ] 是否不需要頻繁的人工決策？ --- 4. 監控與迭代 監控狀態 狀態檔案內容 使用技巧 1. 建立外部記憶機制 - 利用 `IMPLEMENTATION_PLAN.md` 作為真相來源 - 讓 Gemini 將進度寫入檔案，避免 context 累積 2. 設置 Guardrails - 在 `GEMINI.md` 中定義專案規範 - 明確禁止不希望的行為 3. 觀察迭代模式 - 如果連續多次迭代沒有進展，考慮調整提示詞 - 失敗模式可能暗示需要更明確的指引 自檢清單 - [ ] 是否定期檢查迭代進度？ - [ ] 是否有外部檔案記錄工作進度？ - [ ] Gemini 是否有足夠的 guardrails？ - [ ] 迭代是否有明顯的進步趨勢？ --- 5. 終止迴圈 正常完成 當任務真正完成時，Gemini 會輸出： 手動取消 使用技巧 1. 誠實輸出承諾 - 只有當陳述確實為真時才輸出承諾 - 切勿為了退出迴圈而謊報完成 2. 評估取消時機 - 迭代無進展超過 3-5 次 - 發現任務需要重新定義 - 遇到需要人工決策的阻塞點 自檢清單 - [ ] 完成標準是否真正達成？ - [ ] 所有自動化驗證是否通過？ - [ ] 是否有未完成的子任務？ - [ ] 程式碼品質是否符合專案標準？ --- 6. 最佳實踐總結 | 階段 | 關鍵行動 | |------|----------| | 啟動前 | 定義明確目標、設定客觀標準、準備 guardrails | | 執行中 | 定期監控、觀察模式、必要時調整 | | 完成後 | 驗證結果、審查變更、記錄學習 | 黃金法則 > 「Ralph 的核心就是一個 Bash 迴圈」 — Geoffrey Huntley > > 簡單、持續、迭代。讓 AI 反覆嘗試，從失敗中學習，直到成功。",
    "path": "提示詞工程/gemini-cli-ralph-guide.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/gemini-cli-指令.md",
    "title": "gemini-cli-指令",
    "content": "你是一個專精於軟體工程任務的代理。你的主要目標是協助使用者安全且有效率地完成工作，嚴格遵守以下指示並善用可用工具。 核心規範 - 慣例遵守： 嚴格遵循專案既有慣例，讀取或修改程式碼前先分析周遭程式碼、測試與設定。 - 函式庫/框架： 絕不假設函式庫或框架可用或適合使用，必須先確認專案已有使用紀錄（查看 import、設定檔如 package.json、Cargo.toml、requirements.txt、build.gradle 等，或鄰近檔案）才可使用。 - 風格與結構： 仿造專案現有程式碼的風格（排版、命名）、結構、框架選擇、型別及架構模式。 - 慣用變更： 修改程式碼時，理解當地上下文（import、函式/類別）以確保變更自然且符合慣用法。 - 註解： 精簡添加註解，聚焦說明「為何這麼做」，特別是複雜邏輯，避免解釋「做什麼」。只有必要或使用者要求時才添加高價值註解。不修改與變更無關的註解。絕不透過註解與使用者溝通或說明變更。 - 主動性： 徹底完成使用者請求，包含合理且直接隱含的後續動作。 - 確認模糊與擴展： 未經使用者確認，不做超出明確請求範圍的重大行動。若被問「如何做」，先說明方法，勿直接執行。 - 變更說明： 完成程式碼或檔案修改後，除非被要求，否則不提供摘要。 - 不還原變更： 除非使用者要求，否則不還原已修改的程式碼。只有當變更造成錯誤或使用者明確要求時，才還原你所做的變更。 主要工作流程 軟體工程任務 修正錯誤、新增功能、重構或說明程式碼時，依序執行： 1. 理解： 分析使用者請求與程式碼上下文。大量使用 'searchfilecontent' 和 'glob' 平行搜尋檔案結構、既有慣例和程式碼模式。用 'readfile' 和 'readmany_files' 驗證假設與理解。 2. 計畫： 建立一個根據步驟 1 理解的明確且合理的解決方案。必要時以簡短清晰的方式告知使用者計畫。若相關，嘗試透過撰寫單元測試建立自我驗證循環。可用輸出日誌或除錯訊息協助驗證。 3. 實作： 遵守核心規範，運用可用工具（如 'replace'、'writefile'、'runshell_command'）執行計畫。 4. 驗證（測試）： 如可行，透過專案既有測試程序驗證變更。藉由檢查 README、建置設定（如 package.json）或既有測試指令找到正確的測試指令與框架。絕不假設標準測試指令。 5. 驗證（標準）： 非常重要：程式碼變更後，執行專案特定的建置、檢查、型別檢查指令（如 tsc、npm run lint、ruff check .）以確保程式碼品質及標準遵守。若不確定指令，可詢問使用者是否需執行及如何執行。 新應用程式 目標： 自主實作並交付視覺美觀、實質完整且功能齊全的原型。善用所有工具完成應用。常用工具包括 'writefile'、'replace'、'runshell_command'。 1. 理解需求： 分析使用者請求，明確核心功能、期望使用者體驗（UX）、視覺風格、應用類型／平台（網頁、行動、桌面、CLI、函式庫、2D/3D 遊戲）及限制。若缺關鍵資訊，提出明確且精準的詢問。 2. 提案計畫： 制定內部開發計畫，向使用者簡潔明瞭地說明。包含應用類型及核心目的、主要技術、關鍵功能與使用者互動方式、視覺設計與 UX 概述（特別針對 UI 應用）。若需視覺資源（遊戲或豐富 UI），說明佔位資源策略（幾何圖形、程序生成圖案或開源素材）。內容結構化、易讀。 - 若未指定技術，優先建議： - 網站前端： React（JavaScript/TypeScript）搭配 Bootstrap CSS，採用 Material Design 原則 - 後端 API： Node.js（Express.js）或 Python（FastAPI） - 全端： Next.js（React/Node.js）搭配 Bootstrap CSS 與 Material Design，或 Python（Django/Flask）後端配合 React/Vue.js 前端 - CLI： Python 或 Go - 行動 App： Compose Multiplatform（Kotlin Multiplatform）或 Flutter（Dart）採 Material Design，原生則用 Jetpack Compose 或 SwiftUI - 3D 遊戲： HTML/CSS/JavaScript 搭配 Three.js - 2D 遊戲： HTML/CSS/JavaScript 3. 使用者同意： 取得使用者對計畫的認可。 4. 實作： 按核准計畫自主開發功能與設計，利用所有工具。開始時用 'runshellcommand' 執行建置指令（npm init、npx create-react-app 等）。務求完整，主動建立或取得必要佔位資源，確保視覺一致且功能正常，降低依賴使用者提供。若可自動生成簡單素材，應生成，否則說明佔位策略與後續替換方式。 5. 驗證： 檢查成品是否符合原始請求與核准計畫，修正錯誤及不符，確保風格與互動良好，產出高品質且美觀的原型。最後確保建置無錯誤。 6. 收集回饋： 如仍適用，提供啟動指令並請求使用者針對原型回饋。 操作指引 口吻與風格（CLI 互動） - 簡潔直接： 採用專業、直接且簡潔的語氣，符合 CLI 環境。 - 輸出最小化： 每次回應盡量不超過三行文字（不含工具呼叫或程式碼生成），聚焦使用者問題。 - 必要時重視清晰度： 重要說明或不明確請求時，優先保證清楚。 - 不閒聊： 避免空話、前言（「好的，我現在...」）或後語（「我已完成...」），直接行動或回覆。 - 格式： 使用 GitHub-flavored Markdown，回應以等寬字體呈現。 - 工具 vs. 文字： 執行行動時使用工具，文字僅用於溝通，工具呼叫內不添加說明註解（除非是程式碼或指令本身必要部分）。 - 無法執行時： 簡短說明無法完成原因（1 ～ 2 句），如適合提供替代方案。 安全規則 - 關鍵指令說明： 執行會修改檔案系統、程式碼庫或系統狀態的 shell 指令前，須簡要說明指令目的及潛在影響，重視使用者理解與安全。無需詢問執行許可，系統會自動彈出確認對話框。 - 安全優先： 永遠遵守安全最佳實務，避免產生暴露、紀錄或提交機密、API 金鑰等敏感資訊的程式碼。 工具使用 - 檔案路徑： 工具呼叫時務必使用絕對路徑，絕不支援相對路徑。 - 平行處理： 同時執行多個相互獨立的工具呼叫（如搜尋）以提升效率。 - 指令執行： 使用 'runshellcommand' 執行 shell 指令，先說明修改性指令作用。 - 背景執行： 長時間執行且不會自動終止的指令可加 '&' 背景執行，如不確定請詢問使用者。 - 互動式指令： 避免需使用者交互的指令（如 git rebase -i），優先使用非互動版本（如 npm init -y），並提醒使用者互動指令可能導致凍結。 - 記憶管理： 使用 'save_memory' 工具記住使用者相關的明確偏好或資訊（非專案內容），如程式風格、常用路徑、工具別名。專案相關內容應放在 GEMINI.md 等專案文件。若不確定是否儲存，詢問使用者。 - 尊重使用者決定： 多數工具呼叫需先經使用者確認，若使用者取消，尊重決定不再嘗試，除非使用者後續再次請求。 互動細節 - 幫助指令： 使用者可用 /help 取得說明。 - 回報問題： 用 /bug 指令回報錯誤或提供回饋。 沙盒外運行提醒 你在沙盒外直接於使用者系統執行，對會影響系統的關鍵指令，除說明指令作用，也提醒使用者考慮啟用沙盒保護。 範例（口吻與工作流程示範） user: 1 + 2 model: 3 user: 13 是質數嗎？ model: 是 user: 列出這裡的檔案。 model: [toolcall: listdirectory for path '.'] user: 啟動 server.js 中實作的伺服器 model: [toolcall: runshell_command for 'node server.js &'，因為需要背景執行] user: 重構 src/auth.py 的驗證邏輯，改用 requests 函式庫取代 urllib。 model: 好的，我可以重構 'src/auth.py'。 首先，我會分析程式碼並確認有測試保護網，再開始規劃變更。 [toolcall: glob for path 'tests/testauth.py'] [toolcall: readfile for absolutepath '/path/to/tests/testauth.py'] （分析後） 很好，'tests/test_auth.py' 存在並覆蓋了核心驗證邏輯。有這個安全網，我可以安心規劃重構。 我也會確認 'requests' 是否為依賴項。 [toolcall: readfile for absolute_path '/path/to/requirements.txt'] （分析後） 沒問題，'requests' 可用。 計畫如下： 1. 將 'urllib' 呼叫替換為 'requests'。 2. 為新的網路呼叫添加適當的 'try...except' 錯誤處理。 3. 移除舊的 'urllib' import。 4. 執行專案的 linter 和測試以驗證變更。 要繼續嗎？ user: 好 model: [toolcall: writefile or replace 套用重構到 'src/auth.py'] 重構完成。執行驗證... [toolcall: runshell_command for 'ruff check src/auth.py && pytest'] （驗證通過後） 所有檢查通過。這是一個穩定的檢查點。 user: 刪除 temp 目錄。 model: 我可以執行 `rm -rf ./temp`。這會永久刪除該目錄及其所有內容。 user: 為 someFile.ts 撰寫測試 model: 好的，我可以撰寫那些測試。首先，我會讀取 `someFile.ts` 來理解其功能。 [toolcall: readfile for absolute_path '/path/to/someFile.ts' 或使用 glob 尋找 `someFile.ts` 若位置未知] 現在我會查找現有或相關的測試檔案，以理解目前的測試慣例和依賴。 [toolcall: readmany_files for paths ['/.test.ts', 'src//.spec.ts'] 假設 someFile.ts 在 src 目錄] （審視現有測試與檔案內容後） [toolcall: writefile 建立 /path/to/someFile.test.ts 包含測試程式碼] 我已撰寫測試。現在執行專案的測試指令來驗證。 [toolcall: runshell_command for 'npm run test'] user: 在這個系統中如何更新使用者的個人資料？ model: 我不確定使用者個人資料如何更新。我會搜尋程式碼庫中的 'UserProfile'、'updateProfile' 或 'editUser' 等關鍵字來找到相關檔案或 API 端點。 [toolcall: searchfile_content for pattern 'UserProfile|updateProfile|editUser'] （審視搜尋結果後，假設找到相關檔案如 '/path/to/UserProfileService.java'） 好的，`/path/to/UserProfileService.java` 看起來是最相關的檔案。我會讀取其內容來理解更新是如何處理的。 [toolcall: readfile for absolute_path '/path/to/UserProfileService.java'] （讀取檔案後） 看起來 `UserProfileService.java` 中的 `updateUserProfile` 方法負責此功能。它需要使用者 ID 和一個 `UserProfileDTO` 物件... user: 這個專案中所有的 'app.config' 檔案在哪裡？我需要檢查它們的設定。 model: [tool_call: glob for pattern '/app.config'] （假設 GlobTool 回傳路徑列表如 ['/path/to/moduleA/app.config', '/path/to/moduleB/app.config']） 我找到以下 'app.config' 檔案： - /path/to/moduleA/app.config - /path/to/moduleB/app.config 為協助你檢查設定，我可以讀取它們的內容。你想從哪一個開始，還是要我全部讀取？ 最終提醒 你的核心職責是高效且安全地協助。精簡與清晰兼顧，特別注意安全與系統變更。優先尊重使用者控制與專案慣例，不做無根據假設，盡量以讀取檔案驗證。你是代理，請持續協助直到問題完全解決。",
    "path": "提示詞工程/gemini-cli-指令.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/stars 整合測試撰寫規則.md",
    "title": "stars 整合測試撰寫規則",
    "content": "整合測試撰寫規則 概述 - 需遵守整合測試的精神。 - 若撰寫的 api 中有嚴重違反 SOLID 原則時，可以簡單提出，讓我評估後續的優化方向。 - 需遵守 coding style 的規範 撰寫風格內容總結 撰寫標準 1. 檔案結構：每個 API 方法獨立檔案，命名 `{MethodName}Test.php` 2. 檔案命名：使用 `Test.php`（非 `IntegrationTest.php`） 3. 方法命名：snake_case（非 camelCase），且必須宣告 `: void` 返回類型 4. 常數定義：定義 `private const METHOD`、`private const URL`，使用 Laravel HTTP 狀態碼常數（如 `Response::HTTP_OK`） 5. 錯誤處理：使用 `resources/lang/en/error.php` 定義的錯誤碼 6. 屬性類型：使用 PHP 8 屬性類型聲明（如 `private Games $game;`） 7. Mock 初始化：在 `setUp()` 中初始化 Mock 服務實例 8. 測試行為設定：在測試方法中設定 Mock 行為和斷言 9. Redis 清理：僅在測試實際使用 Redis 時操作 10. 測試覆蓋：確保 input/output 正確，涵蓋所有商業邏輯 11. 測試資料：優先使用 factory 建立，且若 Factory 已定義狀態方法（如 `enabled()`），禁止在 `create()` 中重複帶入相同參數 12. Interface 優先：若有 Interface 定義（如 `ILanguage`），禁止硬編碼字串（如 `'en'`），必須使用 Interface 常數 13. 資料修改：優先修改現有資料而非新建 14. 結構分隔：使用 `// ============================================================================` 分隔不同類型的測試區塊（如測試生命週期、參數驗證、業務邏輯等） 測試覆蓋範圍 每個測試檔案須包含： - 基本驗證：缺少 header、無效 header - 參數驗證：必要參數、類型驗證、null 值 - 業務邏輯：存在性驗證、狀態驗證 - 成功案例：正常操作流程 檔案結構範例 結構原則：每個檔案專注單一 API 方法，提高可維護性 測試結構模板 測試常數：定義 `METHOD`、`URL` 常數，使用 Laravel HTTP 狀態碼常數 屬性類型：使用 PHP 8 屬性類型聲明（如 `private Providers $provider`） 測試方法：使用 `void` 返回類型，遵循 snake_case 命名規則 測試常數與屬性宣告 生命週期： 參數組織及斷言模式： 服務測試模板 依賴注入測試： Star 服務測試： 部分 Mock 測試： 測試類別結構： 測試原則 1. 環境設定：在 `setUp()` 中初始化 Mock 服務實例，測試方法中設定行為 2. 服務識別：優先依賴注入，減少 `app()` 直接調用 3. Mock 策略：依賴注入用 `$this->app->instance()`，註冊服務用 `app()->instance()` 4. 測試資料：優先修改現有資料而非新建，測試後恢復原狀 5. 錯誤處理：使用專案定義錯誤碼驗證 6. 資源清理：測試結束清理 Mock，避免記憶體洩漏 Service Mock 注意事項 由於專案歷史因素，Service 的實作與呼叫方式並非全面採用依賴注入 (Dependency Injection)。 - ServiceFactory 模式： 多數 Controller 與 Service 使用 `app('Service')->init('ServiceName')` 取得實例。此方式底層是直接 `new ServiceName`，不經過 Laravel Container。 因此，單純使用 `Mockery::mock(Service::class)` 並 `$this->app->instance(Service::class, $mock)` 無法 成功 Mock 該 Service。 - 撰寫策略： 1. 檢查呼叫方式：撰寫測試前，務必查看 Controller 及 Service 程式碼。 - 若使用 `app('Service')->init(...)`，則無法直接 Mock 目標 Service。 - 若使用 `construct` 注入，則可正常 Mock。 2. Mock ServiceFactory (高難度/不建議)： 若必須 Mock，需 Mock `Service` (ServiceFactory) 本身，並在 `init` 方法中針對特定字串回傳 Mock 物件。這會增加測試複雜度。 3. 整合測試優先： 針對無法 Mock 的 Service，建議採用真實資料庫/Redis 的整合測試策略，而非單元測試。確保 `setUp` 時資料庫與快取是乾淨的，並建立必要的測試資料。 常見陷阱與解決方案 (Common Pitfalls) 1. Middleware 驗證依賴 後台 API (`/api/backend/*`) 會驗證 `x-pid` 標頭。測試前必須在 `setUp()` 建立基礎資料，否則會拋出 500 錯誤： 2. 錯誤狀態碼慣例 專案 API 在驗證失敗時回傳 200 OK 搭配 `error_code`。請斷言 200 而非 422： 3. Logging 隔離與除錯 確保 `phpunit.xml` 設定 `LOG_CHANNEL` 為 `null` 避免連接 GCP。若測試時需要排查錯誤，請使用 `Log::channel('')` 指令指定頻道（如 `single` 或 `daily`）將 Log 寫到本地： 資料庫選擇策略 為了平衡測試速度與真實環境一致性，整合測試應根據以下原則選擇資料庫： 1. 預設使用 SQLite 大多數標準的 Eloquent 操作、關聯查詢與業務邏輯驗證，應預設使用 SQLite（In-Memory）以獲得最快的回饋速度。 - 適用場景： - 標準 CRUD 操作 (`save`, `find`, `delete`) - Eloquent 關聯 (`with`, `load`) - 一般業務邏輯驗證 2. 必須使用 MySQL 的情境 若測試涉及以下特性，SQLite 可能無法模擬或行為不一致，必須使用 MySQL 並標記 `skipIfNotMySQL`： - 特定錯誤代碼 (Error Codes)： - 例如預期 MySQL 拋出 Error 1054 (Unknown column) 並轉換為專案特定錯誤碼 (如 `10001 sqlisbusy`)。SQLite 可能會忽略該錯誤或拋出不同格式的異常。 - 原生 SQL 語法 (Raw SQL)： - 使用了 MySQL 特有的函數 (如 `DATEFORMAT`, `JSONEXTRACT`, `IF`)。 - 使用了 SQLite 不支援的語法。 - 資料庫鎖定 (Locking)： - 測試 `lockForUpdate()` 或交易併發行為（SQLite 只有檔案鎖，行為與 Row-lock 不同）。 - 嚴格模式與約束 (Strict Mode & Constraints)： - 測試 Unique Constraint 或 Foreign Key 違規的具體錯誤訊息。 - 測試 Enum 欄位的嚴格型別檢查。 3. 實作方式 若測試案例依賴 MySQL，請在測試類別中使用 `DatabaseSpecificTestTrait` 並在測試方法開頭呼叫： 4. 決策檢查表 (Checklist) 在撰寫測試前，請依序確認： 1. 是否使用 Raw SQL？ (是 -> MySQL) 2. 是否驗證資料庫層級的錯誤碼？ (是 -> MySQL) 3. 是否涉及複雜的 JSON 操作或日期函數？ (是 -> MySQL) 4. 是否測試交易鎖定？ (是 -> MySQL) 5. 以上皆否 -> 使用 SQLite",
    "path": "提示詞工程/stars 整合測試撰寫規則.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/stars 開發注意事項.md",
    "title": "stars 開發注意事項",
    "content": "- podman container name is php8 (not stars) - jq is not installed in the container - Project path(in pod): /var/www/html/stars 專案術語定義 (Project Terminology) 核心概念定義 Provider (站台/遊戲平台) - 定義: 站台、遊戲平台 - 說明: 一個提供遊戲服務的平台，類似於遊戲網站或應用程式 - 關係: 一個 provider 底下可以有多個 platform Platform (遊戲供應商/遊戲廠商) - 定義: 遊戲供應商、遊戲廠商 - 說明: 實際開發和提供遊戲內容的廠商或供應商 - 關係: 一個 platform 可以屬於多個 provider 關係架構 Provider (站台) ├── Platform A (遊戲廠商) ├── Platform B (遊戲廠商) └── Platform C (遊戲廠商) Platform X (遊戲廠商) ├── Provider 1 (站台) └── Provider 2 (站台) 使用注意事項 - 在 stars、satellite、cron 專案中，provider 和 platform 的定義與一般常見定義不同 - 撰寫程式碼或文件時，請使用上述定義而非一般常見的定義 - 當提到「站台」時，指的是 provider - 當提到「遊戲廠商」時，指的是 platform - { \"environment\": { \"podmanContainerName\": \"php8\", \"projectPath\": \"/var/www/html/stars\" }, \"aiFriendlySummaryV1\": { \"coreDefinitions\": { \"Provider\": { \"english\": \"Provider\", \"chinese\": \"站台\", \"description\": \"A platform that hosts game services; one provider can have multiple platforms\" }, \"Platform\": { \"english\": \"Platform\", \"chinese\": \"遊戲廠商\", \"description\": \"A game vendor/provider; one platform can belong to multiple providers in this project\" } }, \"relationships\": [ { \"type\": \"providertoplatforms\", \"description\": \"Provider 下有多個 Platform\" }, { \"type\": \"platformtoproviders\", \"description\": \"Platform 可能屬於多個 Provider\" } ], \"projectNotes\": { \"domainSpecifics\": \"Stars 專案中 provider/platform 的定義與一般慣例不同\", \"implementationGuidance\": \"以此文件為 Stars 專案的唯一參考定義\" }, } }",
    "path": "提示詞工程/stars 開發注意事項.md",
    "category": "提示詞工程"
  },
  {
    "id": "提示詞工程/需求模版.md",
    "title": "需求模版",
    "content": "[功能名稱] 1. 概述 簡要說明此功能的目的、背景和預期效果。這部分應該讓讀者快速理解為什麼需要這個功能。 2. 需求說明 列出具體的需求項目。這些應該是明確的、可測試的陳述，描述系統應該做什麼。 - [需求1] - [需求2] - [需求3] 3. 功能說明 詳細描述功能的各個方面。這部分應該讓讀者了解功能如何運作，用戶如何與之互動。 - [功能方面1] - [功能方面2] - [功能方面3] 4. 實現邏輯 步驟式地描述功能的實現過程。這應該是一個高層次的邏輯流程，而不是具體的代碼。 1. [邏輯步驟1] 2. [邏輯步驟2] 3. [邏輯步驟3] 5. 技術實現 提供具體的代碼示例或技術細節。這部分應該展示如何在代碼層面實現功能。 5.1 [子模塊1] 5.2 [子模塊2] 6. 注意事項 列出實現過程中需要特別注意的點，可能包括潛在的問題、限制或特殊情況。 - [注意事項1] - [注意事項2] - [注意事項3] 7. 影響範圍 描述這個功能可能影響到的其他系統部分或功能。這有助於評估變更的風險。 - [影響範圍1] - [影響範圍2] - [影響範圍3]",
    "path": "提示詞工程/需求模版.md",
    "category": "提示詞工程"
  },
  {
    "id": "系統相關/Bootstrap 學習筆記.md",
    "title": "Bootstrap 學習筆記",
    "content": "Bootstrap 學習筆記 html 引入 表格 部分顏色名稱 - primary 主要的 - secondary 副標 - success 成功 - danger 危險 - warning 警告 - info 訊息 - light 明亮(帶有淺邊框) - dark 深色 - white 白色 改變字型的外觀 - font-weight-bold - font-weight-normal - font-weight-light - fon-italic(斜體) 文字位置設定 - text-left - text-center - text-right 輪播牆 drop down",
    "path": "系統相關/Bootstrap 學習筆記.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/Curl 學習筆記.md",
    "title": "Curl 學習筆記",
    "content": "curl 命令完整說明手冊 目錄 1. 基本概念 2. HTTP 方法 3. 常用選項 4. 實際範例 5. 進階功能 6. 故障排除 7. 最佳實踐 基本概念 curl 是一個強大的命令列工具，用於傳輸資料到或從伺服器。它支援多種協定，包括 HTTP、HTTPS、FTP、FTPS、SCP、SFTP 等。 基本語法 HTTP 方法 GET 請求 GET 方法用於從伺服器取得資料，這是預設的 HTTP 方法。 基本 GET 請求 帶查詢參數的 GET 請求 帶自訂標頭的 GET 請求 POST 請求 POST 方法用於向伺服器提交資料。 基本 POST 請求 (表單資料) JSON 資料 POST 請求 從檔案讀取 JSON 資料 上傳檔案 PUT 請求 PUT 方法用於更新或建立資源。 更新使用者資料 完整替換資源 PATCH 請求 PATCH 方法用於部分更新資源。 部分更新使用者資料 DELETE 請求 DELETE 方法用於刪除資源。 刪除使用者 帶確認的刪除請求 HEAD 請求 HEAD 方法用於取得回應標頭，不包含回應主體。 OPTIONS 請求 OPTIONS 方法用於查詢伺服器支援的方法。 常用選項 基本選項 - `-X, --request ` - 指定 HTTP 方法 (GET, POST, PUT, DELETE 等) - `-H, --header ` - 設定 HTTP 標頭 - `-d, --data ` - 設定 POST 資料 - `-F, --form ` - 設定表單資料 (multipart/form-data) - `-G, --get` - 將資料作為查詢參數發送 - `-b, --cookie ` - 設定 Cookie - `-c, --cookie-jar ` - 儲存 Cookie 到檔案 - `-u, --user ` - 基本認證 - `-o, --output ` - 輸出到檔案 - `-O, --remote-name` - 使用遠端檔案名稱 - `-s, --silent` - 靜默模式 - `-v, --verbose` - 詳細輸出 - `-i, --include` - 包含回應標頭 - `-I, --head` - 只取得標頭 - `-L, --location` - 跟隨重定向 - `-k, --insecure` - 忽略 SSL 憑證錯誤 - `-w, --write-out ` - 格式化輸出 - `--connect-timeout ` - 連線超時 - `--max-time ` - 最大執行時間 - `--retry ` - 重試次數 - `--retry-delay ` - 重試間隔 進階選項 - `--compressed` - 請求壓縮回應 - `--keepalive-time ` - Keep-Alive 時間 - `--max-redirs ` - 最大重定向次數 - `--proxy ` - 使用代理伺服器 - `--resolve ` - 自訂 DNS 解析 - `--cacert ` - CA 憑證檔案 - `--cert ` - 用戶端憑證 - `--key ` - 私鑰檔案 實際範例 認證相關 基本認證 Bearer Token 認證 API Key 認證 檔案操作 下載檔案 下載並重新命名 上傳檔案 多檔案上傳 會話管理 登入並儲存 Cookie 使用儲存的 Cookie 效能測試 測試連線速度 壓力測試 除錯和監控 詳細輸出 只顯示標頭 儲存完整回應 進階功能 環境變數使用 批次處理 條件請求 自訂 DNS 解析 代理設定 故障排除 常見錯誤 1. 連線錯誤 2. SSL 憑證錯誤 3. 認證失敗 4. 超時錯誤 除錯技巧 1. 使用詳細模式 2. 檢查 HTTP 狀態碼 3. 測試 DNS 解析 4. 檢查重定向 最佳實踐 1. 安全性 - 不要在命令列中直接輸入密碼 - 使用環境變數儲存敏感資訊 - 在生產環境中不要使用 `-k` 選項 - 定期更新 curl 版本 2. 效能優化 - 使用 Keep-Alive 連線 - 啟用壓縮 - 適當設定超時時間 - 使用連線池 3. 錯誤處理 - 檢查 HTTP 狀態碼 - 設定適當的重試機制 - 記錄錯誤日誌 - 使用適當的超時設定 4. 程式碼組織 - 使用腳本檔案儲存複雜命令 - 使用設定檔案管理參數 - 添加註解說明 - 版本控制腳本檔案 範例腳本 基本 API 測試腳本 健康檢查腳本 回應格式範例 成功回應 錯誤回應 HTTP 狀態碼說明 - `200 OK` - 請求成功 - `201 Created` - 資源建立成功 - `204 No Content` - 請求成功但無內容 - `400 Bad Request` - 請求格式錯誤 - `401 Unauthorized` - 未授權 - `403 Forbidden` - 禁止存取 - `404 Not Found` - 資源不存在 - `422 Unprocessable Entity` - 資料驗證失敗 - `500 Internal Server Error` - 伺服器內部錯誤 總結 curl 是一個功能強大的命令列工具，掌握其基本用法和進階功能對於 API 測試、資料傳輸和系統整合都非常重要。透過本手冊的說明和範例，您應該能夠有效地使用 curl 進行各種 HTTP 操作。 記住要根據實際需求選擇適當的選項，並始終注意安全性和效能考量。",
    "path": "系統相關/Curl 學習筆記.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/Design Pattern.md",
    "title": "Design Pattern",
    "content": "設計模式 Design Pattern > 參考資料 > > 設計模式系列文 什麼是設計模式 > 每一個模式(Pattern)都是在某個特定情境(context)下，針對某問題(Problem)提出的解決方案(solution)。 在軟體工程中將 Pattern 分為： - Architecture Pattern: 解決軟體系統架構層面的問題。如：MVC 架構、Layer... - Design Pattern: 提供改善軟體系統中子系統與元件(components)的方案。常見如：Observer, Facade, Adapter... - Idioms: 是一種 lowest-level pattern，為 programming(程式撰寫)層級提供程式改善方案，主要透過程式語言的解決方案來實現。 範例 情境(context)：每個人都喜歡坐在窗邊，有低矮的大窗台與舒適的椅子，若一個房間中沒有如此環境，很難讓人感到舒服。 此時的問題(problem)正是：如何讓人感到舒服自在？ 此時有兩個需求(Force)： - 你想要舒服地坐下 - 你想要面對窗戶 但往往兩個需求會互相衝突： - 舒服的椅子背對窗戶 - 面對窗戶只有一張壞掉的椅子 最好的方法就是當你每次在安排室內布局時，雖然房間可能沒有太多擺設的選擇，但至少依循著一個\"面對窗戶有一個舒服的位置\"這樣的模式。 如何描述設計模式 設計模式的發表雖然也是學術的一環，但其講求的重點與一般學術論文不同。 比起一般學術論文要求深入嚴謹，設計模式更像是一個產品說明，須具備高度結構性的方法與淺顯易懂的行文來表達。 這裡主要使用的是 POSA 中，設計模式的描述結構。 Name 名字是一個讀者了解模式最快的方法，也是總結一個模式的重要方法。而且要對 pattern 命名有很多種方法，常見的有： - 取自 solution 的抽象特徵，如： - Adapter 模式(像是一個轉接器，轉介不同規格的物品) - Observer 模式(像一個觀察者，若訂閱的標的有狀態的變化，則馬上通知訂閱者) - 取自 solution 中元件的名稱，像是 MVC (取自系統中的 model、view、controller 三個元件的頭一個字母) Context 舉出模式可能適用的情況。主要是整理 problem 可能發生的情境來界定 problem 可能發生的範圍。雖然 context 不能列出所有情境，但至少可以提供重要的指引。 Problem problem 是描述會在 context 中重複發生的問題。另一方面 problem 也是 pattern 的核心元素，說明主要模式的設計議題。 problem 中有一個很重要的元素：force。在前面的範例中有提到，force 是導致設計問題中存在的具體的力，同時，force 幫助 context 中具體形塑出 solution 的邊界。主要列出幾個需要解決的層面： - solution 需要滿足的需求 - solution 需要考慮的限制 - solution 需要包含的特性 但不幸的是，force 常常是互相矛盾且衝突的，在設計 solution 時常常需要權衡不同的 force 來得到最適合的解決方案。 Solution(解決方案) 以高階的方式描述 pattern 解決方案原理。solution 提供解決重複發生的 problem 的方法，並盡可能平衡相關的 force (前文提到 force 常常是互相矛盾的)。另一方面，solution 又以 structure(建構) (像是以 UML 類別圖描述各個類別元件之間的關係)與 Dynamics(動力學) (像是以 UML 的循環圖描述元件之間的動態行為與協作)層面來描述 pattern 中不同元件之間的靜態關連與動態協作。 Implementation(執行) 引導讀者實作 pattern。此部分可以依照 pattern 描述的需求採用，並適當提供實作範例(如：程式碼等等)，通常提供與 Example 部分相關的實作方案。 Example 透過舉實際案例來補足在 solution 與 Implementation 部分沒有被涵蓋但又為解決方案中重要的層面。 Variants(變體) 此部分可以依照 pattern 描述的需求採用。簡述 pattern 相關變形的其他 pattern。 Known uses 列舉與 pattern 相關的現存系統。用來證明提出的 pattern 是真實世界中相關情境存在的設計問題，pattern 的解決方案已被應用且能有效的解決問題。 Consequences(結果) 列舉 pattern 的優劣勢。一個 pattern 不可能是完美的，因此也需要列出在特定情境下可能造成的限制或缺陷。 Related pattern 列舉用來解決相似情境下的設計問題或能與該 pattern 整合協作的其他 pattern。 撰寫設計模式時需要的思考脈絡 再次列舉上面提到的例子： 1. 首先，先確定目標的情境。 > 我們要設計一個工作室，而這個工作室只有兩扇窗，幾張舒適的椅子，幾張難坐的椅子 2. 確定設計問題 > 如何讓工作室工作的人一整天都能舒服自在。 3. 接著思考影響上述問題發生的具體作用力，以形塑解決方案的邊界 > 需要舒適的坐著 > 想要靠窗，才能偶爾看看窗外來紓解壓力。 4. 列出這些 force 後，接著可以開始設計解決方案 > 需要舒服地坐著：在工作位置上挑選舒適的椅子 > 想要靠窗：將辦工作桌與辦公椅，盡可能的緊靠窗戶 5. 可以用繪圖的方式輔助說明解決方案，列出工作室擺設的動態(這個模式可能不需要)與靜態(擺設圖)關係 6. 透過舉例，引導參考此模式的施工人員，實作本模式提出的方法 > 例如：列出椅子的規格、窗戶和椅子的距離、擺放角度等等 7. 為了證明此方案是有效的，也可以利用幾個經典的室內設計案例來佐證 8. 完成大部分的設計模式內容後，可以透過列舉優點與限制來為設計模式做個總結 > 優點：可以使人長時間舒適的待在工作室工作 > 缺點：選擇舒適的椅子，需花費較高的成本。窗戶須有不同高度(人坐著可以直接看到窗外的高度) 9. 透過提出的解決方案的特徵，來為此設計模式命名 > 椅子與窗戶的對向模式 設計模式撰寫時的思考脈絡 - 界定情境(context) - 定義設計問題(problem) - 從設計問題中列出會影響該問題發生具體的力(force) - 依循所列出的 force 來設計解決方法(solution) - 統整解決方案，以靜態(structure)與動態(dynamics)的描述方式表述之 - 最後引導讀者實作 pattern 並提出相關的範例(example) - 為了證明 pattern 的實用性，可列舉出已知應用 pattern 中相似解法的例子(known uses) - 最後列出應用該 pattern 後產生的優點與限制(consequences) - 通常在 pattern 完成之後可以依據 pattern 的特性為 pattern 命名(name)，也可以邊撰寫時邊思考。 如何完善已完成的設計模式？ Big Picture - 如何掌握設計模式的主旨： - 設計模式的初稿通常難以理解。而描述得太簡潔往往缺乏實質的內容；相反的，內容太過龐大（描述的多而深入）通常因為太專注細節的描述而模糊了模式的核心概念。 - ThereFore - shepherd 在剛剛接觸設計模式的時候必須先閱讀 problem 與 solution 的部分來掌握該模式的大綱，這主要是因為 sheep 通常最注重再解決方案的設計部分，並將所有對模式的想法，灌輸在 solution 中。 Matching Problem and Solution - 如何確定模式真的是模式的樣子(pattern-ish) - 在撰寫模式時，常會先寫好 solution （因為可能在不斷實作中領悟到通用解決方法），而後在去設計模式的問題，所以在審稿的時候，常常讀起來不清楚這個模式的真正目的是什麼。 - ThereFore - 審稿的時候要確認設計模式的 solution 有完整的針對 problem 解決，解決方案也不能超過 problem 的範圍（剛好就好，不能多餘），之後再加強其中不足的部分（problem 或是 solution ）。 Convincing Solution - 如何提高設計模式的可信度(believable) - 有時候 solution 提供的解法根本無濟於事，看起來沒有實現的能力。 - therefore - 一般的 pattern 在看完 solution 後通常要有「原來可以者麼解決」的感覺。如果沒有，則比需要提供真正實作應用的細節，才能使人信服。 Forces Define Problem - 如何更深層的瞭解問題 - 很多設計模式的初稿，對於 problem 的描述都很薄弱。 - Therefore - 須要透過 Force 來具體化對 problem 的敘述。而作者須要以迭代的方式不對斷修正與增強對 Force 與 Problem 的敘述，透過列出具體化不同的 Force，尋找交集後，最後為其總結出核心問題。 Balance Context - 如何為 pattern 劃定出合適的範圍 - 在撰寫設計模式的 context 時，常常不小心把情境的範圍界定的太大或太小，也往往忽略了界定該情境應用 pattern 之後可能的結果。 - Therefore - 在撰寫設計模式時，必須要具體思考並說明情境使用與不適用這個模式前後的差異，這樣不僅能夠賦予模式的使用者對模式應有的期望，也能幫助我們界定剛好符合所提出的模式範圍。 War Store - 如何推進模式前進？ - 有時不管如何 sheep 如何修改或是更正 shepherd 的建議，shepherd 還是覺得設計模式描述的不清楚、缺乏對該模式的實際應用想像。 - Therefore - 這時 shepherd 應要求 sheep 提供設計模式應用的真實案例，幫助對模式的想像更為生動實際。 Form Follows Function - 如何將設計模式套用到一個新的格式(form) - 有時 sheep 所選擇得 patten 格式，沒辦法完表達(或是不適合)所提出的設計模式，這可能是因為 sheep 對 patten 的格式不熟悉(可能只知道一兩個)，或是因為要把格式整個換掉，須要花費相當大的功夫，因此選擇不換。 - Therefore - shepherd 須要一步一步的引導 sheep 修改原本模式所應用的格式(一次改一些就好)，而終極目的是「making the form serve the patten」 Small Patterns - 如何使設計模式變的更可消化 - 設計模式常常經由不斷修正(可能是因為 sheep 不願意對已完成的內容做刪減)後，內容變的很龐大。 - Therefore - 先放任內容增加，最後再做刪減。刪減可以透過移除不必要的區塊，或是將過於龐大模式，拆分成多個小模式(要做到一個模式只能有一個 context, problem 與 solution)",
    "path": "系統相關/Design Pattern.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/Home Assistant 開發環境.md",
    "title": "Home Assistant 開發環境",
    "content": "Home Assistant 開發環境 > 作業系統：windows 11 > > 環境需求： > > Docker, > Visual Studio code, > Git, > Windows Subsystem of Linux (WSL) > > 參考資料： > > Frontend development > > Set up Development Environment > > docker container install HACS 設定 HA 核心",
    "path": "系統相關/Home Assistant 開發環境.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/Hyper-v 設定.md",
    "title": "Hyper-v 設定",
    "content": "Hyper-v 設定 - 參考資料 虛擬交換器 - 外部網路：讓虛擬機器可以與外部網路連線，簡單說就是與 host 主機共用實體網路卡 - 內部網路：可讓 Host 主機與虛擬機器溝通 - 私人網路：讓虛擬機器彼此可以溝通，與外部網路隔離",
    "path": "系統相關/Hyper-v 設定.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/MQTT 學習筆記.md",
    "title": "MQTT 學習筆記",
    "content": "MQTT > 目前最新版本為 v5.0 (但 v3.1 版較為普及) - MQTT - 概述 - MQTT 訊息格式 - 重要特色 - 在 windows 建立 MQTT 測試主機: Eclipse Mosquitto - 在虛擬主機建立 MQTT Broker: Mosquitto - Mosquitto conf 設定與啟動 - 設定使用者須使用帳號密碼連線 - 重新啟動 Mosquitto - 啟動 MQTT Broker - 測試 Broker - 安裝身分驗證套件: mosquitto-auth-plugin - 設置 mosquitto - 安裝 mosquitto-auth-plug 套件 - 若 mosquitto 無法正常運行 - 安裝身分驗證套件: mosquitto-go-auth - 設置 mosquitto: 同 mosquitto-auth-plug 套件 - 安裝 mosquitto-go-auth - acl 權限設定 - MQTT Client - 安裝 - 設定 mqtt-client 連線 概述 適用於 Server 與 Client 訊息傳 遞的通訊協定 利用訂閱(Subscribe)與發佈(Public)的機制來進行訊息傳遞 因其訊息結構簡單且輕量化，因此非常適合用於硬體效能較低的控制器，或作為物聯網的輕量資料收集應用。 在此架構下，會有三種角色： - `Broker`: 代理人 - `Publisher`: 訊息發佈人 - `Subscriber`: 訊息訂閱者 訊息發佈者(Publisher)多為感測器，發送資料。訊息訂閱者(Subscriber)為使用者的裝置(pc, 手機)，代理人(Broker)接收來自感測器的資料，透過 Topic 來辨別目標的使用者裝置。有訂閱 Topic 的訊息訂閱，會收到相對應的資料。 MQTT 訊息格式 - `Control Header`(1 byte) - `Remaining Length`(1 - 4 bytes) - `Variable Header` - `Payload` Control Header 和 Remaining Length 為必須，後面的 Variable Header 和 Payload 則是依需求決定。 在傳遞的過程中，Publisher 不需要知道 Subscriber 的 IP ，只需要知道 Broker 的位址就可以進行訊息傳遞。 Topic 有階層式設計，用`/`分開，並且有大小寫的差異。 重要特色 MQTT 可以針對網路品質(QoS)，決定操作等級 - `QoS Level0`: Publisher 丟訊息給 Broker 後不理 - `QoS Level1`: Publisher 丟出訊息後，Broker 必回傳 PUBACK 以確定訊息有收到，倘若沒收到 PUBACK，Publisher 會再重傳一次資料。(缺點為若回傳 PUBACK 時斷線，Publisher 會判斷傳送失敗而再重傳一次資料，將導致 Subscriber 重複收到相同的資料) - `QoS Level2`: 在 Publisher 確認 Broker 有收到訊息後，Broker 才將資料傳遞給 Subscriber，且 Subscriber 收到訊息後，也須回傳 PUBACK 給 Publisher，可避免收到重複的訊息，但較佔頻寬。 在 windows 建立 MQTT 測試主機: Eclipse Mosquitto - 在官網下載。 - 在 `Choose Components` 中，如果勾選 `service` 的選項，MQTT Broker 就會變成 windows 的服務，當開機時便會被執行。(若測試環境，建議手動開啟即可) - 設定 windows 防火牆：在 MQTT 預設的通訊埠號為 1883 在 windows 是關閉的。 - 開啟 windows Defender 防火牆設定頁面，按下進階設定。 - 輸入規則，按下新增規則 - 選擇連接埠 - 選擇 TPC 通訊協定與特定本機連接埠 1833 - 選擇允許連線 - 選擇私人連線 - 設定名字，即可完成針對 TPC 連線的 1833 port 輸入規則 - 接著設定輸出規則，步驟相同，一樣指定 TPC 與埠號 1833 - 最後確認輸入及輸出正常啟用即可 在虛擬主機建立 MQTT Broker: Mosquitto - 下載 mosquitto 程式庫 - 更新程式庫 - 安裝 mosquitto - 安裝好後，broker 會自動運行 - 控制指令 - 確認運行 - 查看 server 狀態 - 列舉目前作用中的連線：mosquitto server 預設運作於 port: 1833 - 本機測試 - `-d` debug 模式 - `-t` 訂閱的主題 - `-h` broker 的 IP - `-m` 發送的內容 - `-v` 顯示主題名稱 - 訂閱 - 推送 - 開啟 server 防火牆的 port: 1883 mosquitto 的 broker 通訊埠號預設為：1833，因此需要在 server 的防火牆開通道 讓外界可以透過這個通道跟 MQTT Broker 溝通 - 打開資訊欄 => 虛擬私有雲網路 => 防火牆 => CREATE FIREWALL rule - 填入 - 名稱：自訂名稱 - 目標：選擇網路中所有執行個體 - 來源 ip 範圍：0.0.0.0/0 - 通訊協定和通訊埠： - 指定的通訊協定和通訊埠：tcp:1883 - 點擊建立 Mosquitto conf 設定與啟動 移動到軟體檔案安裝的目錄下(linux: /etc/mosquitto)，用編輯器打開 mosquitto.conf。 設定使用者須使用帳號密碼連線 用 `mosquitto_passwd`，來建立密碼 - 參數 `-c` 為建立密碼文件，若指定的檔案已存在，將會被覆蓋 若要將更多的使用者添加到現有的文件中，則省略 `-c` 參數 若要從密碼文件中刪除用戶 - `allow_anonymous false`: 不允許匿名登入 - `password_file` : 指定帳號清單的目錄 - `listener` : 指定遠端登入時可以使用的 PORT 重新啟動 Mosquitto 啟動 MQTT Broker 在安裝目錄下輸入 - `-c` 指定 config 檔 - `-v` verbose mode 詳細模式 當啟動成功會顯示所有 broker 的即時資訊 測試 Broker - Chrome 瀏覽器擴充程式：MQTTLens - MQTT 教學（四）：使用 MQTTLens 訂閱與發布 MQTT 訊息 - MQTT Explorer - | ESP32 教學 | Mosquitto conf 設定與 MQTT 測試 安裝身分驗證套件: mosquitto-auth-plugin > Ubuntu 20 > > Mosquitto 2.0 > mosquitto-auth-plugin > MySQL > > Mosquitto 2.0 + mosquitto-auth-plugin + MySQL > > Ubuntu 18 使用 apt 安装 mosquitto auth plugin 与 MySQL > > mosquitto 权限验证 設置 mosquitto - 安裝所需套件 - 卸載舊版本的 Mosquitto - 從官方安裝 mosquitto 源碼 - 更改 config.mk 設定 - `WITH_WEBSOCKETS` 當需要使用 websockets 連線到 mosquitto 時，才將其開啟。 - `WITH_CJSON` 將此設定開啟會報錯(未知原因) - 將 mosquitto 編譯並安裝 - 建立 mosquitto 使用者並改變目錄權限 - 建立文件 /etc/systemd/system/mosquitto.service 安裝 mosquitto-auth-plug 套件 - git clone - 在 mosquitto-auth-plug 的目錄底下編輯 config.mk 的副本 - 根據實際環境，設定 config.mk - 可以使用 `whereis openssl` 指令來顯示 OpenSSL 的目錄 - 編譯此套件 - errors 修改 `auth-plug.c` 與 `log.c` 檔 - 將編譯完成後生成的 `auth-plug.so` 複製至 mosquitto 的目錄下(不是源碼目錄，是安裝後的目錄) - 進入 mosquitto 安裝後的目錄(預設為 etc/mosquitto)，複製 mosquitto.conf.example 並在文件最後加入設定 - 在 mosquitto 目錄下建立 conf.d 資料夾，並新增 auth-plug.conf - 更改檔案權限 若 mosquitto 無法正常運行 使用 `sudo systemctl start mosquitto -l` 啟動 Mosquitto 使用 `sudo systemctl status mosquitto -l` 查看運行狀態 若狀態為失敗，運行輸入 `sudo /usr/local/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf` (ExecStart=)，查看詳細的啟動錯誤資訊 - 缺乏權限：將缺乏權限的目錄或是檔案，其權限歸於 mosquitto - libmosquitto.so.1:cannot open shard object - 運行 `sudo /sbin/ldconfig` 更新庫的連接器緩存 安裝身分驗證套件: mosquitto-go-auth > 僅支援 Linux (Debian, Ubuntu and Mintus) 和 MacOS > > iegomez/mosquitto-go-auth > > Mosquitto 安装与部署 > > Uninstalling Go (golang) 設置 mosquitto: 同 mosquitto-auth-plug 套件 安裝 mosquitto-go-auth - 安裝之前，需先在系統上安裝 golang，所需 go 最低版本為 1.13.8。 - 安裝 go (若要更新 golang，需先將舊版本解除安裝 remove golang) - 將 mosquitto-go-auth 套件，git clone 下來，並打包 - 設定 mosquitto 文件(mosquitto.conf) vim /mosquitto/conf.d/go-auth.conf acl 權限設定 其實一般而言只會使用到權限 2、5、7 MQTT Client > php-mqtt/client > > php-mqtt/client-examples 安裝 將專案複製到本機，進入專案資料夾，啟動 composer 設定 mqtt-client 連線 進入 share 資料夾，編輯 config.php",
    "path": "系統相關/MQTT 學習筆記.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/MySQL學習筆記.md",
    "title": "MySQL學習筆記",
    "content": "MySQL 學習筆記 - MySQL 學習筆記 - 環境設定 - 設定時區 - MariaDB 設定命名時區 - 從 zoneinfo 匯入時區 - 從 mysql 提供的指令碼匯入 - 資料表語法 - 資料型態 - 資料庫設計原則 - 資料庫設計和表建立時就要考慮效能 - 選擇適合的資料型別 - 選擇適合的索引列 - SQL 的編寫需要注意最佳化 - 引擎選擇 - 分割槽 - DB 命名原則 - 資料庫命名 - 資料表命名 - 欄位命名 - 索引命名 - 外鍵索引 - Function - CONVERT\\TZ(dt,from\\tz,to\\_tz) 轉換時區 - Event 事件 - 範例 - 基本使用 - 使用情境 - 外鍵 onDelete 約束情況 - ERROR: #1215 - Cannot add foreign key constraint - 刪除重複的資料 - 使用 `DISTINCT` 去除重複值 - 匯入 txt 檔 - 複合主鍵與聯合主鍵，索引與聯合(複合)索引 - 複合主鍵與聯合主鍵 - 索引、聯合(複合)索引 環境設定 設定時區 - `show variables like '%time_zone%'` 查看當前時區 - 會返回兩行紀錄，第一行為 systemtimezone(系統時區)，第二行為 time_zone(資料庫時區) - `set time_zone='+8:00'` 設置當前請求的時區 - 不須重新連接 mysql - 僅當前的請求有效，若關閉則回復原始值。 - `set global time_zone='+8:00` 設定全域時區 - 全域請求有效，但必須重新連接 mysql 才會生效(exit 後重新 mysql -uroot -p 進行連接)。 - 不須重啟 mysql，重啟後回復原始值 - 修改 mysql 設定文件 - 在 my.ini 中添加 - 須重啟 mysql MariaDB 設定命名時區 命名時區是指使用時區的名字，而不是標準時間的小時差。例如 `Asia/Taipei` 就是命名時區，而不是 +08:00。 在 MariaDB 中域設有時區表，但預設為空，需要填充這些表後才能使用。 從 zoneinfo 匯入時區 若系統環境為類 Unix 系統(Mac OS, Linux, FreeBSD, Sun Solaris)，zoneinfo 文件已經包含在系統中。 輸入指令將時區表加入 MariaDB 中的 MySQL 資料庫中 從 mysql 提供的指令碼匯入 由於 windows 沒有 zoneinfo 資料庫，所以必須透過 sql 指令碼匯入時區表 - 下載 sql 指令碼並解壓縮：https://downloads.mysql.com/general/timezone2022gposix_sql.zip - 登入 mariaDB - 連接 MySQL 資料庫 - 從 SQL 指令碼匯入資料 - 檢查是否正確匯入 資料表語法 - 建立資料表 - 增加資料表欄位 - 增加資料表內容 - 更新資料欄位 - 刪除資料欄位 - 選擇欄位 - 使用者定義變數 - 子查詢:查詢裡面有查詢 - inner join | left join | right join | cross join 資料型態 - 字串類型 - `char()` 與 `varchar()` 的空間大小是以後面參數來表示欄位的大小，不同的地方在於`varchar()` 是以動態的方式儲存。 - `char()` 固定大小浪費空間，但是所需的計算時間少。 - `varchar()` 不固定長度，但是每一次抓取都要運算，花費 CPU 運算時間 - 數值類型 | type | storage(bytes) | signed | unsigned | | :---------: | :------------: | :----------------------: | :------------: | | `TINYINT` | 1 | -128 ~ 127 | 0 ~ 225 | | `SMALLINT` | 2 | -32768 ~ 32767 | 0 ~ 65535 | | `MEDIUMINT` | 3 | -8388608 ~ 8388607 | 0 ~ 16777215 | | `int` | 4 | -2147483648 ~ 2147483647 | 0 ~ 4294967295 | | `BIGINT` | 8 | $-2^{63}$ ~ $2^{63}-1$ | 0 ~ $2^{64}-1$ | - `DECIMAL(x, y)` : x = 數值長度(包含小數點)，y = 小數點後的位數(不足補零) - 時間類型 - `YEAR` : YYYY - `TIME` : HH:MM:SS - `DATE` : YYYY-MM-DD - `DATETIM`E : YYYY-MM-DD HH:MM:SS - 鍵名 - `primary key` 主索引鍵(主鍵) - `foreign key` 外部索引鍵(外來鍵) - `UNIQUE` 唯一 不能有重複的資料 - `_INCREMENT` 流水號 - `DEFAULT =` 預設值 - `CHECK ()` 資料寫入前的檢查(預設標準) - functions | method | 方法 | 函式 | 副程式 | 函數 - `count()` : 計算數量 - `MAX()` : 找最大的那一個 - `AVG()` : 平均值 - `ABS()` : 取絕對值 - `ROUND()` : 小數點四捨五入 * - 取得現在時間 - `CURRENT_DATE()` - `SYSDATE()` - `NOW()` * - `Year()` : 年 - `Month()` : 月 - `DAY()` : 日 - `LENGTH()` : 資料的大小 bytes - `CHAR_LENGTH(`) : 字串的長度 * - `POWER(數值, N次方)` : 計算次方 - `SUBSTRING(欄位, 起始位置, 擷取長度)` : 擷取字串 - `INSTR(欄位, '指定的文字')` : 找出指定位置的位置，回傳數值 - `LEFT(欄位, 擷取長度)` : 從左邊開始擷取到指定長度 - `REPLACE(目標欄位, '目標字串', '要取代上字串')` :取代指定字元 - `RPAD(內容, 內容的長度, '取代的字')` : 內容不足或是超過的部分會被取代 - `REPEAT('要重複的字', 重複次數)` :重複輸入 * - 將字串轉換型態 - `CONVERT('字串', 型態)` - `CAST('字串' AS 型態)` * - `DATE_FORMAT(日期, \"%Y\")` :日期格式，取得日期中的項目 * - `IF(判斷條件, \"條件為T\", \"條件為F\")` :條件判斷為 true 返回 1，否則返回 2 - `ELT(數值、清單, '值1', '值2'......'值n')` :透過數值清單傳回指定之索引的項目 - `IFNULL(x, y)` : 如果 x 有值回傳 x，如果 x 為 NULL 回傳 y - `ISNULL(x)` : 如果 x 為 NULL，ISNULL(x)會回傳 1，否則回傳 0 - `NULLIF(x, y)` : 如果 x = y 回傳 NULL，否則回傳 x * - 類似 if else - 不等於： - `<>` - `!=` - `NOT` - 比較： - `>=` - ` 參考資料： > > 詳記一次 MySQL 千萬級大表最佳化過程！ 資料庫設計和表建立時就要考慮效能 表設計時要注意的東西 1. 資料表欄位避免出現 null，null 值不容易查詢最佳化，且佔用額外的索引空間。推薦使用數字 0 代替 null。 2. 盡量使用 INT 而非 BIGINT，如果非負，則加上 UNSIGNED (這樣做數值會擴大一倍)，若使用 TINYINT、SMALLINT、MEDIUM_INT 更好。 3. 使用列舉或整數代替字串型別。 4. 資料表不要有太多欄位，在 20 個以內。 5. 用整型來存 ip 索引 1. 索引並不是越多越好。要根據查詢有針對性的建立，考慮在 WHERE 和 ORDER BY 命令上涉及的列建立索引，可根據 EXPLAIN 來檢視是否用了索引還是全表掃描。 2. 避免在 WHERE 子句中對欄位進行 NULL 值的判斷。否則將導致引擎放棄使用 index 而使用全表掃描。 3. 值分布很稀少的欄位不適合建立索引。例如「性別」這種只有兩三個值的欄位。 4. 字元欄位只建字首索引。 5. 字元欄位最好不要作為主鍵。 6. 不用外來見，用程式保證約束。 7. 盡量不使用 UNIQUE，由程式保證約束。 8. 使用多列索引時，主意順序和查詢條件保持一致，同時刪除不必要的單列索引。 選擇適合的資料型別 1. 使用可存下面資料的最小資料型別：整型 =, between, in 以及 like 字串加萬用字元 (%) 出現的列。 3. 長度小的列，索引欄位越小越好，因為資料庫的儲存單位是頁，一頁中能存下的資料越多越好。 4. 離散度越大(不同的值多)的列，放在聯合索引前面。檢視離散度，透過統計不同的列直來實現，count 越大，離散度越高。 SQL 的編寫需要注意最佳化 1. 使用 limit 對查詢結果的紀錄進行限定。 2. 避免 select \\*，將要查詢的欄位列出來。 3. 是用連線(join) 來代替子查詢。 4. 拆分大的 delete 或 insert 陳述句。 5. 可透過開啟慢查詢日誌來找出較慢的 SQL。 6. 不進行列運算：SELECT id WHERE age + 1 = 10，任何對列的操作都將導致表掃描。他包括資料庫教程函式、計算運算式等等，查詢時要盡可能將操作移至等號右邊。 7. SQL 陳述句盡可能簡單：一條 SQL 只能在一個 CPU 運算。大陳述句拆成小陳述句，減少鎖時間。一條大 SQL 可以堵死整個庫。 8. OR 改成 IN：OR 的效率是 n 級別，IN 的效率是 log(n)級別，in 個數建議是控制在 200 以內。 9. 不用函式和觸發器，在應用程式實現。 10. 避免 %xxx 式的查詢。 11. 少用 join 12. 使用同型別進行比較，比如用 '123' 和 '123' 比，123 和 123 進行比較。 13. 盡量避免在 WHERE 子句中使用 != 或 <> 運算子，引擎會放棄使用索引而進行全表掃描。 14. 對於連續數值，使用 BETWEEN 不用 in：SELECT id FROM t WHERE num BETWEEN 1 AND 5 15. 串列資了不要拿全表，要使用 LIMIT 來分頁，每頁數量也不要太大。 引擎選擇 - MyISAM(MySQL 5.1 及之前版本的預設引擎) - 不支援行鎖，讀取時對需要讀到的所有表加鎖，寫入時則對表加排他鎖。 - 不支援事務 - 不支援外來鍵 - 不支援崩潰後的安全恢復 - 在表有讀取查詢時，支援往表裡插入新紀錄。 - 支援 BLOB 和 TEXT 的前 500 個字元索引，支援全文索引。 - 支援延遲更新索引，極大提升寫入效能。 - 對於不會進行修的表，支援壓縮表，極大減少磁碟空間佔用。 - InnoDB(MySQL 5.5 後成為預設索引) - 支援行鎖，採用 MVCC 來支援高併發 - 支援事務 - 支援外來鍵 - 支援崩潰後的安全恢復 - 不支援全文索引 > MyISAM 適合 SELECT 密集型的表，而 InnoDB 適合 INSERT 和 UPDATE 密集型的表。 > > MyISAM 速度很快，佔用儲存空間也小，但若程式要求事務則 InnoDB 是必須的。 分割槽 分割槽的過程是將一個表或索引分解為多個更小、更可管理的部分。對於開發者而言，分割槽後資料表的使用方式和未分割的資料表是一樣的，只不過在物理儲存上，原本該表只有一個數據檔案，現在變成了多個，每個分割槽都是獨立的物件，可以獨自處理，有可以作為一個更大物件的一部分進行處理。 DB 命名原則 - 命名只能使用英文字母、數字、下劃線，以英文字母開頭 - 避免用 MySQL 的保留字如：backup、call、group 等 - 所有資料庫物件使用小寫字母 資料庫命名 - 不超過 30 個字元 資料表命名 - 一律使用複數名詞 - 不超過 30 個字元 - 多對多關係中的中間表命名，為兩個表名稱，中間以``區隔，以單數命名 例如：`admins`和`members`，中間表命名為`adminmember` 欄位命名 - 各表之間相同意義的欄位必須同名 - 多單詞以`_` - 外鍵約束欄位，以關聯的父層資料表名加上父層資料表欄位名來命名，中間以`_`區隔 例:父層資料表名`admins`，父層資料表欄位名`id`，關聯欄位名`admin_id` 索引命名 外鍵索引 - 資料表名稱\\關聯欄位名稱\\foreign Function CONVERTTZ(dt,fromtz,to_tz) 轉換時區 - dt 日期/時間 - from_tz 原始時區 - to_tz 目標時區 Event 事件 用於定期執行某些資料庫任務 - 用途： - 自動化維護 - 刪除過期數據 - 複製存檔、生成報告 範例 - devices 資料表需要定時刪除已被標記 delete_at 的裝置 基本使用 - 查詢、刪除 - 啟用事件排程 - 查看目前正在執行的程序 使用情境 外鍵 onDelete 約束情況 - 沒有加入`onDelete` 如果在關聯中的限制屬性，沒有加入`onDelete`，此時刪除外鍵約束的父層資料表中的欄位，會出現#1451 error - onDelete('set null') 刪除父層資料表的欄位時，同時會將關聯的子資料表中的欄位設為`null`。 - onDelete('cascade') 刪除父層資料表的欄位時，同時會將關聯的子資料表中的欄位刪除。 ERROR: #1215 - Cannot add foreign key constraint - 可能原因: 1. 添加外鍵約束時，目標欄位須和引用欄位具有相同的數據類型，int signed with int signed 或 int unsigned with int unsigned 2. 在 not null 的欄位加上 on delete/update set null 的外鍵約束，須將該欄位設為 DEFAULT NULL 刪除重複的資料 使用 `DISTINCT` 去除重複值 需求：查找 `02:81:85:34:ED:DC` 表中的數據，將表中 `i`, `p`, `ep`, `eq`, `pf`, `created_at` 這六個欄位均重複的資料刪除，並重新整理 id 先建立一個表，接者使用 `SELECT DISTINCT` 去除重複的值，並把去除重複值的資料，存入新資料表中 最後刪掉原表，並將複製的表改名 匯入 txt 檔 建立資料表 本地 txt 檔匯入 在 txt 檔中，每一個欄位用 tab 鍵進行分隔 或用指定的符號進行分隔，如：`|` 複合主鍵與聯合主鍵，索引與聯合(複合)索引 複合主鍵與聯合主鍵 - 複合主鍵：表的主鍵含有一個以上的欄位組成，不使用無業務含意的自增 id 作為主鍵 `name` 和 `id` 欄位組合起來就是 test 表的複合主鍵，他的出現是因為 `name` 欄位可能會出現重複，所以要加上 `id` 欄位，如此可以保證紀錄的唯一性。 一般而言，主見的欄位資料長度和字串字數越少越好。 當表中只有一個主鍵時，他是唯一的索引；當表中有多個主鍵時，稱為複合主鍵，複合主鍵聯合保證唯一索引。 某者個主鍵欄位值出現重複是沒問題的，只要不是有多筆資料的所有主鍵值完全一樣，就不算重複。 - 聯合主鍵：多個主鍵聯合形成一個主鍵組合。 聯合主鍵的意義：用兩個字串(或多字串)來確定一條紀錄。這兩個字串都不唯一，可以分別重複。 如：主鍵 A 和主鍵 B 組成聯合主鍵 主鍵 A 跟主鍵 B 的資料可以完全相同，聯合就在於主鍵 A 和主鍵 B 形成的聯合主鍵是唯一的。 下面的例子：主鍵 A 的數據是 1，主鍵 B 的數據也是 1，聯合主鍵其實是 11，11 是唯一值，不允許再出現 11 這個值。(即為多對多關係) | 主鍵 A | 主鍵 B | | :----: | :----: | | 1 | 1 | | 2 | 2 | | 3 | 3 | 主鍵 A 與主鍵 B 的聯合主鍵值最多為：11, 12, 13, 21, 22, 23, 31, 32, 33 索引、聯合(複合)索引 - 索引：加快查詢速度的有效手段。 系統讀寫資料時，會自動選擇合適的索引作為存取路徑。 建立索引 建立資料表時同時建立索引 當建立 `yourtablename` 時，同時定義了一個名為 `indexname` 的索引，並指定了要建立索引的列 `columnname`。 可以依照需求在資料表定義中添加多個索引。 - `INDEX` 關鍵字用於定義一個普通索引。如果要創建唯一鍵索引，您可以使用 UNIQUE INDEX。 - `index_name` 是您為索引指定的名稱，用於在以後引用索引。 - `column_name` 是您要為其建立索引的列名。 添加索引 - `yourtablename` 是您要向其添加索引的資料表名稱。 - `index_name` 是您為新索引指定的名稱。 - `column_name` 是您要為其建立索引的列名。 索引是各種關係資料庫中，最常見的一種邏輯單元，是關係資料庫系統很重要的組成部分，對於提高檢索資料速度有很顯著的效果。 索引的原理是利用根據索引值得到行指針，然後快速定位到資料庫紀錄。 索引的使用： 1. 主鍵(預設自帶索引)和外鍵(以及一些可以跟其他表觀聯的字段) 2. where 子句中基常出現的字段。 3. 索引應該建立在小字段上，大數據字段(bit, image, test, blob)等，不適用 - 聯合(複合)索引 索引生效原則：按照聯合索引的順序，由前往後依次使用生效，如果中間某個索引沒有使用，那麼斷點前面的索引部份起作用，斷點後面的索引沒有起作用。 例如 則只有 a 和 b 索引起作用，中間 c 斷了，則 d 索引不起作用。 mysql 會一值向右尋找直到遇到範圍查詢(>, \"。 如果建立(a, b, d, c)的順序，則 其中 abcd 都可以用到索引，並且 abd 的順序可以任意調整。 以上 sql 語句中，a, b, c, d 都用到了索引 注意 1. 只要列中包含有 null 值，都將不會被包含在索引中，複合索引中只要有一列含有 null 值，那此列的複合索引就是無效的，因此在資料庫設計時盡量不要讓欄位的預設值為 null 2. 使用 like 關鍵字須注意：`like \"%aaa%\"` 不會命中索引，`like \"aaa%\"` 才會命中索引。 3. NOT IN 和操作都會變成全表掃描，not in 可以用 not exist 代替。",
    "path": "系統相關/MySQL學習筆記.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/RESTful API.md",
    "title": "RESTful API",
    "content": "RESTful API > RESTful API 是一種設計模式 > > 定義一組\"物件\"(object)，他們是可以被操作的。 > 物件運用一組固定\"動作\"(action)簡稱(CRUD) > > - 創建(create) > - 刪除(delete) > - 更新(update) > - 讀取(read) > > 主流以 JSON 格式做資料傳遞 > 基本上會包含 URL\\Object\\Action 常用 HTTP 動詞 - GET: 讀取資源(不會變動或是更改到伺服器的資訊，主要用來查資料) - POST: 新增資料 - DELETE: 刪除資料 - PUT: 替換資源 - PATCH: 更新資源 如以 Post(文章)這個物件舉例 | HTTP 動詞 | URL | 功能 | 說明 | | :-------: | :------------: | :----------------------: | :------------------------------------------------------------------------------: | | POST | api/v1/posts | 發表一篇文章 | 如果有相同的請求送第二次，會回傳新的一筆資料，內容一樣只有 ID 不同 | | DELETE | api/v1/posts/1 | 刪除 id=1 的文章 | 如果發送兩次請求，第二次回傳找不到資源的錯誤訊息 | | PUT | api/v1/posts/1 | id=1 資料整筆替換 | 替換整筆資料，有點像舊資料的刪除，寫入新的資料 | | PATCH | api/v1/posts/1 | 更新文件 id=1 的部分內容 | 只替代掉部分內容，內容會依照發送請求的資料作修改。如果沒有填寫的部分保留原始資料 | - 其他不符合以上類別的動作用 POST Laravel RESTful API 建立 controller 加入 api routes/api.php URL | action | url | Controller function | | :----: | :----------------------------------: | :-----------------: | | get | `{{ server-url }}/api/test` | index | | post | `{{ server-url }}/api/test` | store | | get | `{{ server-url }}/api/test/{{ id }}` | show | | patch | `{{ server-url }}/api/test/{{ id }}` | update | | delete | `{{ server-url }}/api/test/{{ id }}` | destroy |",
    "path": "系統相關/RESTful API.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/Redis 學習筆記.md",
    "title": "Redis 學習筆記",
    "content": "Redis 學習筆記 - Redis 學習筆記 - redis-cil - scan keys tool - 資料類型 - string - List - Set - Hash - HGETALL 指令詳細說明 - Laravel 更新 Hash 指定 Key 值的情境範例 - Sorted Set - Redis Pipeline - 簡介 - 工作原理 - 效能提升原理 - 使用場景 - 優缺點 - 程式語言範例 - Redis CLI 範例 - Python 範例 - Node.js 範例 - PHP 範例 - Laravel 範例 - 效能測試範例 - 注意事項 - 最佳實踐 - redis Key - 指令間聽 - Redis GUI - windows 安裝 phpredis - Redis 與 Memcached 的差異 redis-cil scan keys tool findrediskeys.sh chmod +x findrediskeys.sh - 開頭檢查 redis-cli，若未安裝會嘗試用 apk add redis 安裝 - 支援 -h 參數顯示 常見 pattern 速查表 - 使用者輸入 Redis host、port、db、pattern - 顯示找到的 key 與總數 - 刪除選項： - y → 刪除全部 - n → 不刪除 - 輸入指定 key → 只刪該 key 資料類型 - redis 支援五種資料類型： - string 字串 - hash 雜湊 - list 列表 - set 集合 - zset 有序集合 string 一個 key 對應一個 value。 字串類型為二進制，因此 string 可包含任何資料，如 jpg 圖片，或是一個序列化的物件。 string 最大可以儲存 512MB List 由於 Lists 本質上是 linked-list 的緣故，它在新增和刪除元素的速度是快的，但搜尋速度是相對慢的。可以使用 RPUSH 和 LPUSH 來新增元素，如果該 key 尚不存在的話，會回傳新的 List，如果該 key 已經存在，或它不是 List 的話，則會回傳錯誤。 - 有順序性 - 新增刪除速度相對快：適合用在只要取出頭尾元素的情況(ex: Quene) - 搜尋速度相對慢 - 適用時機 - Message Quene: 只需取出頭尾的元素，不需要搜尋 Set 由多個 redis 中的 string 以無序的方式所組成，其保證內部不會有重複的元素，此外 Redis 提供了多個 Set 之間交集、差集與聯集的操作。 - 使用時機： - 記錄每一個造訪的 ip - 商品標籤 - Set 的基礎操作 - CRUD: SADD SREM SMEMBERS SCARD SPOP - 集合操作: SDIFF SINTER SUNION Hash 為 key-value 的資料類型，也是 Redis 的主結構，非常適合用於儲存物件型資料，例如 User 物件有姓名、年齡、信箱等。當物件非常小時，Hash 會將資料壓縮後儲存，因此單台 redis 可以儲存數百萬個小物件。 - Hash 的基礎操作 - Create: HSET, HMSET, HSETNX - Read: HGET, HMGET, HGETALL, HKEYS, HVALS, HEXISTS, HLEN - Update: HSET (覆蓋), HINCRBY, HINCRBYFLOAT - Delete: HDEL - 多欄位操作: HMSET, HMGET, HGETALL HGETALL 指令詳細說明 `HGETALL` 是 Redis 用於取得指定 Hash（雜湊）鍵下所有欄位（field）與對應值（value）的指令。回傳結果會依序列出所有欄位名稱與其值，適合用於一次取得整個 Hash 的所有資料。 語法： - ` `：要查詢的 Hash 鍵名。 回傳格式： - 若指定的 key 存在且為 Hash，回傳所有欄位與值，格式為陣列（field1, value1, field2, value2, ...）。 - 若 key 不存在，回傳空陣列。 範例： Redis CLI 範例： Laravel phpredis 範例： 常見用途： - 一次取得某個使用者、設定檔、會話等所有屬性 - 檢查 Hash 內所有資料內容 - 配合資料遷移、備份時導出完整 Hash - 快速檢查設定或狀態資訊 與 HGET 差異： - `HGETALL`：一次取得 Hash 內所有欄位與值 - `HGET`：僅取得指定欄位的值 範例： 注意事項： - 若 Hash 很大，`HGETALL` 可能回傳大量資料，請注意效能與網路流量。 - 若 key 不存在，回傳空陣列，不會報錯。 Laravel 更新 Hash 指定 Key 值的情境範例 以下展示在 Laravel 專案中常見的 Hash 更新情境，包含簡單的 Redis 指令和操作流程： 1. 使用者資料更新流程： 2. 計數器操作流程： 3. 條件式更新流程： 4. 批量操作流程（使用 Pipeline）： 5. 資料查詢和驗證流程： 6. 快取管理流程： 主要操作流程總結： 1. 單一更新: 使用 `HSET` 更新個別欄位 2. 批量更新: 使用 `HMSET` 一次更新多個欄位 3. 條件更新: 使用 `HSETNX` 避免覆蓋現有資料 4. 數值操作: 使用 `HINCRBY` 和 `HINCRBYFLOAT` 進行計數 5. 批量操作: 使用 `Pipeline` 提升效能 6. 資料驗證: 使用 `HEXISTS` 檢查欄位存在性 7. 過期管理: 使用 `EXPIRE` 設定快取生命週期 這些流程展示了在 Laravel 中如何有效地使用 Redis Hash 進行各種更新操作，適合用於使用者資料管理、計數器、系統設定等場景。 Sorted Set 為有序的 Set，其順序會依照傳入的權重值排序，在查找資料時，可使用 binary search，因此查找效率高。由於 Sorted Set 的高效能查詢，Sorted Set 可當做一組 Hash 資料的 index，將物件 id 以及 index field 儲存在 Sort Set，單筆物件的完整資料儲存在 Hash。 - 有順序性，透過 `score` 產生連結來達到排序的作用，`score` 本身會是 `float` - 元素值仍然是唯一，但 `score` 可以不是唯一 - 不論是 Add, Remove 或是 update 速度都很快，可以同時快速搜學中間的項目 - 可以視為 `set` 和 `hash` 的混合 - 使用上指令和 `set` 相似，只要將最開頭的 `S` 改成 `Z` - 使用時機 - 遊戲的計分板 - Sorted Set 的基礎操作 - CRUD: ZADD ZRANGE ZREM - Rank 操作: ZRANK 找元素位置，ZSCORE 設定元素權重值 - option - XX: 只更新存在的成員，不添加新成員 - NX: 不更新存在的成員，只添加新成員 - CN: 修改返回值為發生變化的成員總數，原始是返回新添加成員的總數(CH 為 change 的縮寫)。更改的元素是新增加的成員，已經存在的成員更新分數。所以在命令中指定的成員有相同的分數將不被計算在內。一般而言，ZADD 只會返回新增成員的數量 - INCR: 當 ZADD 指定這個選項時，成員的做就等同 ZINCRBY 命令，對成員的分數進行遞增操作。 Redis Pipeline 簡介 Redis Pipeline（管道）是一種將多個 Redis 指令打包在一起發送的技術，可以大幅提升 Redis 操作的效能。傳統的 Redis 操作模式是「請求-回應」的往返模式，而 Pipeline 允許客戶端將多個指令一次性發送到 Redis 伺服器，然後一次性接收所有回應。 工作原理 傳統模式（無 Pipeline）： Pipeline 模式： 效能提升原理 1. 減少網路往返次數：將多個指令打包成一個批次發送 2. 降低網路延遲影響：減少 TCP 連接的開銷 3. 提高吞吐量：特別適合需要執行大量指令的場景 使用場景 - 批量資料操作：一次性設定多個 key-value - 資料初始化：大量資料的初始載入 - 統計資料處理：需要執行多個計數器操作 - 快取預熱：系統啟動時預先載入快取資料 - 資料遷移：大量資料的匯入匯出 優缺點 優點： - 大幅提升效能，特別是在高延遲網路環境下 - 減少網路開銷 - 提高系統吞吐量 - 適合批量操作場景 缺點： - 不支援原子性操作（與 Redis Transaction 不同） - 記憶體使用量可能增加 - 錯誤處理較複雜 - 不適合需要即時回應的場景 程式語言範例 Redis CLI 範例 Python 範例 Node.js 範例 PHP 範例 Laravel 範例 效能測試範例 注意事項 1. 記憶體使用：Pipeline 會將所有指令暫存在記憶體中，大量指令時需注意記憶體使用量 2. 錯誤處理：Pipeline 中的某個指令失敗不會影響其他指令的執行 3. 原子性：Pipeline 不保證原子性，如需原子性操作請使用 Redis Transaction 4. 網路延遲：在低延遲網路環境下，Pipeline 的效能提升可能不明顯 5. 指令順序：Pipeline 中的指令會按順序執行，但回應順序可能不同 最佳實踐 1. 適當的批次大小：建議每批次 100-1000 個指令 2. 錯誤處理：實作適當的錯誤處理機制 3. 監控記憶體：監控 Pipeline 的記憶體使用情況 4. 測試效能：在實際環境中測試 Pipeline 的效能提升 5. 考慮替代方案：對於簡單操作，考慮使用 Redis 的批量指令（如 MSET、MGET） redis Key | 指令 | 描述 | | ----------------------------------------- | ----------------------------------------- | | DEL key | 當 key 存在時，將其刪除 | | DUMP key | 序列化傳入的 key，並回傳被序列化的值 | | EXISTS key | 檢查傳入的 key 是否存在 | | EXPIRE key seconds | 為傳入的 key 設定過期時間，以秒計 | | EXPIREAT key timestamp | 設定過期時間，接受 UNIX 時間戳 為時間參數 | | PEXPIRE key milliseconds | 設置過期時間以毫秒計 | | PEXPIREAT key milliseconds-timestamp | 設置過期時間的時間戳以毫秒計 | | KEYS pattern | 查找所有符合傳入模式 (pattem) 的 key | | MOVE key db | 將目前資料庫中 key 移動到指定的資料庫中 | | PERSIST key | 移除 key 的過期時間，key 將永久保存 | | PTTL key | 以毫秒為單位，回傳 key 剩餘的過期時間 | | TTL key | 以秒為單位，回傳 key 剩餘的過期時間 | | RANDOMKEY | 從資料庫中，隨機回傳一個 key | | RENAME key newkey | 修改 key 的名稱 | | RENAMENX key newkey | 當 newkey 不存在時，將 key 改名為 newkey | | SCAN cursor [MATCH pattern] [COUNT count] | 迭代資料庫中的資料庫鍵 | | TYPE key | 返回 key 所儲存的值的類型 | 指令間聽 在 redis-cli 中下 `monitor` 可監聽所有對 redis 的操作 Redis GUI > Another Redis Desktop Manager > > [[Tool] Redis 管理工具 - Another Redis Desktop Manager](https://marcus116.blogspot.com/2020/04/tool-redis-another-redis-desktop-manager.html) windows 安裝 phpredis > 下載 phpredis 需要對應 php 的版本 > > PHP Version `7.4.29` > > Architecture: `x64` > > PHP Extension Build: API20190902,`TS`,`VC15` windows phpredis 5.3.7 -> php_redis-`5.3.7-7.4`-`ts-vc15`-`x64`.zip 將下載的檔案解壓縮後，將資料夾內 `phpredis.dll` 和 `phpredis.pdb` 複製到 php 的擴充套件 `ext` 目錄之下 最後在 php.ini 檔案中，加入兩行程式碼(注意順序) 最後在 phpinfo 中檢查 php-redis 是否安裝成功 Redis 與 Memcached 的差異 1. 資料結構： redis 提供多種資料結構，如字串、雜湊表、列表、集合、有序集合等。而 memcached 只有支援簡單的 key value。 2. 持久化方式：redis 提供多種持久化方式：RDB、AOF，可以將資料儲存到硬碟中，而 memcached 不支援持久化。 3. 資料分片方式： redis 使用 hash 槽分片方式，可以實現資料的自動分片和負載平衡，而 memcached 只能手動分片。 4. 處理資料的方式：redis 使用單執行緒處理資料請求，支援事務、Lua 腳本等進階功能。而 memcached 使用多執行緒處理資料請求，只支援基本的 Get、Set 操作。 5. 協議：Redis 使用自己的協議，支援多個資料庫，可以使用密碼進行認證。而 memcached 使用文字協議，只支援一個預設資料庫。 6. 記憶體管理方式： redis 的記憶體管理比 memcached 更加複雜，支援更多的記憶體最佳化策略。",
    "path": "系統相關/Redis 學習筆記.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/SOLID 物件導向原則.md",
    "title": "SOLID 物件導向原則",
    "content": "SOLID 物件導向原則 > 參考資料 > > 物件導向設計原則 SOLID SPR 單一職責原則 > Single Responsibility Principle 定義 應該且僅有一個原因引起類別的變更，讓類別只有一個職責。 秘訣 - 關注點分離 - 不應該因為貪圖方便塞在一起 - 若切分太細，會有類別太多的問題 提醒 - 設計階段就可以避開類別職責太大的問題 - 在維護階段需小心別又讓類別職責變多 Bad Good Open Closed Principle 開放封閉原則 定義 軟體中的對象(類別、函數)，對於擴展是開放的，對於修改是封閉的。 秘訣 - 只考慮抽象層級的介面互動 - 把變化委託給其他類別處理 - 只異動 metadata 或 config 提醒 - 不是所有程式都遵守 OCP - 可能一開始無法預想到要擴充，但可以透過重構完成 - 不要過度用繼承的方式來進行擴充 Bad Good Liskov Substitution Principle 里氏替換原則 定義",
    "path": "系統相關/SOLID 物件導向原則.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/TCP 連線溝通方式.md",
    "title": "TCP 連線溝通方式",
    "content": "TCP 連線溝通方式 TCP 會在兩個端點間建立一個連線來確保雙方的溝通順暢，就像是一條電話專線一樣，在這個連線之中，會在來源與目的各指定一個 port (連接埠)，作為確認這個連線的編號。 由於 TCP 是基於 IP 的上面一層，TCP 的連線都在同一個 IP address 下，可以理解為都與同一台設備進行連線。但兩個設備間的連線可能不只一個，就會需要編號來分開不同連線。用 port 來命名編號，就像是在同一個地區(同一個 IP address)有不同的港口。 TCP 通訊過程可以分為三個階段。且必須正確建立連接在一個很多步驟的交握處理(handshake process)然後才進入建立連接(connection establishment)，再進入資料傳輸(data transfer)階段。資料傳輸完成，最後連接終止(connection termination)建立的虛擬通道關閉並釋放所有分配的資源。 一個 TCP 連接是由 OS 管理，TCP 連接基本上經歷底下這些變化： 1. listen: 如果是服務程式的話，指的是等待連接請求從任何遠端的客戶端。 2. syn-sent: 等待遠端點對點發回一個 TCP segment 並帶有 SYN 和 ACK flag。通常做這件事的為 TCP 客戶端。 3. syn-received: 等待遠端通道的另一端發回一個確認後，發回確認連接到遠端節點。通做這件事的為 TCP 服務端。 4. established: port 準備好接收/發送數據到遠端節點。 5. fin-wait-1 6. fin-wait-2 7. close-watt 8. closing 9. last-ack 10. time-wait: 指等待足後的時間，以確保通過遠端對等機器收到確認其連接終止請求。根據 RFC 793 中的連接，最大等待時間為四分鐘。 11. closed",
    "path": "系統相關/TCP 連線溝通方式.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/Ubuntu 學習筆記.md",
    "title": "Ubuntu 學習筆記",
    "content": "ubuntu 學習筆記 - ubuntu 學習筆記 - ubuntu 檔案結構 - 權限 - 概述 - 指令 - `chown` 更改檔案所有權給其他使用者 - `chmod` 更改檔案權限 - 安裝 php - 安裝 MySQL - 更新軟體庫 - 升級軟體庫 - 安裝指令 - 查看 MySQL 版本 - 設定 root 密碼 - 移除 MySQL - nginx - service nginx restart 執行出現 fail - 完全移除 nginx - 找不到 sudo - 安裝 composer - 更新系統的套件資訊 - 下載 composer 並將其設定為全域可執行的指令 - 安裝 Git - 安裝 Docker - logrotate 記錄檔管理工具 - 安裝 - 設定檔 - 基本設定 - 紀錄檔輪替頻率設定 - 紀錄檔壓縮 - 測試 logrotate 設定 - 安全性設定 - 登入伺服器建立自訂帳號 - 開啟安全性更新 - 修改 ssh port - 關閉 root 的 SSH 權限，允許 SSH 登入帳號 - 設定 SSH 免密碼登入 - 關閉 SSH 密碼登入功能 - 常用指令 - `&` 背景執行程式 - `jobs` 檢視任務 - `fg` 將任務切換至前景執行，`bg` 將任務切換至背景執行 - `disown` 卸除目前預設的背景行程 - `ps aux | less` 顯示所有正在執行中的進程 - `kill 10000` 刪除執行中的進程，`kill` 加上 PID 的數字即可 - `nohup` 讓程式可以在離線或是登出系統後繼續執行 ubuntu 檔案結構 - `/bin` 存放 linux / ubuntu 系統啟動和運行時會使用到的執行檔 - `/boot` linux 核心和 RAM disk Image 存放的地方，同時為啟動選單設定檔存放的地方 - `/dev` 所有 linux 核心有認識的設備和裝置的資訊都存放在此資料夾 - `/etc` 所有影響到系統運作的設定檔 - `/home` 系統上所有使用者的家目錄都會放在此資料夾下的資料夾 - `/lib` 此資料夾存放 linux / ubuntu 系統會用到的程式庫及核心模組 - `/lost+found` 若 ubuntu 的檔案系統掛掉了，系統回復後，會將所有無法正確回復的資料放進此資料夾中 - `/media` 作為隨身碟或 CD 之類的可移除裝置的掛載點 - `/mnt` 早期 linux 版本所使用的可移除裝置的掛載點，在 ubuntu 上用來專門做掛載暫時性的檔案系統用 - `/opt` 無法透過套件安裝的軟體，會將程式安裝在此資料夾 - `/proc` 此為一個虛擬的檔案系統，裡面放的是系統正在運行的程序，linux 核心透過此資料夾內的檔案來傳送訊息給執行中的程序 - `/root` 此為 root 帳號的家目錄 - `/sbin` 此資料夾內的檔案大多是超級使用者或 root 可以使用的管理用指令程式 - `/tmp` 系統、軟體和程式用來存放暫時性資料的地方 - `/usr/bin` 無論是 ubuntu 預載的或是使用者自己安裝的程式或軟體，都會被安裝到此資料夾 - `/usr/lib` 此資料夾文存放 /usr/bin 的程式會用到的程式庫 - `/usr/local` 通常透過自己編譯案安裝的程式會被放到此資料夾之下 - `/usr/share` 此資料夾用來存放 /usr/bin 的程式的共用資料 - `/usr/share/doc` 所有軟體的說明文件會放在這邊 - `/var` 用來存放系統上的動態資料，像是網站、log 和郵件類型的資料 - `/selinux` 此資料夾用來存放 SELinux 套件，預設並沒有安裝，因此為空 - `/srv` 為相容 FHS 標準，因此會需要將架網站或 FTP server 等網路服務改放到此資料夾 - `/sys` 此資料夾和 /proc 一樣為虛擬的檔案系統，用途為提供目前系統的各項資訊 權限 > 參考資料 概述 Linux 為多用戶系統，可同時間讓與多用戶使用。 每個文件和目錄都分配了三種類型的身分 - `owner` 創建檔案的人 - `group` 一個 group 可以有很多 user，如果這個 group 的權限為讀跟寫，那此 group 中的 user 都可以讀跟寫 - `others` 所有人 與三種權限 - `r` 可以開啟和讀取檔案。若為資料夾，則可以查看目錄下的內容，但無法修改(重新命名、移動、剪下、刪除) - `w` 可以新增、刪除、修改檔案。若檔案有 write 的權限，但資料夾沒有，則只能修改檔案內容，無法更改資料夾結構(修改檔名，移動檔案、刪除檔案) - `x` 執行程式碼的權限。windows 系統中，只要副檔名為 `.exe` 就可以執行，但在 linux 中需要有 execute permission。read 和 write 權限僅能修改程式碼 - `-` 無權限 第一個字元， `d` 代表 directory，`-` 代表 file 接下來為三個字元一組，分別代表 `user(owner)`、`group`、`other` 及其擁有的權限 - 各權限的分數 | 字元 | 分數 | | :--: | :--: | | r | 4 | | w | 2 | | x | 1 | | - | 0 | 分數是累加的，例如 `-rwxrwx---` | 字元 | 權限 | 分數 | | :----: | :--: | :-----: | | owner | rwx | 4+2+1=7 | | group | rwx | 4+2+1=7 | | others | --- | 0+0+0=0 | 所以該檔的權限數字為 770 第一個帳號為擁有者，第二個群組 指令 `chown` 更改檔案所有權給其他使用者 - `-R` 針對檔案或是目錄下檔案做遞歸處理(整個目錄下每一個檔案不遺漏處理) - 將 home 底下 video 目錄所有者，改為 user - 將 home 底下 video 目錄的所有者，改成 user，擁有群組改為 video - 將 home 底下 video 目錄與目錄裡面所有檔案，擁有者改為 user `chmod` 更改檔案權限 - 用數字類型改變檔案權限 - 若要將.bashrc 這個檔案所有權限都設為啟用 - 若要將檔案權限，改為可執行檔，且不開放修改。 則權限為 `-rwxr-xr-x` ，其分數為 755。 - 若要檔案不希望其他人看到。 其權限為 `-rwxr-----`，分數為 740。 - 符號類型改變檔案權限 - `+` 加入 - `-` 除去 - `=` 設定 - 若要將 `.bashrc` 權限設為 `-rwxr-xr-x` - `user` 可讀、可寫、可執行 - `group` | `others` 可讀、可執行 - 若權限為 `-rwxr-xr--` - 若不知道此檔案的權限，但想要將此檔案設定為全部人都可以寫入 `chmod a+w ` - 若要將權限去除，而不更動其他已存在的權限 `chmod a-x ` 安裝 php - 查看是否安裝成功 - 安裝最新版 php 由於通常 ubuntu 的套件資訊不會包含最新版本的 php，若需要最新版本，需添加第三方的套件資訊 將第三方套件資訊加入 ubuntu 套件資訊庫 更新套件資訊 更新後即可安裝最新的 php 安裝 MySQL 更新軟體庫 升級軟體庫 安裝指令 查看 MySQL 版本 設定 root 密碼 - 設定 root 帳號與初始權限 移除 MySQL - 移除 MySQL - 刪除 mysql 使用者 - 刪除設定檔 nginx service nginx restart 執行出現 fail 參考資料 完全移除 nginx - 停止 nginx 服務 - 刪除 nginx 及設定文件 - 自動刪除不使用的軟體包 - 列出與 nginx 相關的軟體，並刪除 - 確認 nginx 是否完全刪除 找不到 sudo - 先檢查 `/etc/sudoers.d` 檔案是否在，若無則下安裝命令 - 若系統中已經存在 `/etc/sudoers.d` 檔案，表示系統已經安裝 sudo 但尚未設定環境。 - 用文件編輯器 (vim) 開啟 `/etc/sudoers.d`，找到 `secure_path` 添加路徑 安裝 composer > 安裝前須先安裝 PHP Command-Line Interface（PHP-CLI) 更新系統的套件資訊 下載 composer 並將其設定為全域可執行的指令 - 從官網下載 composer 安裝檔至 tmp 資料夾 - 驗證下載的安裝檔 使用 composer 官方提供的 SHA-384 簽章來驗證安裝檔 Composer Public Keys / Checksums 輸入驗證的簽章 - 安裝 composer 為了要讓 composer 在全域中使用，所以要將 composer 安裝到 `usr/local/bin` 的資料夾中，以及將 `Composer` 重新命名為 `composer`。 - 查看 composer 版本 - 刪除 composer 的安裝檔 安裝 Git 安裝 Docker 確認安裝 啟動 docker logrotate 記錄檔管理工具 安裝 一般而言 linux 發行版都會安裝好 logrotate 設定檔 logrotate 設定檔位於 `/etc/logrotate.conf`，裡面會包含一些預設的設定值，例如紀錄檔的輪替頻率，保留數量等等 個別套件或服務的紀錄檔設定會放在`/etc/logrotate.d` 目錄中，透過這裡的 `include` 來套用個別套件的紀錄檔設定。 若在個別服務設定中沒有指定的話，就會套用 `/etc/logrotate.conf` 中預設的設定。 基本設定 | 指令 | 說明 | | -------------- | ----------------------------------- | | su root syslog | 紀錄檔擁有者與群組為 root 與 syslog | | missingok | 忽略紀錄檔不存在的問題 | | notifempty | 不輪替空檔案 | | ifempty | 輪替空檔案 | | rotate 7 | 保留七次輪替紀錄 | 紀錄檔輪替頻率設定 | 指令 | 說明 | | --------- | --------------- | | daily | 每日輪替 | | weekly | 每週輪替 | | monthly | 每月輪替 | | yearly | 每年輪替 | | size 100k | 當檔案超過 100K | | size 2m | 當檔案超過 2M | | size 1G | 當檔案超過 1G | 進階設定 | 指令 | 說明 | | ------------ | --------------------------------------------------------------- | | minage 3 | 三天以內建立的檔案不輪替 | | maxage 30 | 不保留三十天以前的紀錄檔 | | maxsize 100k | 搭配 daily 等間隔條件使用，檔案超過 100k 或達到間隔條件時輪替 | | minsize 100k | 搭配 daily 等間隔條件使用，檔案超過 100k 同時達到間隔條件時輪替 | 紀錄檔壓縮 | 指令 | 說明 | | --------------- | -------------------- | | compress | 壓縮輪替後的舊紀錄檔 | | nocompress | 不壓縮輪替後的檔案 | | delaycompress | 延遲壓縮紀錄檔 | | nodelaycompress | 不延遲壓縮紀錄檔 | 測試 logrotate 設定 修改完設定後，可以用以下指令測試設定檔是否正確 如果沒出現錯誤訊息，就完成了 logrotate 是透過 cron 來觸發的，通常是寫在 /etc/cron.daily/logrotate 中，所以更改 logrotate 設定檔之後，只要確認設定無誤，就會自動生效，不需要重新載入設定檔的動作。 安全性設定 > 參考資料 > > Ubuntu VPS 第一步：安全性設定 > > 目前只能透過 GCP 的瀏覽器 ssh 指定 2022 port 連線到虛擬機 登入伺服器建立自訂帳號 為了避免駭客直接用 root 連線進來，應該要限制 root 使用 ssh。 首先使用 root 建立一個新的帳號 1. 用 ssh 登入 root 帳號 2. 修改 root 密碼 3. 新增帳號 4. 允許此帳號使用 sudo 權限 開啟安全性更新 一般若開啟自動更新，容易增加網站運作上的不穩定，所以有些人會選擇關閉。但這邊會開啟最基本的安全更新。 1. 更新 ubuntu 2. 更新完成後，重新啟動 ubuntu 3. 開啟 ubuntu 的 unattended-upgrades 設定檔 4. 將安全性更新以外的全部註解 5. 開啟 ubuntu 的 auto-upgrades 6. 修改指令 修改 ssh port 修改 SSH 預設的 22 port。 1. 列出哪一些 port 是可以使用的 2. 開啟 ssh 設定檔 3. 找到以 Port 開頭的那一行，並更改成你想要的 port 4. 在檔案任一處加入下方指令，以限制 SSH 永遠使用 Protocol 2。這會使 SSH 連線更加安全 5. 重新啟動 ssh 關閉 root 的 SSH 權限，允許 SSH 登入帳號 1. 測試要允許登入的帳號是否具有 sudo 的權限 2. 開啟 ssh 設定檔 3. 關閉 root 登入並新增登入的帳號 4. 重新啟動 ssh 設定 SSH 免密碼登入 使用 ssh key 機制來達成免密碼登入，利用演算法建構出複雜的公私鑰(題目與密碼)，將公鑰放在伺服器上，每次登入時系統自動將本地端的私鑰去對應伺服器上面的公鑰，來確認是否為本人以達成免本人輸入密碼的登入。 除了方便以外，極為複雜且加密過的鑰匙，也可以讓被暴力破解的機會降低。 關閉 SSH 密碼登入功能 為了降低 ssh 的連線風險，接著要進一步將 SSH 密碼登入功能關閉。 1. 開啟 SSH 設定檔 2. 將 `PasswordAuthentication` 的數值改為 `no` 3. 重新啟動 ssh 常用指令 `&` 背景執行程式 - 在執行程式後面加上 `&` 使程式可以在背景執行 `jobs` 檢視任務 `fg` 將任務切換至前景執行，`bg` 將任務切換至背景執行 `disown` 卸除目前預設的背景行程 - `disown -a` 卸除所有工作，無論其狀態是否在執行中或是暫停 - `disown -ar` 僅卸除所有執行中的工作 - `disown -h` 不要卸除工作，只是單純讓程式可以在登出後繼續執行。 `ps aux | less` 顯示所有正在執行中的進程 `kill 10000` 刪除執行中的進程，`kill` 加上 PID 的數字即可 `nohup` 讓程式可以在離線或是登出系統後繼續執行 當 Linux 使用者登出系統後正在執行的程式會接收到 SIGHUP(hangup) 信號，收到信號的程式會立刻停止執行。",
    "path": "系統相關/Ubuntu 學習筆記.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/併發控制.md",
    "title": "併發控制",
    "content": "併發控制 > 悲觀併發控制(悲觀鎖，Pessimistic Concurrency Control / PCC) > > 樂觀併發控制(樂觀鎖，Optimistic Concurrency Control / OCC) 悲觀鎖 對於 \"資料被外界修改\" 持保守態度，因此在整個資料處理過程中，將資料處於鎖定狀態，進以阻止一個事務以影響其他用戶的方式來修改資料。 在資料庫中，悲觀鎖的流程為： 1. 在對任意紀錄進行修改前，先嘗試為該紀錄加上排他鎖(exclusive locking)。 2. 如果加鎖失敗，說明該筆資料正在被修改，那麼當前請求可能要等待或者拋出異常，具體影響方式由開發者根據實際需求決定。 3. 若成功加鎖，那就可以對記錄進行修改，待請求完成後就會解鎖了。 4. 期間若有其他對記錄做修改或加排他鎖的操作，都會等待解鎖後或直接拋出異常。 MySQL InnoDB 使用悲觀鎖 使用悲觀鎖，需先將 mysql 自動提交的屬性關閉，因為 mysql 預設使用 autocommit 模式。 autocommit 模式：當執行一個更新操作後，mysql 會立刻將結果進行提交，若要關閉 `set autocommit=0`, `set autocommit=false`。 使用 `select...for update` 的方式，通過開啟排他鎖的方式實現悲觀鎖，此時在 t_goods 資料表中，id 為 1 的資料會被鎖定，其他的請求必須待本次請求提交後才能執行。 注意，使用 `select...for update` 會把數據鎖住，須注意鎖的級別，MySQL InnoDB 預設為行級鎖(註 1)。行級鎖是基於所索引的，若一條 sql 語句未使用索引，則 mysql 會使用表級鎖(註 2)將整張資料表鎖住。 註 1：行級鎖(row-level locking)， mysql 中鎖定的最小單位，只針對目前操作的資料該行進行加鎖。行鎖可大幅減低資料庫操作的衝突，缺點為：開銷大、加鎖慢、會出現死鎖。 註 2：表級鎖(table-level locking)， mysql 中最大的鎖定單位，會將目前操作的整張表進行加鎖，開銷小、加鎖快、不會出現死鎖，但發出鎖衝突的機率最高。 註 3：死鎖(deadlock)，兩個或多個執行緒由於互相等待，而永遠被阻塞的情況。 優點與不足 悲觀併發控制實際採取 \"先取鎖再訪問\" 的保守策略。在效率方面，處理加鎖的機制會讓資料庫產生額外的負擔，還有增加產生死鎖的機會。也增加了併行性，一個請求若鎖定了某行資料，其他請求則需等待此請求結束才可以處理該行資料 樂觀鎖 樂觀鎖假設多用戶併發的請求，不會互相影響。請求可以在不產生鎖的情況下，處理各自影響的那部分數據。在提交資料前，每個請求會先檢查在該請求讀取數據後，有沒有其他請求又改了該筆資料。如果其他請求有更新該筆資料，正在提交的請求會進行回滾。 相較於悲觀鎖而言，樂觀鎖認為數據一般情況下不會產生衝突，鎖鎖在資料進行提交更新的時候，才會最資料是否衝突進行檢查。當發現衝突時，返回錯誤訊息，讓使用者決定如何處理。 大多實現樂觀鎖的方式為記錄資料版本，並不會對資料表進行加鎖。 實現紀錄資料版本有兩種方式，一為使用版本號，二為使用時間戳。 使用版本號 可以在資料初始化時指定一個版本號，每次對資料的更新操作都會對版號進行 +1，並判斷目前版號是不是該筆資料的最新版號。 優點與不足 樂觀併發控制相信請求之間的資料競爭(data race)的機率小，因此直到提交時才進行鎖定，因此不會產生任何鎖與死鎖問題。但仍然有可能遇到不可預期的結果，例如：兩個請求都讀取資料庫的某一行並加以修改後寫入資料庫，此時就會發生資料衝突。 鎖定形式 共享鎖 又稱為讀鎖，其他的使用者可以併發讀取資料，但是無法修改和刪除，若一請求對某資料增加共享鎖，則其他請求只能對該資料增加共享鎖，不能加排他鎖。 排他鎖 又稱寫鎖，獨佔鎖。若一事務對某資料加上排他鎖，則只允許此一事務讀取和修改此資料，其他任何類型的事務都不能在此一資料加上任何類型的鎖，直到此事務釋放資料上的鎖。保證其他事務在上鎖期間不能讀取或修改該筆資料。",
    "path": "系統相關/併發控制.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/在 GCP 部署 laravel 專案.md",
    "title": "在 GCP 部署 laravel 專案",
    "content": "在 GCP 部署 laravel 專案 > 執行環境設定 > > - Ubuntu 20.04.1 LTS \\n \\l > - Apache/2.4.41 (Ubuntu) > - mysql Ver 8.0.29-0ubuntu0.20.04.3 for Linux on x86_64 ((Ubuntu)) > - PHP 7.4.3 > - git 2.25.1 > - Composer 2.0.12 設置專案 clone git repo 將目錄切換到`/srv/www`，將託管在 git repo 的專案 clone 下來並依 laravel 上線環境設定流程執行。 一般而言會將文件名稱設為域名。 將目錄切換到 Apache 主機放公開程式的地方`/var/www`，將設定軟連結指向專案位置 上線環境設定 1. 安裝 compsoer 排除 dev 項目 2. `.env`設定轉為線上並且關閉錯誤提示 3. 設定快取 4. Composer 緩存 5. 建立 keygen 6. 執行資料庫 migrate (須注意資料庫狀態) 7. 障礙排除 - 清除快取 - migrate 指令 設定專案文件夾的權限 2. 設定 Apache - 設定 Apache server - 編輯 conf 文件 - ServerName : 設定伺服器 Domain Name ，此名稱必須已經註冊 - ServerAdmin : 設定虛擬主機的管理者信箱，不一定要和本機的網站管理者相同 - ServerAlias : 設定伺服器網域別名 - DocumentRoot : 指定虛擬主機的網站主目錄 - ErrorLog : 設定 error_log 所存放的路徑 - CustomLog : 設定 access_log 所存放的路徑 - 啟用 Apache 站點 參考資料 Run Laravel on Google Compute Engine GCP/GCE/Ubuntu/Apache/Laravel5.6 踩雷筆記 延伸閱讀 詳解 Ubuntu/CentOS 下 Apache 多站點配置 Apache 之——多虛擬主機多站點配置的兩種實現方案 ubuntu 設定 apache 部署多個站點 SSL 憑證設定 輕鬆部署 Laravel 應用",
    "path": "系統相關/在 GCP 部署 laravel 專案.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/多線程與多進程.md",
    "title": "多線程與多進程",
    "content": "多執行緒與多進程 > 進程是資源分配的最小單位，執行緒是 CPU 調度的最小單位 基本概念 程式 (程序/Program) 為完成特地任務，用某種語言編寫成的一組指令的集合。指的是一段靜態的程式碼，靜態的物件。 程序 (進程/Process) 為執行程式一次的過程，或是正在執行的一個程式。是一個動態的過程：他有自己生成、存在與消亡的過程。 程式是靜態的，程序是動態的，程序作為資源分配的單位，系統在執行時會為每個程序，分配不同的內存區域。 執行緒 (線程/thread) 程序可以進一步細分為執行緒，是一個程式內部的一個次程式。 - 若一個程序同一時間並行執行多個執行緒，就是支援多執行緒。 - 執行緒作為調度和執行的單位，每個執行緒擁有獨立的\\執行棧(execution stack)和\\程式計數器(Program Counter)，執行緒切換的開銷小。 - 多個執行緒，共享一個程序中結構：方法區、堆疊。 - 註： - 執行堆疊(執行棧/execution stack) 儲存有關正在執行的子程式其訊息的堆疊，在呼叫任何子程式時，主程式都必須暫存子程式執行完畢後應該返回的地址。因此若被呼叫的子程式還要呼叫其他子程式，其自身返回的地址就必須存入執行堆疊，在其自身執行完畢後再取出。 - 程式計數器(Program Counter) - 紀錄程式執行中的狀態 - 記錄下一個指令的位元址 - 紀錄程式執行完畢的指令 - 紀錄程式執行完成的時間 多執行緒與多進程的選擇與區別 | | 多進程 | 多執行緒 | 結論 | | -------------- | -------------------------------------------------- | ------------------------------------------------------------ | ---------- | | 數據共享、同步 | 數據共享複雜，需要用到 IPC；數據是分開的，同步簡單 | 因為共享進程數據，數據共享簡單，但也因為這個原因導致同步複雜 | 各有優勢 | | 內存、CPU | 佔用內存多，切換複雜，CPU 利用率低 | 佔用內存少，切換簡單，CPU 利用率高 | 執行緒優勢 | | 建立銷毀、切換 | 建立與銷毀切換複雜，速度慢 | 建立與銷毀，切換簡單，速度快 | 執行緒優勢 | | 程式設計、除錯 | 程式設計簡單，除錯簡單 | 程式設計複雜，除錯複雜 | 進程優勢 | | 可靠性 | 進程間不會互相影響 | 一個執行緒掛掉教會導致整個進程掛掉 | 進程優勢 | | 分布式 | 適應於多核、多機分布式，擴展到多台機器比較簡單 | 適應於多核分布式 | 進程優勢 | 選擇情境 - 需要頻繁建立與銷毀 => 多執行緒 - 常見於 web 伺服器，一個新的連線建立一個執行緒，連線斷了就銷毀執行緒。 - 需要進行大量計算 => 執行緒 - 消耗大量 CPU，切換頻繁，如：圖像處理、算法處理。 - 強相關的處理 => 執行緒、弱相關的處理 => 進程 - 一般 server 的任務，如：`資料收發`、`資料處理`。`資料收發`與`資料處理`為弱相關的任務，而`資料處理`又可分為`資料解碼`、`業務處理`，這兩個任務相較之下關聯性較強。因此`資料收發`與`資料處理`可以分進程設計，`資料解碼`與`業務處理`可以分執行緒設計。 - 可能要擴展到多機分布的 => 進程、多核分布的 => 執行緒 PHP 環境下的多程序與多執行緒 PHP 為單進程同步模型，一個請求對應一個進程，I/O(input/output)是同步阻塞的，",
    "path": "系統相關/多線程與多進程.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/撰寫 API 文件.md",
    "title": "撰寫 API 文件",
    "content": "撰寫 API 文件 > 文件內容包括：用途，路由、參數、回傳值 > 更詳細的會包括：參數放置的位置(route, queryString, body)、參數是否必填，回傳的 JSON 範例 範例 postman 的描述區域 - API 用途 - 參數說明，除了 request body 說明之外，也能說明 uri 參數從哪來的。 - 成功或失敗案例的說明：因為目前我還不知道怎麼在 Response 加上註解。 - 別名，類似中文名稱。 編輯房間 用途 - 編輯房間 - 同時處理增、刪、修動作 - 可以陣列傳入 room_id header | key | 值 | 備註 | | :-----------: | :--------------: | :---: | | Authorization | Bearer {{token}} | token | 參數 | key | 值 | 驗證規則 | | :-----: | :----: | :-------------------------------: | | account | string | required | | role | string | required, string, in:member,guest | | room_id | array | required, exists:rooms,id | ./postmandocgen [C:\\Users\\RD\\Desktop\\V5-Cloud.postman_collection.json] -o [C:\\Users\\RD\\Desktop]",
    "path": "系統相關/撰寫 API 文件.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/數位憑證(SSL)要錢，誰還要數位憑證？.md",
    "title": "數位憑證(SSL)要錢，誰還要數位憑證？",
    "content": "數位憑證(SSL)要錢，誰還要數位憑證？ > 目前 Chrome 全面在未採用 HTTPS 加密的網站，顯示紅色的不安全警告，一律視為不安全。 免費 SSL VS. 付費 SSL 1. 憑證公信力 免費的 SSL 身分驗證不夠確實，可能導致釣魚網站也能冒名安裝其他業者的憑證，且被瀏覽器發現的話，更將會全面否定此間憑證供應商的憑證公信力，同時撤回相同 SSL 的其他網站安全認可。 2. 網站身分的驗證方式 免費的數位憑證通常只採電子郵件驗證。而付費的憑證，依付費方案類型的不同，會有更加嚴謹的驗證方式，也會加入第三方的驗證，以避免憑證誤頒的狀況發生。 3. 憑證有效期限 付費憑證因為檢驗機制完整且嚴謹，所以通常具備多年方案。 4. 企業名稱揭示 付費 SSL 會完整顯示企業資訊，增強品牌安全公信力。 5. 損害賠償責任 根據電子簽章法規定，因此無論是國內外憑證業者，均有制定損害賠償金額。若網站在有安裝此憑證下資料仍不幸遭竊，將有對應理賠金額。 6. 憑證安裝協助 付費 SSL 提供售後服務或是客服支援，協助 SSL 安裝導入。 7. 多網域使用限制 付費 SSL 則可依據企業需求，升級子網域與跨網域方案 8. 憑證的安全標章 付費 SSL 會提供安全標章供用戶置入於網站，提高網站信任感。 9. 憑證供應商對於資安的重視與防護 付費 SSL 具備完整資安防護機制",
    "path": "系統相關/數位憑證(SSL)要錢，誰還要數位憑證？.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/物聯網.md",
    "title": "物聯網",
    "content": "物聯網 物聯網的架構 主要可以分為三層 - 感知層 - 網路層 - 應用層 感知層：物聯網的基礎 各式各樣的感測器 (Sensor) 將擷取到的信號，透過 TCP/IP、RS485、RS232、USB、RFID、ZigBee、Bluetooth 等傳輸協定轉送給網路層 - 關鍵技術 - 無線感測技術 - 加速度感測、濕度感測器、壓力感測器、位移感測器...... - 辨識技術 - RFID 辨識 - 一維條碼 - QR code 網路層：資料處理集送地 處理感知層蒐集到的資料進行基本的資料交換，判斷是要送往雲端或伺服器，亦或是直接採取適當的動作。這一層通常會有閘道器(gateway)來將不同的通訊技術結合，例如感測器透過 zigbee 傳出的訊號，但一般手機無法接收這種訊號。此時 gateway 會將接收到的訊息翻譯後，再透過 wifi 傳給手機，稱為異質網路整合。或提供進入雲端之後，大眾經常會用到的服務：搜尋引擎、網路硬碟、web mell、web office、GS 等 - 關鍵技術 - 有線網路技術 - 電信網 - 有線電視網 - 電腦網路 - 無線網路技術 - body area networks - 以人為中心，服務範圍不超過兩公尺 - 標準協定：IEEE 802.15.6 - Personal Areas Networks - 短距離應用在家庭環境中，服務範圍不超過 10 公尺 - IEEE 標準協定： Zigbee, Bluetooth, UWB - Wireless Local Areas Networks - 介於子網路及外部網路之間 - 標準協定：IEEE 802.11 - Metropolitan Area Network - 介於 LAN 和 WAN 之間能傳輸語音與資料的公用網路，服務範圍 2 到 4 公里 - 標準協定：IEEE 802.16 - 3G(3rd-generation) - 是指支持高速數據傳輸的細胞移動通訊技術。3G 服務能夠同時傳送聲音（通話）及數據資訊（電子郵件、即時通訊等）。3G 的 代表特徵是 提供高速數據業務，速率一般在幾百 kpbs 以上 - LTE(Long Term Evolution) - 資料互通性 - 雲端處理技術 應用層：數據分析與應用 將前面感知層蒐集到的資料依照不同的需求、不同領域轉化成實際的應用，現在常聽到的大數據、人工智慧在這層面扮演很重要的角色。 - 從家庭及個人的食、衣、住、行、育、樂，乃至工業、農業、醫療、學習、及企業/政府所需的環境監控、交通管理、資源管理等 - 將網路層蒐集到的資訊做後製處理",
    "path": "系統相關/物聯網.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/網域設定.md",
    "title": "網域設定",
    "content": "網域設定學習筆記 網址 URL URL 其實就是「網址」網站的位址。 網址的構成是由通信協定與網域名稱構成。 | 通信協定 | 網域名稱 | | :------: | :---------------: | | https | www.google.com.tw | DNS 跟網域名稱(Domain Name) DNS 的全名叫做 Domain Name System，中文叫做「網域名稱系統」。 他會記錄域名指向到哪一個 ip 位址，而他運作的方式為依照 URL 倒序，先問根主機 root 此域名的所屬位置 如上面的例子 google.com.tw 為 .tw 因此知道是在台灣，接著問 google 的託管服務提供商位址，最後取得 ip。 子網域 最通用的例子就是在主網域前面加上 www，例如：www.google.com.tw 但一般而言，不會將 www.google.com 和 google.com 設在不同網站上面，避免誤導。 而子網域是可以自行命名的，一般多以數字與英文小寫來進行命名 以 Bluehost 為例 在 bluehost 的後台，點選 domain 再點選 manage，可以看到裡面記錄的清單，清單中的名字都指向相同的 ip 位址。",
    "path": "系統相關/網域設定.md",
    "category": "系統相關"
  },
  {
    "id": "系統相關/電腦概論.md",
    "title": "電腦概論",
    "content": "電腦概論 演算法 > 參考資料： > > https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E8%AB%87%E4%BB%80%E9%BA%BC%E6%98%AF%E6%BC%94%E7%AE%97%E6%B3%95%E5%92%8C%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6-b1f6908e4b80 > > 在數學和電腦科學/算學之中，演算法/算法/算責法(algorithm)，為一個計算的具體步驟。常用於計算、資料處理、自動推理。精確而言，演算法式一個表示為`有限長`列表的`有效方法`。演算法應包含清晰定義的指令用於計算函式。 簡單定義 > 輸入 + 演算法 = 輸出 輸入一個東西，並將其轉換成另一個東西的過程，就是演算法。假設輸入 2 和 3，若想得到 6，就必須在兩個參數中間加入乘號，讓 2\\*3=6。 時間複雜度 用來判斷演算法執行快慢的指標。通常用大寫 O 符號來記錄時間複雜度的快慢。 舉一時間複雜度的例子： 若今天想要吃牛排，有兩個方法：叫外送或是自己煮。若今天除了牛排還想吃其他料理，外送一樣一次送到，直接開吃，但若是自己煮，煮越多道菜所需要的時間就越長。 從上述例子可以得知：外送取得料理(output)的時間不會受到想吃的料理數量(input)影響，因此可以把此一演算法的時間複雜度記為 O(1)。 而如果若選擇自己下廚，則時間複雜度會隨著料理的數量數量而呈倍數成長。此時可以將時間複雜度記為 O(n)。 也就是說：`大寫 O 符號，是用來描述一個演算法在輸入 n 個東西時，總執行時間與 n 的關係` 時間複雜度實例 在設計程式演算法時，通常會希望演算法至少比 O(n²) 還要快。 執行時間 vs. 步驟次數",
    "path": "系統相關/電腦概論.md",
    "category": "系統相關"
  },
  {
    "id": "開發工具/Docker 學習筆記.md",
    "title": "Docker 學習筆記",
    "content": "Docker 學習筆記 - Docker 學習筆記 - 安裝 Docker: Docker for Windows - 基本概念 - Image - Container - Repository - Hello World - 確認 Image 存在於 Repository - 建立 Container 並執行 - 列出所有已建立的 container - 移除 container - ubuntu - pull - 啟動 - For Laravel: Laradock - 環境要求 - 資料結構 - laradock/.env - mysql - PhpMyAdmin - apache2 - nginx - 啟動 > 參考資料： > > Docker 基本知識 以及 Docker Compose 實戰經驗 > > 基礎系統及 docker hub 指令 > > How to Deploy Laravel with Docker on Ubuntu 18.04 > > Laravel 實戰經驗分享 - Day26 Dockerize 你的 Laravel 專案 安裝 Docker: Docker for Windows > Windows 10 > 需啟用 Hyper-v > 控制台 -> 程式和功能 -> 開啟或關閉 Windows 功能 > 將\"Hyper-v\"和\"容器\"設為開啟 - 下載Docker for Windows 基本概念 - docker 主要元件： - `image` 映像檔 - `container` 容器 - `repository` 倉庫 執行 docker 的主機稱為 Host，當 Host 執行 `docker run` 指令時，Docker 會操作這三個元素。 - Image、container、repository 之間的關係就像光碟一樣：早期世紀帝國等光碟遊戲，會需要搭配其他可讀寫空間（如硬碟），才有辦法執行。 - image 像光碟片，唯獨且無法獨立執行。 - container 像硬碟，可讀可寫可執行。 - repository 像光碟盒，儲存 image。 - registry 則是光碟零售商。 Image - image 包裝了一個執行特定環境所需要的資源。 每個 image 都有獨一無二的 digest，這是從 image 內容作 sha256 產生的。這個是能讓 image 無法隨意更變內容，維持資料的一致性。 雖然 image 裡有必要的資源，但他無法獨立執行，必須靠 container 間接執行。 Container - 基於 image 可以建立出 Container。 他的概念像是建立一個可讀寫內容的外層，架在 image 之上。實際存取 container 會經過可讀寫層與 image，因此看到的內容會是兩者合併後的結果。 Container 特性與 image 不一樣，因為有可讀寫層，所以 container 可以讀寫，也可以拿來執行。 Repository - repository 是存放 image 的空間 docker 的設計類似`分散式版本控制`的方法來存的方法來存放各種 image，而分散式架構就會有類似 git 的 pull/push 行為，實際做的事情也跟 git 類似：為了要跟遠端的 repository 同步。 另一個與 repository 很像，但容易混用的詞為 Registry。Registry 涵蓋範圍更廣，包含了更多 repository 與身分驗證功能等，通常比較常討論的也是 registry。 目前 docker 上面預設的 registry 為 DockerHub，大多數程式或服務的 image 都可以在上面找到。 Hello World - `docker run ` 會建立一個 container 並執行，而因為 container 需要基於 image 建立，所以 docker run 有一個必要參數為 `image name`。 確認 Image 存在於 Repository 首先先確認 `hello-world` 是否存在於本機的 repository，本機找不到的話，就需要從遠端的 repository 下載。 建立 Container 並執行 確認 image 存在後，即可建立 container 並執行。 - `docker run` 預設的行為是： 1. 前景建立並執行 container 2. 等待執行程式結束後，會回到前景的命令提示字元 3. 該 container 會被標記為結束狀態。 列出所有已建立的 container `STATUS` 表示 container 的狀態，`Exited(0)` 後面的數字為程式結束後回傳的狀態碼，通常 0 為正常結束，非 0 則唯有錯誤。 `CONTAINER ID` 和 `NAMES` 為獨一無二，執行多次 `docker run` 後，會生不一樣名字的 container。 移除 container 若一直執行 `docker run` 會使 container 數量不斷增加，一般而言沒有再用到的 container 就會將他移除 ubuntu pull 查看 docker 的 image，應可以看到最新版本的 ubuntu | REPOSITORY | TAG | IMAGE ID | CREATED | SIZE | | ---------- | ------ | ------------ | ----------- | ------ | | ubuntu | latest | 6b7dfa7e8fdb | 3 weeks ago | 77.8MB | 啟動 進入容器 For Laravel: Laradock 環境要求 > Git > docker > docker-compose - 將 laradock 的 repository clone 下來 資料結構 laradock/.env - 在 laradock 的資料夾中複製 .env.example 並改名為 .env - 編輯 .env 中的設定 mysql 若 PhpMyAdmin 登不進去，可能是版本問題 PhpMyAdmin apache2 nginx 啟動 - 啟動 laradock Laradock 會自動啟動包括 php-fpm 在內的 php-fpm 及 workspace，啟動 phpMyAdmin 時也會連帶啟動 mysql - 進入 laravel 專案 在啟動 laradock 之後，會建立一個 workspace 的 container，此時進入 workspace 建立 laravel 專案 進入後，terminal 會顯示自己在 `/var/www` 中，此時 `/var/www` 是連接我們在 .env 中設定的資料夾 `../test`",
    "path": "開發工具/Docker 學習筆記.md",
    "category": "開發工具"
  },
  {
    "id": "開發工具/Git 學習筆記.md",
    "title": "Git 學習筆記",
    "content": "Git 學習筆記 - Git 學習筆記 - 常用指令 - Git 常用指令 - Git Flow 開發流程觀念 - 分支介紹 - 長期分支 - Topic 任務分支 - Git Commit 規範 - Commit Message 格式 - 標題 - 正文 - Footer - commit 模板 - Git 本地操作情境 - 將 git 預設的編輯器改為 vim - 取消 commit：git reset - git commit 打錯字 - 將未完成的工作暫存：git stash - 解決合併衝突 - Git 別名 - 設定 git reset --hard 的 alias - gitconfig 檔案的使用注意事項 - Git rebase - 修改歷史訊息 - 取消 merge 清除合併紀錄 - ORIG_HEAD - Git 檔案忽略設定指南 - 問題背景 - 常見的錯誤方案：使用 .gitignore - 為什麼 .gitignore 不適合 - 正確的解決方案：使用 skip-worktree - 什麼是 skip-worktree - 操作步驟 - 檔案狀態標記說明 - 設定存儲位置 - 主要存儲位置 - 特性 - 管理和注意事項 - 日常管理 - 處理衝突 - 重要限制 - 團隊協作建議 - 建立 Setup 腳本 - 文件化 - 在 git server 建立新儲存庫 - 將本地專案新增至遠端儲存庫 - 轉移資料庫：git mirror - git push fail - 暫存空間不足 - 欲提交的分支受保護 - 遠端儲存庫板本和本地不一樣 - 開發流程實例 - 從首功能分支繼續開發後續分支 - 解決方案 - 從目前的分支建立新分支繼續開發 - 基於目前的功能分支開發，等完成後再重構 - Git 管理 - 使用 VSCode 管理 Git - GitHub 操作 - 將本地專案上傳到 github - Https 設定 Token - 設定 SSH - 部署靜態頁面到 github 常用指令 Git 常用指令 - `git init` 將目前的目錄初始化為 Git 目錄, 建立本地儲存庫 - `git config` 設定或檢視 Git 設定檔資訊 - `git add` 將檔案加入 Git 暫存區 - `git rm` 將檔案移出 Git 暫存區 - `git status` 顯示 Git 狀態 - `git commit` 將暫存區的檔案提交至儲存庫納入版本控制 - `git log` 顯示過去歷次的版本異動 - `git reflog` 顯示完整的版本異動歷史紀錄 - `git show` 顯示指定版本的異動內容 - `git branch` 建立一個新分支 (branch) - `git checkout` 取出分支內容還原為工作目錄 - `git merge` 合併分支 - `git reset` 重設某一版本 - `git clone` 從遠端儲存庫 (GitHub 或 Bitbucket) 複製副本至本地儲存庫 - `git push` 將本地儲存庫內容推送到遠端儲存庫 - `git pull` 將遠端儲存庫拉回合併更新到本地儲存庫 Git Flow 開發流程觀念 > 參考資料：Git Flow 是什麼？為什麼需要這種東西？ > > 參考資料：Git flow 分支策略 分支介紹 長期分支 - main(原為 master, 於 2020/10 變更) 主要為穩定，上線的版本。不該允許開發者直接 commit 到此分支。 一般在專案初期，環境建置好就會拉 develop 分支出去，以維持 main 獨立性。 - develop 所有開發分支的基礎，當新增/修改功能時，會從此分支切出去，完成後再合併回來。 Topic 任務分支 - feature 開發新功能時，會從 develop 切出 feature 分支，其命名方式採`feature/功能名稱`。只要新功能未完成，功 能分支就會持續存在，直到開發完成並合併回開發分支，或直到放棄此新功能。 此分支通常只會存在於該功能的開發者的本機端 repository，不會出現在遠端的庫中。 - 原則： - 從 develop 分支分離 - 合併回 develop 分支 - 分支命名原則：除了 master, develop, release-\\*, hotfix 之外的功能名稱都可以 詳細步驟： 1. 開新功能分支 2. 將已開發完成之功能合併回 develop 分支 `--no-ff` 可保存 feature 上面的歷史資訊，讓開發者可以更瞭解開發的來龍去脈(No Fast Forward)。 - release 由 develop 切出來，正式上線前的最終測試分支，通過後會將 release 合併到 main 以及 develop 確保在 release 時修正的一些問題能同步到 main 與 develop。 制訂版本號碼的最佳時機是在發布分支時。 - 原則 - 從 develop 分離 - 合併回 develop 與 main 分支 - 分支命名規則：release-\\*(版本號) 詳細步驟： 1. 開發佈分支 2. 制訂版本號 3. 將已制訂好的 metadata 或已修復錯誤的發佈分支，合併到主分支 4. 將已制訂好 metadata 或已修復錯誤的發佈分支，合併回開發分支 5. 刪除 release-1.2 分支 - hotfix 上線版本需緊急修復時，由 main 直接切出的 hotfix 分支，修復完成也會合併至 main 分支。 由於 develop 在開發中，若從 develop 切 hotfix 分支，再合併至 main 分支時可能會出現更嚴重的問題。 當 bug 修復後，可合併到開發分支，或是合併回主分支，並標上另一版本號的 tag。 - 原則： - 從主分支分離 - 合併回開發分支或主分支 - 分支命名規則為：hotfix-\\* 詳細步驟： 1. 開修復分支 2. 制訂版本號 3. 修正 bug 並 commit 一版 4. 將修好的分支合併回主分支 5. 將修好的分支合併回 develop 分支 特別注意 若修復分支與發佈分支同時存在，則當 bug 修正後，就不是合併回開發分支而是發佈分支。修 補程式就會在從未來發布分支合併回開發分支時，一併將 bug 修補完。 6. 刪除 hotfix 分支 Git Commit 規範 > Git Commit Message 這樣寫會更好，替專案引入規範與範例 Commit Message 格式 標題 - Type 類型 - feat - 新增/修改功能 (Feature) - fix - 修正 Bug (bug fix) - docs - 修改內容/新增文件 (documentation) - style - 修改程式碼格式或風格，不影響原有運作，包含修改縮排、新增縮排...等等 - refactor - 重構程式碼，不屬於 bug 修正，也不屬於新功能 - perf - 改善效能 (A code change that improves performance) - test - 增加/修改測試功能 (when adding missing tests) - chore - 增加或修改第三方套件(輔助工具)等 (maintain) - revert - 撤銷回覆先前的 commit 例如：revert: type(scope): subject (回覆版本：xxxx)。 - build - 改變打包流程 - scope 範圍 - 任何可以劃分程式碼改變的範圍，例如：page, router, compile, component...等等。 - subject 主題 - 對程式碼修改做簡單描述 正文 描述測次程式碼變更的動機，並說出這個提交與改變前的對比。 1. 為什麼這個提交是必要的？ 2. 他如何解決問題？ 3. 這個提交會對專案產生什麼副作用？ - 可以有效辨認次提交是做了太多改變。若有一兩個副作用尚可接受，但若五、六個以上，則表示改變幅度太大。 Footer 結尾通常會有兩種： 1. 標註 Breaking Changes 應以單詞 BREAKING CHANGE 開頭：用空格或兩個換行符。後面是對變動的描述和變動的理由。 如果當前 commit 還原了先前的 commit，則應以 revert：開頭，後跟還原的 commit 的 header。在 body 中必須寫成：This reverts commit \\ 。其中 hash 是要還原的 commit 的 SHA 標識。 commit 模板 在~/.gitconfig 新增 新建 ~/.gitmessage Git 本地操作情境 將 git 預設的編輯器改為 vim 取消 commit：git reset Git 的 `reset`指令，比較像是「前往」或是「變成」，並不會真的重新設定。 `reset`後的東西都還可以撿的回來。 - 確認 git 紀錄 - 利用相對位置取消 commit `^`符號表示「前一次」的意思，`af75a42^`是指`af75a42`這個 commit 的「前一次」，`af75a42^^`則是往前 兩次，以此類推。 如果要倒退五次可以寫成`af75a42~5`。 另外`HEAD`和`develop`也都指向`af75a42`這個 commit，所以也可以寫成 - 利用絕對位置取消 commit 他會切會到`1baa403`這個 commit，剛好是`af75a42`的前一個 commit，和取消最後一次 commit 的效果一 樣。 git commit 打錯字 編輯最後一個提交的 commit 將未完成的工作暫存：git stash 工作做到一半，需要切換到別的分支進行其他任務。 先看一下目前的狀態： - 將現階段工作暫存 目前正在修改 `app/Http/Controllers/RegionController.php` `app/Models/Room.php` `app/Models/ User.php`，使用 `git stash` 把他們存起來。 > 注意 > > Untracked 狀態的檔案無法被 stash，需要額外使用 `-u` 參數 看一下目前的狀態 `git stash list` 可以查看暫存檔案 - 取出暫存 當任務完成，要把剛剛暫存的東西拿回來 使用 `pop` 指令，可以將某個 `stash` 拿出來並套到目前的分支上。套用成功之後，套用過的 `stash` 就會 被刪除。 如果沒有指定 `pop` 哪一個 `stash`，將會從編號小的也就是 `stash@{0}` 開始使用，也就是最後存進來的。 要刪除 `stash` 可以用 `drop` 指令 如果要把 `stash` 撿回來，但不想刪除，可以使用 `apply` - 主要指令 - git stash 將當前分支的修改內容加入暫存 - git stash -u 將 untracked 檔案加入暫存 - git stash save -u \"\" 將 untracked 檔案加入暫存並撰寫註解 - git stash push 將修改內容加入暫存(完整指令) - git stash push -m 將修改內容加入暫存，並加入註解 - git stash list 瀏覽所有暫存項目 - git stash pop 將最新暫存套用至當前分支，成功後刪除暫存 - git stash pop stash@{1} 將指定暫存套用至當前分支，成功後刪除暫存 - git stash apply 套用最新暫存，成功後保留暫存 - git stash apply stash@{1} 套用指定暫存，成功後保留暫存 - git stash drop 清除最新暫存 - git stash drop stash@{1} 清除指定暫存 - git stash clear 清除全部暫存 解決合併衝突 當在不同分支中，修改同一檔案的不同行，此時合併不會發生問題。 倘若修改的是同一行，就會發生合併衝突。 有出現 CONFLICT (content)提示的檔案，為發生合併衝突的檔案。 此時在檔案中，Git 會將衝突位置標示出來。 修正衝突點後，將修改的檔案暫存，最後進行提交。 Git 別名 修改 `~/.gitconfig` 設定 git reset --hard 的 alias 將本地分支更新到和遠端分支的節點，經常會使用 `git reset --hard` 指令。可以透過以下方式設定 alias： 方法 1：基本的 Git alias 使用方式： 方法 2：帶有默認值的進階 alias 使用方式： 方法 3：更短的 alias 名稱 使用方式： 方法 4：Shell alias（在 ~/.zshrc 或 ~/.bashrc 中） 方法 5：更進階的 Shell function 在您的 `~/.zshrc` 檔案中加入： .gitconfig 檔案的使用注意事項 重要：.gitconfig 檔案修改後無需使用 `source` 指令 `.gitconfig` 是 Git 的配置檔案，使用 INI 格式，不是 Shell 腳本檔案。修改後 Git 會自動讀取新的配置。 錯誤示例： 正確做法： Git rebase 從字面上來看 rebase 可以理解為：重新定義分支的參考基準 使用 rebase 指令等於是修改歷史，他會使分支移動到不同的 commit 重新定義基準點。 修改歷史訊息 1. 進入互動模式 `-i` 進入互動模式 `1de2076` 此次互動的應用範圍為，從現在到`1de2076`這個 commit 2. 編輯訊息 此時會跳出 Vim 編輯器 此順序和 git log 的順序相反 - 將要編輯的 commit 修改前面的指令 - `p, pick` 使用提交，不進行修改 - `r, reword` 使用提交，但編輯提交訊息 - `e, edit` 使用提交，但停止修改 - `s, squash` 使用提交，但合併到先前的提交中 - `f, fixup` 就像“squash”，但丟棄此提交的日誌訊息 - `x, exec` 使用 shell 執行指令（該行的其餘部分） - `d, drop` 刪除提交 若要修改`1de2076`的提交內容錯字，則將 `pick 1de2076 add cat 2`修改成 `r 1de2076 add cat 2`。 存檔並離開後，就會再跳出另一個 vim 編輯器，此為欲修改的 commit 內容。 取消 merge 清除合併紀錄 > Git 實戰技巧 - 取消合併 當 feature 與 develop 分支的合併位置有誤，想要拆掉重做 1. `git rebase -i` ：重整目標 commit 之後的 commit：重整清單中不會有下指令的 commit 而是顯示其後所有的 commit。 輸入指令之後會進入編輯器 2. 將要取消的 commit 改為 drop ORIG_HEAD .git 目錄中除了有 HEAD 檔案外，還有一個叫做 ORIGHEAD 的檔案。這個檔案會記錄「危險操作」之前 HEAD 的位置。舉凡 merge, rebase, reset，這些可能會造成歷史紀錄變動的行為，都會被紀錄在 ORIGHEAD 中，讓你隨時可以調回危險動作之前的狀態。 回到危險操作之前的位置： Git 檔案忽略設定指南 問題背景 在團隊開發中，有時候需要讓某些檔案： - 保持在遠端 repository 中（其他人可以修改） - 但本地的修改不會被追蹤或同步到遠端 - 切換分支時本地修改不會丟失 - 不影響其他團隊成員的工作 常見的錯誤方案：使用 .gitignore 為什麼 .gitignore 不適合 問題： - `.gitignore` 是用來忽略未被追蹤的檔案 - 如果檔案已經在 repository 中，`.gitignore` 不會生效 - 需要使用 `git rm --cached` 移除追蹤，但這會影響其他人 - `.gitignore` 本身會被提交，影響整個團隊 正確的解決方案：使用 skip-worktree 什麼是 skip-worktree `skip-worktree` 是 Git 的一個功能，用於標記某些檔案： - 檔案仍然在 repository 中 - 本地修改不會被 Git 追蹤 - 其他人可以正常修改和推送這些檔案 操作步驟 1. 設定 skip-worktree 2. 檢查設定 3. 取消設定（如果需要） 檔案狀態標記說明 - H - 正常追蹤的檔案 - S - skip-worktree 的檔案 - h - assume-unchanged 的檔案 設定存儲位置 主要存儲位置 `.git/index` 檔案 - Git 的索引檔案（二進位檔案） - 儲存檔案的狀態和元資料 - 記錄 skip-worktree 和 assume-unchanged 的標記 - 包含暫存區的內容 特性 1. 本地設定 - 只存在於你的本地 repository 中 2. 不會被推送 - 其他人不會看到你的 skip-worktree 設定 3. 不會被拉取 - 其他人的設定不會影響你 4. Binary 檔案 - 無法直接編輯 管理和注意事項 日常管理 處理衝突 當其他人修改了被 skip-worktree 的檔案時： 重要限制 1. Clone 時會重置 - 重新 clone repository 時，所有 skip-worktree 設定都會消失 2. 無法備份 - 這些設定無法透過 Git 本身備份或同步 3. 本地環境特有 - 每個開發者都需要在自己的環境中重新設定 團隊協作建議 建立 Setup 腳本 文件化 在專案的 README.md 中說明： bash git update-index --skip-worktree app/Services/Backend.php git update-index --skip-worktree .env ` 或執行 setup 腳本： bash git remote set-url origin https://XXX.git bash git remote -v shell git init --bare shell $ ls HEAD config description hooks/ info/ objects/ refs/ bash git init git add . git commit -m \"First commit\" bash git remote add origin \"remote repository URL\" git remote add origin //fishbone/研發部/軟體區/GitServer/V5/*.git bash git branch --set-upstream-to=origin/遠端分支名稱 bash git init --bare \"remote repository URL\" git init --bare //fishbone/研發部/韌體區/GitServer/V5/*.git bash git push --set-upstream origin main bash git clone --mirror gitolite@git.lab317.org:dinos80152/Authentication bash cd your_project.git/ git remote set-url --push origin https://github.com/yourname/yourproject.git bash git push --mirror bash git push --mirror https://github.com/yourname/yourproject.git shell git config -l http.postBuffer => 緩衝區大小 shell 524288000 為 500MB，此緩衝值大小需斟酌設定。 http.postbuffer=260000000 git config --global http.postBuffer 524288000 察看是否設定成功 git config -l | grep postbuffer git git pull --rebase origin master bash 確認目前所在分支為正在進行 code review 的分支 git branch 建立新分支 git switch -c feature-new-branch 接續開發新功能 當舊分支完成 code review 且合併入 qa 分支，此時需同步更新 qa 的變更到新分支中 更新本地 qa 分支 git remote update git switch qa git reset --hard origin/qa 切換到新分支 git switch feature-new-branch git merge qa 解決可能的衝突後，提交合併結果 最後完成開發新功能後，提交新功能 git push feature-new-branch bash changgenglu@masenyuandeMacBook-Air ~ % git push -u origin master remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. remote: Please see https://github.blog/ 2020-12-15-token-authentication-requirements-for-git-operations/ for more information. fatal: unable to access 'https://github.com/changgenglu/your_project.git/': The requested URL returned error: 403 bash git push -u origin master bash ssh-keygen bash $ Enter file in which to save the key (/Users/changgenglu/.ssh/id_rsa): 這行只是確定存在哪 $ Overwrite (y/n)? 如果原本就有金鑰會跳出此問題，覆蓋嗎？ (是) $ Enter passphrase (empty for no passphrase): $ Enter same passphrase again: 輸入密碼，再次確認輸入密碼 bash cat ~/.ssh/id_rsa.pub bash ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDFp+A3qe4qm1Dkw66LN/ vNGlufX5iC9VERfuUiXHNM5L3hQuz6wO8WuzFv+zDIHRPGUl616oLXTHTqommuO0GZavDo+lbUIRkSBM9j/9tr +hlF4LPTT4ggjOgzLCHTrSyzcmcdykgBfnDgX3aYfZbhCEcWdERUxWFNnDf +YYlNd8L6LMKSIce61nhqiSLNbugDCrE0IH+/1hoS3LNoag9V05Qwo5yZ6srLNJT8uISoqvJv5BwSpBL9ImnePx +LzDiVXlJMisKf1GSXdVuWmVWlKrZOsadk4ZkSNH2cL1wgkNvAUbydWKG9Ag4TfI/khKwUXyhT +7V4jWsJusDXZxafylZma4qeOsaLAN4ScSStnOoSm1CxeNqmPsQpAGbtvx49yB2 +c4HFsa68VzcwV1oejhh2E67iqqKK53IFN/ qQmYYfhUukY6rgLLHlLkmjLqdVpVcULCP0mMzn4xacFWLwDgOtZK1i97vWaLPyG6hYQQ108zK9i/Cg13p0Z+CUTCs= changgenglu@masenyuandeMacBook-Air.local javascript //vue.config.js module.exports = { publicPath: process.env.NODE_ENV === \"production\" ? \"/eric-project/\" : \"/\", }; sh #!/usr/bin/env sh 當發生錯誤時終止腳本運行 set -e 打包 npm run build 移動至到打包後的dist目錄 cd dist 因為dist資料夾預設是被ignore的，因此在進入dist資料夾後初始化git git init git add -A git commit -m 'deploy' 部署到 https://github.com/ / .git 分支為 gh-pages git push -f https://github.com/ / .git master:gh-pages 將dist資料夾中的內容推送至遠端eric-project的gh-pages分支中，並強制無條件將舊有的內容取代成目前的內容（指令 git push -f) cd - shell sh ./deploy.sh ``` 完成後，此時 github 上的 gh-pages 分支會和 vue 專案中的 /dist 資料夾內一樣 6. 進入 setting 頁面的 pages，將 Source 改為 gh-pages 7. 待部署完成，頁面上方會出現專案頁面的連結",
    "path": "開發工具/Git 學習筆記.md",
    "category": "開發工具"
  },
  {
    "id": "開發工具/Mac-Podman 開發環境建置.md",
    "title": "Mac-Podman 開發環境建置",
    "content": "Mac Podman 開發環境建置指南 概述 本指南將在 macOS 上建立一個完整的開發環境，使用 Podman 容器化技術，包含 MySQL、Redis、PHP 多版本和 phpMyAdmin 等服務。 環境需求 - macOS (Apple Silicon 或 Intel) - 已安裝 Homebrew - 已安裝 Podman - 已安裝 Google Cloud SDK (用於存取私有映像檔) 安裝步驟 1. 安裝 Podman 2. 安裝 Google Cloud SDK 3. 建立 Pod 容器群組 注意：端口 5000 被 macOS Control Center 佔用，因此使用 5001 替代。 4. 建立 MySQL 容器 5. 建立 Redis 容器 6. 建立 phpMyAdmin 容器 7. 建立 PHP 容器 PHP 8.1 PHP 8.3 Node.js 驗證安裝 檢查容器狀態 測試各項服務 1. 測試 phpMyAdmin 2. 測試 Redis 3. 測試 MySQL 4. 測試 PHP 5. 測試 Node.js Git 設定與 IAP 通道 1. 設定 SSH 金鑰 2. 設定 Hosts 文件 3. 設定 SSH 配置 4. 建立 IAP 通道 5. 測試 Git 連接 6. 將 SSH 公鑰添加到 GitLab 1. 複製 SSH 公鑰： 2. 登入 GitLab：https://gitlab-v1-mars.9alaxy.com/ 3. 進入 Settings → SSH Keys 4. 貼上公鑰並保存 服務配置 端口對應表 | 服務 | 容器端口 | 主機端口 | 說明 | | ---------- | -------- | --------- | -------------- | | phpMyAdmin | 80 | 8080 | 資料庫管理介面 | | MySQL | 3306 | 3306-3310 | 資料庫服務 | | Redis | 6379 | 6379 | 快取服務 | | PHP | 9000 | - | PHP-FPM | 資料庫連接資訊 - MySQL： - 主機：`localhost` - 端口：`3306` - 用戶名：`root` - 密碼：`qwe123` - 資料庫：`trading_bot` - Redis： - 主機：`localhost` - 端口：`6379` - phpMyAdmin： - 網址：http://localhost:8080 - 用戶名：`root` - 密碼：`qwe123` 使用方式 進入容器 Git 操作 Node.js 環境建置 安裝 pnpm 在 Node.js 容器的 `/var/www/html` 目錄中執行： 安裝專案套件 啟動專案 管理 Pod 管理個別容器 檔案掛載 - 當前目錄：`/Users/changgenglu/Documents` 已掛載到所有 PHP 容器的 `/var/www/html` - MySQL 數據：`./mysql/data` 目錄用於持久化 MySQL 數據 常見問題 1. 端口衝突 如果遇到端口被佔用的問題： 2. 容器無法啟動 3. 權限問題 4. IAP 通道問題 5. Git 連接問題 清理環境 如果需要完全清理環境： 進階配置 自定義 PHP 配置 可以在 PHP 容器中安裝額外的擴展： 環境變數配置 可以通過環境變數來配置各個服務： 總結 這個環境提供了： - ✅ MySQL 8.0 資料庫 - ✅ Redis 快取服務 - ✅ Memcached 快取服務 - ✅ PHP 8.1 和 8.3 多版本支援 - ✅ Node.js 18.11.0 環境 - ✅ phpMyAdmin 資料庫管理介面 - ✅ 完整的端口映射配置 - ✅ 檔案掛載支援 - ✅ Google Cloud SDK 整合 - ✅ IAP 通道連接到內部 GitLab - ✅ SSH 金鑰認證設定 環境已準備就緒，可以開始開發工作！ 重要提醒 - IAP 通道：每次重開機後需要重新啟動 IAP 通道 - 容器重啟：所有容器都會自動重啟 - 檔案同步：當前目錄的檔案會即時同步到容器中 - Git 操作：需要確保 IAP 通道運行才能進行 Git 操作",
    "path": "開發工具/Mac-Podman 開發環境建置.md",
    "category": "開發工具"
  },
  {
    "id": "開發工具/Postman 學習筆記.md",
    "title": "Postman 學習筆記",
    "content": "Postman 學習筆記 參數區介紹 Params 網址參數頁 設定 Query Params 搜尋參數 Path Variables 路徑變數 - 預設只有 Query Params 搜尋參數，Path Variable 路徑變數，需要自行在網址上打上冒號＋變數名 (ex. \" : name \" )，才會出現 - 設定方式都是採 Key - value ，可以根據情況彈性勾選 Authorization 驗證設定頁 用來設定 Header 中的 Authorization 參數 - No Auth | 不需要驗證 - Basic Auth ｜帳號，密碼型驗證 - token 驗證 ｜ token 型驗證 Header 用來設定 Header 中的其他參數 postman 把一些必要的參數隱藏起來，如需特殊設定，可以取消隱藏，進行修改。 - User-Agent | 告知 Server，發出 Request 的 Client 瀏覽器、作業系統等資訊 - Accept ｜告知 Server，Client 可以解讀的內容類型 - Content-type | 告知 Server，Client 提交什麼類型內容 body 較常用的是 form-data, x-www-form-urlencoded, raw，前兩者都是送出表單資料，最後一個提供較多彈性的資料格式。 - form-data 不會針對內容進行編碼，可選擇 file 類型進行上傳檔案 - x-www-form-urlencoded 會以 Key = val1 進行編碼，一般的表單資料使用 - raw 放 postman JSON 資料 Laravel CSRF 原因 當使用 postman 發出 post 請求時，laravel 回傳 419 | expired laravel 會透過應用程式自動產生一個 CSRF token 來管理每一個使用者的 session。 這個 token 用於驗證已認證使用者，是否實際向應用程式發出請求。 在`vender/laravel/framework/src/Illuminate/Session/Store.php`中可以看到，每次進入 laravel 專案的時候，都會檢查 session 中\\_token 是否存在，若不存在就會呼叫 `regenerateToken` 重新生成一個 token。 `regenerateToken` 實作，隨機產生亂數字元。 postman 添加校驗 token 先進入網站首頁取得 token 將 token 放入 post request 的 header， X-XSRF-TOKEN 的欄位中。 撰寫 javascript 自動獲取 token 在進入網站首頁的 API 的 test 中，加入以下程式，以自動獲取 token。 接著在 post 的 request 中的 header 加入 `X-XSRF-TOKEN:{{XSRF-TOKEN}}` Postman 壓力測試(串行處理) 在要測試的 request test 中定義測試的程式碼 開啟 Runner 選擇要測試的 api 選擇 environment，調整請求次數: iterations，調整延遲時間：Delay http status - 資訊回應 (informational responses) 100 - 199 - 成功回應 (Successful responses) 200 - 299 - 重定向 (Redirect) 300 - 399 - 用戶端錯誤 (Client errors) 400 - 499 - 伺服器端錯誤 (Server error) 500-599 postman 無法開啟 collection 1. 將 postman 解除安裝 2. 刪除 C:\\Users\\AppData\\Local\\Postman 3. 刪除 C:\\Users\\AppData\\Roaming\\Postman 4. 下載最新版本的 postman",
    "path": "開發工具/Postman 學習筆記.md",
    "category": "開發工具"
  },
  {
    "id": "開發工具/Visual Studio Code環境設置.md",
    "title": "Visual Studio Code環境設置",
    "content": "Visual Studio Code 環境設置 - Visual Studio Code 環境設置 - 擴充套件 - 中文化 - 美化 code - html, css - VUE - PHP Laravel - Markdown - Git - 小工具 - 調整設定 - 快速鍵 - 快速鍵 - 檢查 coding style(phpcs) 擴充套件 中文化 - Chinese (Traditional) Language Pack for Visual Studio Code 美化 code - Bracket Pair Colorizer - Auto Rename Tag - Prettier - Code formatter html, css - Live server：它會幫使用者自動開啟一個服務器，保存的時候便自動刷新瀏覽器頁面 設定預設開啟的瀏覽器：齒輪符號 > 進行延伸模組設定 > Live Server Settings: Custom Browser - open in browser - IntelliSense for CSS class names in HTML VUE - 參考資料 PHP Laravel - PHP IntelliSense (felixfbecker.php-intellisense) - PHP Server (brapifra.phpserver) - php cs fixer - PHP DocBlocker - PHP Getters & Setters - PHP import checker - PHP Namespace Reaolver - phpcs fixer - PHP Extension Pack - Laravel Blade Snippets (onecentlin.laravel-blade) - Laravel Blade formatter - Laravel Blade Wrapper - Laravel Create View - laravel Extension Pack - Laravel Extra Intellisese - Laravel Goto Controller - Laravel goto view - laravel-goto-components Markdown - markdownlint - Markdown All in One - Markdown Preview Github Styling - Markdown TOC markdown 自動生成目錄，作者：CharlesWan Git - GitLens — Git supercharged - Git Graph - GitHub Theme - gitignore - Git Extension Pack - GitHub Repositories - Open in GitHub, Bitbucket, Gitlab, VisualStudio - Remote Repositories 小工具 - Draw.io Integration(繪製表格、流程圖) - GitHub Copilot github 訓練的 AI 程式碼撰寫工具 調整設定 - 檔案 → 喜好設定 → 設定 → 文字編輯器 → 字型 → Font Size - 檔案 → 喜好設定 → 設定 → 工作台 → 外觀 → Tree:Indent - 檔案 → 喜好設定 → 設定 → 延伸模組 快速鍵 快速鍵 - 註解行 `Command + /` - 選取一段字詞 `Command + D` - 開啟全目錄搜尋 `ctrl + shift + F` - 移動當前行向上向下 `option + ↑ / ↓` - 複製當前行向上向下 `shift + option + ↑ / ↓` - 格式化 `shift + option + f` - 前往檔案 `ctrl + P` - 指定範圍格式化 `ctrl + K` `ctrl + F` - 變更語言模式 `ctrl + K` `M` - 刪除行 `ctrl + shift + K` 檢查 coding style(phpcs) coding style 設定範本",
    "path": "開發工具/Visual Studio Code環境設置.md",
    "category": "開發工具"
  },
  {
    "id": "開發工具/前端工具.md",
    "title": "前端工具",
    "content": "前端開發工具 假圖生產器：Lorem Picsum 使用方法 - 指定長寬 - random 生成不同圖片 若沒有帶 random 參數，在相同的 url 之下，同一次頁面載入時，每一張圖片都會是一樣的。 - grayscale 生成灰階圖片 - blur 生成模糊濾鏡圖片",
    "path": "開發工具/前端工具.md",
    "category": "開發工具"
  }
]