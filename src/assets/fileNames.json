[{"name":"Javascript 學習筆記.md","content":"# Javascript 學習筆記\r\n\r\n- [Javascript 學習筆記](#javascript-學習筆記)\r\n  - [基本概念](#基本概念)\r\n    - [宣告與命名](#宣告與命名)\r\n      - [let, const 特性](#let-const-特性)\r\n      - [如何分辨使用 let 和 const 的時機？](#如何分辨使用-let-和-const-的時機)\r\n    - [let 和 const 解決了什麼問題？](#let-和-const-解決了什麼問題)\r\n    - [javascript 參數傳遞方式](#javascript-參數傳遞方式)\r\n  - [存取資料的方法](#存取資料的方法)\r\n    - [基本型別](#基本型別)\r\n    - [物件型別](#物件型別)\r\n    - [把基本型別當作參數傳入函式](#把基本型別當作參數傳入函式)\r\n    - [Function](#function)\r\n      - [First-class Object](#first-class-object)\r\n      - [宣告 function](#宣告-function)\r\n      - [呼叫 function](#呼叫-function)\r\n      - [IIFF (Immediately Invoked Function Expression) 或稱自我調用函式](#iiff-immediately-invoked-function-expression-或稱自我調用函式)\r\n      - [Scope 作用域](#scope-作用域)\r\n        - [Lexical Scope(語彙範疇)](#lexical-scope語彙範疇)\r\n        - [參數也屬於內層 scope](#參數也屬於內層-scope)\r\n        - [巢狀 scope](#巢狀-scope)\r\n  - [運算式與運算子](#運算式與運算子)\r\n    - [嚴謹模式](#嚴謹模式)\r\n    - [賦值運算子](#賦值運算子)\r\n    - [比較運算子](#比較運算子)\r\n    - [算數運算子](#算數運算子)\r\n    - [邏輯運算子](#邏輯運算子)\r\n    - [其餘運算子與展開運算子 `...`](#其餘運算子與展開運算子-)\r\n    - [三元運算式](#三元運算式)\r\n    - [if else](#if-else)\r\n  - [流程判斷與迴圈](#流程判斷與迴圈)\r\n    - [switch](#switch)\r\n    - [while 迴圈](#while-迴圈)\r\n    - [for 迴圈](#for-迴圈)\r\n    - [for of](#for-of)\r\n    - [for in](#for-in)\r\n  - [函式 function](#函式-function)\r\n    - [定義函式](#定義函式)\r\n    - [箭頭函式](#箭頭函式)\r\n    - [變數的有效範圍 (Scope)](#變數的有效範圍-scope)\r\n    - [提升(Hoisting)](#提升hoisting)\r\n      - [變數提升](#變數提升)\r\n      - [函式提升](#函式提升)\r\n      - [為何會有 Hoisting 的現象？](#為何會有-hoisting-的現象)\r\n      - [最佳實踐](#最佳實踐)\r\n    - [全域變數](#全域變數)\r\n  - [方法](#方法)\r\n    - [取得 base\\_url](#取得-base_url)\r\n    - [document](#document)\r\n      - [`.querySelector()` 元素選擇器](#queryselector-元素選擇器)\r\n      - [`.querySelectorAll()` 選取所有指定元素](#queryselectorall-選取所有指定元素)\r\n    - [prototype.forEach()](#prototypeforeach)\r\n    - [prototype.map()](#prototypemap)\r\n    - [prototype.push()](#prototypepush)\r\n    - [`Math.round()` 四捨五入](#mathround-四捨五入)\r\n    - [`Array.prototype.filter()`](#arrayprototypefilter)\r\n    - [`Array.prototype.splice()` 新增刪除陣列中的元素](#arrayprototypesplice-新增刪除陣列中的元素)\r\n    - [物件取值、新增與刪除](#物件取值新增與刪除)\r\n      - [物件取值](#物件取值)\r\n      - [物件轉為陣列](#物件轉為陣列)\r\n      - [新增物件屬性](#新增物件屬性)\r\n      - [刪除物件屬性](#刪除物件屬性)\r\n    - [SET 集合](#set-集合)\r\n      - [基本使用](#基本使用)\r\n      - [陣列與集合間轉換](#陣列與集合間轉換)\r\n      - [過濾陣列中重複的元素](#過濾陣列中重複的元素)\r\n    - [JSON 轉換](#json-轉換)\r\n      - [`JSON.stringify()` 將物件轉為 json 字串](#jsonstringify-將物件轉為-json-字串)\r\n      - [`JSON.parse()` 將 json 字串轉換為物件](#jsonparse-將-json-字串轉換為物件)\r\n  - [屬性描述器](#屬性描述器)\r\n    - [使用字面值宣告屬性的特徵](#使用字面值宣告屬性的特徵)\r\n    - [取得屬性特徵](#取得屬性特徵)\r\n    - [Object.defineProperty 設定單一個屬性描述器](#objectdefineproperty-設定單一個屬性描述器)\r\n    - [Object.defineProperties 一次設定多個屬性](#objectdefineproperties-一次設定多個屬性)\r\n    - [資料描述器](#資料描述器)\r\n      - [writable 屬性是否可以改值](#writable-屬性是否可以改值)\r\n      - [Configurable 是否可編輯該屬性](#configurable-是否可編輯該屬性)\r\n      - [Enumerable 屬性是否會在物件的屬性列舉時被顯示](#enumerable-屬性是否會在物件的屬性列舉時被顯示)\r\n      - [value 屬性的值](#value-屬性的值)\r\n      - [屬性描述器屬於淺層設定](#屬性描述器屬於淺層設定)\r\n    - [存取器描述器](#存取器描述器)\r\n      - [宣告方式](#宣告方式)\r\n      - [Getter](#getter)\r\n    - [setter](#setter)\r\n    - [資料處理器與存取器處理器](#資料處理器與存取器處理器)\r\n    - [取值器與設值器的應用](#取值器與設值器的應用)\r\n  - [額外補充](#額外補充)\r\n    - [random(亂數)公式](#random亂數公式)\r\n\r\n> **參考資料：**\r\n>\r\n> [重新認識 javascript](https://ithelp.ithome.com.tw/users/20065504/ironman/1259)\r\n\r\n## 基本概念\r\n\r\n- Javascript 的原始值(基本型別/primitive type)：\r\n  - null(empty)\r\n  - undefined(預設/未定義)\r\n  - string(\"12345\")\r\n  - number(12345)\r\n  - boolean(true/false)\r\n  - symbol(ES6)\r\n- Javascript 的複合值(物件 => object)：包含一個或多個原始值，像是物件或是物件實字，除了基本型別以外的型別都是物件\r\n\r\n- 物件：使用 new 關鍵字建立物件\r\n\r\n```javascript\r\nconst name = new type(arguments);\r\nconst d = new Date();\r\n```\r\n\r\n- 物件實字\r\n\r\n```javascript\r\nvar obj = {\r\n  name: \"eason\",\r\n  action: \"haha\",\r\n};\r\n```\r\n\r\n- 陣列\r\n\r\n```javascript\r\nvar arr = [1, 2, 3, 4, 5];\r\narr[8] = 12;\r\narr = [1, 2, 3, 4, 5, \"\", \"\", \"\", 12];\r\n```\r\n\r\n- 用 new 建構出來的是物件 object\r\n\r\n```javascript\r\n    var a = new String(\"test\");\r\n    typeof(a) = object\r\n```\r\n\r\n- 只有建構式，則會轉為原始值\r\n\r\n```javascript\r\n    var a = String(\"test\");\r\n    typeof(a) = string\r\n```\r\n\r\n- 複合值在 javascript 是透過記憶體中的位址來比對\r\n\r\n```javascript\r\nvar a = new String(\"test\");\r\nvar b = new String(\"test\");\r\n\r\nconsole.log(a === b);\r\n// false\r\n```\r\n\r\n- 將不同型態的物件通通轉為字串  \r\n  \\`${}\\` 在大括號中加入變數\r\n\r\n- 宣告原始值：單獨放一個記憶體位址 以 by value 運作\r\n- 宣告複合值：包含許多原始值，但是只放在一個記憶體位置 以 by reference(參考) 運作\r\n\r\n- 更改變數為參考物件(複合值)內的原始值，記憶體位址不變\r\n- 更改變數為原始值，會更改變數的記憶體位址\r\n\r\n- undefined  \r\n  這地方沒有這個東西，所以你無法使用\r\n- NaN  \r\n   要轉型成數字時傳入參數非數字的時候\r\n- null  \r\n  這地方會有一個值，但這個值目前還沒準備好的意思，所以先填入 `null`\r\n\r\n- this\r\n  - 物件掛在誰身上就是`this`，`this`只在當下單一層的作用域裡有效果，箭頭函式就不會。\r\n  - 如果宣告變數，則在宣告當層以及內層為有效範圍。\r\n  - 單純的呼叫`this`，`this`會變成 Global\r\n\r\n.bind //定義 function 內的 this 是什麼\r\n\r\n### 宣告與命名\r\n\r\n- 命名規則\r\n  - 開頭字元需要是 ASCII 字元(英文小寫)，或是下底線(\\_)、錢號($)。開頭字元不得使用數字。\r\n  - 大小寫敏感\r\n  - 名稱不得使用保留字\r\n\r\n**注意** 下底線開頭的命名常為特別用途：如類別中的私有變數、常數或方法。錢符號也通常為特殊用途命名。\r\n\r\n變數與方法名稱都用小駝峰式的命名，類別用大駝峰式命名。\r\n\r\n在 ES5 之前都只會用 `var` 宣告變數，在 ES6 之後加入 `let` 和 `const`，現在應以新加入的特性進行宣告。\r\n\r\n#### let, const 特性\r\n\r\n- 區塊作用域\r\n\r\n  - 變數只存活在 {} 花括號裡面，外面不能調用\r\n\r\n  ```javascript\r\n  {\r\n    const x = 10;\r\n  }\r\n  console.log(x); //Uncaught ReferenceError: x is not defined\r\n\r\n  {\r\n    let y = 20;\r\n  }\r\n  console.log(y); //Uncaught ReferenceError: y is not defined\r\n\r\n  {\r\n    var z = 30;\r\n  }\r\n  console.log(z); //30\r\n  ```\r\n\r\n- 變量會提升，但若未宣告該變數，會回報錯誤，而非 undefined\r\n  - var 變數的宣告，初始預設值為 undefined，但 let, const 不會有這個預設，當執行 let 變數宣告語句時，才會初始化且能夠被訪問。\r\n- 不允許重複宣告\r\n- 全域變數不會成為 window 的屬性\r\n\r\n#### 如何分辨使用 let 和 const 的時機？\r\n\r\n> 如果變數會變，就使用 let，不變就用 const\r\n\r\n更改指的是記憶體地址的改變，而不是值的改變\r\n\r\n- 記憶體存放變數的原則：\r\n  - 基本型別值：\r\n    - 字串、數值、undefined、null、symbol\r\n    - 以上不能更改他的值，只能重新賦值，此時會更改記憶體位址\r\n- 引用值：\r\n  - 物件、陣列、函式\r\n  - 可以修改裡面的值，這樣不會更改記憶體位置，但若重新賦予一個新的值，就會更改記憶體位址。\r\n\r\n### let 和 const 解決了什麼問題？\r\n\r\n用 var 宣告時，容易導致意外汙染全域變數的問題，例如，區域變數覆蓋全域變數\r\n\r\n```javascript\r\nvar food = \"apple\";\r\nfunction func() {\r\n  var result = \"I eat \" + food;\r\n  console.log(result);\r\n}\r\nfunc(); //I eat apple\r\n```\r\n\r\n在 func 方法中用到全域變數 food，組合字串及回傳。\r\n\r\n但如果程式碼變得複雜時，沒注意到 food 已經在第一行宣告過了\r\n\r\n### javascript 參數傳遞方式\r\n\r\n> 可能是 Call by sharing\r\n\r\n下面的例子，原始型別的 mtString 傳遞給 target 的結果符合 call by value 的行為\r\n\r\n但當我們將 myObj 傳遞給 target 時，為何也出現和 call by value 的行為相同的結果？\r\n\r\n```javascript\r\nvar myString = \"hello world\";\r\nvar myObj = { prop1: 123 };\r\nfunction setAsLiteralobj(target) {\r\n  console.log(\"target_1: \");\r\n  console.log(target);\r\n  target = {};\r\n  console.log(\"target_2: \");\r\n  console.log(target);\r\n}\r\nsetAsLiteralObj(myString);\r\nconsole.log(myString); // 'hello world'\r\nsetAsLiteralObj(myObj);\r\nconsole.log(myObj);\r\n```\r\n\r\n```log\r\n<!-- setAsLiteralObj(myString) -->\r\n\"target_1: \"\r\n\"hello world\"\r\n\"target_2: \"\r\n[object Object] { ... }\r\n<!-- setAsLiteralObj(myString) -->\r\n\r\n<!-- console.log(myString); // 'hello world' -->\r\n\"hello world\"\r\n<!-- console.log(myString); // 'hello world' -->\r\n\r\n<!-- setAsLiteralObj(myObj); -->\r\n\"target_1: \"\r\n[object Object] {\r\n  prop1: 123\r\n}\r\n\"target_2: \"\r\n[object Object] { ... }\r\n<!-- setAsLiteralObj(myObj); -->\r\n\r\n<!-- console.log(myObj); -->\r\n[object Object] {\r\n  prop1: 123\r\n}\r\n<!-- console.log(myObj); -->\r\n```\r\n\r\n當宣告完 `function setAsLiteralObj()` 後的記憶體位置狀況，`setAsLiteralObj()` 其實是被當成一個變數，指向 `function setAsLiteralObj()` 的內容。\r\n\r\n當呼叫 `setAsLiteralObj()`，此時 `myString` 會將記憶體位置指派給 function 中的 `target` 參數，可以理解為在乎叫 function 時，宣告參數：\r\n\r\n```javascript\r\nvar target = myString;\r\n```\r\n\r\n因此記憶體位置會變成 `myString` 與 `target` 都會指向同一個位置。\r\n\r\n此時在 function 中，將 `target` 透過字面值賦值 `{}`，所以 `target` 會從原本指向 `hello world` 改成指向我們剛創造出來的 `{}`\r\n\r\n當呼叫 function 時傳入的參數為 `object` 時，也是一樣的概念 `setAsLiteralObj(myObj)`，`myObj` 會被指派給 function 的參數 `target`。此時，`target` 與執行 `setAsLiteralObj(myString)` 時的 `target` 不同，下面將以 `target'` 代稱被指配 `myObj` 的新 `target`。\r\n\r\n在 `target = {}` 時，`target'` 被賦值 `{}`，因此原來 `target'` 從原本指向 `{prop1: 123}` 改成指向剛剛創造出來的 `{}` 位置。\r\n\r\n結果就是 `myString` 和 `myObj` 依然指向原來的記憶體物件，而這些記憶體物件的內容都沒有被改變，改變的只有 `target` 和 `target'` 指向的記憶體位置而已\r\n\r\n## 存取資料的方法\r\n\r\n- 基本類型：傳值(pass by value)\r\n- 物件類型：傳址(pass by reference)、pass by sharing\r\n\r\n### 基本型別\r\n\r\n當一個變數被賦予基本型別的值時，整個值就會存在記憶體中。\r\n\r\n當複製基本型別的值到另一個變數時，只會複製他們的值，而該兩變數並不會影響到對方。\r\n\r\n這個情況稱作傳值。\r\n\r\n```javascript\r\nvar box1 = 10;\r\nvar box2 = \"hello\";\r\n\r\n//拷貝box1,box2的值\r\nvar boxA = box1;\r\nvar boxB = box2;\r\n\r\nboxA = 30;\r\nboxB = \"goodbye\";\r\n\r\nconsole.log(box1, box2, boxA, boxB); // 10,\"hello\",30,\"goodbye\"\r\n```\r\n\r\n一開始 boxA 和 boxB 只是各自複製了 box1 和 box2 的值，boxA 和 box1，以及 boxB 和 box2 是沒有關係的，所以當要重新賦值給 boxA. boxB 時，box1, box2 不會受到影響。\r\n\r\n### 物件型別\r\n\r\n當變數被賦予是物件型別的資料時，記憶體會被存放該物件在記憶體中的位置，並引用該地址來指向該物件。\r\n\r\n當複製一個物件到另一個變數時，複製的是該物件的地址，若此物件有被修改，所有引用該物件的變數，值都會被修改\r\n\r\n```javascript\r\nvar user = {\r\n  name: \"Mary\",\r\n  age: 30,\r\n};\r\n\r\n//拷貝user物件的地址\r\nvar userCopy = user;\r\nuserCopy.age = 20;\r\n\r\nconsole.log(user); // {name: 'Mary', age:20}\r\nconsole.log(userCopy); // {name: 'Mary', age:20}\r\nconsole.log(user === userCopy); // true\r\n```\r\n\r\n但若將變數重新賦予一個新變數\r\n\r\n```javascript\r\nvar user = {\r\n  name: \"Mary\",\r\n  age: 30,\r\n};\r\n\r\nvar userCopy = user;\r\n\r\nuserCopy = {\r\n  name: \"Mary\",\r\n  age: 20,\r\n};\r\n\r\nconsole.log(user); // {name: Mary\", age: \"30\"}\r\nconsole.log(userCopy); // {name: Mary\", age: \"20\"}\r\nconsole.log(user === userCopy); // false\r\n```\r\n\r\n當一個變數被重新賦予一個新的物件，並非修改該物件，因此地址整個變了，並指向另一個新的物件。\r\n\r\n### 把基本型別當作參數傳入函式\r\n\r\n當我們把基本型別當作參數傳入函式時，函式的參數會複製那些基本型別的值，所以在函式外的變數並不會被影響。\r\n\r\n```javascript\r\nvar box1 = 100;\r\nvar box2 = 200;\r\n\r\nfunction add(a, b) {\r\n  a = 10;\r\n  b = 20;\r\n}\r\n\r\nadd(box1, box2);\r\nconsole.log(box1, box2); //100,200\r\n```\r\n\r\n以上例子中，像之前提及的傳值概念一樣，a 和 b 複製了 box1, box2 的值。即使修改 a 和 b，box1, box2 都不會被修改。\r\n\r\n### Function\r\n\r\n> 可以將 javascript 的 function 看做是可執行的物件，其有兩大特性：\r\n>\r\n> 是 first-class Object\r\n> 有自己的 Scope\r\n\r\n#### First-class Object\r\n\r\n對物件型別能做的事情，也能對 function 做\r\n\r\n- 將 function 自由指派給變數或屬性\r\n\r\n  ```javascript\r\n  function myFunction() {\r\n    console.log(\"This is myFunction\");\r\n  }\r\n  var a = myFunction,\r\n    myObj = { fn: myFunction };\r\n  console.log(a); // f myFunction() { console.log('This is  myFunction'); }\r\n  console.log(myObj.fn); // f myFunction() { console.log('This is  myFunction'); }\r\n  a(); // \"This is myFunction\"\r\n  myObj.fn(); // \"This is myFunction\"\r\n  ```\r\n\r\n  function 可以自由指派給其他參數，當印出 `a`/`myObj.fn` 時，會 log 整個 `myFunction` 的內容。此時變數/屬性的內容是 `myFunction`，因此當加上 `()`，就會執行 function。\r\n\r\n- 為 function 加上屬性\r\n\r\n  ```javascript\r\n  function myFunction() {\r\n    console.log(\"This is myFunction\");\r\n  }\r\n  myFunction.prop1 = \"This is prop1\";\r\n  console.log(myFunction.prop1); // \"This is prop1\"\r\n  myFunction(); // \"This is myFunction\"\r\n  ```\r\n\r\n- 當作 Expression 使用\r\n  `function` 可以搭配各種運算元用，甚至也可以放在 if 中判斷\r\n\r\n  if 判斷的是 `function` 是否被正式宣告，未加上 `()` 時，`function` 不會被執行\r\n\r\n  ```javascript\r\n  function myFunction() {\r\n    console.log(\"This is myFunction\");\r\n  }\r\n  console.log(!myFunction); // false\r\n  ```\r\n\r\n- 可以在任何地方宣告\r\n  和物件一樣，可以在任何地方宣告，也可以在 function 中宣告一個 function，甚至在傳入參數時宣告\r\n\r\n  ```javascript\r\n  function myFunction(callback) {\r\n    console.log(\"This is myFunction\"); // This is myFunction\r\n    callback(); // This is myCallback\r\n    function myInnerFunction() {\r\n      console.log(\"This is myInnerFunction\");\r\n    }\r\n    myInnerFunction(); // This is myInnerFunction\r\n  }\r\n  myFunction(function myCallback() {\r\n    console.log(\"This is myCallback\");\r\n  });\r\n  ```\r\n\r\n#### 宣告 function\r\n\r\n宣告的方法主要有三種：\r\n\r\n- function declaration\r\n\r\n  ```javascript\r\n  function myFunction() {\r\n    console.log(\"Function declared with Function declaration\");\r\n  }\r\n  ```\r\n\r\n- function expression\r\n  function 可以被傳遞給其他參數儲存。如字面值一般， function 也可以在定義的同時賦予變數。\r\n\r\n  ```javascript\r\n  var myFunction = function NamedFunction() {\r\n    console.log(\"Function declared with Function expression\");\r\n  };\r\n  myFunction(); // \"Function declared with Function expression\"\r\n  ```\r\n\r\n  也因為此宣告方式會將 function 傳遞給一個變數，因此 javascript 允許 function 搭配匿名函式使用：\r\n\r\n  ```javascript\r\n  var myFunction = function () {\r\n    console.log(\"Function declared with Function expression\");\r\n  };\r\n  myFunction(); // \"Function declared with Function expression\"\r\n  ```\r\n\r\n- with function constructor\r\n  和其他的內建物件型別相同，function 也可以利用 new 來新增物件\r\n\r\n  ```javascript\r\n  var myFunction = new Function(\"parameter1\", \"parameter2\", \"console.log('Function declared with Function Constructor')\");\r\n  myFunction(); // Function declared with Function Constructor\r\n  ```\r\n\r\n  若用 function expression 也有相同效果\r\n\r\n  ```javascript\r\n  var myFunction = function (parameter1, parameter2) {\r\n    console.log(\"Function declared with Function expression\");\r\n  };\r\n  myFunction(); // \"Function declared with Function expression\"\r\n  ```\r\n\r\n  因此一般而言會使用 function expression 取代 new 來增加易讀性與效能\r\n\r\n#### 呼叫 function\r\n\r\n- 一般呼叫\r\n  在 function 後面加上 `()` 就可以呼叫 function\r\n\r\n  ```javascript\r\n  myFunction();\r\n  ```\r\n\r\n- 使用 function 內建函式呼叫\r\n  function 中有內建 `call` 和 `apply` 函式可以用來呼叫 function\r\n  和使用 `()` 來執行 function 的差別在於內建函式具有明確指定 this 的功能。\r\n\r\n  ```javascript\r\n  var myFunction = function (parameter1, parameter2) {\r\n    console.log(parameter1, parameter2);\r\n  };\r\n  myFunction.call(null, \"hello world\", 123); // \"hello world\" 123\r\n  myFunction.apply(null, [\"hello world\", 123]); // \"hello world\" 123\r\n  ```\r\n\r\n  `call` 和 `apply` 函式的差異在於 apply 的第二個參數為陣列，裡面帶要傳入 `function` 的參數，因此在範例中可以看到 `apply` 的第二個參數為 `['hello world', 123]`，這兩個參數會被攤開為 `parameter1` 和 `parameter2` 後放入 `myFunction` 中執行\r\n\r\n- 使用 new 呼叫\r\n  使用 new 代表 function 當作建構式來使用，會回傳子行別為該 function 的物件\r\n\r\n  ```javascript\r\n  function myFunction() {\r\n    console.log(\"Function declared with Function expression\");\r\n  }\r\n  var a = new myFunction(); // \"Function declared with Function expression\"\r\n  console.log(a); // myFunction {}\r\n  ```\r\n\r\n#### IIFF (Immediately Invoked Function Expression) 或稱自我調用函式\r\n\r\nIIFE 有兩種特性：\r\n\r\n- 當程式執行到 IIFE 的宣告位置時，IIFE 會自動執行\r\n- 為一種 function expression\r\n\r\n```javascript\r\n// 格式\r\n(function () {\r\n  // some codes\r\n})();\r\n\r\n// 實際範例\r\n(function () {\r\n  console.log(\"This is IIFE\"); // \"This is IIFE\"\r\n})();\r\n```\r\n\r\n不需要額外呼叫就會自己執行，重點除了包裹 function 的 `()` 外，還有用來呼叫 function 的 `()`。\r\n\r\n若未加上最後面呼叫 function 的 `()`，此 function 便不會自動執行。\r\n\r\nIIFE 回傳值\r\n\r\n```javascript\r\nvar myString = (function () {\r\n  return \"This is IIFE\";\r\n})();\r\nconsole.log(myString); // This is IIFE\r\n```\r\n\r\nIIFE 除了會自動執行以外，與一般 function 的特性都是一模一樣的。\r\n\r\n#### Scope 作用域\r\n\r\n> Scope: 規範哪些變數在哪些程式碼中可以取用的規則\r\n>\r\n> javascript 和大多數的語言都是採用 Lexical Scope(語彙範疇)\r\n\r\n##### Lexical Scope(語彙範疇)\r\n\r\n代表著區塊間的包裹關係，被包裹在內層的區塊可以保護自己的變數不被外層取用；相反的，外層區域的變數還是可以被內層區塊使用\r\n\r\n```javascript\r\nvar outer = \"From Outer\";\r\nfunction myFunction() {\r\n  var inner = \"From Inner\";\r\n  console.log(outer); // \"From Outer\"\r\n  console.log(inner); // \"From Inner\"\r\n}\r\nconsole.log(outer); // \"From Outer\"\r\nconsole.log(inner); // Uncaught ReferenceError: inner is not defined\r\n```\r\n\r\n在 function 的 `{}` 區塊中宣告一個新的變數 `inner`，此一變數可以在 `myFunction(){}` 的區塊裡被取用，然而當 `myFunction(){}` 區塊外試圖取用 `inner` 時，就會發生 `innerVar is not defined` 的錯誤。\r\n\r\n##### 參數也屬於內層 scope\r\n\r\n```javascript\r\nvar myString = \"hello world\";\r\nfunction setAsLiteralObj(target) {\r\n  target = {};\r\n}\r\nsetAsLiteralObj(myString);\r\nconsole.log(myString); // 'hello world'\r\nconsole.log(target); // Uncaught ReferenceError: target is not defined\r\n```\r\n\r\n執行 `setAsLiteralObj(myString);` 時，`myString` 會將記憶體位置指派給 `function` 中新的參數 `target`，也就是 `target` 是再執行 `setAsLiteralObj` 時才建立的新參數，新參數 `target` 是屬於 `setAsLiteralObj` 這個 `function` 區塊，因此在外層印 `target` 時，一樣會得到錯誤訊息。\r\n\r\n##### 巢狀 scope\r\n\r\n```javascript\r\nvar outer = \"outer\";\r\nfunction myFunction() {\r\n  // --- 內層 ---\r\n  var middle = \"middle\";\r\n  function myInnerFunction() {\r\n    // ~~~ 最內層 ~~~\r\n    var inner = \"inner\";\r\n    // ~~~ 最內層 ~~~\r\n  }\r\n  myInnerFunction();\r\n  // --- 內層 ---\r\n}\r\n\r\nmyFunction();\r\n```\r\n\r\n## 運算式與運算子\r\n\r\n### 嚴謹模式\r\n\r\n- 宣告在主程式開頭：Global Scope，所有的程式都會在嚴謹模式下執行。\r\n- 宣告在函數開頭：Function Scope，只有該函數內的程式會在嚴謹模式下執行。\r\n\r\n```javascript\r\nvar chang = 100; // 將變數chang改成99\r\nchag = 99; // 拼錯字\r\nconsole.log(chang); // 100\r\n\r\n(\"use strict\");\r\nvar chang = 100;\r\nchag = 99; // // ReferenceError: chag is not defined\r\n```\r\n\r\n- 嚴謹模式需要明確的宣告，未明確宣告`this`也會失效，這樣比較不會因為拼錯字而產生污染\r\n- 在非嚴謹模式下如果沒有用 var 宣告變數，而直接賦值，會直接將此變數作宣告\r\n- 嚴謹模式下並不會幫你執行，程式完全不跑\r\n\r\n### 賦值運算子\r\n\r\n- 賦值\r\n- 賦予左方運算元與右方運算元相同之值。`x = y` 會把`y`的值賦予給`x`。\r\n\r\n```javascript\r\nx = y;\r\n```\r\n\r\n- 加法賦值\r\n\r\n```javascript\r\nx += y;\r\nx = x + y;\r\n```\r\n\r\n- 減法賦值\r\n\r\n```javascript\r\nx -= y;\r\nx = x - y;\r\n```\r\n\r\n### 比較運算子\r\n\r\n`==`：等於\r\n\r\n`!=`：不等於\r\n\r\n- 如果運算元相同型別，就使用嚴格比較去檢驗。\r\n- null 跟 undefined 相同。\r\n- 運算元一個是數值，一個是字串，會將字串轉數字，再進行比較。\r\n- 其中一個是 true 或 false 會轉成數字的 1 或 0，再進行比較。\r\n- 其中一個是物件，另一個是字串或數值，物件會先轉成基型值，再進行比較。\r\n\r\n`===`：嚴格等於\r\n\r\n`!==`：嚴格不等於\r\n\r\n- 先判斷運算元的型別是否相同，若不相同，結果為 false。\r\n- null 與 undefined 都跟自己相等。\r\n- true 與 false 都跟自己相等。\r\n- NaN 不等於任何值，包括自己。\r\n- 只要是 number 型別的值一樣，他們就相等。\r\n- 0 跟-0 相等。\r\n- string 長度跟內容不一樣，包括空白，它們就不相等。\r\n- 如果參考至同一個物件、陣列、函式，相同的記憶體位置，他們就相等，若無，就算內容的值一樣，它們也不相等，不同的記憶體位置存相同的值。\r\n\r\n```javascript=\r\nconsole.log('1' === 1); //false\r\nconsole.log(null === null); //true\r\nconsole.log(undefined === undefined); //true\r\nconsole.log(null === undefined); //false\r\nconsole.log(NaN === NaN); //false\r\nconsole.log(NaN !== NaN); //true\r\nconsole.log('ABC' === 'ABC '); //false\r\n```\r\n\r\n`>`：大於\r\n\r\n`>=`：大於等於\r\n\r\n`<`：小於\r\n\r\n`<=`：小於等於\r\n\r\n注意：`=>`不是運算子，是箭頭函式。\r\n\r\n### 算數運算子\r\n\r\n- `%` 回傳兩個運算元相除後的餘數。\r\n\r\n```javascript\r\ncount = 12 % 5;\r\nconsole.log(count); // 回傳 2\r\n```\r\n\r\n- `++` 將運算元增加 1。\r\n\r\n```javascript\r\nx = 3;\r\nx++;\r\nconsole.log(x); // 回傳4，設定之後回傳\r\n\r\n++x;\r\nconsole.log(x); // 回傳3，回傳之後再設定\r\n```\r\n\r\n- `--` 將運算元減少 1。\r\n\r\n```javascript\r\nx = 3;\r\nx--;\r\nconsole.log(x); // 回傳2，設定之後回傳\r\n\r\n--x;\r\nconsole.log(x); // 回傳3，回傳之後再設定\r\n```\r\n\r\n### 邏輯運算子\r\n\r\n- `&&` // `and` 前後全部為 `true` ，才會是 `true`，否則都返回 `false`\r\n- `||` // `or` 前後只要一個是 `true` 就會返回 `true`，除非全部都是 `false`\r\n- `!` // `not` 將後面的值做反向，如果是 `true` 就返回 `false`，如果是 `false` 就返回 `true`\r\n- `!!` // `true`反轉再反轉，返回原本的布林值。\r\n  大多用在轉換一些可以形成布林值的情況。\r\n  而經過`!!`運算後，只會很單純出現`true` or `false`，可以單純化減少某些特殊情況出錯的機率。\r\n  例如：希望\"空字串\"和`null`被視為完全相同時\r\n\r\n  ```javascript\r\n  const a = \"\";\r\n  const b = null;\r\n\r\n  a === b; // false\r\n  !!a === !!b; // true\r\n  ```\r\n\r\n- 短路邏輯(短路解析)  \r\n  Javascript 裡面只要是 `0`、`\"\"`、`null`、`false`、`undefined`、`NaN` 都會被判定為 `false`\r\n\r\n  - 用 || 來設定變數預設值  \r\n    如果 obj 存在的話就維持原樣，如果不存在就給予空物件\r\n\r\n    ```javascript\r\n    if (!obj) {\r\n      obj = {};\r\n    }\r\n\r\n    //短路邏輯的寫法\r\n    var obj = obj || {};\r\n    ```\r\n\r\n  - 用 && 來檢查物件與屬性值\r\n\r\n    ```javascript\r\n    var name = o && o.getName();\r\n    ```\r\n\r\n  - 用 || 來簡化程式碼\r\n\r\n    ```javascript\r\n    if (!obj) {\r\n      call_function();\r\n    }\r\n    obj || call_function();\r\n    ```\r\n\r\n  - 用 && 來簡化程式碼\r\n\r\n    ```javascript\r\n    var a = 1;\r\n    if (a == 1) {\r\n      alert(\"a=1\");\r\n    }\r\n    a == 1 && alert(\"a=1\");\r\n    ```\r\n\r\n  - 用 && 、|| 來簡化程式碼\r\n\r\n    ```javascript\r\n    var a = 3,\r\n      b;\r\n    if (a == 3) {\r\n      b = 1;\r\n    } else if (a == 5) {\r\n      b = 2;\r\n    } else {\r\n      b = 3;\r\n    }\r\n    b = (a == 3 && 1) || (a == 5 && 2) || 3;\r\n    ```\r\n\r\n  - 善用 ! 的轉換\r\n\r\n    ```javascript\r\n    if (obj !== \"null\" && obj !== \"undefined\") {\r\n      //....\r\n    }\r\n    if (!!obj) {\r\n      //....\r\n    }\r\n    ```\r\n\r\n### 其餘運算子與展開運算子 `...`\r\n\r\n- 其餘運算子\r\n\r\n  假設要將一個陣列的值相加後取平均\r\n\r\n  ```javascript\r\n  let arr = [1, 2, 3, 4, 5];\r\n\r\n  let avg = function (arr) {\r\n    let sum = 0;\r\n    for (let i = 0; i < arr.length; i++) {\r\n      sum += arr[i];\r\n    }\r\n    return sum / arr.length;\r\n  };\r\n\r\n  console.log(avg(arr)); //  3\r\n  ```\r\n\r\n  但若呼叫 function 時，不是傳入陣列，而是傳入多個參數\r\n\r\n  最後得到的結果會是 NaN\r\n\r\n  ```javascript\r\n  let avg = function (arr) {\r\n    let sum = 0;\r\n    for (let i = 0; i < arr.length; i++) {\r\n      sum += arr[i];\r\n    }\r\n    return sum / arr.length;\r\n  };\r\n\r\n  console.log(avg(1, 3, 5, 7, 9)); // NaN\r\n  ```\r\n\r\n  運用其餘運算子`...`，將輸入函式中的參數值變成陣列的形式\r\n\r\n  ```javascript\r\n  let avg = function (...arr) {\r\n    console.log(arr); // [1,3,5,7,9]\r\n    let sum = 0;\r\n    for (let i = 0; i < arr.length; i++) {\r\n      sum += arr[i];\r\n    }\r\n    return sum / arr.length;\r\n  };\r\n\r\n  console.log(avg(1, 3, 5, 7, 9)); // 5\r\n  ```\r\n\r\n- 展開運算子\r\n\r\n  關鍵字與其餘運算子相同，但功能與其餘運算子相反，展開運算子可以把陣列中的元素取出。\r\n\r\n  假設要用 `Math.max()` 來找出最大值，但傳入的參數為陣列，此時會得到 NaN\r\n\r\n  ```javascript\r\n  let number = [1, 2, 3, 4, 5, 6, 7, 8];\r\n\r\n  console.log(Math.max(number)); // NaN\r\n  ```\r\n\r\n  運用展開運算子將陣列展開成許多數值\r\n\r\n  ```javascript\r\n  let number = [1, 2, 3, 4, 5];\r\n\r\n  console.log(Math.max(...number)); // 5\r\n\r\n  console.log(...number); // 1,2,3,4,5\r\n  ```\r\n\r\n### 三元運算式\r\n\r\n```javascript\r\ncondition ? val1 : val2;\r\n```\r\n\r\n- 如果條件為 true ，此時回傳[數值 / 運算式（1）]\r\n- 如果條件為 false，此時回傳[數值 / 運算式（2）]\r\n\r\n```javascript\r\nvar status = \"\";\r\nif (a < 60) {\r\n  status = \"不及格\";\r\n} else {\r\n  status = \"及格\";\r\n}\r\n\r\n// 三元運算式\r\nvar status = a < 60 ? \"不及格\" : \"及格\";\r\n```\r\n\r\n### if else\r\n\r\n```javascript\r\nif (A) {\r\n  //  A = True 執行這邊\r\n} else if (B) {\r\n  //  A = False and B = True 執行這邊\r\n} else {\r\n  //  A = False and B = False 執行這邊\r\n}\r\n```\r\n\r\n- 判斷式括號裡會強制轉成布林值\r\n- `null` 跟 `undefined` 和 `NaN` 在 if 判斷時值都會轉換為 `false`\r\n\r\n## 流程判斷與迴圈\r\n\r\n### switch\r\n\r\n```javascript\r\nswitch (expression) {\r\n  // expression => 表達式，用來跟每個case做比較\r\n  case value1:\r\n    //當 表達式 的值符合 value1\r\n    //要執行的陳述句\r\n    break;\r\n  case value2:\r\n    //當 表達式 的值符合 value2\r\n    //要執行的陳述句\r\n    break;\r\n  default:\r\n    //當 表達式 的值都不符合上述條件\r\n    //要執行的陳述句\r\n    break;\r\n}\r\n```\r\n\r\n- 如果忘記放 break，則當下的 case 執行完之後，會直接往下一個 case 執行，直到遇見 break\r\n\r\n```javascript\r\nswitch (表達式) {\r\n  case x:\r\n  case y:\r\n  case z:\r\n    //如果有多項條件，要執行同一陳述句可以合併撰寫\r\n    // code block\r\n    break;\r\n  case a:\r\n  case b:\r\n  case c:\r\n    // code block\r\n    break;\r\n}\r\n```\r\n\r\n### while 迴圈\r\n\r\n```javascript\r\nwhile ((A = x)) {\r\n  陳述句; // 當條件式\"A\"成立的時候，就重複做\"陳述句\"\r\n  break; // 遇到 break 就會停止，否則就會繼續執行，直到 A = F\r\n}\r\n```\r\n\r\n- 完成之後再回去檢查\"A\"，成立就做\"B\"\r\n- 直到\"A\"不成立，才會離開\r\n\r\n```javascript\r\ndo {\r\n  // 放要重複做的事情，會先執行一次再進入判斷\r\n} while (判斷式);\r\n```\r\n\r\n### for 迴圈\r\n\r\n```javascript\r\nfor (var i = 0; i < 10; i++) {\r\n  // 要被執行的陳述句\r\n  // for迴圈會產生出從\"i = 0\"開始到\"i < 10\"的長度\r\n  // 可以當作計數器，每數一次就執行一次陳述句\r\n}\r\n\r\n// for (statement 1; statement 2; statement 3){}\r\n// Statement 1 執行程式之前做一次\r\n// Statement 2 執行程式的條件\r\n// Statement 3 執行程式後每次執行\r\n\r\nfor (var i = 0; i < 10; i++) {\r\n  // 也可以在迴圈裡加入判斷式取\"i\"的值\r\n  if (i % 2 == 0) {\r\n    continue; //跳過這次不做\r\n  }\r\n  if (i == 7) {\r\n    break; //跳出整個for迴圈\r\n  }\r\n\r\n  console.log(i); // ans = \"1  3  5\" 7跟9已經跳出迴圈，所以不會被執行出\r\n}\r\n```\r\n\r\n### for of\r\n\r\n```javascript\r\nvar 物件 = [\"A\", \"B\", \"C\", \"D\"];\r\nfor (const 變數1 of 物件1) {\r\n  // 大多使用在陣列，或是其他需要查找物件的內容物\r\n}\r\n\r\nlet 字串 = \"ES6\"; //例如用來查找字串或數列等等\r\nfor (let 變數2 of 字串) {\r\n  console.log(變數2); // \"E\", \"S\", \"6\"\r\n}\r\n```\r\n\r\n### for in\r\n\r\n```javascript\r\nvar 物件2 = {\r\n  AA: 100,\r\n  BB: 20,\r\n};\r\nfor (變數3 in 物件2) {\r\n  //會逐一尋找物件裡的屬性\r\n  //且只顯示有值的資料出來\r\n  console.log(物件2); //此時出現的是物件裡的字串\r\n  console.log(物件2[變數3]); //此時出現的是物件裡的數值\r\n}\r\n\r\nvar 物件3 = [10, 20, 30];\r\n物件3[6] = 999; //這時物件3的陣列[10, 20, 30, nill]\r\n```\r\n\r\n## 函式 function\r\n\r\n> function 是物件的一種\r\n\r\n### 定義函式\r\n\r\n- 函式宣告\r\n\r\n  ```javascript\r\n  function name(params) {\r\n    // do some things\r\n  }\r\n  ```\r\n\r\n- 函式運算式\r\n\r\n  透過匿名函式將變數賦值\r\n\r\n  ```javascript\r\n  var squsre = function (params) {\r\n    return params;\r\n  };\r\n  ```\r\n\r\n  若在 function 加上名稱時，這個名稱只在\"自己函式的區塊內有效\"\r\n\r\n  ```javascript\r\n  var square = function func(number) {\r\n    console.log(typeof func); // \"function\"\r\n    return number * number;\r\n  };\r\n\r\n  console.log(typeof func); // undefined\r\n  ```\r\n\r\n- 透過 new 關鍵字建立函式\r\n\r\n```javascript\r\n// F 要大寫\r\nvar square = new Function(\"number\", \"return number * number\");\r\n```\r\n\r\n透過關鍵字建立的函式物件，每次執行時都會進行解析字串的動作(如：`'return number * number'`)\r\n\r\n### 箭頭函式\r\n\r\n```javascript\r\nfunction test(a) {\r\n  return a + 1; // 將物件、運算結果傳出到呼叫點\r\n}\r\n\r\nvar test = function (a) {\r\n  return a + 1;\r\n};\r\n\r\nvar test = (a) => {\r\n  return a + 1;\r\n};\r\n\r\nvar test = (a) => a + 1; //最終省略了function和return\r\n\r\nvar answer = test(5); //呼叫點，test(5)會將刮號內的參數傳到function的刮號(a)中\r\n```\r\n\r\n- 箭頭函式僅用於 function 內只有一條運算式時\r\n\r\n### 變數的有效範圍 (Scope)\r\n\r\n> 全域變數和區域變數的差異\r\n\r\n```javascript\r\nvar x = 1;\r\n\r\nvar someThingHappened = function (y) {\r\n  var x = 100;\r\n  return x + y;\r\n};\r\n\r\nconsole.log(someThingHappened(50)); // 150\r\nconsole.log(x); // 1\r\n```\r\n\r\n切分變數有效範圍的最小單位是 `function`\r\n\r\n因此在 function 中透過 var 宣告的變數，其作用範圍僅限於這個函式。\r\n\r\n此例中在一開始宣告的變數 x 與在 function 內部宣告的變數 x 為兩個不同變數。\r\n\r\n若 function 中沒有宣告新變數，則會一層一層往外尋找，直到全域變數為止\r\n\r\n```javascript\r\nvar x = 1;\r\n\r\nvar doSomeThing = function (y) {\r\n  x = 100;\r\n  return x + y;\r\n};\r\n\r\nconsole.log(doSomeThing(50)); // 150\r\nconsole.log(x); // 100\r\n```\r\n\r\n此例中，function 中未宣告新變數 x，因此 javascript 向外層尋找同名的變數，直到最外層的全域變數，並將其賦值。\r\n\r\n### 提升(Hoisting)\r\n\r\n#### 變數提升\r\n\r\n當 Scope 中的變數有被宣告，即使在宣告之前即調用變數，javascript 會將先告的語法拉到此 scope 的上面\r\n\r\n```javascript\r\nvar x = 1;\r\n\r\nvar doSomeThing = function (y) {\r\n  console.log(x); // undefined\r\n\r\n  var x = 100;\r\n  return x + y;\r\n};\r\n\r\nconsole.log(doSomeThing(50)); // 150\r\nconsole.log(x); // 1\r\n```\r\n\r\n對編譯器而言此，這段程式碼會是這個樣子\r\n\r\n```javascript\r\nvar x = 1;\r\n\r\nvar doSomeThing = function (y) {\r\n  var x; // 宣告的語法被拉到上面\r\n  console.log(x); // undefined\r\n  x = 100;\r\n  return x + y;\r\n};\r\n\r\nconsole.log(doSomeThing(50)); // 150\r\nconsole.log(x); // 1\r\n```\r\n\r\n#### 函式提升\r\n\r\n透過\"函式宣告\"方式定義的函式可以在宣告前使用\r\n\r\n```javascript\r\nsquare(2); // 4\r\n\r\nfunction square(number) {\r\n  return number * number;\r\n}\r\n```\r\n\r\n而透過\"函式運算式\"定義的函式則是會出現錯誤\r\n\r\n```javascript\r\nsquare(2); // TypeError: square is not a function\r\n\r\nvar square = function (number) {\r\n  return number * number;\r\n};\r\n```\r\n\r\n除呼叫時機不同，此兩者在執行時無明顯差異\r\n\r\n#### 為何會有 Hoisting 的現象？\r\n\r\n> javascript 中的 Compiler(編譯器) 和 Engine (引擎) 執行的順序，造成提升的特性\r\n\r\n- 變數宣告屬於 compiler 的工作\r\n  javascript compiler 會將程式碼解析成有意義的語法結構，轉換成機器可以理解的目的碼。接著 compiler 會建立所有的變數，保留其記憶體空間，並且繫結到所屬的 scope 上面。也就是說，程式開始一行一行執行前，會先將所有變數宣告好。\r\n\r\n- 初始化、賦值屬於 engine 的工作\r\n  在 compiler 好之後，engine 才會開始一行一行的執行程式，也就是初始化、賦值的這個動作也是由 engine 在編譯好之後，等待被執行的程式碼之一。\r\n\r\n#### 最佳實踐\r\n\r\n1. 宣告變數應集中在燈前 scope 的最上面\r\n\r\n### 全域變數\r\n\r\n其實在 javascript 中並無所謂\"全域變數\"，所謂全域變數指的是\"全域物件\"(亦稱作\"頂層物件\")的屬性。\r\n\r\n以瀏覽器而言，全域物件指的是 `window`，在 node 的環境中則叫做 `global`。\r\n\r\n- 全域物件的屬性\r\n\r\n  於外層透過 var 宣告一個變數 a，當我們調用 `window.a` 會回傳我們宣告的此一變數\r\n\r\n  ```javascript\r\n  var a = 10;\r\n  console.log(a); // 10\r\n  ```\r\n\r\n- 變數的作用範圍，最小的的切分單位為 function\r\n- 即使是寫在函式中，沒有 var 宣告的變數，會變成全域變數\r\n- 全域變數指的是全域物件(頂層物件)的屬性\r\n\r\n> ### 附註\r\n>\r\n> 在 javascript ES6 之後有新的宣告方法 let 與 const，分別定義\"變數\"與\"常數\"\r\n> 和 var 不同的是，他們的作用區域是透過大括號`{}`來切分的\r\n\r\n## 方法\r\n\r\n### 取得 base_url\r\n\r\n- 在 html 加入 meta 標籤\r\n\r\n  ```html\r\n  <head>\r\n    <meta name=\"base-url\" content=\"{{ url('/') }}\" />\r\n  </head>\r\n  ```\r\n\r\n- 此時就可以透過 meta 標籤取得 base_url\r\n\r\n  ```javascript\r\n  window.base_url = document.head.querySelector('meta[name=\"base-url\"]');\r\n  ```\r\n\r\n### document\r\n\r\n#### `.querySelector()` 元素選擇器\r\n\r\n用法和 css 一樣，選取 id 元素時用 `#`，選取 class 元素時用 `.`\r\n\r\n```javascript\r\ndocument.querySelector(\".title\");\r\n```\r\n\r\n#### `.querySelectorAll()` 選取所有指定元素\r\n\r\n用法和 `.querySelector()` 一樣，但不同於 `.querySelector()`，`.querySelectorAll()` 可以一次選取所有具有相同元素的內容\r\n\r\n### prototype.forEach()\r\n\r\nforEach 會修改原始陣列，且不會回傳值\r\n\r\n```javascript\r\nvar forEachIt = people.forEach(function (item, index, array) {\r\n  console.log(item, index, array); // 物件, 索引, 全部陣列\r\n  return item; // forEach 沒在 return 的，所以這邊寫了也沒用\r\n});\r\nconsole.log(forEachIt); // undefined\r\n\r\npeople.forEach(function (item, index, array) {\r\n  item.age = item.age + 1; // forEach 就如同 for，不過寫法更容易\r\n});\r\n\r\nconsole.log(people); // 全部 age + 1\r\n```\r\n\r\n### prototype.map()\r\n\r\n使用 map 時會需要回傳一個值，他會透過函式內所回傳的值組成一個陣列。\r\n\r\n- 如不回傳，則為 undefined\r\n- 回傳長度等於原始長度\r\n\r\nmap 很適合將原始的變數運算後，重新組合成一個新的陣列。\r\n\r\n使用語法：\r\n\r\n```Javascript\r\nconst newArr = arr.map(function (value, index, array){\r\n  //...\r\n});\r\n```\r\n\r\n- `newArr` 處理後的新陣列\r\n- `arr` 要執行 map 的舊陣列\r\n- `function` 舊陣列中每個元素要執行的函式\r\n- `value` 陣列中正在處理的值\r\n- `index` 陣列中正在處理的 key 值(可略)\r\n- `array` 舊陣列(可略)\r\n\r\n```javascript\r\nlet A = [9000, 8500, 5500, 6500];\r\nlet B = A.map(function (value, index, array) {\r\n  return value * 2;\r\n});\r\n\r\nconsole.log(A); // [9000, 8500, 5500, 6500] - 原陣列不會被修改\r\nconsole.log(B); // [18000, 17000, 11000, 13000] 回傳新陣列\r\n```\r\n\r\n### prototype.push()\r\n\r\n添加一個或多個元素至陣列末端，並回傳陣列的新長度。\r\n\r\n```javascript\r\narr.push(element1[, ...[, elementN]])\r\n```\r\n\r\n- `elementN` 欲添加至陣列末端的元素\r\n\r\n### `Math.round()` 四捨五入\r\n\r\n```javascript\r\nMath.round(3.14); // 3\r\nMath.round(5.49999); // 5\r\nMath.round(5.5); // 6\r\nMath.round(\"5.50001\"); // 6\r\nMath.round(-5.49999); // -5\r\nMath.round(-5.5); // -5\r\nMath.round(-5.50001); // -6\r\n\r\nlet data = 18.62645;\r\nMath.round(data * 10) / 10; // 18.6\r\nMath.round(data * 100) / 100; // 18.63\r\nMath.round(data * 1000) / 1000; // 18.626\r\n```\r\n\r\n### `Array.prototype.filter()`\r\n\r\n- `arr.filter(function(item, index, array), thisValue)`\r\n  - `item` 必須，目前元素的值\r\n  - `index` 可選，目前元素的 key\r\n  - `array` 可選，目前元素屬於的陣列\r\n  - `thisValue` 可選，物件作為該次呼叫時使用，傳遞給函數當作 `this` 的值，若省略，則 `this` 的值為 `undefined`\r\n\r\n```javascript\r\nvar ages = [32, 33, 12, 40];\r\n\r\nfunction checkAdult(age) {\r\n  return age >= document.getElementById(\"ageToCheck\").value;\r\n}\r\n\r\nfunction myFunction() {\r\n  document.getElementById(\"demo\").innerHTML = ages.filter(checkAdult);\r\n}\r\n```\r\n\r\n若要去除陣列中的空值\r\n\r\n```javascript\r\nvar myArrayNew = myArray.filter((el) => el);\r\n```\r\n\r\n### `Array.prototype.splice()` 新增刪除陣列中的元素\r\n\r\n- `array.splice(start, deleteCount, item)`\r\n\r\n  - start 必填，陣列中要開始改動的元素索引。若索引長度大於陣列長度，則實際開始的索引值會被預設為陣列長度。若索引值為負，則會從陣列中最後一個元素開始往前改動(起始為 -1)，若其絕對值大於陣列長度，則會被設為 0。\r\n  - deleteCount 可選，欲刪除的原陣列數量的整數。若省略，或其值大於可以被刪除的元素數量(從 start 到陣列最後的長度)，則將從 start 開始到陣列最後一個元素全部刪除。若 deleteCount 為 0 或負數，則不會有元素被刪除。\r\n  - item 1, item 2 可選，從 start 開始要加入的元素，若未傳入任何數值，則將 start 到 deleteCount 之間的元素刪除。\r\n\r\n- 從 `[2]` 的位置開始，刪除 0 個元素並插入 `drum`\r\n\r\n  ```javascript\r\n  var myFish = [\"angel\", \"clown\", \"mandarin\", \"sturgeon\"];\r\n  var removed = myFish.splice(2, 0, \"drum\");\r\n\r\n  // myFish 為 [\"angel\", \"clown\", \"drum\", \"mandarin\", \"sturgeon\"]\r\n  // removed 為 []，沒有任何元素被刪除\r\n  ```\r\n\r\n- 從 `[3]` 的位置開始，刪除一個元素\r\n\r\n  ```javascript\r\n  var myFish = [\"angel\", \"clown\", \"drum\", \"mandarin\", \"sturgeon\"];\r\n  var removed = myFish.splice(3, 1);\r\n\r\n  // removed 為 [\"mandarin\"]\r\n  // myFish 為 [\"angel\", \"clown\", \"drum\", \"sturgeon\"]\r\n  ```\r\n\r\n- 從 `[0]` 開始，刪除兩個元素，並插入 \"parrot\", \"anemone\", \"blue\"\r\n\r\n  ```javascript\r\n  var myFish = [\"angel\", \"clown\", \"trumpet\", \"sturgeon\"];\r\n  var removed = myFish.splice(0, 2, \"parrot\", \"anemone\", \"blue\");\r\n\r\n  // myFish 為 [\"parrot\", \"anemone\", \"blue\", \"trumpet\", \"sturgeon\"]\r\n  // removed 為 [\"angel\", \"clown\"]\r\n  ```\r\n\r\n### 物件取值、新增與刪除\r\n\r\n#### 物件取值\r\n\r\n```javascript\r\nvar family = {\r\n  name: \"ma's family\",\r\n  deposit: 1000,\r\n  members: {\r\n    mother: \"mom\",\r\n    father: \"dad\",\r\n  },\r\n};\r\n\r\nconsole.log(family.name); // ma's family\r\nconsole.log(family.members.mother); // mom\r\nconsole.log(family[\"name\"]); // ma's family\r\n```\r\n\r\n用中括號語法，允許以變數的方式取值\r\n\r\n```javascript\r\nvar family = {\r\n  name: \"ma's family\",\r\n  deposit: 1000,\r\n  members: {\r\n    mother: \"mom\",\r\n    father: \"dad\",\r\n  },\r\n};\r\nvar a = \"name\";\r\n\r\nconsole.log(family.a); // undefine\r\nconsole.log(family[a]); // ma's family\r\n```\r\n\r\n`.` 語法是直接以字串的方式尋找該物件的屬性，而 family 物件並無 a 屬性。\r\n但中括號中的語法是將變數 a 的值帶入，相當於 `family['name']`。\r\n\r\n另外，在物件中的屬性一律是字串，因此可以允許各種數字或是特殊字元，但在 `.` 語法中，會受到許多限制。\r\n\r\n```javascript\r\nvar family = {\r\n  name: \"ma's family\",\r\n  deposit: 1000,\r\n  members: {\r\n    mother: \"mom\",\r\n    father: \"dad\"\r\n  },\r\n  1: '1',\r\n  '$-小名家': '$-小名家 string'\r\n};\r\n\r\nconsole.log(family.1) // 語法錯誤\r\nconsole.log(family[1]) // 1\r\n\r\nconsole.log(family.$-小名家) // 語法錯誤\r\nconsole.log(family['$-小名家']) // $-小名家 string\r\n```\r\n\r\n執行物件中的方法，也可以用點語法或是中括號\r\n\r\n```javascript\r\nvar family = {\r\n  name: \"ma's family\",\r\n  deposit: 1000,\r\n  members: {\r\n    mother: \"mom\",\r\n    father: \"dad\",\r\n  },\r\n  callFamily: function () {\r\n    console.log(\"call 2 ma's family\");\r\n  },\r\n};\r\n\r\nfamily.callFamily(); // call 2 ma's family\r\nfamily[\"callFamily\"](); // call 2 ma's family\r\n```\r\n\r\n#### 物件轉為陣列\r\n\r\n陣列本身舉有許多好用的方法：`forEach`, `map`, `reduce`, `find`...，但物件無法使用這些陣列方法\r\n\r\n利用 `Object` 關鍵字，將物件轉為陣列。\r\n\r\n- Object.values 可以直接傳入一個物件，並將物件直接轉為陣列的形式，但無法取得 key 值。\r\n- Object.keys 傳入一個物件，並將其 key 值以陣列方式呈現，僅只取 key 值。\r\n- Object.entries 傳入物件，並同時回傳 key 值與 values，但產生的新結構，會另外用一層陣列組成。\r\n\r\n#### 新增物件屬性\r\n\r\n```javascript\r\nvar family = {\r\n  name: \"ma's family\",\r\n  deposit: 1000,\r\n  members: {\r\n    mother: \"mom\",\r\n    father: \"dad\",\r\n  },\r\n  callFamily: function () {\r\n    console.log(\"call 2 ma's family\");\r\n  },\r\n};\r\n\r\nfamily.dog = \"小豬\";\r\nfamily[\"kitten\"] = \"K Ka貓\";\r\nfamily[\"$\"] = \"money\";\r\nconsole.log(family);\r\n```\r\n\r\n#### 刪除物件屬性\r\n\r\n使用 `delete` 關鍵字\r\n\r\n```javascript\r\nvar family = {\r\n  name: \"ma's family\",\r\n  deposit: 1000,\r\n  members: {\r\n    mother: \"mom\",\r\n    father: \"dad\",\r\n  },\r\n  callFamily: function () {\r\n    console.log(\"call 2 ma's family\");\r\n  },\r\n};\r\n\r\nfamily.dog = \"小豬\";\r\nfamily[\"kitten\"] = \"K Ka貓\";\r\nfamily[\"$\"] = \"money\";\r\n\r\ndelete family.deposit;\r\ndelete family[\"$\"];\r\nconsole.log(family);\r\n```\r\n\r\n### SET 集合\r\n\r\n#### 基本使用\r\n\r\n- set 裡面的值是不會重複的\r\n\r\n```javascript\r\n// new Set Type\r\nlet classroom = new Set(); //  建立教室這個 set\r\nlet Aaron = { name: \"Aaron\", country: \"Taiwan\" };\r\nlet Jack = { name: \"Jack\", country: \"USA\" };\r\nlet Johnson = { name: \"Johnson\", country: \"Korea\" };\r\n\r\n// 把物件放入 set 中\r\nclassroom.add(Aaron);\r\nclassroom.add(Jack);\r\nclassroom.add(Johnson);\r\n\r\n// 檢驗 set 中是否包含某物件\r\nif (classroom.has(Aaron)) console.log(\"Aaron is in the classroom\");\r\n\r\n//  把物件移除 set 中\r\nclassroom.delete(Jack);\r\nconsole.log(classroom.size); //    看看 set 中有多少元素\r\nconsole.log(classroom);\r\n```\r\n\r\n#### 陣列與集合間轉換\r\n\r\n```javascript\r\n// 集合轉成陣列\r\nlet setToArray = [...classroom]; // Array.from(classroom)\r\n\r\n// 陣列轉成集合\r\nlet arrayToSet = new Set(setToArray);\r\n```\r\n\r\n#### 過濾陣列中重複的元素\r\n\r\n利用 set 中元素不會重複的特性，來過濾掉陣列中重複的元素，留下唯一\r\n\r\n```javascript\r\nvar mySet = new Set();\r\n\r\nmySet.add(1); // Set { 1 }\r\nmySet.add(5); // Set { 1, 5 }\r\nmySet.add(\"some text\"); // Set { 1, 5, 'some text' }\r\nvar o = { a: 1, b: 2 };\r\nmySet.add(o); // Set { 1, 5, 'some text', { a: 1, b: 2 } }\r\n\r\n// // o is referencing a different object so this is okay\r\nmySet.add({ a: 1, b: 2 }); // Set { 1, 5, 'some text', { a: 1, b: 2 }, { a: 1, b: 2 } }\r\n```\r\n\r\n### JSON 轉換\r\n\r\n- json 為一組字串\r\n- 在使用 {} 建立物件時，屬性名稱的引號可以省略，但在 json 格式中，屬性名稱一定要有引號。\r\n- 若物件中的值為 function 時，無法透過 json 傳遞。\r\n\r\n#### `JSON.stringify()` 將物件轉為 json 字串\r\n\r\n#### `JSON.parse()` 將 json 字串轉換為物件\r\n\r\n## 屬性描述器\r\n\r\n當對於屬性除了指定 key/value 以外有更進一步的要求時，例如設定屬性為 read-only 甚至是 constant 時，就可以使用屬性描述器。\r\n\r\n屬性的特徵：\r\n\r\n- 資料描述器\r\n  - writable\r\n  - configurable\r\n  - enumerable\r\n  - value\r\n- 存取器描述器\r\n  - get\r\n  - set\r\n\r\n這些特徵都是可以透過屬性描述器去設定的 `Object.defineProperty` 和 `Object.definedProperties`\r\n\r\n### 使用字面值宣告屬性的特徵\r\n\r\n- writable, configurable, enumerable 都會是 true\r\n- value 代表屬性的值\r\n- get, set 則是沒有設定\r\n\r\n### 取得屬性特徵\r\n\r\n若想要瞭解一個屬性的特徵時，可以使用 `Object.getOwnPropertyDescriptor(object, 'propertyName')` 這個內建函式\r\n\r\n```javascript\r\nvar obj = { prop1: \"prop1\", prop2: \"prop2\" };\r\nObject.getOwnPropertyDescriptor(obj, \"prop1\", \"prop2\");\r\n// {\r\n//    value: \"prop1\",\r\n//    writable: true,\r\n//    enumerable: true,\r\n//    configurable: true\r\n// }\r\n```\r\n\r\n使用字面值創建的屬性，其 `writable`, `enumerable`, `configurable` 都會是 `true`，而 `value` 就會是此屬性的值 `prop1`\r\n\r\n對於一次察看多個屬性的特徵，可以使用 `Object.getOwnPropertyDescriptors(object, 'propertyName1', 'propertyName2', ...)`\r\n\r\n```javascript\r\nvar obj = { prop1: \"prop1\", prop2: \"prop2\" };\r\nObject.getOwnPropertyDescriptors(obj, \"prop1\", \"prop2\");\r\n// {\r\n//   prop1: { value: \"prop1\", writable: true, enumerable: true, configurable: true },\r\n//   prop2: { value: \"prop2\", writable: true, enumerable: true, configurable: true }\r\n// }\r\n```\r\n\r\n### Object.defineProperty 設定單一個屬性描述器\r\n\r\n```javascript\r\nObject.defineProperty(object, \"propertyName\", descriptor);\r\n// descriptor 是一個 object，descriptor 裡面的屬性可以是剛剛提到的屬性特徵\r\n```\r\n\r\n在 `obj` 中按需求設定 ‵prop` 這個屬性\r\n\r\n```javascript\r\nvar obj = {};\r\nObject.defineProperty(obj, \"prop\", {\r\n  writable: false,\r\n  configurable: true,\r\n  enumerable: true,\r\n  value: \"This is prop\",\r\n});\r\nconsole.log(obj.prop); // \"This is prop\"\r\n```\r\n\r\n### Object.defineProperties 一次設定多個屬性\r\n\r\n```javascript\r\nObject.definedProperties(object, properties);\r\n\r\n// properties 也是一個 object，其結構如下：\r\n// {\r\n//   'propertyName1': descriptor1,\r\n//   'propertyName2': descriptor1,\r\n//    ...\r\n//   'propertyNamen': descriptorn\r\n// }\r\n```\r\n\r\n```javascript\r\nvar obj = {};\r\nObject.defineProperties(obj, {\r\n  prop1: {\r\n    writable: false,\r\n    configurable: true,\r\n    enumerable: true,\r\n    value: \"This is prop1\",\r\n  },\r\n  prop2: {\r\n    writable: false,\r\n    configurable: true,\r\n    enumerable: true,\r\n    value: \"This is prop2\",\r\n  },\r\n});\r\nconsole.log(obj.prop1); // \"This is prop1\"\r\nconsole.log(obj.prop2); // \"This is prop2\"\r\n```\r\n\r\n### 資料描述器\r\n\r\n> 參考資料：\r\n>\r\n> [JavaScript - 屬性描述器](https://ithelp.ithome.com.tw/articles/10197826)\r\n\r\n#### writable 屬性是否可以改值\r\n\r\n可以將屬性設定為 `read-only`\r\n\r\n當使用屬性的字面值( `obj.prop` 與 `obj[prop]`)定義屬性時，屬性的 writable 為 true，也就代表可以寫入。\r\n\r\n相較之下，當 writable 為 false 就代表此屬性為 read-only\r\n\r\n在非嚴格模式下，還是可以對 read-only 的屬性進行寫值，但會沒有效果。\r\n\r\n```javascript\r\nvar obj = {};\r\nObject.defineProperty(obj, \"prop1\", {\r\n  value: \"This is prop1\",\r\n  configurable: true,\r\n  enumerable: true,\r\n  writable: false, // 將 writable 設為 false\r\n});\r\nconsole.log(obj.prop1); // 'This is prop1'\r\nobj.prop1 = \"This is prop2\";\r\nconsole.log(obj.prop1); // 'This is prop1'\r\n```\r\n\r\n#### Configurable 是否可編輯該屬性\r\n\r\n屬性描述器在一般狀況下，可以利用屬性描述器重新設定，若沒有重新設定，會保留原有的特徵。\r\n\r\n```javascript\r\nvar obj = {};\r\nobj.prop1 = \"This is prop1\";\r\n\r\nObject.defineProperty(obj, \"prop1\", {\r\n  value: \"This is prop1\",\r\n  configurable: true,\r\n  enumerable: true,\r\n  writable: false,\r\n});\r\nconsole.log(obj.prop1); // \"This is prop1\"\r\nobj.prop1 = \"This is prop2\";\r\nconsole.log(obj.prop1); // \"This is prop1\"\r\n```\r\n\r\n上面將 `writable` 設為 `false`，因此無法對 `obj.prop1` 賦值。\r\n\r\n下面實作禁止屬性被重新設定：\r\n\r\n```javascript\r\nvar obj = {};\r\nObject.defineProperty(obj, \"prop1\", {\r\n  value: \"This is prop1\",\r\n  configurable: false,\r\n  enumerable: true,\r\n  writable: true,\r\n});\r\nconsole.log(obj.prop1); // \"This is prop1\"\r\n\r\nObject.defineProperty(obj, \"prop1\", {\r\n  value: \"This is prop1\",\r\n  configurable: true,\r\n  enumerable: true,\r\n  writable: false,\r\n}); // Uncaught TypeError: Cannot redefine property: prop1\r\n\r\ndelete obj.prop1; // false 禁止屬性被刪除\r\nconsole.log(obj.prop1); // \"This is prop1\"\r\n```\r\n\r\n當 `obj.prop1` 已經被設定為 `configurable: false` 時，又試著重新設定屬性描述器一次時，javascript 會報錯。\r\n\r\n即是在非嚴格模式下，都不允許重新設定 `configurable: false` 的屬性描述。\r\n\r\n但有一個特例：在 `configurable: false`，`writable` 特徵還是可以從 `true` 改為 `false`\r\n\r\n#### Enumerable 屬性是否會在物件的屬性列舉時被顯示\r\n\r\n在 `for...in` 的屬性列舉動作中，只有可列舉的屬性會被迭代\r\n\r\n```javascript\r\nvar obj = {};\r\nObject.defineProperty(obj, \"prop1\", {\r\n  value: \"This is prop1\",\r\n  configurable: true,\r\n  enumerable: false,\r\n  writable: true,\r\n});\r\nobj.prop2 = \"This is prop2\";\r\n\r\nconsole.log(\"prop1\" in obj); // true\r\nconsole.log(\"prop2\" in obj); // true\r\nfor (var prop in obj) {\r\n  console.log(\"prop: \", prop); // \"prop: This is prop2\"\r\n}\r\n```\r\n\r\n雖然 `prop1` 和 `prop2` 都存在於物件中(利用 `in` 檢查)，但因為 `obj.prop1` 被設定為 `enumerable: false` 因此在 `for...in` 列舉的動作中，並不會被迭代到。\r\n\r\n相較之下，普通屬性的 `obj.prop2` 可以被列舉。\r\n\r\n- `obj.propertyIsEnumerable` 檢查屬性是否可列舉且為物件自有的\r\n\r\n```javascript\r\nvar obj = { prop1: \"prop1\" };\r\nObject.defineProperty(obj, \"prop2\", {\r\n  value: \"prop2\",\r\n  enumerable: false,\r\n  writable: true,\r\n  configurable: true,\r\n});\r\nobj.propertyIsEnumerable(\"prop1\"); // true\r\nobj.propertyIsEnumerable(\"prop2\"); // false\r\n```\r\n\r\n使用 Object.keys 會將所有可列舉的屬性列成一個陣列\r\n\r\n```javascript\r\nvar obj = { prop1: \"prop1\" };\r\nObject.defineProperty(obj, \"prop2\", {\r\n  value: \"prop2\",\r\n  enumerable: false,\r\n  writable: true,\r\n  configurable: true,\r\n});\r\nObject.keys(obj); // [\"prop1\"]\r\n```\r\n\r\n#### value 屬性的值\r\n\r\n```javascript\r\nvar obj = {};\r\nObject.defineProperty(obj, \"prop1\", {\r\n  value: \"This is prop1\",\r\n  writable: true,\r\n  configurable: true,\r\n  enumerable: true,\r\n});\r\nconsole.log(obj.prop1); // \"This is prop1\"\r\n```\r\n\r\n上面程式碼，等同於下面\r\n\r\n```javascript\r\nvar obj = {};\r\nobj.prop1 = \"This is prop1\";\r\nconsole.log(obj.prop1); // \"This is prop1\"\r\n```\r\n\r\n#### 屬性描述器屬於淺層設定\r\n\r\n淺層設定：只有目標物件的`自有屬性`才會擁有這個特徵，若屬性又指向了另一個物件，則另一個物件內的屬性，即不為自有屬性，亦不會擁有這個特徵。\r\n\r\n```javascript\r\nvar obj = {};\r\nvar innerObj = { innerProp: \"This is innerProp\" };\r\n\r\nObject.defineProperty(obj, \"prop1\", {\r\n  value: innerObj,\r\n  writable: false,\r\n  configuration: true,\r\n  enumerable: true,\r\n});\r\n\r\nobj.prop1 = {};\r\nconsole.log(obj.prop1); // { innerProp: \"This is innerProp\" }\r\n\r\nobj.prop1.innerProp = \"innerProp changed!\";\r\nconsole.log(obj.prop1); // { innerProp: \"innerProp changed!\" }\r\n```\r\n\r\n將 `obj.prop1` 設為 `writable: false`，並賦值為 `innerObj`，接著試圖將`{}` 寫入 `obj.prop1`。此時寫入的動作並沒有成功，`obj.prop1` 還是指向 `innerObj`\r\n\r\n但若賦值的是 `innerObj` 的屬性 `innerProp` 的話，是可以寫入的，因為只有 `obj` 自身的屬性 `prop1` 被指定為 `writable: false`，而 `prop1` 指向的 `innerObj` 內部屬性則不受 `prop1` 的特徵管轄，因此複寫 `innerProp` 是可行的\r\n\r\n### 存取器描述器\r\n\r\n`get` 和 `set` 分別為取值器與設值器，可以將他想像成是函式。\r\n當有設定這兩個特徵時，他們會覆蓋 javascript 原有的取值與設值行為 `[[GET]]` 和 `[[set]]`\r\n\r\n#### 宣告方式\r\n\r\n- 使用物件字面值時直接定義\r\n\r\n  ```javascript\r\n  var obj = {\r\n    get propName() {\r\n      // ... do something\r\n      return \"some value\";\r\n    },\r\n    set propName(val) {\r\n      // ... do something\r\n    },\r\n  };\r\n  ```\r\n\r\n- 利用屬性描述器定義\r\n\r\n  ```javascript\r\n  Object.defineProperty(obj, \"prop1\", {\r\n    // ...\r\n    get: function () {\r\n      // ... do something\r\n      return \"some value\";\r\n    },\r\n    set: function (val) {\r\n      // ... do something\r\n    },\r\n  });\r\n  ```\r\n\r\n以上的宣告方式是一樣的\r\n\r\n#### Getter\r\n\r\n需要回傳一個值來當作取值結果\r\n\r\n```javascript\r\nvar obj = {\r\n  get prop1() {\r\n    return \"This is prop1\";\r\n  },\r\n};\r\nconsole.log(obj.prop1); // 'This is prop1'\r\n\r\nobj.prop1 = \"Change value!\";\r\nconsole.log(obj.prop1); // 'This is prop1'\r\n```\r\n\r\n無論怎麼修改 prop1 的值，最後回傳的都是取值器回傳的 \"This is prop1\"\r\n\r\n### setter\r\n\r\n在拿到值之後，去做指定的動作\r\n\r\n```javascript\r\nvar obj = {\r\n  set prop1(val) {\r\n    console.log(\"prop1 setted: \", val);\r\n  },\r\n};\r\nobj.prop1 = \"This is prop1\"; // \"prop1 setted:  This is prop1\"\r\n\r\nconsole.log(obj.prop1); // undefined\r\n```\r\n\r\n將 \"this is prop1\" 傳入 prop1 中，此時會印出 set 要求的 log，當要取出 obj.prop1 的值時，因為我們並沒有設置 get，因此出現 undefined\r\n\r\n### 資料處理器與存取器處理器\r\n\r\n- 資料描述器：代表屬性是有值，會有以下兩個特徵\r\n  - value\r\n  - writable\r\n- 存取器描述器：屬性的值是由取值器與設值器所決定，會有以下兩個特徵：\r\n  - get\r\n  - set\r\n\r\n需要注意的是，資料描述器與存取器描述器不相容。\r\n\r\n若今天物件中的屬性已經設定了 get 和 set，也就代表已經定義取值和設值的行為，此時再額外進行屬性值(value)與唯獨(writable)的設定，產生行為衝突\r\n\r\n```javascript\r\nvar obj = {};\r\nObject.defineProperty(obj, \"prop1\", {\r\n  get: function () {\r\n    return \"This is prop1\";\r\n  },\r\n  value: \"test\",\r\n  writable: true,\r\n}); // Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #<Object>\r\n```\r\n\r\n### 取值器與設值器的應用\r\n\r\n```javascript\r\nvar obj = {};\r\nObject.defineProperty(obj, \"prop1\", {\r\n  set: function (val) {\r\n    this._prop1_ = val * 2;\r\n  },\r\n  get: function () {\r\n    return this._prop1_;\r\n  },\r\n  configurable: true,\r\n  enumerable: true,\r\n});\r\n\r\nobj.prop1 = 100;\r\nconsole.log(obj.prop1); // 200\r\n```\r\n\r\n上面我們宣告了一個變數 obj 並加入一個屬性 prop1，並為這個屬性同時加入 get 和 set，這兩個函式的共通點：都對 obj.prop1 進行存取。\r\n\r\n## 額外補充\r\n\r\n### random(亂數)公式\r\n\r\n```javascript\r\nfunction getRandom(start, end) {\r\n  return Math.floor(Math.random() * (end - start + 1)) + start;\r\n}\r\nvar r = getRandom(0, 255);\r\nvar g = getRandom(0, 255);\r\nvar b = getRandom(0, 255);\r\n```\r\n\r\n\r\n我在這邊加入了一些東西喇","date":"2023-07-14T09:29:02.458Z","matchingLines":["## 基本概念\r","## 存取資料的方法\r","## 運算式與運算子\r","## 流程判斷與迴圈\r","## 函式 function\r","## 方法\r","## 屬性描述器\r","## 額外補充\r"]},{"name":"VueX 學習筆記.md","content":"# VueX 學習筆記\r\n\r\n> 參考資料：\r\n>\r\n> [Vuex 是什麼? 怎麼用?](https://medium.com/itsems-frontend/vue-vuex5-sumup-c170d4bd6c42)\r\n>\r\n> 實作：\r\n>\r\n> [github-repo](https://github.com/changgenglu/vuex-note)\r\n>\r\n> [github-pages](https://changgenglu.github.io/vuex-note/)\r\n\r\n- [VueX 學習筆記](#vuex-學習筆記)\r\n  - [什麼是 VueX](#什麼是-vuex)\r\n  - [帶入參數及呼叫方法](#帶入參數及呼叫方法)\r\n    - [State](#state)\r\n    - [mapState](#mapstate)\r\n    - [Getters](#getters)\r\n    - [mapGetters](#mapgetters)\r\n    - [mutations](#mutations)\r\n    - [mapMutations](#mapmutations)\r\n    - [actions](#actions)\r\n  - [專案結構](#專案結構)\r\n\r\n## 什麼是 VueX\r\n\r\n一個專門為 vue 專案開發的資料管理套件，可以為網站做全域的資料管理。\r\n\r\n在專案結構下面可能會有多個組件，組件中又會有組件，組件的溝通，通常會會透過 emit 和 prop，而為了處理大型專案的兄弟組件間的溝通，VueX 就這樣誕生了。\r\n\r\nVueX 有一點像是全域的 components，大家可以拿他資料，呼叫他出來用。\r\n\r\nstate 就像是 data，action + Mutation 就像是 methods，getters 就像 computed\r\n\r\n在 VueX 中，儲存的狀態為 State，Component 使用 Dispatch 呼叫 Actions，讓 Actions 發出 commit 觸發 Mutations 去修改 State 的資料。整個 VueX 的方法也稱為 store。\r\n\r\n## 帶入參數及呼叫方法\r\n\r\n### State\r\n\r\n- 定義：/store.js\r\n\r\n  ```javascript\r\n  import Vue from \"vue\";\r\n  import Vuex from \"vuex\";\r\n  Vue.use(Vuex);\r\n\r\n  const store = new Vuex.Store({\r\n    state: {\r\n      isLoading: false,\r\n    },\r\n  });\r\n  export default store;\r\n  ```\r\n\r\n- 使用：/app.vue\r\n\r\n  ```vue\r\n  <template>\r\n    <div id=\"app\">\r\n      <p>isLoading: {{ ifLoading }}</p>\r\n    </div>\r\n  </template>\r\n\r\n  <script>\r\n  export default {\r\n    name: \"app\",\r\n    computed: {\r\n      // 注意: 這邊的ifLoading跟store的state的isLoading名字不同，是可以自定義的喔\r\n      ifLoading() {\r\n        return this.$store.state.isLoading;\r\n      },\r\n    },\r\n  };\r\n  </script>\r\n  ```\r\n\r\n### mapState\r\n\r\n- 定義：/store.js\r\n\r\n  ```javascript\r\n  import Vue from \"vue\";\r\n  import Vuex from \"vuex\";\r\n  Vue.use(Vuex);\r\n\r\n  const store = new Vuex.Store({\r\n    state: {\r\n      myName: \"Emma\",\r\n      isLoading: false,\r\n    },\r\n  });\r\n\r\n  export default store;\r\n  ```\r\n\r\n- 使用：/app.vue\r\n\r\n  ```vue\r\n  <template>\r\n    <div id=\"app\">\r\n      <p>My Name is {{ myName }}</p>\r\n      <p>isLoading: {{ isLoading }}</p>\r\n    </div>\r\n  </template>\r\n\r\n  <script>\r\n  import { mapState } from \"vuex\";\r\n  export default {\r\n    name: \"app\",\r\n    computed: {\r\n      // 陣列寫法\r\n      ...mapState([\"isLoading\", \"myName\"])\r\n      // 物件寫法\r\n      ...mapState({\r\n        isLoading: state => state.isLoading,\r\n        myName:  state => state.myName,\r\n      })\r\n    }\r\n  };\r\n  </script>\r\n  ```\r\n\r\n### Getters\r\n\r\n- 可帶參數：state, getters\r\n- 定義：/store.js\r\n\r\n  ```javascript\r\n  import Vue from \"vue\";\r\n  import Vuex from \"vuex\";\r\n  Vue.use(Vuex);\r\n\r\n  const store = new Vuex.Store({\r\n    state: {\r\n      myName: \"Emma\",\r\n    },\r\n    getters: {\r\n      // 只有一個參數的箭頭函式寫法\r\n      newName: (state) => {\r\n        return state.myName + \" lin\";\r\n      },\r\n    },\r\n  });\r\n\r\n  export default store;\r\n  ```\r\n\r\n- 使用：/app.vue\r\n\r\n  ```vue\r\n  <template>\r\n    <div id=\"app\">\r\n      <p>My New Name is {{ newName }}</p>\r\n    </div>\r\n  </template>\r\n\r\n  <script>\r\n  export default {\r\n    name: \"app\",\r\n    computed: {\r\n      newName() {\r\n        return this.$store.getters.newName;\r\n      },\r\n    },\r\n  };\r\n  </script>\r\n  ```\r\n\r\n加上參數 getters 表示可以呼叫別的 getters 來用\r\n\r\n- 定義：/store.js\r\n\r\n  ```javascript\r\n  import Vue from \"vue\";\r\n  import Vuex from \"vuex\";\r\n  Vue.use(Vuex);\r\n\r\n  const store = new Vuex.Store({\r\n    state: {\r\n      myName: \"Emma\",\r\n    },\r\n    getters: {\r\n      newName: (state) => {\r\n        return state.myName + \" lin\";\r\n      },\r\n      // 這邊呼叫下面那個getters\r\n      anotherName: (state, getters) => {\r\n        return getters.nickName;\r\n      },\r\n      nickName: (state) => {\r\n        return state.myName + \" Watson\";\r\n      },\r\n    },\r\n  });\r\n\r\n  export default store;\r\n  ```\r\n\r\n- 使用：/app.vue\r\n\r\n  ```vue\r\n  <template>\r\n    <div id=\"app\">\r\n      <p>My New Name is {{ newName }}</p>\r\n      <p>or you can call me {{ anotherName }}</p>\r\n    </div>\r\n  </template>\r\n\r\n  <script>\r\n  export default {\r\n    name: \"app\",\r\n    computed: {\r\n      newName() {\r\n        return this.$store.getters.newName;\r\n      },\r\n      anotherName() {\r\n        return this.$store.getters.anotherName;\r\n      },\r\n    },\r\n  };\r\n  </script>\r\n  ```\r\n\r\n### mapGetters\r\n\r\n定義和上面的 store.js 相同，差異在 components 呼叫的時候\r\n\r\n- 使用：\r\n\r\n  ```vue\r\n  <script>\r\n  import { mapGetters } from \"vuex\";\r\n  export default {\r\n    name: \"app\",\r\n    computed: {\r\n      // 陣列寫法\r\n      ...mapGetters([\"newName\", \"anotherName\"])\r\n      // 物件寫法\r\n      ...mapGetters({\r\n        newName: \"newName\",\r\n        anotherName: \"anotherName\"\r\n      })\r\n    }\r\n  };\r\n  </script>\r\n  ```\r\n\r\n### mutations\r\n\r\n可帶參數：state, payload\r\n\r\n- 使用：/app.vue\r\n\r\n  ```javascript\r\n  methods: {\r\n    reverse() {\r\n      this.$store.commit(\"Loaded\");\r\n    },\r\n  }\r\n  ```\r\n\r\n- with payload:\r\n  通常 payload 可以用物件表示，就能更具描述性，但是要記得在 mutations 運算時，帶入的參數 payload 要加上參數物件的 key\r\n\r\n  - /app.vue\r\n\r\n    ```javascript\r\n    store.commit(\"addCounts\", {\r\n      amount: 10,\r\n    });\r\n    ```\r\n\r\n  - /store.js\r\n\r\n    ```javascript\r\n    mutations: {\r\n      addCounts (state, payload) {\r\n        state.count += payload.amount\r\n      }\r\n    }\r\n    ```\r\n\r\n  - 所以帶上 payload 的呼叫可以這樣使用：\r\n\r\n    ```javascript\r\n    this.$store.commit(\"addTimes\", 10);\r\n    // 或\r\n    this.$store.commit({\r\n      type: \"addTimes\",\r\n      count: 2,\r\n    });\r\n    ```\r\n\r\n    物件 type 是必要的，其他可以隨意\r\n\r\n### mapMutations\r\n\r\n```vue\r\n<script>\r\nimport { mapMutations } from \"vuex\";\r\nexport default {\r\n  name: \"app\",\r\n  computed: {\r\n    // 陣列寫法\r\n    ...mapMutations([\"Loaded\", \"addTimes\"])\r\n    // 物件寫法\r\n    ...mapMutations({\r\n      // add是component自定義的事件名稱，addTimes是mutations在store的名稱\r\n      add: 'addTimes'\r\n    })\r\n  }\r\n};\r\n</script>\r\n```\r\n\r\n使用 mapMutations，就要把 payload 直接帶入 template：\r\n\r\n```html\r\n<button @click=\"addTimes(2)\">addTimes</button>\r\n```\r\n\r\n**注意**：mutations 一定只能同步執行，action 才能執行非同步\r\n\r\n### actions\r\n\r\n- 可帶參數：\r\n  - context: {commit, dispatch, state, getters, rootState, rootGetters}, payload\r\n\r\n上面描述 mutations 只能同步執行，action 執行非同步，意旨 axios 要在 Actions 裡面做，不可以在 mutations 裡面做。\r\n\r\n- 定義：/app.vue\r\n\r\n  ```javascript\r\n  ClickedActions({ commit }, payload) {\r\n  commit('addTimes', payload)\r\n  }\r\n  ```\r\n\r\n- 使用：/app.vue\r\n\r\n  ```javascript\r\n  methods: {\r\n    add() {\r\n      this.$store.dispatch(\"ClickedActions\",2);\r\n    }\r\n  }\r\n  ```\r\n\r\n## 專案結構\r\n\r\n1. App 層級的狀態要在 state 集中管理\r\n   > app 層級的意思是指：不會因為跨組件改變的狀態，如：登入資訊、購物車清單...等。\r\n   >\r\n   > 會因為跨組件改變的狀態，如：下拉式選單的開關狀態、商品列表...等。\r\n2. 唯一改變 state 的方式只有 mutations，而且是同步執行\r\n3. actions 才可以非同步執行\r\n\r\n```txt\r\n|--index.js\r\n|--main.js\r\n|--api\r\n|  |--...             // 後端 api\r\n|--components         // 頁面\r\n|  |--App.vue\r\n|  |--...\r\n|--store\r\n   |--index.js        // 註冊 modules 並 export store\r\n   |--actions.js      // 跨組件的 action\r\n   |--mutations.js    // 跨組件的 mutations\r\n   |--modules\r\n      |--cart.js      // 購物車 model\r\n      |--products.js  // 商品 model\r\n```\r\n","date":"2023-07-06T08:58:20.402Z","matchingLines":["## 什麼是 VueX\r","## 帶入參數及呼叫方法\r","## 專案結構\r"]},{"name":"Vue 學習筆記.md","content":"# Vue 學習筆記\r\n\r\n- [Vue 學習筆記](#vue-學習筆記)\r\n  - [Vue 實體的生命週期](#vue-實體的生命週期)\r\n  - [Vue 屬性](#vue-屬性)\r\n    - [監聽器(watch)](#監聽器watch)\r\n      - [$watch](#watch)\r\n      - [watch](#watch-1)\r\n    - [計算(computed)](#計算computed)\r\n      - [watch 和 computed 差別](#watch-和-computed-差別)\r\n        - [依賴更新才會重新執行](#依賴更新才會重新執行)\r\n    - [computed、watch 和 methods 的使用時機](#computedwatch-和-methods-的使用時機)\r\n  - [eventHub 事件中心 (vue 2)](#eventhub-事件中心-vue-2)\r\n  - [指令(directive)](#指令directive)\r\n    - [屬性綁定](#屬性綁定)\r\n    - [表單綁定 `v-model`](#表單綁定-v-model)\r\n      - [input](#input)\r\n      - [textarea 文字方塊](#textarea-文字方塊)\r\n      - [radio](#radio)\r\n      - [checkbox](#checkbox)\r\n      - [select 下拉式選單](#select-下拉式選單)\r\n    - [v-model 修飾子](#v-model-修飾子)\r\n      - [.lazy](#lazy)\r\n    - [模板綁定](#模板綁定)\r\n      - [v-text](#v-text)\r\n      - [v-html](#v-html)\r\n      - [v-once](#v-once)\r\n      - [v-pre](#v-pre)\r\n    - [樣式綁定](#樣式綁定)\r\n  - [條件渲染](#條件渲染)\r\n    - [v-if](#v-if)\r\n    - [v-show](#v-show)\r\n  - [迴圈渲染](#迴圈渲染)\r\n  - [事件監聽器](#事件監聽器)\r\n  - [props](#props)\r\n    - [命名與使用](#命名與使用)\r\n    - [傳遞 props 值的方法](#傳遞-props-值的方法)\r\n      - [傳遞字串](#傳遞字串)\r\n      - [傳遞數字、布林值、陣列、物件](#傳遞數字布林值陣列物件)\r\n    - [單向數據流](#單向數據流)\r\n    - [改變子模組內的 prop 值](#改變子模組內的-prop-值)\r\n    - [物件型別的 prop 傳遞](#物件型別的-prop-傳遞)\r\n    - [子組件接收來自父組件的 props](#子組件接收來自父組件的-props)\r\n      - [在模板中](#在模板中)\r\n      - [在 data 中](#在-data-中)\r\n      - [在 methods 中](#在-methods-中)\r\n      - [在 mounted 中](#在-mounted-中)\r\n      - [在 computed 中](#在-computed-中)\r\n  - [ref 取得 Dom 元素](#ref-取得-dom-元素)\r\n    - [基本用法：取得 dom 元素](#基本用法取得-dom-元素)\r\n    - [獲取子組件中的 data 和調用子組件的方法](#獲取子組件中的-data-和調用子組件的方法)\r\n    - [子組件呼叫父組件的方法](#子組件呼叫父組件的方法)\r\n    - [this.$refs 介紹](#thisrefs-介紹)\r\n  - [備註](#備註)\r\n    - [判斷當前環境是否為開發環境](#判斷當前環境是否為開發環境)\r\n\r\n## Vue 實體的生命週期\r\n\r\n- `beforeCreate`: 當 Vue 實例初始化時便立即調用，此時尚未創建實例，因此所有 Vue 實體中的設定(如：data)都還未配置。\r\n- `created`: 完成創建實例，此時 Vue 實體中的配置除了 \\$el 外，其餘已全部配置，而 \\$el 要在掛載模板後才會配置。\r\n- `beforeMount`: 在 Vue 實體中被掛載到目標元素之前調用，此時的 \\$el 依然未被 Vue 實體中的定義渲染的初始設定模板。\r\n- `mounted`: Vue 實體上的設置已經安裝上模板，此時 \\$el 是已經藉由實體中的定義渲染成真正的頁面。\r\n- `beforeUpdate`: Vue 實體中的 data 產生變化後，或是執行 vm.$forceUpdate() 時調用，此時頁面尚未被重新渲染成變過的畫面。\r\n- `update`: 在重新渲染頁面後調用，此時的頁面已經被重新渲染成改變後的畫面。\r\n- `beforeDestroy`: 在此實體被銷毀前調用，此時實體依然擁有完整的功能。\r\n- `destroyed`: 於此實體被銷毀後調用，此時實體中的任何定義(data, methods...)都已被解除綁定，在此做任何操作都會失效。\r\n\r\n## Vue 屬性\r\n\r\n### 監聽器(watch)\r\n\r\n當資料變化時調用函數，函數會有兩個傳入參數：改變前的值、改變後的後的值，可以使用這個函數做跟此資料變化有的處理。\r\n\r\n監聽器在 vue.js 中有兩種使用方式：\r\n\r\n- `$watch` 實體上的函數，使用此函數註冊監聽器。\r\n- `watch` 實體上的屬性，此屬性設置的物件在實體建立時會調用 `$watch` 註冊監聽器。\r\n\r\n`$watch` 是註冊監聽器的函數，而 watch 是為了開發者方便在實體上設置監聽器而提供的，其實 watch 本身也是使用 $watch 註冊監聽器。\r\n\r\n#### $watch\r\n\r\n```javascript\r\nunwatched = vm.$watch(expOrFn, callback, [options]);\r\n```\r\n\r\n`$watch` 的回傳值是註銷監聽器的函數，執行此函數可使監聽器失效。\r\n\r\n- `exOrFn` 設定要監聽的目標，可以使用 javascript 表達式或是一個回傳監聽目標值的函數\r\n- `callback` 當數值改變時，要叫用的函數，此函數會有兩個傳入參數：callback(newVal, oldVal)\r\n  - `newVal` 改變後的資料值\r\n  - `oldVal` 改變前的資料值\r\n- `[options]` 非必要參數，監聽器的設定\r\n  - `deep` 監聽物件時，物件下層屬性變化也會觸發監聽器\r\n  - `immediate` 在實體初始畫設置監聽器的時候馬上叫用 callback 函數\r\n\r\n```html\r\n<div id=\"app\">\r\n  <button @click=\"a++\">+</button>\r\n  <button @click=\"a--\">--</button>\r\n  <div>a: {{a}}</div>\r\n  <div>changed: {{newA}}</div>\r\n  <div>before change: {{oldA}}</div>\r\n</div>\r\n```\r\n\r\n```javascript\r\nvar vm = new Vue({\r\n  ...\r\n  data: {\r\n    a: 1,\r\n    newA: 0,\r\n    oldA: 0\r\n  }\r\n});\r\n\r\nvm.$watch('a', function(newA, oldA) {\r\n  this.newA = newA;\r\n  this.oldA = oldA;\r\n});\r\n```\r\n\r\n#### watch\r\n\r\n```javascript\r\nwatch: (\r\n  key: value,\r\n  ...\r\n)\r\n```\r\n\r\n- 以 watch 為 key 值，下面定義的屬性都是欲監聽的資料來源。\r\n- key 監聽目標名稱，可以使用 javascript 表達式\r\n- value callback 函數的設定，共有 string, function, object 及 array 可以設定。\r\n  - string callback 函數名稱\r\n  - function callback 函數\r\n  - object 設定監聽物件，設定方法如下\r\n    - handler callback 函數\r\n    - deep 布林值，是否監聽物件下層屬性\r\n    - immediate 布林值 使否在實體初始化時立即調用 callback\r\n  - array 當有多個監聽器時，使用陣列帶入多個 callback 函數\r\n\r\n### 計算(computed)\r\n\r\n和 watch 一樣，都是用來監聽數據的方式，但使用場景不同。\r\n\r\ncomputed 是一個計算屬性，他根據依賴的資料，動態計算出一個新的值，並且會自動存入快取。當依賴的資料發生變化時，computed 會自動重新計算。這樣可以有效避免重複計算和提高性能。\r\n\r\ncomputed 通常用計算衍生的資料，例如從一個列表中過濾出符合條件的資料，或根據資料的狀態產生顯示內容等等。在模板中，可以像普通的資料屬性一樣使用 computed\r\n\r\n```javascript\r\nexport default {\r\n  data() {\r\n    return {\r\n      count: 0,\r\n    };\r\n  },\r\n  computed: {\r\n    doubleCount() {\r\n      return this.count * 2;\r\n    },\r\n  },\r\n};\r\n```\r\n\r\n`doubleCount` 為一個計算屬性，他依賴於 count 屬性。當 count 屬性發生變化時，doubleCount 會自動重新計算。在模板中，可以像下面這樣使用：\r\n\r\n```html\r\n<p>count: {{ count }}</p>\r\n<p>double count: {{ doubleCount }}</p>\r\n```\r\n\r\n#### watch 和 computed 差別\r\n\r\ncomputed 最大特點是必須回傳一個值，並且將其存入快取，當方法中的依賴改變時，才會重新執行和求值。\r\n\r\n但 watch 和 methods 不會強制要求回傳一個值，他們只需要執行動作，不一定要回傳值。\r\n\r\nwatch 會偵測單一個值，當她有變化時就執行。methods 只要呼叫，就會執行。\r\n\r\n- computed 的特點\r\n  - 當元件被建立時(created 生命週期)，computed 方法會被建立和執行一次。之後如果依賴沒有更新，就不會重新執行和求值，僅回傳快取的值。\r\n  - computed 只能被該 computed 修改，不能被其他方法修改。例如：this.some_computed_function = 123 就會報錯。\r\n  - computed 的方法必須回傳一個值。\r\n  - computed 方法無法傳入參數\r\n\r\n##### 依賴更新才會重新執行\r\n\r\n> vue 官方文件\r\n>\r\n> 计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。\r\n\r\n響應式依賴：在一個 computed 方法中，他所用到在 data 建立的資料，當資料產生變化，此方法就會重新執行和求值。\r\n\r\n```javascript\r\ncomputed:{\r\n    total(){\r\n        return this.price * this.quantity * this.discount\r\n    }\r\n}\r\n```\r\n\r\ntotal 的依賴就是 this.price, this.quantity, this.discount。只要其中一樣產生變化，就會重新執行 total()，並回傳新的值。\r\n\r\n當 computed 內所有的依賴都沒有發生變化，此 computed 函示就會一直回傳之前儲存起來的值。\r\n\r\n```javascript\r\n<div id=\"app\">\r\n  <button @click=\"num = 1\">按我改num</button>\r\n  <p> 用add方法把以下的值由0變1：</p>\r\n  <p> {{ add }} </p>\r\n</div>\r\n```\r\n\r\n```javascript\r\n// 當num變成1之後，changeOne()就不會再觸發，而「我有被觸發了！」這句也不會印出來\r\n\r\nimport { createApp } from \"https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.9/vue.esm-browser.js\";\r\ncreateApp({\r\n  data() {\r\n    return {\r\n      num: 0,\r\n    };\r\n  },\r\n  computed: {\r\n    add() {\r\n      console.log(\"我有被觸發了！\");\r\n      return this.num;\r\n    },\r\n  },\r\n}).mount(\"#app\");\r\n```\r\n\r\n當元件剛建立時(created)時，會打印一次，然後第一次按下按鈕時，會在打印一次，並且 num 會變成 1。\r\n但第二次之後按下按鈕，就不會再觸發 add() 方法，因為每次按下按鈕，都會將 num 賦值為 1，和之前快取儲存的值相同。\r\n\r\n### computed、watch 和 methods 的使用時機\r\n\r\n當三者都能實現同一效果，但 computed 的效能較好\r\n\r\n## eventHub 事件中心 (vue 2)\r\n\r\n在無關聯的組件之間，互相傳遞 data\r\n\r\n在需要取得 data 的組件上設置一個監聽器，每次要傳遞 data 時，那個組件就會廣播這個事件並調用這些監聽器。\r\n\r\neventHub 最主要的功能就是**監聽**和**廣播**\r\n\r\n若 vue 搭配其他框架時，在 library 新增一個 eventHub.js\r\n\r\n```javascript\r\nimport Vue from \"vue\";\r\nconst eventHub = new Vue();\r\nexport default eventHub;\r\n```\r\n\r\n若只有單純 vue 框架，則在頂層組件的 `data` 裡初始化 eventHub，並使用 `provide` 對外傳遞這個 eventHub\r\n\r\n```javascript\r\nimport Vue from \"vue\";\r\n\r\nexport default {\r\n  name: \"App\",\r\n  components: {\r\n    GrandParent,\r\n  },\r\n  data() {\r\n    return {\r\n      eventHub: new Vue(),\r\n    };\r\n  },\r\n  provide() {\r\n    return {\r\n      eventHub: this.eventHub,\r\n    };\r\n  },\r\n  methods: {\r\n    setRandomValue() {\r\n      this.eventHub.$emit(\"update:msg\", Math.random() * 100);\r\n    },\r\n  },\r\n};\r\n```\r\n\r\n在要傳遞 data 的組件裡加入廣播\r\n\r\n```javascript\r\nimport eventHub from \"../library/eventHub\";\r\nexport default {\r\n  data() {\r\n    return {\r\n      name: \"\",\r\n    };\r\n  },\r\n  methods: {\r\n    getCategories: function () {\r\n      let id = \"\";\r\n      axios\r\n        .get(base_url + \"/api/category/\")\r\n        .then((response) => {\r\n          this.name = response.data.name;\r\n          eventHub.$emit(\"categoryupdate\", this.name);\r\n        })\r\n        .catch(function (error) {\r\n          console.log(error);\r\n        });\r\n    },\r\n  },\r\n  created() {\r\n    this.getCategories();\r\n  },\r\n};\r\n```\r\n\r\n接著在需要監聽的組件裡注入這個依賴，並在添加事件監聽。\r\n\r\n```javascript\r\nimport eventHub from \"../library/eventHub\";\r\nexport default {\r\n  data() {\r\n    return {\r\n      categories: [],\r\n    };\r\n  },\r\n  mounted() {\r\n    eventHub.$on(\"categoryupdate\", this.categoryupdate);\r\n  },\r\n  methods: {\r\n    categoryupdate(input) {\r\n      this.categories.push(input);\r\n    },\r\n  },\r\n};\r\n```\r\n\r\n## 指令(directive)\r\n\r\n### 屬性綁定\r\n\r\n透過 `v-bind`，進行數據綁定 HTML class\r\n\r\n傳遞對象給 v-bind:class，用以動態切換 class\r\n\r\n```html\r\n<div v-bind:class=\"{ active: isActive }\"></div>\r\n```\r\n\r\n此時 `active` 這個 class 是否存在，將取決於 property `isActive` 的 truthiness(註 1)。\r\n\r\n可以在對象中傳入更多屬性，來動態切換多個 class。此外 v-bind:class 也可以與普通的 class attribute 共存\r\n\r\n```html\r\n<div class=\"static\" v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"></div>\r\n```\r\n\r\ndata:\r\n\r\n```javascript\r\ndata: {\r\n  isActive: true,\r\n  hasError: false\r\n}\r\n```\r\n\r\n渲染結果\r\n\r\n```html\r\n<div class=\"static active\"></div>\r\n```\r\n\r\n當 isActive 或 hasError 變化時，class 的屬性會同步更新。\r\n\r\n例如：若 hasError 值為 true，class 屬性將變為 \"static active text-danger\"。\r\n\r\n綁定的數據對象，不一定要定義在模板裡\r\n\r\n```html\r\n<div v-bind:class=\"classObject\"></div>\r\n```\r\n\r\n```javascript\r\ndata: {\r\n  classObject: {\r\n    active: true,\r\n    'text-danger': false\r\n  }\r\n}\r\n```\r\n\r\n此渲染的結果和上面一樣。\r\n\r\n也可以在此綁定 computed 屬性。\r\n\r\n```html\r\n<div v-bind:class=\"classObject\"></div>\r\n```\r\n\r\n```javascript\r\ndata: {\r\n  isActive: true,\r\n  error: null\r\n},\r\ncomputed: {\r\n  classObject: function () {\r\n    return {\r\n      active: this.isActive && !this.error,\r\n      'text-danger': this.error && this.error.type === 'fatal'\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 表單綁定 `v-model`\r\n\r\n> 當使用 v-model 指令時，表單元素會自動忽略原有的 value, checked 和 selected 屬性，實際的值將以 data 內的狀態為主\r\n\r\n#### input\r\n\r\n在 input 文字框加入 v-model=\"message\" 屬性之後，此文字框便會自動被綁定 input 事件\r\n\r\n```html\r\n<div id=\"app\">\r\n  <input type=\"text\" v-model=\"message\" />\r\n  <p>Message is {{ message }}</p>\r\n</div>\r\n\r\n<script>\r\n  const vm = Vue.createApp({\r\n    data() {\r\n      return {\r\n        message: \"Hello\",\r\n      };\r\n    },\r\n  });\r\n</script>\r\n```\r\n\r\n#### textarea 文字方塊\r\n\r\n使用方式與 input 完全一樣\r\n\r\n```html\r\n<p><span>Multiline message is:</span>{{ message }}</p>\r\n\r\n<textarea v-model=\"message\"></textarea>\r\n```\r\n\r\n#### radio\r\n\r\n```html\r\n<div id=\"app\">\r\n  <div>\r\n    <input type=\"radio\" id=\"one\" value=\"1\" v-model=\"picked\" />\r\n    <label for=\"one\">One</label>\r\n  </div>\r\n  <div>\r\n    <input type=\"radio\" id=\"two\" value=\"2\" v-model=\"picked\" />\r\n    <label for=\"two\">Two</label>\r\n  </div>\r\n\r\n  <span>Picked: {{ picked }}</span>\r\n</div>\r\n\r\n<script>\r\n  const vm = Vue.createApp({\r\n    data() {\r\n      return {\r\n        picked: 1,\r\n      };\r\n    },\r\n  }).mount(\"#app\");\r\n</script>\r\n```\r\n\r\n因為 data 裡的 picked 預設為 1，所以執行時畫面上 `<input type=\"radio\" id=\"one\" value=\"1\">` 會預設為已選擇\r\n\r\n#### checkbox\r\n\r\n可以當作多選的選項，而當他只有一個的時候，又可以將它做 boolean 的選項\r\n\r\n複選時，用法跟前面 radio 完全一樣，因為是複選的關係，其差別在 data 內的狀態必須為陣列\r\n\r\n```html\r\n<div id=\"app\">\r\n  <input type=\"checkbox\" id=\"jack\" value=\"jack\" v-model=\"checkedNames\" />\r\n  <label for=\"jack\">jack</label>\r\n  <input type=\"checkbox\" id=\"john\" value=\"john\" v-model=\"checkedNames\" />\r\n  <label for=\"john\">john</label>\r\n  <input type=\"checkbox\" id=\"mike\" value=\"mike\" v-model=\"checkedNames\" />\r\n  <label for=\"mike\">mike</label>\r\n  <input type=\"checkbox\" id=\"mary\" value=\"mary\" v-model=\"checkedNames\" />\r\n  <label for=\"mary\">mary</label>\r\n  <br />\r\n  <p>Checked names: {{ checkedNames }}</p>\r\n</div>\r\n\r\n<script>\r\n  const vm = Vue.createApp({\r\n    data() {\r\n      return {\r\n        checkedNames: [],\r\n      };\r\n    },\r\n  }).mount(\"#app\");\r\n</script>\r\n```\r\n\r\n- 如果要控制表單的全選或全部取消，只要控制 data 內的 checkedNames 陣列內容即可\r\n\r\n當 checkbox 為單選時\r\n\r\n```html\r\n<div id=\"app\">\r\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"isChecked\" />\r\n  <label for=\"jack\">Status: {{ isChecked }}</label>\r\n</div>\r\n\r\n<script>\r\n  const vm = Vue.createApp({\r\n    data() {\r\n      return {\r\n        isChecked: true,\r\n      };\r\n    },\r\n  }).mount(\"#app\");\r\n</script>\r\n```\r\n\r\n此時， data 內的選項，會變成 true 或 false，當值為 true 時，對應的 checkbox 會被勾起。\r\n\r\n#### select 下拉式選單\r\n\r\n```html\r\n<div id=\"app\">\r\n  <select v-model=\"selected\">\r\n    <option disabled value=\"\">請選擇</option>\r\n    <option>台北市</option>\r\n    <option>新北市</option>\r\n    <option>基隆市</option>\r\n  </select>\r\n\r\n  <p>Selected: {{ selected || '未選擇' }}</p>\r\n</div>\r\n\r\n<script>\r\n  const vm = Vue.createApp({\r\n    data() {\r\n      return {\r\n        selected: \"\",\r\n      };\r\n    },\r\n  }).mount(\"#app\");\r\n</script>\r\n```\r\n\r\nv-model 標籤須使用在 `<select>` 標籤，不能用在 `<option>` 標籤中\r\n\r\n### v-model 修飾子\r\n\r\n#### .lazy\r\n\r\n```html\r\n<input v-model.lazy=\"message\" />\r\n```\r\n\r\n在 v-model 屬性後面加上.lazy，此輸入框就會從原本的 input 事件，變成監聽 change 事件\r\n\r\n也就是，原本 input 事件會在輸入值時做實時的更新，而監聽 change 事件，則是當使用者離開輸入框焦點時才會更新。\r\n\r\n### 模板綁定\r\n\r\n#### v-text\r\n\r\n```html\r\n<div id=\"app\">\r\n  <div v-text=\"text\"></div>\r\n</div>\r\n\r\n<script>\r\n  const vm = Vue.createApp({\r\n    data() {\r\n      return {\r\n        text: \"hello\",\r\n      };\r\n    },\r\n  }).mount(\"#app\");\r\n</script>\r\n```\r\n\r\n當透過 v-text 指令來進行綁定，此時畫面渲染出來的結果會與下面相同\r\n\r\n```html\r\n<div>{{ text }}</div>\r\n```\r\n\r\n但若在 v-text 綁定的標籤內加入文字，以 v-text 指令渲染出來的結果會無視標籤內的內容\r\n\r\n```html\r\n<!-- 只會出現 Hello -->\r\n<div v-text=\"text\">World!</div>\r\n\r\n<!-- 出現 Hello world! -->\r\n<div>{{ text }} world!</div>\r\n```\r\n\r\n#### v-html\r\n\r\n和 v-text 類似，但當 data 的內容為 HTML 的語法時，v-html 會將其渲染為 html 語法\r\n\r\n```html\r\n<button v-for=\"(item, index) in data.links\">{{ item.label }}</button>\r\n<!--  輸出結果 -->\r\n&laquo; Previous\r\n```\r\n\r\n```html\r\n<button v-for=\"(item, index) in data.links\" v-html=\"item.label\"></button>\r\n<!--  輸出結果 -->\r\n<< Previous\r\n```\r\n\r\n#### v-once\r\n\r\n只渲染指定的節點一次，往後就不再更新\r\n\r\n#### v-pre\r\n\r\n加入 v-pre 後，就不會解析模板內容。\r\n\r\n### 樣式綁定\r\n\r\n## 條件渲染\r\n\r\n### v-if\r\n\r\n其屬性為 truthy，當其返回 true 時會被渲染。\r\n\r\n```html\r\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\r\n```\r\n\r\n可以添加 `v-else`\r\n\r\n```html\r\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\r\n<h1 v-else>It's not true.</h1>\r\n```\r\n\r\n還可以添加 `v-else-if`\r\n\r\n此三元素需緊跟彼此，否則將不會被識別\r\n\r\n### v-show\r\n\r\n和 `v-if` 用法類似，不同的是 `v-show` 的元素始終會被渲染並保留在 DOM 中，`v-show` 只是單純的切換元素的 CSS property display。\r\n\r\n`v-if` 是真正的條件渲染，他會確保在切換過程中條件內的事件監聽器和子組件適當的被銷毀和重建。\r\n\r\n同時 `v-if` 也是惰性的，若在初始渲染時條件為 false，則不執行，直至條件第一次轉為 true 時，才會開始渲染。\r\n\r\n相較之下，`v-show` 就比較單純，無論初始條件，元素總是會被渲染，`v-show` 做的只是基於 CSS 進行切換。\r\n\r\n## 迴圈渲染\r\n\r\nv-for 可以用陣列進行渲染成一個列表。其語法為 item in items，items 為源陣列，而 item 則為被迭代的陣列元素別名。\r\n\r\n```html\r\n<ul id=\"example-1\">\r\n  <li v-for=\"item in items\" :key=\"item.message\">{{ item.message }}</li>\r\n</ul>\r\n```\r\n\r\n```javascript\r\nvar example1 = new Vue({\r\n  el: \"#example-1\",\r\n  data: {\r\n    items: [{ message: \"Foo\" }, { message: \"Bar\" }],\r\n  },\r\n});\r\n```\r\n\r\n輸出\r\n\r\n```log\r\nFoo\r\nBar\r\n```\r\n\r\n在 v-for 中可以訪問所有父作用域的 property。v-for 還可加入可選的第二參數作為當前的 key 值。\r\n\r\n```html\r\n<ul id=\"example-2\">\r\n  <li v-for=\"(item, index) in items\">{{ parentMessage }} - {{ index }} - {{ item.message }}</li>\r\n</ul>\r\n```\r\n\r\n```javascript\r\nvar example2 = new Vue({\r\n  el: \"#example-2\",\r\n  data: {\r\n    parentMessage: \"Parent\",\r\n    items: [{ message: \"Foo\" }, { message: \"Bar\" }],\r\n  },\r\n});\r\n```\r\n\r\n```log\r\nparent-0-Foo\r\nparent-1-Bar\r\n```\r\n\r\n用 v-for 來迭代一個對象的 property\r\n\r\n```html\r\n<ul id=\"v-for-object\" class=\"demo\">\r\n  <li v-for=\"value in object\">{{ value }}</li>\r\n</ul>\r\n```\r\n\r\n```javascript\r\nnew Vue({\r\n  el: \"#v-for-object\",\r\n  data: {\r\n    object: {\r\n      title: \"How to do lists in Vue\",\r\n      author: \"Jane Doe\",\r\n      publishedAt: \"2016-04-10\",\r\n    },\r\n  },\r\n});\r\n```\r\n\r\n```log\r\nHow to do lists in Vue\r\nJane Doe\r\n2016-04-10\r\n```\r\n\r\n可以傳入第二個參數作為 property 的名稱(key 值)\r\n\r\n```html\r\n<div v-for=\"(value, name) in object\">{{ name }}: {{ value }}</div>\r\n```\r\n\r\n```log\r\ntitle: How to do lists in Vue\r\nauthor: Jane Doe\r\npublishedAt: 2016-04-10\r\n```\r\n\r\n還可以傳入第三個參數作為索引值\r\n\r\n```html\r\n<div v-for=\"(value, name, index) in object\">{{ index }}. {{ name }}: {{ value }}</div>\r\n```\r\n\r\n```log\r\n0. title: How to do lists in Vue\r\n1. author: Jane Doe\r\n2. **publishedAt**: 2016-04-10\r\n```\r\n\r\n## 事件監聽器\r\n\r\n> 靜態事件監聽\r\n>\r\n> - 元素上使用 v-on 監聽原生事件\r\n> - 父組件設定 v-on 設定所需要監聽的事件，子組件用 $emit 觸發事件\r\n> - 在 Vue 實體上設定生命週期鉤子，監聽各個鉤子事件。\r\n\r\n當要在執行時去動態增減事件的監聽，這時就要用到 $on, $once, and $off 這些 js 函式來做設定。\r\n\r\n## props\r\n\r\n### 命名與使用\r\n\r\n可以使用 PascalCase 或是 camelCase 的命名方法，但在 html 中必須使用 kebab-case 且應該小寫(html 大小寫不敏感)\r\n\r\n像是 PostTitle 、 CartItem 、 TodoItem 等，在 HTML 中使用時就會變成 post-title 、 cart-item 、 todo-item。\r\n\r\n```vue\r\n<div id=\"vm\">\r\n<!--post-title 跟 post-content 都是props -->\r\n  <blog-post post-title=\"Blog1\" post-content=\"I\\'m content1\"></blog-post>\r\n</div>\r\n\r\n<script>\r\n  Vue.component(\"blog-post\", {\r\n    props: [\"PostTitle\", \"postContent\"],\r\n    template: `<div>\r\n    <h3>{{ PostTitle }}</h3>\r\n    <div>{{ postContent }}</div>\r\n  </div>`,\r\n  });\r\n</script>\r\n```\r\n\r\n### 傳遞 props 值的方法\r\n\r\n#### 傳遞字串\r\n\r\n```vue\r\n<blog-post post-title=\"Blog1\" post-content=\"I\\'m content1\" post-complete=\"true\" post-total-num=\"500\" post=\"{title:'Blog1'}\"></blog-post>\r\n```\r\n\r\n只要是直接傳遞(靜態傳遞)都是字串，所以 prop 接收的值 log1、I\\'m content1、true、500、{...} 等等都是字串。\r\n\r\n#### 傳遞數字、布林值、陣列、物件\r\n\r\n利用 vue 的 v-bind 傳遞字串以外的值。\r\n\r\n```vue\r\n<blog-post\r\n  post-title=\"動態傳遞\"\r\n  post-content=\"I\\'m content1\"\r\n  v-bind:post-complete=\"true\"\r\n  v-bind:post-total-num=\"500\"\r\n  v-bind:post=\"{ title: '動態傳遞' }\"\r\n></blog-post>\r\n```\r\n\r\n也可以透過給予變數來獲得數字、布林值、陣列或物件等型別\r\n\r\n```vue\r\n<blog-post\r\n  :post-title=\"postTitle\"\r\n  :post-content=\"postContent\"\r\n  :post-complete=\"postComplete\"\r\n  :post-total-num=\"postTotalNum\"\r\n  :post=\"post\"\r\n></blog-post>\r\n\r\n<script>\r\n  const vm = new Vue({\r\n    el: \"#vm\",\r\n    data: {\r\n      postTitle: \"動態傳遞\",\r\n      postContent: \"I'm content\",\r\n      postComplete: true,\r\n      postTotalNum: 500,\r\n      post: { title: \"動態傳遞\" },\r\n    },\r\n  });\r\n</script>\r\n```\r\n\r\n### 單向數據流\r\n\r\nprop 是為了接收從富組件傳遞過來的資料，而這些資料是單向綁定的，已就是說父模組資料的更新，會影響子模組裡的 prop，但子模組裡 prop 值改變並不會影響父模組。\r\n\r\n```vue\r\n<prop-change :counter=\"counter\"></prop-change>\r\n<br />\r\n<span>外 {{counter}}</span>\r\n<button type=\"button\" @click=\"changeOuterCounter\">改變外面數字</button>\r\n\r\n<script>\r\n  Vue.component(\"prop-change\", {\r\n    props: [\"counter\"],\r\n    template: `<div>\r\n    <span>component內的  {{counter}}</span>\r\n    <button type=\"button\" @click=\"changeInnerCounter\">改變component數字</button>\r\n  </div>`,\r\n    methods: {\r\n      changeInnerCounter() {\r\n        this.counter += 2;\r\n      },\r\n    },\r\n  });\r\n\r\n  const vm = new Vue({\r\n    el: \"#vm\",\r\n    data: {\r\n      counter: 1,\r\n    },\r\n    methods: {\r\n      changeOuterCounter() {\r\n        this.counter += 1;\r\n      },\r\n    },\r\n  });\r\n</script>\r\n```\r\n\r\n以上測試可以得知：\r\n\r\n- 外面(父層)的資料 counter 改變會影響子模組 prop 的 counter 的值。\r\n- 子模組 prop 的 counter 值改變僅影響內部 counter 值\r\n- 不論子模組的 prop 的 counter 值是否有變動，只要父模組資料 counter 改變時，子模組 prop 的 counter 值一定會連動。\r\n\r\n### 改變子模組內的 prop 值\r\n\r\n- 在 data 內創建一個值\r\n  賦予 data 跟 prop 初始值相同的值，且之後也是針對該 data 內的值操作，並且不會再受到該 prop 的影響了\r\n\r\n  ```javascript\r\n  Vue.component(\"one-way-data\", {\r\n    props: [\"counter\"],\r\n    template: `<div>\r\n      <span>component內的  {{newCounter}}</span>\r\n      <button type=\"button\" @click=\"changeNewCounter\">改變component數字</button>\r\n    </div>`,\r\n    data() {\r\n      return {\r\n        newCounter: this.counter,\r\n      };\r\n    },\r\n    methods: {\r\n      changeNewCounter() {\r\n        this.newCounter += 10;\r\n      },\r\n    },\r\n  });\r\n  ```\r\n\r\n### 物件型別的 prop 傳遞\r\n\r\n- 父層透過標籤傳遞參數\r\n\r\n```javascript\r\n<ExLogLineComponent :channel-names=\"channel_names\" :region-id=\"region.id\" :bx-mac=\"region.bx_mac\"></ExLogLineComponent>\r\n```\r\n\r\n- 子層 prop 接收參數後，透過 watch 將參數存入 data.return\r\n\r\n```javascript\r\nprops: ['channelNames', 'regionId', 'bxMac'],\r\n    data() {\r\n        return {\r\n            channel_names: [],\r\n            region_id: '',\r\n            mac: ''\r\n        }\r\n    },\r\n    watch: {\r\n        channelNames(names) {\r\n            this.channel_names = names;\r\n        },\r\n        regionId(id) {\r\n            this.region_id = id;\r\n        },\r\n        bxMac(mac) {\r\n            this.mac = mac;\r\n        }\r\n    },\r\n```\r\n\r\n### 子組件接收來自父組件的 props\r\n\r\n#### 在模板中\r\n\r\n```vue\r\n<template>\r\n  <div>{{ parentData }}</div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    props: [\"parentData\"],\r\n  };\r\n</script>\r\n```\r\n\r\n#### 在 data 中\r\n\r\n```vue\r\n<script>\r\n  export default {\r\n    props: [\"parentData\"],\r\n    data() {\r\n      return {\r\n        parent_data: this.parentData,\r\n      };\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n#### 在 methods 中\r\n\r\n```vue\r\n<script>\r\n  export default {\r\n    props: [\"parentData\"],\r\n    methods: {\r\n      printParentData: function () {\r\n        console.log(this.$props.parentData);\r\n      },\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n#### 在 mounted 中\r\n\r\n```vue\r\n<script>\r\n  export default {\r\n    props: [\"parentData\"],\r\n    mounted() {\r\n      console.log(this.message);\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n#### 在 computed 中\r\n\r\n```vue\r\n<template>\r\n  <div>\r\n    <p>{{ parentDataLength }}</p>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    props: [\"parentData\"],\r\n    computed: {\r\n      parentDataLength() {\r\n        return this.parentData.length;\r\n      },\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n## ref 取得 Dom 元素\r\n\r\n> `refs` 是 vue 提供的一個 api，可以讓我們在 vue 中取得 Dom 元素\r\n\r\n`ref` 被用來給元素或子組件註冊引用訊息，引用訊息將會註冊在父組件的`$refs` 物件上，如果在普通的 dom 元素上使用，那麼指向的就會是普通的 dom 元素；如果用在子組件上，引用就會指向該子組件的實例。\r\n\r\nref 的特性就是為元素或子組件賦予一個 id 引用，通過 `this.$ref.refName` 來訪問元素或是子組件的實例。\r\n\r\n- 一共有三種用法：\r\n  - ref 加在普通元素上，用 `this.ref.name` 獲取到的是 dom 元素\r\n  - ref 加在子組件上，用 `this.ref.name` 方式，獲得的是組件實例，可以使用組件的所有方法。\r\n  - 如何利用 v-for 和 ref 獲取一組陣列或是 dom 節點\r\n\r\n### 基本用法：取得 dom 元素\r\n\r\n```html\r\n<p ref=\"p\">Hello</p>\r\n<children ref=\"children\"></children>\r\n```\r\n\r\n```javascript\r\nthis.$ref.p;\r\nthis.$ref.children;\r\n```\r\n\r\n### 獲取子組件中的 data 和調用子組件的方法\r\n\r\n```vue\r\n<!-- 子組件 -->\r\n<template>\r\n  <div>{{ msg }}</div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data() {\r\n      return {\r\n        msg: \"我是子組件\";\r\n      }\r\n    },\r\n    methods: {\r\n      changeMsg() {\r\n        this.mag = \"變身\";\r\n      }\r\n    }\r\n  }\r\n</script>\r\n```\r\n\r\n```vue\r\n<!-- 父組件 -->\r\n<template>\r\n  <div @click=\"parentMethod\">\r\n    <children ref=\"children\"></children>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  import children from \"components/children.vue\";\r\n\r\n  export default {\r\n    components: {\r\n      children,\r\n    },\r\n    data() {\r\n      return {};\r\n    },\r\n    methods: {\r\n      parentMethod() {\r\n        this.$ref.children; // 返回一個物件\r\n        this.$ref.children.changMsg(); // 呼叫 children 的 changeMsg 方法\r\n      },\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n### 子組件呼叫父組件的方法\r\n\r\n```vue\r\n<!-- 子組件 -->\r\n<template>\r\n  <div></div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    methods: {\r\n      open() {\r\n        console.log(\"已呼叫\");\r\n        // 呼叫父組件方法\r\n        this.$emit(\"refreshData\");\r\n      },\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n```vue\r\n<!-- 父組件 -->\r\n<template>\r\n  <div id=\"app\">\r\n    <HelloWorld ref=\"hello\" @refreshData=\"getData\" />\r\n    <button @cilck=\"getHello\">取得 HelloWorld 組件中的值</button>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  import HelloWorld from \"./components/HelloWorld.vue\";\r\n\r\n  export default {\r\n    components: {\r\n      HelloWorld,\r\n    },\r\n    data() {\r\n      return {};\r\n    },\r\n    methods: {\r\n      getHello() {\r\n        this.$refs.hello.open();\r\n      },\r\n      getData() {\r\n        console.log(\"111111111\");\r\n      },\r\n    },\r\n  };\r\n</script>\r\n```\r\n\r\n最後輸出時，`已呼叫`為子組件輸出，`111111111111`為父組件輸出\r\n\r\n### this.$refs 介紹\r\n\r\n`this.$refs` 為一個物件，持有當前組件中註冊過`ref`特性的所有`dom`元素和子組件實例。\r\n\r\n注意：`$refs` 只有在組件完成渲染後才會填充，在初始渲染時無法取得，並且他是非響應式的，因此不能用他模版中做數據綁定。\r\n\r\n當 ref 和 v-for 一起用時，你得到的 ref 將會是一個包含了對應的數據源的這些子組件的陣列。\r\n\r\n```vue\r\n<template>\r\n  <ul>\r\n    <li v-for=\"item in people\" ref=\"refContent\">{{ item }}</li>\r\n  </ul>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data: {\r\n      return {\r\n        people:['one', 'two', 'three', 'four', 'five']\r\n      }\r\n    },\r\n    created() {\r\n      this.$nextTick(() => {\r\n        console.log(this.$refs.refContent);\r\n      })\r\n    },\r\n    mounted() {\r\n      console.log(this.$refs.refContent);\r\n    }\r\n  };\r\n</script>\r\n```\r\n\r\n## 備註\r\n\r\n- 註 1: `Truthy` 假值(false, 0, -0, 0n, \"\", null, undefined, NaN)以外的任何值皆為 true\r\n\r\n### 判斷當前環境是否為開發環境\r\n\r\n```javascript\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  this.is_dev = true;\r\n} else {\r\n  this.is_dev = false;\r\n}\r\n```\r\n","date":"2023-07-05T05:57:58.407Z","matchingLines":["## Vue 實體的生命週期\r","## Vue 屬性\r","## eventHub 事件中心 (vue 2)\r","## 指令(directive)\r","## 條件渲染\r","## 迴圈渲染\r","## 事件監聽器\r","## props\r","## ref 取得 Dom 元素\r","## 備註\r"]},{"name":"Laravel Artisan command.md","content":"# Artisan Command\r\n\r\n## 自訂 Artisan command\r\n\r\n### 利用指令建立要自訂命令的檔案\r\n\r\n```bash\r\nphp artisan make:command <command-name>\r\n```\r\n\r\n建立的檔案位置會在 app/Console/Commands\r\n\r\n### 編輯檔案\r\n\r\n編輯指令名稱\r\n\r\n```php\r\nprotected $signature = 'EditCity:city {country_code}';\r\n```\r\n\r\n實際指令\r\n\r\n```bash\r\nphp artisan EditCity:city us\r\n```\r\n\r\n編寫命令\r\n\r\n```php\r\npublic function handle()\r\n{\r\n    try {\r\n       echo \"Hello World\";\r\n    } catch (QueryException $ex) {\r\n        dd($ex->getMessage());\r\n    }\r\n}\r\n```\r\n\r\n### 參數\r\n\r\n- 花括號中為傳入的參數\r\n\r\n  - {country_code?} 可選的參數\r\n  - {country_code=tw} 參數的預設值\r\n  - {country_code*} `*`代表輸入的是陣列\r\n  - {country_code:國家代碼} 加入敘述\r\n\r\n- 選項：關鍵字是`--`\r\n\r\n  - {--queue=} 選項後面加上 `=`，表示選項需要明確指定值。\r\n  - {--Q|queue} 可用簡寫\r\n  - {--id=_} `_`代表輸入的是陣列\r\n  - {--queue=:這個工作是否該進入隊列} 加入敘述\r\n\r\n- 取得參數\r\n\r\n  - $this->argument('user') 取得單一 user 參數\r\n  - $this->arguments() 取得所有參數，以陣列呈現\r\n  - $this->options('queue') 取得單一 queue 選項\r\n  - $this->options() 取得所有選項，以陣列呈現\r\n\r\n- 互動式指令\r\n\r\n  - ask 詢問\r\n\r\n    ```php\r\n    $name = $this->ask('what is ur name');\r\n    ```\r\n\r\n  - secret 詢問，但回答在終端機看不到\r\n\r\n    ```php\r\n    $name = $this->secret('what is ur password');\r\n    ```\r\n\r\n  - confirm 確認問題，預設回傳值是 false，若使用者回傳 y 則回傳 true\r\n\r\n    ```php\r\n    if ($this->confirm('wanna continue?')) {\r\n        //\r\n    }\r\n\r\n    ```\r\n\r\n  - anticipate 自動完成，若是 Taylor 或是 Dayle 這兩個選項就自動完成，使用者亦可以輸入其他選項\r\n\r\n    ```php\r\n    $name = $this->anticipate('what is ur name', ['Taylor', 'Dayle']);\r\n    ```\r\n\r\n  - choice 選項選擇，使用者輸入 key 值\r\n\r\n    ```php\r\n    $name $this->choice('what is ur name', ['Sunny', 'Taylor', 'Dayle'], $defaultIndex);\r\n    ```\r\n\r\n    ```log\r\n    What is your name? [Taylor]: //在這個$defaultIndex = 1\r\n      [0] Sunny\r\n      [1] Taylor\r\n      [2] Dayle\r\n     > 0\r\n\r\n    Display name: Sunny\r\n    ```\r\n\r\n### 註冊 command\r\n\r\napp\\console\\Commands\\Kernel.php\r\n\r\n```php\r\nprotected $commands = [\r\n    EditCity::class\r\n];\r\n```\r\n","date":"2023-07-05T01:08:28.613Z","matchingLines":["## 自訂 Artisan command\r"]},{"name":"前端工具.md","content":"# 前端開發工具\r\n\r\n## 假圖生產器：Lorem Picsum\r\n\r\n### 使用方法\r\n\r\n- 指定長寬\r\n\r\n  ```html\r\n  <img src=\"https://picsum.photos/<length>/<width>\" />\r\n  ```\r\n\r\n- random 生成不同圖片\r\n\r\n  ```html\r\n  <img src=\"https://picsum.photos/80?random=1\" />\r\n  <img src=\"https://picsum.photos/80?random=2\" />\r\n  <img src=\"https://picsum.photos/80?random=3\" />\r\n  ```\r\n\r\n  若沒有帶 random 參數，在相同的 url 之下，同一次頁面載入時，每一張圖片都會是一樣的。\r\n\r\n- grayscale 生成灰階圖片\r\n\r\n  ```html\r\n  <img src=\"https://picsum.photos/80?grayscale\" />\r\n  ```\r\n\r\n- blur 生成模糊濾鏡圖片\r\n\r\n  ```html\r\n  <img src=\"https://picsum.photos/80?blur\" />\r\n  ```\r\n","date":"2023-06-28T03:01:37.977Z","matchingLines":["## 假圖生產器：Lorem Picsum\r"]},{"name":"Laravel 環境設置.md","content":"# Laravel 環境設置\r\n\r\n- [Laravel 環境設置](#laravel-環境設置)\r\n  - [環境初始設定](#環境初始設定)\r\n    - [1. 安裝 XAMPP or phpEnv](#1-安裝-xampp-or-phpenv)\r\n      - [xampp 更改 php 版本 (版本 5 =\\> 7)](#xampp-更改-php-版本-版本-5--7)\r\n      - [macOS Monterey 上安裝 PHP](#macos-monterey-上安裝-php)\r\n    - [2. 安裝 composer](#2-安裝-composer)\r\n      - [windows 透過 composer 官網下載 composer 安裝檔](#windows-透過-composer-官網下載-composer-安裝檔)\r\n      - [下載 Composer(MacOS)](#下載-composermacos)\r\n      - [全局調用 Composer (MacOS)](#全局調用-composer-macos)\r\n    - [3. 安裝 Visual Studio Code or phpStorm](#3-安裝-visual-studio-code-or-phpstorm)\r\n    - [4. Laravel 全域安裝 (XAMPP)](#4-laravel-全域安裝-xampp)\r\n  - [從 Git clone Laravel 專案](#從-git-clone-laravel-專案)\r\n    - [開發環境設定](#開發環境設定)\r\n    - [上線環境設定](#上線環境設定)\r\n    - [composer install 失敗](#composer-install-失敗)\r\n  - [Laravel ReactJS](#laravel-reactjs)\r\n  - [Laravel 安裝 bootstrap](#laravel-安裝-bootstrap)\r\n    - [Laravel 8](#laravel-8)\r\n    - [Laravel 6](#laravel-6)\r\n\r\n## 環境初始設定\r\n\r\n### 1. 安裝 XAMPP or phpEnv\r\n\r\n#### xampp 更改 php 版本 (版本 5 => 7)\r\n\r\n> 注意！php 8.1 不相容 laravel 6.x 以下(包含 6)\r\n\r\n1. 開啟 Apache Admin 查看當前 XAMPP 所有版本資訊\r\n2. 到[XAMPP](https://windows.php.net/download/)下載要更新的 php 版本的 zip 檔。(注意！選擇 `Thread Safe` 版本！)\r\n3. 解壓縮定指定資料夾名稱為`php`，將此資料夾放至 XAMPP 資料夾中，並將原本的 php 資料夾另外命名\r\n4. 至 XAMPP 控制面板點選 `config` 按鈕，開啟 `httpd-xampp.conf` 檔，並修改其內容\r\n\r\n   1. 找到以下文字，並將其修改\r\n\r\n      修改前\r\n\r\n      ```txt\r\n      LoadFile \"C:/xampp/php/php5ts.dll\"\r\n      LoadFile \"C:/xampp/php/libpq.dll\"\r\n      LoadModule php5_module \"C:/xampp/php/php5apache2_4.dll\"\r\n      ```\r\n\r\n      修改後\r\n\r\n      ```txt\r\n      LoadFile \"C:/xampp/php/php7ts.dll\"\r\n      LoadFile \"C:/xampp/php/libpq.dll\"\r\n      LoadModule php7_module \"C:/xampp/php/php7apache2_4.dll\"\r\n      ```\r\n\r\n      - 修改時需確認修改路徑的檔案確實存在，若無此檔案，可能是 php 版本的關係\r\n\r\n   2. 將 `httpd-xampp.conf` 設定檔中所有 `php5_module` 改為 `php7_module`\r\n      - 在 php8 的 `httpd-xampp.conf` 設定檔為 `php_module`\r\n\r\n5. 重建 `php.ini` 設定檔\r\n\r\n   1. 複製 php 資料夾中的 php.ini-development，並重新命名為 php.ini\r\n   2. 開啟 php.ini 並依開發或網站需求，開啟相關模組(刪除前面的分號`;`)\r\n      1. `Dynamic Extensions` 動態延伸功能\r\n         - extension=curl\r\n         - extension=gd2(version 7) / gd(version 8)\r\n           - 在 php 8.0，DG 延伸功能 windows dll 文件名稱由 php_gd2.dll 改為 php_gd.dll)\r\n         - extension=mbstring\r\n         - **extension=mysqli**\r\n         - extension=openssl\r\n      2. `Paths and Directories` 路徑和目錄\r\n         - **extension_dir = \"ext\"**\r\n      3. 常見設定\r\n         - max_execution_time = 600\r\n         - short_open_tag = On\r\n         - max_input_time = 180\r\n         - **error_reporting=E_ALL & ~E_DEPRECATED & ~E_STRICT**\r\n           - 設置錯誤訊息通知，加入版本兼融性的提示\r\n         - memory_limit = 500M\r\n         - post_max_size = 500M\r\n         - upload_max_filesize = 100M\r\n         - max_file_uploads = 50\r\n\r\n6. 至 XAMPP 面板重啟 Apache\r\n7. 重新執行 composer update\r\n\r\n#### macOS Monterey 上安裝 PHP\r\n\r\n> 問題：安裝完 MAMP 之後，要用終端機安裝 composer，結果出現`zsh: command not found: php`\r\n>\r\n> 原因：MacOS Monterey 版本，預設沒有安裝 PHP。\r\n\r\n1. 安裝 PHP\r\n   [Installing PHP on your Mac](https://daily-dev-tips.com/posts/installing-php-on-your-mac/)\r\n\r\n1. 安裝 Homebrew\r\n   在 terminal 輸入\r\n\r\n   ```terminal\r\n   /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\r\n   ```\r\n\r\n   顯示路徑問題的解決辦法\r\n\r\n   ```terminal\r\n   echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"' >> /Users/changgenglu/.zprofile\r\n\r\n   eval \"$(/opt/homebrew/bin/brew shellenv)\"\r\n   ```\r\n\r\n1. 使用 Homebrew 安裝 PHP\r\n   先確定 Homebrew 安裝成功\r\n\r\n   ```terminal\r\n   brew update\r\n   brew doctor\r\n   ```\r\n\r\n   安裝 PHP\r\n\r\n   ```terminal\r\n   brew install php\r\n   ```\r\n\r\n   安裝特定版本\r\n\r\n   ```terminal\r\n   brew install php@7.4\r\n   ```\r\n\r\n   - 安裝指定版本後，並不會自動切換 PHP 本版本\r\n\r\n1. 使用 Homebrew 切換 PHP\r\n   檢查當前版本\r\n\r\n   ```terminal\r\n   php -v\r\n\r\n   # PHP 8.0.1 (cli) (built: Jan  8 2021 01:27:28) ( NTS )\r\n   ```\r\n\r\n   取消該版本\r\n\r\n   ```terminal\r\n   brew unlink php@8.0\r\n   ```\r\n\r\n   選擇版本\r\n\r\n   ```terminal\r\n   brew link php@7.4\r\n   ```\r\n\r\n   出現路徑問題，提示：須遜行腳本來添加路徑\r\n\r\n   ```terminal\r\n   echo 'export PATH=\"/opt/homebrew/opt/php@7.4/bin:$PATH\"' >> ~/.zshrc\r\n\r\n   ```\r\n\r\n### 2. 安裝 composer\r\n\r\n#### windows 透過 composer 官網下載 composer 安裝檔\r\n\r\n#### 下載 Composer(MacOS)\r\n\r\n- 代碼以[Composer 官網](https://getcomposer.org/download/)為主\r\n\r\n下載安裝程序到當前目錄\r\n\r\n```bash\r\nphp -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\"\r\n```\r\n\r\n驗證安裝程序\r\n\r\n```bash\r\nphp -r \"if (hash_file('sha384', 'composer-setup.php') === '906a84df04cea2aa72f40b5f787e49f22d4c2f19492ac310e8cba5b96ac8b64115ac402c8cd292b8a03482574915d1a8') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;\"\r\n```\r\n\r\n運行安裝程序\r\n\r\n```bash\r\nphp composer-setup.php\r\n```\r\n\r\n刪除安裝程序\r\n\r\n```bash\r\nphp -r \"unlink('composer-setup.php');\"\r\n```\r\n\r\n- MacOS 如果出現 `zsh: command not found: php`\r\n\r\n  原因：MacOS Monterry 版本，沒有包括 PHP。請參考：[macOS Monterey 上安裝 PHP](https://hackmd.io/wnFCr0GUS-iIRxHY2zrBgw)\r\n\r\n- MacOS 須確保 Composer 的系統等級 vendor bin 資料夾有放在$PATH 中，這樣作業系統才能找到`laravel` 可執行檔。一般常見的位置如下：\r\n  - macOS: $HOME/.composer/vendor/bin\r\n  - Windows: %USERPROFILE%\\AppData\\Roaming\\Composer\\vendor\\bin\r\n\r\n#### 全局調用 Composer (MacOS)\r\n\r\n確認是否成功安裝 Composer\r\n\r\n```bash\r\nls\r\n\r\n// 要看到有composer.phar的檔案\r\n```\r\n\r\n將 composer.phar 放入本地的目錄\r\n\r\n```bash\r\nsudo mv composer.phar /usr/local/bin/composer\r\n```\r\n\r\n測試是否安裝成功\r\n\r\n```bash\r\ncomposer\r\n```\r\n\r\n### 3. 安裝 Visual Studio Code or phpStorm\r\n\r\n### 4. Laravel 全域安裝 (XAMPP)\r\n\r\n```bash\r\ncd c:\\xampp\\htdocs\r\ncomposer global require laravel/installer\r\n\r\nlaravel new project_name\r\n\r\ncd project_name\r\n\r\nphp artisan serve\r\n```\r\n\r\n## 從 Git clone Laravel 專案\r\n\r\n由於安全性及維護的考量，Laravel 預設有 .gitignore，所以較為敏感的檔案，不會被 push 上去。\r\n因此專案 clone 下來之後，必須要重建才能正常執行。\r\n\r\n### 開發環境設定\r\n\r\n1. 安裝依賴套件\r\n\r\n   ```bash\r\n   composer install\r\n   ```\r\n\r\n2. 設定.env 檔\r\n\r\n   複製.env.example 並更改為.env\r\n\r\n   ```bash\r\n   cp .env.example .env\r\n   ```\r\n\r\n   修改.env\r\n\r\n3. 設定加密的 APP_KEY\r\n\r\n   ```bash\r\n   php artisan key:generate\r\n   ```\r\n\r\n4. 設定資料庫\r\n\r\n   建立 MySQL 所需的資料庫\r\n\r\n5. Migration 和 Seeding 建立資料表結構\r\n\r\n   ```cmd\r\n   php artisan migrate\r\n   &\r\n   php artisan db:seed\r\n   &\r\n   php artisan migrate --seed\r\n   ```\r\n\r\n6. 若有安裝 passport 需運行命令產生 Access Token\r\n\r\n   ```bash\r\n   php artisan passport:install\r\n   ```\r\n\r\n7. 建立符號連結\r\n   如果有使用到 public storage （如：Storage::disk('public')），\r\n   記得使用以下指令，將 storage 軟連結到 storage/app/public\r\n\r\n   ```cmd\r\n   php artisan storage:link\r\n   ```\r\n\r\n8. 設定伺服器\r\n\r\n   例如到 NGINX 新增、調整 conf 檔\r\n\r\n9. 設定任務排程\r\n\r\n   如果有在 Laravel 中定義排程的任務，\r\n   記得在 crontab 中增加 Laravel 指令排程器\r\n\r\n   ```cmd\r\n   # 在 crontab -e 中\r\n   * * * * * php /path-to-your-project/artisan schedule:run >> /dev/null 2>&1\r\n   ```\r\n\r\n### 上線環境設定\r\n\r\n1. 安裝 composer 排除 dev 項目\r\n\r\n   ```bash\r\n   composer install --optimize-\r\n   loader --no-dev\r\n   ```\r\n\r\n2. `.env`設定轉為線上並且關閉錯誤提示\r\n\r\n   ```php\r\n   APP_NAME=專案名稱\r\n   APP_ENV=production\r\n   APP_KEY=\r\n   APP_DEBUG=false\r\n   APP_URL=https://正式網址\r\n   ```\r\n\r\n3. 設定快取\r\n\r\n   ```bash\r\n   php artisan config:cache\r\n\r\n   #　下次更新程式記得更新config\r\n   php artisan config:clear\r\n   ```\r\n\r\n4. Router 快取  \r\n   error: (Unable to prepare route [api/user] for serialization. Uses Closure. )\r\n\r\n   ```bash\r\n   php artisan route:cache\r\n\r\n   # 下次更新程式記得更新route\r\n   php artisan route:clear\r\n   php artisan cache:clear\r\n   ```\r\n\r\n5. Composer 緩存\r\n\r\n   ```bash\r\n   composer dump\r\n   load -o\r\n   # 每次更新composer install 後，都要再執行一次\r\n   ```\r\n\r\n6. 類別緩存  \r\n   error: (Unable to prepare route [api/user] for serialization. Uses Closure. )\r\n\r\n   ```bash\r\n   php artisan optimize\r\n   ```\r\n\r\n7. 清除類別緩存\r\n\r\n   ```bash\r\n   php artisan clear-compiled\r\n   ```\r\n\r\n8. 建立 keygen\r\n\r\n   ```bash\r\n   php artisan key:generate\r\n   ```\r\n\r\n9. 若有安裝 passport 需運行命令產生 Access Token\r\n\r\n   ```bash\r\n   php artisan passport:keys\r\n   ```\r\n\r\n10. 執行\r\n\r\n```bash\r\n# 遷移資料表\r\nphp artisan migrate\r\n# 填充資料\r\nphp artisan db:seed\r\n```\r\n\r\n### composer install 失敗\r\n\r\n```shell\r\nnode: /lib64/libm.so.6: version `GLIBC_2.27` not found (required by node)\r\nnode: /lib64/libc.so.6: version `GLIBC_2.28` not found (required by node)\r\nnode: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.28` not found (required by node)\r\n```\r\n\r\n當出現上面的錯誤訊息，表示 GLIBC 的版本不符合現行系統上的 node 版本。\r\n\r\n解決錯誤常見的方法有兩種：\r\n\r\n1. 安裝較舊、支援更廣泛的 Node.js (16.x) 版本\r\n\r\n   使用 `nvm` 安裝其他版本的 node.js\r\n\r\n   ```shell\r\n   nvm install 16\r\n   nvm use 16\r\n   ```\r\n\r\n   完成後確認當前版本\r\n\r\n   ```shell\r\n   nvm ls\r\n   node --version\r\n   ```\r\n\r\n   移除特定版本\r\n\r\n   ```shell\r\n   # 👇️ uninstall Node.js version 13.X.X\r\n   nvm uninstall 13\r\n   ```\r\n\r\n   若還未安裝 nvm\r\n\r\n   ```shell\r\n   curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash\r\n   chmod +x ~/.nvm/nvm.sh\r\n   source ~/.bashrc\r\n   # 驗證 nvm 是否安裝成功\r\n   nvm -v\r\n   ```\r\n\r\n2. 將 Linux 操作系統升級到更新版本。\r\n\r\n## Laravel ReactJS\r\n\r\n> Use laravel/ui Package to install react in laravel with Bootstrap 4.\r\n\r\n1. 建立新的專案\r\n\r\n   ```cmd\r\n   composer create-project laravel/laravel --prefer-dist running_in_circles\r\n\r\n   laravel new running_in_circles\r\n   ```\r\n\r\n2. 進入 Laravel 項目\r\n\r\n   ```cmd\r\n   cd running_in_circles\r\n   ```\r\n\r\n3. 安裝 laravel/ui\r\n\r\n   ```cmd\r\n   composer require laravel/ui\r\n   ```\r\n\r\n4. 在 Laravel 中安裝 React\r\n\r\n   ```cmd\r\n   php artisan ui react\r\n   ```\r\n\r\n5. 安裝所需的軟件包\r\n\r\n   ```cmd\r\n   <!-- 檢查node和npm是否安裝 -->\r\n       node -v\r\n       npm -v\r\n   <!-- 建立一個node_modules資料夾並自動安裝package.json -->\r\n       npm install\r\n   ```\r\n\r\n6. 在 Laravel 中設置 React 組件\r\n\r\n   ```javascript\r\n   // 路徑 ==> resource/js/components/User.js\r\n   import React from \"react\";\r\n   import ReactDOM from \"react-dom\";\r\n\r\n   function User() {\r\n     return (\r\n       <div className=\"container mt-5\">\r\n         <div className=\"row justify-content-center\">\r\n           <div className=\"col-md-8\">\r\n             <div className=\"card text-center\">\r\n               <div className=\"card-header\">\r\n                 <h2>React Component in Laravel</h2>\r\n               </div>\r\n               <div className=\"card-body\">I am tiny React component in Laravel app!</div>\r\n             </div>\r\n           </div>\r\n         </div>\r\n       </div>\r\n     );\r\n   }\r\n\r\n   export default User;\r\n\r\n   // DOM element\r\n   if (document.getElementById(\"user\")) {\r\n     ReactDOM.render(<User />, document.getElementById(\"user\"));\r\n   }\r\n   ```\r\n\r\n7. 修改 resources/js/app.js 註冊 React 文件\r\n\r\n   ```javascript\r\n   require(\"./bootstrap\");\r\n\r\n   // Register React components\r\n   require(\"./components/Example\");\r\n   require(\"./components/User\");\r\n   ```\r\n\r\n8. 修改 views/welcome.blade.php 模板\r\n\r\n   ```html\r\n   <!DOCTYPE html>\r\n   <html lang=\"{{ str_replace('_', '-', app()->getLocale()) }}\">\r\n     <head>\r\n       <meta charset=\"utf-8\" />\r\n       <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n       <title>Laravel</title>\r\n       <!-- Styles -->\r\n       <link href=\"{{ asset('css/app.css') }}\" rel=\"stylesheet\" />\r\n     </head>\r\n\r\n     <body>\r\n       <!-- React root DOM -->\r\n       <div id=\"user\"></div>\r\n       <!-- React JS -->\r\n       <script src=\"{{ asset('js/app.js') }}\" defer></script>\r\n     </body>\r\n   </html>\r\n   ```\r\n\r\n9. 執行命令編譯 Laravel 和 React.js\r\n\r\n   ```cmd\r\n   npm run watch\r\n   ```\r\n\r\n10. 編譯成功，運行 laravel\r\n\r\n```cmd\r\nphp artisan serve\r\n```\r\n\r\n## Laravel 安裝 bootstrap\r\n\r\n### Laravel 8\r\n\r\n1. 終端機\r\n\r\n   ```cmd\r\n   npm install\r\n   ```\r\n\r\n2. 建立文件(如果尚未建立) `resources/sass/app.scss` 並引入:\r\n   `@import '~bootstrap';`\r\n\r\n3. 在 webpack.mix.js 加入\r\n\r\n   ```php\r\n   mix.sass('resources/sass/app.scss', 'public/css')\r\n   ```\r\n\r\n4. 終端機\r\n\r\n   ```cmd\r\n   npm run dev\r\n   ```\r\n\r\n5. 現在可以引用 bootstrap\r\n\r\n   ```php\r\n   <link href=\"{{ asset('css/app.css') }}\" rel=\"stylesheet\">\r\n   ```\r\n\r\n### Laravel 6\r\n\r\n1. 終端機輸入\r\n\r\n   ```cmd\r\n   composer require laravel/ui=\"1.*\" --dev\r\n   ```\r\n\r\n2. 輸入\r\n\r\n   ```cmd\r\n   php artisan ui bootstrap\r\n   ```\r\n\r\n3. 如果出現 \"Command \"ui\" is not defined.\"\r\n\r\n   ```cmd\r\n   composer update\r\n   ```\r\n\r\n4. 執行\r\n\r\n   ```cmd\r\n   npm install\r\n   ```\r\n\r\n5. 終端機\r\n\r\n   ```cmd\r\n   npm run dev\r\n   ```\r\n\r\n6. 現在可以引入\r\n\r\n   ```php\r\n   <link rel=\"stylesheet\" href=\"/css/app.css\">\r\n   <script src=\"/js/app.js\"></script>\r\n   ```\r\n","date":"2023-06-27T07:48:13.048Z","matchingLines":["## 環境初始設定\r","## 從 Git clone Laravel 專案\r","## Laravel ReactJS\r","## Laravel 安裝 bootstrap\r"]},{"name":"Git 學習筆記.md","content":"# Git 學習筆記\r\n\r\n- [Git 學習筆記](#git-學習筆記)\r\n  - [常用指令](#常用指令)\r\n    - [Git 常用指令](#git-常用指令)\r\n    - [Git Bash 常用指令](#git-bash-常用指令)\r\n  - [Git Flow 開發流程觀念](#git-flow-開發流程觀念)\r\n    - [分支介紹](#分支介紹)\r\n      - [長期分支](#長期分支)\r\n      - [任務分支(Topic)](#任務分支topic)\r\n        - [feature](#feature)\r\n        - [release](#release)\r\n        - [hotfix](#hotfix)\r\n    - [Git Commit 規範](#git-commit-規範)\r\n      - [Commit Message 格式](#commit-message-格式)\r\n      - [標題](#標題)\r\n      - [正文](#正文)\r\n      - [Footer](#footer)\r\n      - [commit 模板](#commit-模板)\r\n  - [Git 操作情境](#git-操作情境)\r\n    - [將 git 預設的編輯器改為 vim](#將-git-預設的編輯器改為-vim)\r\n    - [取消 commit：git reset](#取消-commitgit-reset)\r\n      - [確認 git 紀錄](#確認-git-紀錄)\r\n      - [利用相對位置取消 commit](#利用相對位置取消-commit)\r\n      - [利用絕對位置取消 commit](#利用絕對位置取消-commit)\r\n    - [git commit 打錯字](#git-commit-打錯字)\r\n    - [轉移資料庫：git mirror](#轉移資料庫git-mirror)\r\n    - [將未完成的工作暫存：git stash](#將未完成的工作暫存git-stash)\r\n      - [將現階段工作暫存](#將現階段工作暫存)\r\n      - [取出暫存](#取出暫存)\r\n      - [主要指令](#主要指令)\r\n    - [解決合併衝突](#解決合併衝突)\r\n    - [更改 git remote 位置](#更改-git-remote-位置)\r\n    - [取消 merge (清除合併紀錄)](#取消-merge-清除合併紀錄)\r\n    - [新增遠端儲存庫](#新增遠端儲存庫)\r\n    - [Git 別名](#git-別名)\r\n  - [Git 管理](#git-管理)\r\n    - [使用 VSCode 管理 Git](#使用-vscode-管理-git)\r\n  - [GitHub 操作](#github-操作)\r\n    - [將本地專案上傳到 github](#將本地專案上傳到-github)\r\n    - [Https 設定 Token](#https-設定-token)\r\n      - [設定 personal access token](#設定-personal-access-token)\r\n    - [設定 SSH](#設定-ssh)\r\n      - [輸入指令產生 SHH](#輸入指令產生-shh)\r\n      - [產生 SSH 連線所需的公鑰內容](#產生-ssh-連線所需的公鑰內容)\r\n      - [上傳公鑰](#上傳公鑰)\r\n    - [部署靜態頁面到 github](#部署靜態頁面到-github)\r\n\r\n## 常用指令\r\n\r\n### Git 常用指令\r\n\r\n- `git init` 將目前的目錄初始化為 Git 目錄, 建立本地儲存庫\r\n- `git config` 設定或檢視 Git 設定檔資訊\r\n- `git add` 將檔案加入 Git 暫存區\r\n- `git rm` 將檔案移出 Git 暫存區\r\n- `git status` 顯示 Git 狀態\r\n- `git commit` 將暫存區的檔案提交至儲存庫納入版本控制\r\n- `git log` 顯示過去歷次的版本異動\r\n- `git reflog` 顯示完整的版本異動歷史紀錄\r\n- `git show` 顯示指定版本的異動內容\r\n- `git branch` 建立一個新分支 (branch)\r\n- `git checkout` 取出分支內容還原為工作目錄\r\n- `git merge` 合併分支\r\n- `git reset` 重設某一版本\r\n- `git clone` 從遠端儲存庫 (GitHub 或 Bitbucket) 複製副本至本地儲存庫\r\n- `git push` 將本地儲存庫內容推送到遠端儲存庫\r\n- `git pull` 將遠端儲存庫拉回合併更新到本地儲存庫\r\n\r\n### Git Bash 常用指令\r\n\r\n| Linux            | Windows               | 說明                             |\r\n| ---------------- | --------------------- | -------------------------------- |\r\n| `pwd`            | `cd`                  | 顯示幕前目錄                     |\r\n| `ls -al`         | `dir`                 | 顯示目前目錄下的檔案與子目錄列表 |\r\n| `mkdir tmp`      | `md tmp`              | 建立子目錄 tmp                   |\r\n| `rm -r tmp`      | `rd tmp`              | 刪除子目錄 tmp                   |\r\n| `cd tmp`         | `cd tmp`              | 切換至子目錄 tmp                 |\r\n| `cd ..`          | `cd ..`               | 切換至上一層目錄                 |\r\n| `touch test.txt` | `copy nul > test.txt` | 建立空白文字檔案                 |\r\n| `cat file/more`  | `type file`           | 顯示檔案內容                     |\r\n| `rm file`        | `del file`            | 刪除檔案 file                    |\r\n| `mv file1 file2` | `ren file1 file2`     | 將檔案 file1 更名為 file2        |\r\n| `cp file1 file2` | `copy file1 file2`    | 複製檔案 file1 為 file2          |\r\n| `date`           | `date`                | 顯示日期 (Linux 含時間)          |\r\n| `clear`          | `cls`                 | 清除螢幕                         |\r\n\r\n## Git Flow 開發流程觀念\r\n\r\n> [參考資料：Git Flow 是什麼？為什麼需要這種東西？](https://gitbook.tw/chapters/gitflow/why-need-git-flow)\r\n>\r\n> [參考資料：Git flow 分支策略](https://git-tutorial.readthedocs.io/zh/latest/branchingmodel.html)\r\n\r\n### 分支介紹\r\n\r\n#### 長期分支\r\n\r\n- **main**(原為 master, 於 2020/10 變更)  \r\n   主要為穩定，上線的版本。不該允許開發者直接 commit 到此分支。  \r\n   一般在專案初期，環境建置好就會拉 develop 分支出去，以維持 main 獨立性。\r\n- **develop**  \r\n   所有開發分支的基礎，當新增/修改功能時，會從此分支切出去，完成後再合併回來。\r\n\r\n#### 任務分支(Topic)\r\n\r\n##### feature\r\n\r\n開發新功能時，會從 develop 切出 feature 分支，其命名方式採`feature/功能名稱`。只要新功能未完成，功能分支就會持續存在，直到開發完成並合併回開發分支，或直到放棄此新功能。\r\n\r\n此分支通常只會存在於該功能的開發者的本機端 repository，不會出現在遠端的庫中。\r\n\r\n- 原則：\r\n  - 從 develop 分支分離\r\n  - 合併回 develop 分支\r\n  - 分支命名原則：除了 master, develop, release-\\*, hotfix 之外的功能名稱都可以\r\n\r\n詳細步驟：\r\n\r\n1. 開新功能分支\r\n\r\n   ```bash\r\n   # 從 develop 分支開一個命為 new-feature 的分支\r\n   $ git checkout -b feature/new-feature develop\r\n   ```\r\n\r\n2. 將已開發完成之功能合併回 develop 分支\r\n\r\n   ```bash\r\n   # 切換至開發分支\r\n   $ git checkout develop\r\n\r\n   # 將 new-feature 分支合併到開發分支\r\n   $ git merge --no-ff feature/new-feature\r\n\r\n   # 刪除 new-feature 分支\r\n   $ git branch -d feature/new-feature\r\n\r\n   # 將開發分支push到遠端的origin\r\n   $ git push origin develop\r\n   ```\r\n\r\n`--no-ff` 可保存 feature 上面的歷史資訊，讓開發者可以更瞭解開發的來龍去脈(No Fast Forward)。\r\n\r\n##### release\r\n\r\n由 develop 切出來，正式上線前的最終測試分支，通過後會將 release 合併到 main 以及 develop 確保在 release 時修正的一些問題能同步到 main 與 develop。\r\n\r\n制訂版本號碼的最佳時機是在發布分支時。\r\n\r\n- 原則\r\n  - 從 develop 分離\r\n  - 合併回 develop 與 main 分支\r\n  - 分支命名規則：release-\\*(版本號)\r\n\r\n詳細步驟：\r\n\r\n1. 開發佈分支\r\n\r\n   ```bash\r\n   # 從開發分支開一支名為「release-1.2」的分支，開完後切換到release-1.2分支。\r\n   $ git checkout -b release-1.2 develop\r\n   ```\r\n\r\n2. 制訂版本號\r\n\r\n   ```bash\r\n   # commit 一個版本，commmit 訊息為「版本跳躍至1.2]\r\n   $ git commit -a -m \"Bump version number to 1.2\"\r\n   ```\r\n\r\n3. 將已制訂好的 metadata 或已修復錯誤的發佈分支，合併到主分支\r\n\r\n   ```bash\r\n   # 切換至主要分支\r\n   $ git checkout master\r\n\r\n   # 將release-1.2分支合併到主要分支\r\n   $ git merge --no-ff release-1.2\r\n\r\n   # 上tag\r\n   $ git tag -a 1.2\r\n   ```\r\n\r\n4. 將已制訂好 metadata 或已修復錯誤的發佈分支，合併回開發分支\r\n\r\n   ```bash\r\n   # 切換至開發分支\r\n   $ git checkout develop\r\n\r\n   # 將release-1.2分支合併回開發分支\r\n   $ git merge --no-ff release-1.2\r\n   ```\r\n\r\n5. 刪除 release-1.2 分支\r\n\r\n   ```bash\r\n   # 刪除分支\r\n   $ git branch -d release-1.2\r\n   ```\r\n\r\n##### hotfix\r\n\r\n上線版本需緊急修復時，由 main 直接切出的 hotfix 分支，修復完成也會合併至 main 分支。\r\n\r\n由於 develop 在開發中，若從 develop 切 hotfix 分支，再合併至 main 分支時可能會出現更嚴重的問題。\r\n\r\n當 bug 修復後，可合併到開發分支，或是合併回主分支，並標上另一版本號的 tag。\r\n\r\n- 原則：\r\n  - 從主分支分離\r\n  - 合併回開發分支或主分支\r\n  - 分支命名規則為：hotfix-\\*\r\n\r\n詳細步驟：\r\n\r\n1. 開修復分支\r\n\r\n   ```bash\r\n   # 從主要分支開一支名為「hotfix-1.2.1」的分支，開完後切換到hotfix-1.2.1分支。\r\n   $ git checkout -b hotfix-1.2.1 master\r\n   ```\r\n\r\n2. 制訂版本號\r\n\r\n   ```bash\r\n   # commit 一個版本，commit 訊息為「版本號跳躍至1.2.1」\r\n   $ git commit -a -m \"Bumped version number to 1.2.1\"\r\n   ```\r\n\r\n3. 修正 bug 並 commit 一版\r\n\r\n   ```bash\r\n   # commit 修正版\r\n   $ git commit -m \"Fixed severe production problem\"\r\n   ```\r\n\r\n4. 將修好的分支合併回主分支\r\n\r\n   ```bash\r\n   # 切換至主要分支\r\n   $ git checkout master\r\n\r\n   # 將hotfix-1.2.1分支合併到主要分支\r\n   $ git merge --no-ff hotfix-1.2.1\r\n\r\n   # 上tag\r\n   $ git tag -a 1.2.1\r\n   ```\r\n\r\n5. 將修好的分支合併回 develop 分支\r\n\r\n   ```bash\r\n   # 切換至開發分支\r\n   $ git checkout develop\r\n\r\n   # 將hotfix-1.2.1分支合併回開發分支\r\n   $ git merge --no-ff hotfix-1.2.1\r\n   ```\r\n\r\n   **特別注意** 若修復分支與發佈分支同時存在，則當 bug 修正後，就不是合併回開發分支而是發佈分支。修補程式就會在從未來發布分支合併回開發分支時，一併將 bug 修補完。\r\n\r\n6. 刪除 hotfix 分支\r\n\r\n   ```bash\r\n   # 刪除分支\r\n   $ git branch -d hotfix-1.2.1\r\n   ```\r\n\r\n### Git Commit 規範\r\n\r\n> [Git Commit Message 這樣寫會更好，替專案引入規範與範例](https://ithelp.ithome.com.tw/articles/10228738)\r\n\r\n#### Commit Message 格式\r\n\r\n```bash\r\n\r\n# 標題: <type>(<scope>): <subject>\r\n# - type: feat, fix, docs, style, refactor, test, chore\r\n# - scope: 如果修改範圍為全局修改或難以分配給單個組件，可略\r\n# - subject: 以動詞開頭的簡短描述\r\n#\r\n# 正文: 內文需包含:\r\n# * 程式碼更訂的原因(問題、原因、需求)\r\n# * 調整項目\r\n# * 與先前行為的對比\r\n#\r\n# 結尾:\r\n# - 任務編號(如果有)\r\n# - 重大變化(紀錄不兼容的更動)，\r\n#   以 BREAKING CHANGE: 開頭，後面是對變動的描述、以及變動原因和遷移方法。\r\n#\r\n```\r\n\r\n#### 標題\r\n\r\n- Type 類型\r\n  - **feat** - 新增/修改功能 (Feature)\r\n  - **fix** - 修正 Bug (bug fix)\r\n  - **docs** - 修改內容/新增文件 (documentation)\r\n  - **style** - 修改程式碼格式或風格，不影響原有運作，包含修改縮排、新增縮排...等等\r\n  - **refactor** - 重構程式碼，不屬於 bug 修正，也不屬於新功能\r\n  - **perf** - 改善效能 (A code change that improves performance)\r\n  - **test** - 增加/修改測試功能 (when adding missing tests)\r\n  - **chore** - 增加或修改第三方套件(輔助工具)等 (maintain)\r\n  - **revert** - 撤銷回覆先前的 commit 例如：revert: type(scope): subject (回覆版本：xxxx)。\r\n  - **build** - 改變打包流程\r\n- scope 範圍\r\n  - 任何可以劃分程式碼改變的範圍，例如：page, router, compile, component...等等。\r\n- subject 主題\r\n  - 對程式碼修改做簡單描述\r\n\r\n#### 正文\r\n\r\n描述測次程式碼變更的動機，並說出這個提交與改變前的對比。\r\n\r\n1. 為什麼這個提交是必要的？\r\n2. 他如何解決問題？\r\n3. 這個提交會對專案產生什麼副作用？\r\n   - 可以有效辨認次提交是做了太多改變。若有一兩個副作用尚可接受，但若五、六個以上，則表示改變幅度太大。\r\n\r\n#### Footer\r\n\r\n結尾通常會有兩種：\r\n\r\n1. 標註 Breaking Changes 應以單詞 BREAKING CHANGE 開頭：用空格或兩個換行符。後面是對變動的描述和變動的理由。\r\n\r\n```bash\r\nBREAKING CHANGE: isolate scope bindings definition has changed.\r\n\r\n    To migrate the code follow the example below:\r\n\r\n    Before:\r\n\r\n    scope: {\r\n      myAttr: 'attribute',\r\n    }\r\n\r\n    After:\r\n\r\n    scope: {\r\n      myAttr: '@',\r\n    }\r\n\r\n    \"The removed `inject` wasn't generally useful for directives so there should be no code using it.\"\r\n```\r\n\r\n如果當前 commit 還原了先前的 commit，則應以 revert：開頭，後跟還原的 commit 的 header。在 body 中必須寫成：This reverts commit \\<hash>。其中 hash 是要還原的 commit 的 SHA 標識。\r\n\r\n```bash\r\nrevert: feat(pencil): add 'delete' option\r\n\r\nThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\r\n```\r\n\r\n#### commit 模板\r\n\r\n在~/.gitconfig 新增\r\n\r\n```config\r\n[commit]\r\ntemplate = ~/.gitmessage\r\n```\r\n\r\n新建 ~/.gitmessage\r\n\r\n```vim\r\n\r\n# 標題: <type>(<scope>): <subject>\r\n# - type: feat, fix, docs, style, refactor, test, chore\r\n# - scope: 如果修改範圍為全局修改或難以分配給單個組件，可略\r\n# - subject: 以動詞開頭的簡短描述\r\n#\r\n# 正文: 內文需包含:\r\n# * 程式碼更訂的原因(問題、原因、需求)\r\n# * 調整項目\r\n# * 與先前行為的對比\r\n#\r\n# 結尾:\r\n# - 任務編號(如果有)\r\n# - 重大變化(紀錄不兼容的更動)，\r\n#   以 BREAKING CHANGE: 開頭，後面是對變動的描述、以及變動原因和遷移方法。\r\n#\r\n```\r\n\r\n## Git 操作情境\r\n\r\n### 將 git 預設的編輯器改為 vim\r\n\r\n```bash\r\ngit config --global core.editor \"vim\"\r\n```\r\n\r\n### 取消 commit：git reset\r\n\r\nGit 的 `reset`指令，比較像是「前往」或是「變成」，並不會真的重新設定。\r\n\r\n`reset`後的東西都還可以撿的回來。\r\n\r\n#### 確認 git 紀錄\r\n\r\n```terminal\r\ngit log --oneline\r\naf75a42 (HEAD -> develop) 0327\r\n1baa403 (origin/develop) no message\r\n13fd2dc 0223\r\na640c49 0222新增\r\ne09ecae init commit\r\n```\r\n\r\n#### 利用相對位置取消 commit\r\n\r\n```terminal\r\ngit reset af75a42^\r\n```\r\n\r\n`^`符號表示「前一次」的意思，`af75a42^`是指`af75a42`這個 commit 的「前一次」，`af75a42^^`則是往前兩次，以此類推。\r\n\r\n如果要倒退五次可以寫成`af75a42~5`。\r\n\r\n另外`HEAD`和`develop`也都指向`af75a42`這個 commit，所以也可以寫成\r\n\r\n```terminal\r\ngit reset develop^\r\n&\r\ngit reset HEAD^\r\n```\r\n\r\n#### 利用絕對位置取消 commit\r\n\r\n```terminal\r\ngit reset 1baa403\r\n```\r\n\r\n他會切會到`1baa403`這個 commit，剛好是`af75a42`的前一個 commit，和取消最後一次 commit 的效果一樣。\r\n\r\n### git commit 打錯字\r\n\r\n先把前一次 add 的內容，保留在 changes to be committed 區域\r\n\r\n```terminal\r\ngit reset --soft HEAD^\r\n```\r\n\r\n接著再重新進行一次 git commit 即可\r\n\r\n### 轉移資料庫：git mirror\r\n\r\n可以轉移整個 repository 的資訊，包括 branch, tags\r\n\r\n將 repo clone --mirror 到本地\r\n\r\n```bash\r\ngit clone --mirror gitolite@git.lab317.org:dinos80152/Authentication\r\n```\r\n\r\n接著在 github 建立新的 repository\r\n\r\n進到專案資料夾，設定新的遠端 git repo 位置\r\n\r\n```bash\r\ncd your_project.git/\r\ngit remote set-url --push origin https://github.com/your_name/your_project.git\r\n```\r\n\r\nlocal 更新 remote branch ,最後將整包 push 上去\r\n\r\n```bash\r\ngit push --mirror\r\n```\r\n\r\n或者一個指令直接指向遠端 repo\r\n\r\n```bash\r\ngit push --mirror https://github.com/your_name/your_project.git\r\n```\r\n\r\n### 將未完成的工作暫存：git stash\r\n\r\n工作做到一半，需要切換到別的分支進行其他任務。\r\n先看一下目前的狀態：\r\n\r\n```bash\r\ngit status\r\nOn branch feature/admin_controller\r\nChanges not staged for commit:\r\n  (use \"git add <file>...\" to update what will be committed)\r\n  (use \"git restore <file>...\" to discard changes in working directory)\r\n        modified:   app/Http/Controllers/RegionController.php\r\n        modified:   app/Models/Room.php\r\n        modified:   app/Models/User.php\r\n\r\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\r\n```\r\n\r\n#### 將現階段工作暫存\r\n\r\n目前正在修改 `app/Http/Controllers/RegionController.php` `app/Models/Room.php` `app/Models/User.php`，使用 `git stash` 把他們存起來。\r\n\r\n```bash\r\ngit stash\r\nSaved working directory and index state WIP on feature/admin_controller: c745ccb style(MemberController): 修改response的資料與取消註解\r\n```\r\n\r\n> **注意**\r\n>\r\n> Untracked 狀態的檔案無法被 stash，需要額外使用 `-u` 參數\r\n\r\n看一下目前的狀態\r\n\r\n```bash\r\ngit status\r\nOn branch cat\r\nnothing to commit, working tree clean\r\n```\r\n\r\n`git stash list` 可以查看暫存檔案\r\n\r\n```bash\r\ngit stash list\r\nstash@{0}: WIP on cat: b174a5a add cat 2\r\n```\r\n\r\n#### 取出暫存\r\n\r\n當任務完成，要把剛剛暫存的東西拿回來\r\n\r\n```bash\r\ngit stash pop stash@{0}\r\nOn branch feature/add_new_api_route\r\nChanges not staged for commit:\r\n  (use \"git add <file>...\" to update what will be committed)\r\n  (use \"git restore <file>...\" to discard changes in working directory)\r\n        modified:   app/Http/Controllers/RegionController.php\r\n        modified:   app/Models/Room.php\r\n        modified:   app/Models/User.php\r\n\r\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\r\nDropped stash@{0} (8810ecbe89e1c1412c0c47d7fb7ded9f3e29aa53)\r\n```\r\n\r\n使用 `pop` 指令，可以將某個 `stash` 拿出來並套到目前的分支上。套用成功之後，套用過的 `stash` 就會被刪除。  \r\n如果沒有指定 `pop` 哪一個 `stash`，將會從編號小的也就是 `stash@{0}` 開始使用，也就是最後存進來的。\r\n\r\n要刪除 `stash` 可以用 `drop` 指令\r\n\r\n```bash\r\ngit stash drop stash@{0}\r\nDropped stash@{0} (87390c02bbfc8cf7a38fb42f6f3a357e51ce6cd1)\r\n```\r\n\r\n如果要把 `stash` 撿回來，但不想刪除，可以使用 `apply`\r\n\r\n```bash\r\ngit stash apply stash@{0}\r\n```\r\n\r\n#### 主要指令\r\n\r\n- git stash 將當前分支的修改內容加入暫存\r\n- git stash -u 將 untracked 檔案加入暫存\r\n- git stash save -u \"\" 將 untracked 檔案加入暫存並撰寫註解\r\n- git stash push 將修改內容加入暫存(完整指令)\r\n- git stash push -m 將修改內容加入暫存，並加入註解\r\n- git stash list 瀏覽所有暫存項目\r\n- git stash pop 將最新暫存套用至當前分支，成功後刪除暫存\r\n- git stash pop stash@{1} 將指定暫存套用至當前分支，成功後刪除暫存\r\n- git stash apply 套用最新暫存，成功後保留暫存\r\n- git stash apply stash@{1} 套用指定暫存，成功後保留暫存\r\n- git stash drop 清除最新暫存\r\n- git stash drop stash@{1} 清除指定暫存\r\n- git stash clear 清除全部暫存\r\n\r\n### 解決合併衝突\r\n\r\n當在不同分支中，修改同一檔案的不同行，此時合併不會發生問題。  \r\n倘若修改的是同一行，就會發生合併衝突。\r\n\r\n```bash\r\ngit merge feature/create_device_model\r\nAuto-merging app-src/app/Http/Controllers/UserController.php\r\nCONFLICT (content): Merge conflict in app-src/app/Http/Controllers/UserController.php\r\nAuto-merging app-src/app/Models/Room.php\r\nAuto-merging app-src/app/Models/User.php\r\nCONFLICT (content): Merge conflict in app-src/app/Models/User.php\r\nAutomatic merge failed; fix conflicts and then commit the result.\r\n```\r\n\r\n有出現 CONFLICT (content)提示的檔案，為發生合併衝突的檔案。  \r\n此時在檔案中，Git 會將衝突位置標示出來。\r\n\r\n```php\r\n<<<<<<< HEAD\r\n當前內容。\r\n=======\r\n要合併的目標分支上歧異的內容。\r\n>>>>>>> feature/i_am_old_branch\r\n```\r\n\r\n修正衝突點後，將修改的檔案暫存，最後進行提交。\r\n\r\n```bash\r\ngit add --all\r\ngit commit\r\n```\r\n\r\n### 更改 git remote 位置\r\n\r\n當修改 git repo 的名稱或是路徑時，若要在本機進行 push 或是 pull 的指令時，會出現：remote: This repository moved. Please use the new location [new location]\r\n\r\n- 解決辦法：重新設定 remote url\r\n\r\n  ```bash\r\n  git remote set-url origin https://XXX.git\r\n  ```\r\n\r\n  檢查 remote url 是否修改成功\r\n\r\n  ```bash\r\n  git remote -v\r\n  ```\r\n\r\n### 取消 merge (清除合併紀錄)\r\n\r\n> [Git 實戰技巧 - 取消合併](https://blog.darkthread.net/blog/git-undo-merge/)\r\n\r\n當 feature 與 develop 分支的合併位置有誤，想要拆掉重做\r\n\r\n```bash\r\ndb7915e (HEAD -> dev, feature/mqtt_test) feat: 測試mqtt連線\r\nb65d2d2 (tag: release_v2.0.0, origin/dev) no message\r\n0a198be refactor(firmware index page): 優化firmware前端頁面\r\n539942f (origin/master, origin/HEAD, master) Merge branch 'feature/fix_firmware_download' into dev\r\n1a4515a fix(firmwareController): 修復firmware下載問題\r\nd1e204f docs(README): 修改上線環境設定\r\n```\r\n\r\n`git rebase -i` ：重整目標 commit 之後的 commit：重整清單中不會有下指令的 commit 而是顯示其後所有的 commit。\r\n\r\n```bash\r\ngit rebase -i 0a198be\r\n```\r\n\r\n輸入指令之後會進入編輯器\r\n\r\n```vim\r\npick db7915e feat: 測試mqtt連線\r\npick b65d2d2 no message\r\n\r\n# Rebase 539942f..879c462 onto 539942f (3 commands)\r\n#\r\n# Commands:\r\n# p, pick <commit> = use commit\r\n# r, reword <commit> = use commit, but edit the commit message\r\n# e, edit <commit> = use commit, but stop for amending\r\n# s, squash <commit> = use commit, but meld into previous commit\r\n# f, fixup [-C | -c] <commit> = like \"squash\" but keep only the previous\r\n#                    commit's log message, unless -C is used, in which case\r\n#                    keep only this commit's message; -c is same as -C but\r\n#                    opens the editor\r\n```\r\n\r\n並將要取消的 commit 改為 drop\r\n\r\n```vim\r\ndrip db7915e feat: 測試mqtt連線\r\npick b65d2d2 no message\r\n```\r\n\r\n```bash\r\nb65d2d2 (HEAD -> dev, tag: release_v2.0.0, origin/dev) no message\r\n0a198be refactor(firmware index page): 優化firmware前端頁面\r\n539942f (origin/master, origin/HEAD, master) Merge branch 'feature/fix_firmware_download' into dev\r\n1a4515a fix(firmwareController): 修復firmware下載問題\r\n```\r\n\r\n### 新增遠端儲存庫\r\n\r\n```bash\r\ngit init\r\n\r\ngit add .\r\n\r\ngit commit -m \"First commit\"\r\n```\r\n\r\n添加遠端儲存庫的路徑\r\n\r\n```bash\r\n## git remote add origin \"remote repository URL\"\r\ngit remote add origin //fishbone/研發部/軟體區/GitServer/V5/*.git\r\n```\r\n\r\n將遠端儲存庫初始化\r\n\r\n```bash\r\n## git init --bare \"remote repository URL\"\r\ngit init --bare //fishbone/研發部/韌體區/GitServer/V5/*.git\r\n```\r\n\r\n將本地儲存庫內容推送到遠端\r\n\r\n```bash\r\ngit push --set-upstream origin main\r\n```\r\n\r\n### Git 別名\r\n\r\n修改 `~/.gitconfig`\r\n\r\n```vim\r\n[alias]\r\nst = status\r\nptlg = log --color --graph --pretty=format:'%C(yellow)%h%Creset %C(bold brightred)%d%Creset %C()%s%Creset \\n %C(blue italic dim)-- %an%Creset %C(green italic dim)(%cr)%Creset'\r\nadal = add --all\r\n```\r\n\r\n## Git 管理\r\n\r\n### 使用 VSCode 管理 Git\r\n\r\n> [Visual Studio Code 無需輸入 Git 指令，透過界面按鈕就可輕鬆管理 Github 中的專案檔案](https://www.minwt.com/webdesign-dev/22926.html)\r\n\r\n## GitHub 操作\r\n\r\n### 將本地專案上傳到 github\r\n\r\n1. git init\r\n2. git add .\r\n3. git commit -m \"init commit\"\r\n4. git remote add origin `https://github.com/<username>/<repo>.git`\r\n5. git push -u origin master\r\n\r\n### Https 設定 Token\r\n\r\n當使用推送，輸入 github 密碼會出現錯誤。\r\n\r\n```terminal\r\nchanggenglu@masenyuandeMacBook-Air ~ % git push -u origin master\r\nremote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.\r\nremote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.\r\nfatal: unable to access 'https://github.com/changgenglu/your_project.git/': The requested URL returned error: 403\r\n```\r\n\r\n大致意思是，密碼驗證於 2021 年 8 月 13 日不再支援，也就是今天不能再用密碼方式去提交程式碼。請用使用 **personal access token** 替代。\r\n\r\n#### 設定 personal access token\r\n\r\n- 開啟 GitHub.com -> Setting -> Developer settings -> Personal access tokens\r\n- 按下`Generate new token`\r\n- Note 欄位填入 token 的備註\r\n- Expiration 設定 token 的時效\r\n- Select scopes 設定權限（基本全部開啟）\r\n- 按下`Generate token`\r\n- 複製 token 代碼\r\n\r\n再次使用終端機推送\r\n\r\n```terminal\r\ngit push -u origin master\r\n```\r\n\r\n輸入 github 密碼的地方，貼上 token 代碼\r\n\r\n### 設定 SSH\r\n\r\n#### 輸入指令產生 SHH\r\n\r\n```terminal\r\nssh-keygen\r\n```\r\n\r\n產生\r\n\r\n```terminal\r\n$ Enter file in which to save the key (/Users/changgenglu/.ssh/id_rsa):\r\n# 這行只是確定存在哪\r\n$ Overwrite (y/n)?\r\n# 如果原本就有金鑰會跳出此問題，覆蓋嗎？ (是)\r\n$ Enter passphrase (empty for no passphrase):\r\n$ Enter same passphrase again:\r\n# 輸入密碼，再次確認輸入密碼\r\n```\r\n\r\n此處的輸入密碼為使用至個金鑰的密碼，可以選擇不輸入。\r\n\r\n#### 產生 SSH 連線所需的公鑰內容\r\n\r\n```terminal\r\ncat ~/.ssh/id_rsa.pub\r\n```\r\n\r\n輸出實例\r\n\r\n```terminal\r\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDFp+A3qe4qm1Dkw66LN/vNGlufX5iC9VERfuUiXHNM5L3hQuz6wO8WuzFv+zDIHRPGUl616oLXTHTqommuO0GZavDo+lbUIRkSBM9j/9tr+hlF4LPTT4ggjOgzLCHTrSyzcmcdykgBfnDgX3aYfZbhCEcWdERUxWFNnDf+YYlNd8L6LMKSIce61nhqiSLNbugDCrE0IH+/1hoS3LNoag9V05Qwo5yZ6srLNJT8uISoqvJv5BwSpBL9ImnePx+LzDiVXlJMisKf1GSXdVuWmVWlKrZOsadk4ZkSNH2cL1wgkNvAUbydWKG9Ag4TfI/khKwUXyhT+7V4jWsJusDXZxafylZma4qeOsaLAN4ScSStnOoSm1CxeNqmPsQpAGbtvx49yB2+c4HFsa68VzcwV1oejhh2E67iqqKK53IFN/qQmYYfhUukY6rgLLHlLkmjLqdVpVcULCP0mMzn4xacFWLwDgOtZK1i97vWaLPyG6hYQQ108zK9i/Cg13p0Z+CUTCs= changgenglu@masenyuandeMacBook-Air.local\r\n```\r\n\r\n#### 上傳公鑰\r\n\r\n到 Github > Settings > SSH and GPG keys 的設定頁面，選擇 New SSH Key。\r\n\r\n### 部署靜態頁面到 github\r\n\r\n> 參考資料：\r\n>\r\n> [[Vue] 將Vue專案部署至Github Pages](https://dean34520.medium.com/vue%E7%B3%BB%E5%88%97%E6%96%87-%E5%B0%87vue%E6%AA%94%E6%A1%88%E9%83%A8%E7%BD%B2%E8%87%B3github-334951cadede)\r\n\r\n1. 建立與本地專案相同名稱的 repository\r\n2. 在專案資料夾中新增 vue.config.js，設定 publishPath\r\n\r\n   ```javascript\r\n   //vue.config.js\r\n   module.exports = {\r\n     publicPath: process.env.NODE_ENV === \"production\" ? \"/eric-project/\" : \"/\",\r\n   };\r\n   ```\r\n\r\n3. 將本地專案推送至雲端\r\n4. 在專案目錄下新增 deploy.sh 自動化腳本\r\n\r\n   ```sh\r\n    #!/usr/bin/env sh\r\n    # 當發生錯誤時終止腳本運行\r\n    set -e\r\n    # 打包\r\n    npm run build\r\n    # 移動至到打包後的dist目錄\r\n    cd dist\r\n    # 因為dist資料夾預設是被ignore的，因此在進入dist資料夾後初始化git\r\n    git init\r\n    git add -A\r\n    git commit -m 'deploy'\r\n    # 部署到 https://github.com/<user-name>/<repo-name>.git 分支為 gh-pages\r\n    git push -f https://github.com/<user-name>/<repo-name>.git master:gh-pages\r\n    # 將dist資料夾中的內容推送至遠端eric-project的gh-pages分支中，並強制無條件將舊有的內容取代成目前的內容（指令 git push -f)\r\n    cd -\r\n   ```\r\n\r\n   github 在部署時只允許三種來源：\r\n\r\n   1. master\r\n   2. gh-pages\r\n   3. master/docs\r\n\r\n5. 執行腳本\r\n\r\n   ```shell\r\n   sh ./deploy.sh\r\n   ```\r\n\r\n   完成後，此時 github 上的 gh-pages 分支會和 vue 專案中的 /dist 資料夾內一樣\r\n\r\n6. 進入 setting 頁面的 pages，將 Source 改為 gh-pages\r\n7. 待部署完成，頁面上方會出現專案頁面的連結\r\n","date":"2023-06-27T03:23:44.379Z","matchingLines":["## 常用指令\r","## Git Flow 開發流程觀念\r","## Git 操作情境\r","## git remote add origin \"remote repository URL\"\r","## git init --bare \"remote repository URL\"\r","## Git 管理\r","## GitHub 操作\r"]},{"name":"Javascript 陣列.md","content":"# JavaScript 陣列\r\n\r\n> 參考資料：\r\n>\r\n> [JavaScript Array 陣列操作方法大全 ( 含 ES6 )](https://www.oxxostudio.tw/articles/201908/js-array.html)\r\n\r\n## 改變原始陣列\r\n\r\n### push() 加入陣列最後一個位置\r\n\r\n將值加入陣列的最後一個位置，push() 會回傳新的陣列長度。\r\n\r\n```javascript\r\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconsole.log(arr.push(9, 10)); // 10\r\nconsole.log(arr); // [1, 2, 3, 4, 5, 6, 7, 8, ,9, 10]\r\n```\r\n\r\n### pop() 取出陣列的最後一個元素\r\n\r\n```javascript\r\nlet arr = [1, 2, 3, 4, 5, 6];\r\nlet new_arr = arr.pop();\r\nconsole.log(arr); // [1,2,3,4,5]\r\nconsole.log(new_arr); // 6\r\n```\r\n\r\n### shift() 取出並移除陣列的第一個元素\r\n\r\n```javascript\r\nlet arr = [1, 2, 3, 4, 5];\r\nlet new_arr = arr.shift();\r\nconsole.log(arr); // [2, 3, 4, 5]\r\nconsole.log(new_arr); // 1\r\n```\r\n\r\n### unshift() 將元素添加到第一個位置\r\n\r\n```javascript\r\nlet arr = [1, 2, 3, 4, 5];\r\narr.unshift(100, 200, 300);\r\nconsole.log(arr); // [100, 200, 300, 1, 2, 3, 4, 5]\r\n```\r\n\r\n### reverse() 反轉陣列\r\n\r\n```javascript\r\nlet arr = [1, 2, 3, 4, 5];\r\narr.reverse();\r\nconsole.log(arr); // [5, 4, 3, 2, 1]\r\n```\r\n\r\n### splice(start, delete_count, item) 新增或移除陣列中指定位置的元素\r\n\r\n可以移除或新增陣列的元素，包含三個參數\r\n\r\n- start 要編輯的序列號碼\r\n- delete_count 要移除的長度(選填，若不填，則將第一個號碼位置面的所有元素清除，若為 0 則不刪除元素)\r\n- item 要添加的內容(選填)\r\n\r\n```javascript\r\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8];\r\narr.splice(5, 1);\r\nconsole.log(arr); // [1, 2, 3, 4, 5, 7, 8] (6 被移除了)\r\n```\r\n\r\n設定第三個參數就能添加或取代元素\r\n\r\n```javascript\r\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8];\r\narr.splice(5, 1, 100);\r\nconsole.log(arr); // [1, 2, 3, 4, 5, 100, 7, 8]; (6 被移除，100 被加到第五的位置)\r\n```\r\n\r\nsplice 方法會回傳被刪除的元素，若無刪除元素，則回傳空陣列\r\n\r\n### sort() 針對陣列的元素進行排列\r\n\r\n### copyWithin()\r\n\r\n### fill()　置換陣列中的值\r\n\r\n會將陣列中所有元素，置換為指定的值。\r\n\r\n其包含三個參數：\r\n\r\n1. 準備要置換的內容(必填)\r\n2. 起使位置(選填，預設為全部置換)\r\n3. 停止置換的元素的前一個位置(選填，預設等於陣列長度)\r\n\r\n> 使用 fill() 會改變原本的陣列內容\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\na.fill(\"a\");\r\nconsole.log(a); // ['a','a','a','a','a','a','a','a']\r\n\r\nlet b = [1, 2, 3, 4, 5, 6, 7, 8];\r\nb.fill(\"b\", 3, 5);\r\nconsole.log(b); // [1,2,3,'b','b',6,7,8]\r\n```\r\n\r\n## 回傳陣列元素資訊或索引值\r\n\r\n### length() 取得陣列長度\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconsole.log(a.length); // 8\r\n```\r\n\r\n### indexOf()\r\n\r\n### lastIndexOf()\r\n\r\n### find() 回傳第一個符合判斷條件的元素\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconsole.log(a.find((e) => e > 3)); // 4\r\nconsole.log(a.find((e) => e < 0)); // undefined\r\n```\r\n\r\n### findIndex()\r\n\r\n### filter() 回傳條件為 true 的元素組成的陣列\r\n\r\n會將陣列中每一個元素，帶入指定的函式做判斷，若元素符合判斷條件會傳出成唯一個新的陣列元素。\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconsole.log(a.filter((e) => e > 3)); // [4, 5, 6, 7, 8]\r\nconsole.log(a.filter((e) => e % 2 == 0)); // [2, 4, 6, 8]\r\n```\r\n\r\n## 針對每個元素進行處理\r\n\r\n### forEach()\r\n\r\n將陣列中每個元素套用到指定函式裡面進行運算。\r\n\r\n函式有三個參數：\r\n\r\n1. 表示每個元素的值(必填)\r\n2. 該元素的索引值(選填)\r\n3. 表示原本的陣列(選填)\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5];\r\nlet b = 0;\r\na.forEach((item) => {\r\n  b = b + item;\r\n});\r\nconsole.log(b); // 15 => (1 + 2 + 3 + 3 + 4 + 5)\r\n```\r\n\r\n## 產生新的陣列或值\r\n\r\n### join()\r\n\r\n### concat()\r\n\r\n### slice()\r\n\r\n### map() 處理陣列中每一個元素，最後回傳一個新的陣列\r\n\r\n裡面有一個函式(必填)和一個回傳函式裡面的 this 參數(選填)，函式中包含三個參數：\r\n\r\n1. 每個元素的值(必填)\r\n2. 當前元素的 index 值(選填)\r\n3. 當前的陣列(選填)\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nlet b = a.map((e) => {\r\n  return e + 10;\r\n});\r\nconsole.log(b); // [11, 12, 13, 14, 15, 16, 17, 18]\r\n```\r\n\r\n套用第二和第三個參數的變化\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nlet b = a.map((e, i, arr) => {\r\n  return `${e}${i}${arr.find((e) => e % 5 == 1)}`; // 組合成「元素 + 索引值 + 除以五餘數為 1 的元素」\r\n});\r\nconsole.log(b); // ['101', '211', '321', '431', '541', '651', '761', '871']\r\n```\r\n\r\n若要使用回傳函式裡 this 的函數，則「不能使用」箭頭函式，因為箭頭函式的 this 指向，和函式的 this 指向不同，所以要用一般的函式處理。\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nlet b = a.map(function (e) {\r\n  return e + this; // 此處的 this 為 10\r\n}, 10);\r\nconsole.log(b); // [11, 12, 13, 14, 15, 16, 17, 18]\r\n```\r\n\r\n### reduce() 計算陣列中每個元素，並將結果與下個元素做計算\r\n\r\n可以將陣列中的每一個元素做計算，每次計算的結果，會再與下個元素做計算到結束為止。\r\n\r\n包含一個函式，函式內有四個參數：\r\n\r\n1. 計算的值(必填)\r\n2. 取得的元素(必填)\r\n3. 該元素的 index 值(選填)\r\n4. 原本的陣列 (選填)\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nlet b = a.reduce(function (total, e) {\r\n  return total + e;\r\n});\r\nconsole.log(b); // 36 => (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36)\r\n```\r\n\r\n### reduceRight() 計算方式為從右到左\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nlet b = a.reduce(function (total, e) {\r\n  return total - e;\r\n});\r\nconsole.log(b); // -34 (1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 = -34)\r\nlet c = a.reduceRight(function (total, e) {\r\n  return total - e;\r\n});\r\nconsole.log(c); // -20 (8 - 7 - 6 - 5 - 4 - 3 - 2 - 1 = -20)\r\n```\r\n\r\n### flat() 將多維陣列扁平化\r\n\r\n可以將一個多維陣列的深度轉換為一維(扁平化)，他有一個選填的參數，代表要轉換的深度，其預設為 1，如果深度很多層，可以用`infinity`來全部展開成一維陣列。\r\n\r\n```javascript\r\nlet a = [1, 2, [3], [4, [5, [6]]]];\r\nlet b = a.flat();\r\nlet c = a.flat(2);\r\nlet d = a.flat(Infinity);\r\nconsole.log(b); // [1, 2, 3, 4, [5, [6]]]\r\nconsole.log(c); // [1, 2, 3, 4, 5, [6]]\r\nconsole.log(d); // [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n### flatMap() map + flat()\r\n\r\n在運算後直接將陣列扁平化\r\n\r\n```javascript\r\nlet a = [1, 2, [3], [4, 5]];\r\nlet b = a.flatMap((e) => e + 1);\r\nlet c = a.map((e) => e + 1).flat();\r\nconsole.log(b); // [2, 3, \"31\", \"4,51\"] ( 可以看到 b 和 c 得到的結果相同 )\r\nconsole.log(c); // [2, 3, \"31\", \"4,51\"]\r\n```\r\n\r\n### Array.from()\r\n\r\n### Array.of() 將數值、字串等內容，轉換為陣列\r\n\r\n```javascript\r\nlet a = Array.Of(1, \"a\", 2, \"b\", 3);\r\nconsole.log(a); // [1, \"a\", 2, \"b\", 3]\r\n```\r\n\r\n### toString() 將陣列轉換為字串\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nlet b = a.toString();\r\nconsole.log(b); // 1,2,3,4,5,6,7,8\r\n```\r\n\r\n## 判斷\r\n\r\n### every() 全部符合判斷條件回傳 true\r\n\r\n只要有任何一個元素不符合判斷條件，就會回傳 false，全部符合就會回傳 true。\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6];\r\nconsole.log(a.every((e) => e > 3)); // false (1, 2 小於 3，3　等於 3)\r\nconsole.log(a.every((e) => e > 0)); // true\r\n```\r\n\r\n### some() 其中任一符合回傳 true\r\n\r\n會將陣列中每一個元素帶入指定的函式中做判斷，只要有任一個元素符合判斷標準，就會回傳 true，若完全不符合，回傳 false\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconsole.log(a.some((e) => e > 3)); // true (因為 4, 5, 6 大於 3)\r\nconsole.log(a.some((e) => e > 6)); // false (因為全部都小於或等於 6)\r\n```\r\n\r\n### include() 陣列中使否包含指定值\r\n\r\n會判斷陣列中是否包含指定值，包含回傳 true，否則回傳 false。\r\n\r\n有兩個參數：\r\n\r\n1. 表示要判斷的值(必填)\r\n2. 陣列的開始位置(選填)\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconsole.log(a.includes(2)); // true\r\nconsole.log(a.includes(2, 2)); // false (從陣列中第二個位置開始搜尋，沒有 2)\r\n```\r\n\r\n### Array.inArray()\r\n\r\n## 其他\r\n\r\n### keys()\r\n\r\n### valueOf() 回傳陣列的原始值\r\n\r\n```javascript\r\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\r\nlet b = a.valueOf();\r\nconsole.log(a); // [1, 2, 3, 4, 5, 6, 7, 8]\r\nlet c = a.valueOf();\r\na.shift();\r\nconsole.log(a); // [2, 3, 4, 5, 6, 7, 8]\r\nconsole.log(b); // [2, 3, 4, 5, 6, 7, 8] ( 因為 a 的原始值更動了，所以 b 也變了 )\r\nconsole.log(c); // [2, 3, 4, 5, 6, 7, 8]\r\n```\r\n","date":"2023-06-26T05:41:29.138Z","matchingLines":["## 改變原始陣列\r","## 回傳陣列元素資訊或索引值\r","## 針對每個元素進行處理\r","## 產生新的陣列或值\r","## 判斷\r","## 其他\r"]},{"name":"Design Pattern.md","content":"# 設計模式 Design Pattern\r\n\r\n> 參考資料\r\n>\r\n> [設計模式系列文](https://kimlin20011.medium.com/%E4%BB%80%E9%BA%BC%E6%98%AF%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-design-pattern-%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E6%96%87-%E4%B8%8A-5988dacfda4a)\r\n\r\n## 什麼是設計模式\r\n\r\n> 每一個模式(Pattern)都是在某個特定情境(context)下，針對某問題(Problem)提出的解決方案(solution)。\r\n\r\n在軟體工程中將 Pattern 分為：\r\n\r\n- Architecture Pattern: 解決軟體系統架構層面的問題。如：MVC 架構、Layer...\r\n- Design Pattern: 提供改善軟體系統中子系統與元件(components)的方案。常見如：Observer, Facade, Adapter...\r\n- Idioms: 是一種 lowest-level pattern，為 programming(程式撰寫)層級提供程式改善方案，主要透過程式語言的解決方案來實現。\r\n\r\n### 範例\r\n\r\n情境(context)：每個人都喜歡坐在窗邊，有低矮的大窗台與舒適的椅子，若一個房間中沒有如此環境，很難讓人感到舒服。\r\n\r\n此時的問題(problem)正是：如何讓人感到舒服自在？\r\n\r\n此時有兩個需求(Force)：\r\n\r\n- 你想要舒服地坐下\r\n- 你想要面對窗戶\r\n\r\n但往往兩個需求會互相衝突：\r\n\r\n- 舒服的椅子背對窗戶\r\n- 面對窗戶只有一張壞掉的椅子\r\n\r\n最好的方法就是當你每次在安排室內布局時，雖然房間可能沒有太多擺設的選擇，但至少依循著一個\"面對窗戶有一個舒服的位置\"這樣的模式。\r\n\r\n## 如何描述設計模式\r\n\r\n設計模式的發表雖然也是學術的一環，但其講求的重點與一般學術論文不同。\r\n\r\n比起一般學術論文要求深入嚴謹，設計模式更像是一個產品說明，須具備高度結構性的方法與淺顯易懂的行文來表達。\r\n\r\n這裡主要使用的是 POSA 中，設計模式的描述結構。\r\n\r\n### Name\r\n\r\n名字是一個讀者了解模式最快的方法，也是總結一個模式的重要方法。而且要對 pattern 命名有很多種方法，常見的有：\r\n\r\n- 取自 solution 的抽象特徵，如：\r\n  - Adapter 模式(像是一個轉接器，轉介不同規格的物品)\r\n  - Observer 模式(像一個觀察者，若訂閱的標的有狀態的變化，則馬上通知訂閱者)\r\n- 取自 solution 中元件的名稱，像是 MVC (取自系統中的 model、view、controller 三個元件的頭一個字母)\r\n\r\n### Context\r\n\r\n舉出模式可能適用的情況。主要是整理 problem 可能發生的情境來界定 problem 可能發生的範圍。雖然 context 不能列出所有情境，但至少可以提供重要的指引。\r\n\r\n### Problem\r\n\r\nproblem 是描述會在 context 中重複發生的問題。另一方面 problem 也是 pattern 的核心元素，說明主要模式的設計議題。\r\nproblem 中有一個很重要的元素：force。在前面的範例中有提到，force 是導致設計問題中存在的具體的力，同時，force 幫助 context 中具體形塑出 solution 的邊界。主要列出幾個需要解決的層面：\r\n\r\n- solution 需要滿足的需求\r\n- solution 需要考慮的限制\r\n- solution 需要包含的特性\r\n\r\n但不幸的是，force 常常是互相矛盾且衝突的，在設計 solution 時常常需要權衡不同的 force 來得到最適合的解決方案。\r\n\r\n### Solution(解決方案)\r\n\r\n以高階的方式描述 pattern 解決方案原理。solution 提供解決重複發生的 problem 的方法，並盡可能平衡相關的 force (前文提到 force 常常是互相矛盾的)。另一方面，solution 又以 structure(建構) (像是以 UML 類別圖描述各個類別元件之間的關係)與 Dynamics(動力學) (像是以 UML 的循環圖描述元件之間的動態行為與協作)層面來描述 pattern 中不同元件之間的靜態關連與動態協作。\r\n\r\n### Implementation(執行)\r\n\r\n引導讀者實作 pattern。此部分可以依照 pattern 描述的需求採用，並適當提供實作範例(如：程式碼等等)，通常提供與 Example 部分相關的實作方案。\r\n\r\n### Example\r\n\r\n透過舉實際案例來補足在 solution 與 Implementation 部分沒有被涵蓋但又為解決方案中重要的層面。\r\n\r\n### Variants(變體)\r\n\r\n此部分可以依照 pattern 描述的需求採用。簡述 pattern 相關變形的其他 pattern。\r\n\r\n### Known uses\r\n\r\n列舉與 pattern 相關的現存系統。用來證明提出的 pattern 是真實世界中相關情境存在的設計問題，pattern 的解決方案已被應用且能有效的解決問題。\r\n\r\n### Consequences(結果)\r\n\r\n列舉 pattern 的優劣勢。一個 pattern 不可能是完美的，因此也需要列出在特定情境下可能造成的限制或缺陷。\r\n\r\n### Related pattern\r\n\r\n列舉用來解決相似情境下的設計問題或能與該 pattern 整合協作的其他 pattern。\r\n\r\n## 撰寫設計模式時需要的思考脈絡\r\n\r\n再次列舉上面提到的例子：\r\n\r\n1. 首先，先確定目標的情境。\r\n   > 我們要設計一個工作室，而這個工作室只有兩扇窗，幾張舒適的椅子，幾張難坐的椅子\r\n2. 確定設計問題\r\n   > 如何讓工作室工作的人一整天都能舒服自在。\r\n3. 接著思考影響上述問題發生的具體作用力，以形塑解決方案的邊界\r\n   > 需要舒適的坐著\r\n   > 想要靠窗，才能偶爾看看窗外來紓解壓力。\r\n4. 列出這些 force 後，接著可以開始設計解決方案\r\n   > 需要舒服地坐著：在工作位置上挑選舒適的椅子\r\n   > 想要靠窗：將辦工作桌與辦公椅，盡可能的緊靠窗戶\r\n5. 可以用繪圖的方式輔助說明解決方案，列出工作室擺設的動態(這個模式可能不需要)與靜態(擺設圖)關係\r\n6. 透過舉例，引導參考此模式的施工人員，實作本模式提出的方法\r\n   > 例如：列出椅子的規格、窗戶和椅子的距離、擺放角度等等\r\n7. 為了證明此方案是有效的，也可以利用幾個經典的室內設計案例來佐證\r\n8. 完成大部分的設計模式內容後，可以透過列舉優點與限制來為設計模式做個總結\r\n   > 優點：可以使人長時間舒適的待在工作室工作\r\n   > 缺點：選擇舒適的椅子，需花費較高的成本。窗戶須有不同高度(人坐著可以直接看到窗外的高度)\r\n9. 透過提出的解決方案的特徵，來為此設計模式命名\r\n   > 椅子與窗戶的對向模式\r\n\r\n## 設計模式撰寫時的思考脈絡\r\n\r\n- 界定情境(context)\r\n- 定義設計問題(problem)\r\n- 從設計問題中列出會影響該問題發生具體的力(force)\r\n- 依循所列出的 force 來設計解決方法(solution)\r\n- 統整解決方案，以靜態(structure)與動態(dynamics)的描述方式表述之\r\n- 最後引導讀者實作 pattern 並提出相關的範例(example)\r\n- 為了證明 pattern 的實用性，可列舉出已知應用 pattern 中相似解法的例子(known uses)\r\n- 最後列出應用該 pattern 後產生的優點與限制(consequences)\r\n- 通常在 pattern 完成之後可以依據 pattern 的特性為 pattern 命名(name)，也可以邊撰寫時邊思考。\r\n\r\n## 如何完善已完成的設計模式？\r\n\r\n### Big Picture\r\n\r\n- 如何掌握設計模式的主旨：\r\n\r\n  - 設計模式的初稿通常難以理解。而描述得太簡潔往往缺乏實質的內容；相反的，內容太過龐大（描述的多而深入）通常因為太專注細節的描述而模糊了模式的核心概念。\r\n\r\n- ThereFore\r\n  - shepherd 在剛剛接觸設計模式的時候必須先閱讀 problem 與 solution 的部分來掌握該模式的大綱，這主要是因為 sheep 通常最注重再解決方案的設計部分，並將所有對模式的想法，灌輸在 solution 中。\r\n\r\n### Matching Problem and Solution\r\n\r\n- 如何確定模式真的是模式的樣子(pattern-ish)\r\n\r\n  - 在撰寫模式時，常會先寫好 solution （因為可能在不斷實作中領悟到通用解決方法），而後在去設計模式的問題，所以在審稿的時候，常常讀起來不清楚這個模式的真正目的是什麼。\r\n\r\n- ThereFore\r\n  - 審稿的時候要確認設計模式的 solution 有完整的針對 problem 解決，解決方案也不能超過 problem 的範圍（剛好就好，不能多餘），之後再加強其中不足的部分（problem 或是 solution ）。\r\n\r\n### Convincing Solution\r\n\r\n- 如何提高設計模式的可信度(believable)\r\n  - 有時候 solution 提供的解法根本無濟於事，看起來沒有實現的能力。\r\n- therefore\r\n  - 一般的 pattern 在看完 solution 後通常要有「原來可以者麼解決」的感覺。如果沒有，則比需要提供真正實作應用的細節，才能使人信服。\r\n\r\n### Forces Define Problem\r\n\r\n- 如何更深層的瞭解問題\r\n  - 很多設計模式的初稿，對於 problem 的描述都很薄弱。\r\n- Therefore\r\n  - 須要透過 Force 來具體化對 problem 的敘述。而作者須要以迭代的方式不對斷修正與增強對 Force 與 Problem 的敘述，透過列出具體化不同的 Force，尋找交集後，最後為其總結出核心問題。\r\n\r\n### Balance Context\r\n\r\n- 如何為 pattern 劃定出合適的範圍\r\n  - 在撰寫設計模式的 context 時，常常不小心把情境的範圍界定的太大或太小，也往往忽略了界定該情境應用 pattern 之後可能的結果。\r\n- Therefore\r\n  - 在撰寫設計模式時，必須要具體思考並說明情境使用與不適用這個模式前後的差異，這樣不僅能夠賦予模式的使用者對模式應有的期望，也能幫助我們界定剛好符合所提出的模式範圍。\r\n\r\n### War Store\r\n\r\n- 如何推進模式前進？\r\n  - 有時不管如何 sheep 如何修改或是更正 shepherd 的建議，shepherd 還是覺得設計模式描述的不清楚、缺乏對該模式的實際應用想像。\r\n- Therefore\r\n  - 這時 shepherd 應要求 sheep 提供設計模式應用的真實案例，幫助對模式的想像更為生動實際。\r\n\r\n### Form Follows Function\r\n\r\n- 如何將設計模式套用到一個新的格式(form)\r\n  - 有時 sheep 所選擇得 patten 格式，沒辦法完表達(或是不適合)所提出的設計模式，這可能是因為 sheep 對 patten 的格式不熟悉(可能只知道一兩個)，或是因為要把格式整個換掉，須要花費相當大的功夫，因此選擇不換。\r\n- Therefore\r\n  - shepherd 須要一步一步的引導 sheep 修改原本模式所應用的格式(一次改一些就好)，而終極目的是「making the form serve the patten」\r\n\r\n### Small Patterns\r\n\r\n- 如何使設計模式變的更可消化\r\n  - 設計模式常常經由不斷修正(可能是因為 sheep 不願意對已完成的內容做刪減)後，內容變的很龐大。\r\n- Therefore\r\n  - 先放任內容增加，最後再做刪減。刪減可以透過移除不必要的區塊，或是將過於龐大模式，拆分成多個小模式(要做到一個模式只能有一個 context, problem 與 solution)\r\n","date":"2023-06-16T08:19:41.704Z","matchingLines":["## 什麼是設計模式\r","## 如何描述設計模式\r","## 撰寫設計模式時需要的思考脈絡\r","## 設計模式撰寫時的思考脈絡\r","## 如何完善已完成的設計模式？\r"]},{"name":"PHP 學習筆記.md","content":"# PHP 學習筆記\r\n\r\n- [PHP 學習筆記](#php-學習筆記)\r\n  - [運算子、判斷](#運算子判斷)\r\n    - [`+`: 算術相加](#-算術相加)\r\n    - [`.`: 字串相加](#-字串相加)\r\n    - [`gettype()`: 判斷變數的型態](#gettype-判斷變數的型態)\r\n    - [`(int)($var1 + $var2)`: 只取商](#intvar1--var2-只取商)\r\n    - [`isset($var)`: 檢查變數是否有設置](#issetvar-檢查變數是否有設置)\r\n    - [`empty($var)`: 檢查變數是否為空值](#emptyvar-檢查變數是否為空值)\r\n    - [`is_null($var)`: 檢查變數是否為 null](#is_nullvar-檢查變數是否為-null)\r\n    - [`var_dump($var);`: 將變數的訊息印出於螢幕上](#var_dumpvar-將變數的訊息印出於螢幕上)\r\n    - [`instanceof` 型態運算子](#instanceof-型態運算子)\r\n  - [Autoload 自動載入](#autoload-自動載入)\r\n  - [魔術常數](#魔術常數)\r\n    - [`__LINE__` 檔案中的當前行號](#__line__-檔案中的當前行號)\r\n    - [`__FILE__` 檔案的完整路徑和檔名](#__file__-檔案的完整路徑和檔名)\r\n    - [`__DIR__` 檔案所在的目錄](#__dir__-檔案所在的目錄)\r\n    - [`__FUNCTION__` 返回該函數被定義時的名字](#__function__-返回該函數被定義時的名字)\r\n    - [`__CLASS__` 返回類別名稱](#__class__-返回類別名稱)\r\n    - [`__TRAIT__` Trait 的名字](#__trait__-trait-的名字)\r\n    - [`__METHOD__` 類別的方法名稱，返回該方法被定義時的名字](#__method__-類別的方法名稱返回該方法被定義時的名字)\r\n    - [`__NAMESPACE__` 當前命名空間的名稱](#__namespace__-當前命名空間的名稱)\r\n  - [魔術方法](#魔術方法)\r\n    - [`__construct()` 類別的構造函數](#__construct-類別的構造函數)\r\n    - [`__destruct()` 類別的解構函數](#__destruct-類別的解構函數)\r\n    - [`__call()` 在物件中呼叫一個不可訪問的方法時，呼叫此方法](#__call-在物件中呼叫一個不可訪問的方法時呼叫此方法)\r\n    - [`__callStatic()` 用靜態方式呼叫一個不可訪問的方法時，呼叫此方法](#__callstatic-用靜態方式呼叫一個不可訪問的方法時呼叫此方法)\r\n    - [`__get()` 獲取一個類別的成員變數時呼叫](#__get-獲取一個類別的成員變數時呼叫)\r\n    - [`__set()` 設置一個類別的成員變數時呼叫](#__set-設置一個類別的成員變數時呼叫)\r\n    - [`__isset()` 當私有屬性呼叫 isset() 或 empty() 時呼叫此方法](#__isset-當私有屬性呼叫-isset-或-empty-時呼叫此方法)\r\n  - [方法](#方法)\r\n    - [`foreach()`](#foreach)\r\n    - [`scandir()` 掃描指定的目錄，並返回為陣列](#scandir-掃描指定的目錄並返回為陣列)\r\n    - [`list()` 宣告陣列中的值，使其成為變數](#list-宣告陣列中的值使其成為變數)\r\n    - [`append()` 將傳入的值附加進陣列](#append-將傳入的值附加進陣列)\r\n    - [在陣列中新增元素](#在陣列中新增元素)\r\n      - [直接賦值](#直接賦值)\r\n      - [`array_push()` 在陣列最後新增元素](#array_push-在陣列最後新增元素)\r\n      - [`array_unshift()` 在陣列前端插入](#array_unshift-在陣列前端插入)\r\n    - [`array_fill()` 以填充數值的方式，建立新陣列](#array_fill-以填充數值的方式建立新陣列)\r\n    - [`array_combine()` 將傳入的參數合併為陣列](#array_combine-將傳入的參數合併為陣列)\r\n    - [`array_unique()` 從陣列中刪除重複的值](#array_unique-從陣列中刪除重複的值)\r\n    - [`array_diff()` 判斷陣列之間差異](#array_diff-判斷陣列之間差異)\r\n    - [日期/時間](#日期時間)\r\n      - [`date(string $format, ?int $timestamp = null)` 格式化 Unix timestamps](#datestring-format-int-timestamp--null-格式化-unix-timestamps)\r\n      - [`mktime($hour, $minute = null, $second = null, $month = null, $day = null, $year = null)` 取得指定日期的時間戳](#mktimehour-minute--null-second--null-month--null-day--null-year--null-取得指定日期的時間戳)\r\n      - [`date_diff()` 獲取以分鐘為單位的時間差](#date_diff-獲取以分鐘為單位的時間差)\r\n    - [`sort` 陣列排序](#sort-陣列排序)\r\n      - [依 value 排序](#依-value-排序)\r\n      - [依 key 排序](#依-key-排序)\r\n      - [自訂排序](#自訂排序)\r\n    - [分割字串](#分割字串)\r\n      - [`explode()`](#explode)\r\n      - [`str_split()`](#str_split)\r\n      - [`array_slice()`](#array_slice)\r\n    - [`implode()` 將陣列轉為字串](#implode-將陣列轉為字串)\r\n    - [`array_filter()` 過濾陣列元素(刪除陣列空值)](#array_filter-過濾陣列元素刪除陣列空值)\r\n    - [`str_pad()` 填充字串為指定長度](#str_pad-填充字串為指定長度)\r\n    - [資料序列化及反序列化](#資料序列化及反序列化)\r\n      - [`string serialize()` 序列化](#string-serialize-序列化)\r\n      - [`mixed unserialize()` 反序列化](#mixed-unserialize-反序列化)\r\n    - [`file_get_contents()` 將本地文件存入一個變數中](#file_get_contents-將本地文件存入一個變數中)\r\n    - [`str_pad()` 補足字串](#str_pad-補足字串)\r\n    - [`str_replace()` 替換字串](#str_replace-替換字串)\r\n    - [將字串轉換為數值](#將字串轉換為數值)\r\n    - [`is_a()` 檢查物件是該類別，或該類別是此物件的父類別(boolean)](#is_a-檢查物件是該類別或該類別是此物件的父類別boolean)\r\n    - [`substr()` 取得部分字串，可設定字串長度](#substr-取得部分字串可設定字串長度)\r\n    - [轉換字母大小寫](#轉換字母大小寫)\r\n      - [`ucfirst()` 將字串的首字母轉為大寫](#ucfirst-將字串的首字母轉為大寫)\r\n      - [`strtolower()` 將字串換為小寫](#strtolower-將字串換為小寫)\r\n      - [`strtoupper()` 將字串換為大寫](#strtoupper-將字串換為大寫)\r\n    - [`define()` 定義一個常數](#define-定義一個常數)\r\n  - [在 Linux 執行 php 檔](#在-linux-執行-php-檔)\r\n    - [方法一](#方法一)\r\n\r\n## 運算子、判斷\r\n\r\n### `+`: 算術相加\r\n\r\n### `.`: 字串相加\r\n\r\n### `gettype()`: 判斷變數的型態\r\n\r\n### `(int)($var1 + $var2)`: 只取商\r\n\r\n### `isset($var)`: 檢查變數是否有設置\r\n\r\n### `empty($var)`: 檢查變數是否為空值\r\n\r\n### `is_null($var)`: 檢查變數是否為 null\r\n\r\n|                 | gettype() |   isset()   |   empty()   |  is_null()  |\r\n| :-------------: | :-------: | :---------: | :---------: | :---------: |\r\n| $x is undefined |   null    | **_false_** |  [true](#)  |  [true](#)  |\r\n|    $x = null    |   null    | **_false_** |  [true](#)  |  [true](#)  |\r\n|     $x = 0      |    int    |  [true](#)  |  [true](#)  | **_false_** |\r\n|    $x = \"0\"     |    str    |  [true](#)  |  [true](#)  | **_false_** |\r\n|     $x = 1      |    int    |  [true](#)  | **_false_** | **_false_** |\r\n|     $x = \"\"     |    str    |  [true](#)  |  [true](#)  | **_false_** |\r\n|   $x = \"PHP\"    |    str    |  [true](#)  | **_false_** | **_false_** |\r\n\r\n### `var_dump($var);`: 將變數的訊息印出於螢幕上\r\n\r\n### `instanceof` 型態運算子\r\n\r\n- 用於確定一個 php 物件是否屬於某一類別\r\n\r\n  ```php\r\n  class MyClass\r\n  {\r\n  }\r\n  class NotMyClass\r\n  {\r\n  }\r\n\r\n  $a = new MyClass;\r\n  var_dump($a instanceof MyClass);\r\n  var_dump($a instanceof NotMyClass);\r\n  ```\r\n\r\n  ```php\r\n  bool(true)\r\n  bool(false)\r\n  ```\r\n\r\n- 也可以用來確定一個物件是不是繼承自某一父類別的子類別\r\n\r\n  ```php\r\n  class ParentClass\r\n  {\r\n  }\r\n  class MyClass extends ParentClass\r\n  {\r\n  }\r\n\r\n  $a = new MyClass;\r\n  var_dump($a instanceof MyClass);\r\n  var_dump($a instanceof ParentClass);\r\n  ```\r\n\r\n  ```php\r\n  bool(true)\r\n  bool(true)\r\n  ```\r\n\r\n- 也可以用於確定一個變數是不是實現了某個接口的物件實例\r\n\r\n  ```php\r\n  interface A\r\n  {\r\n  }\r\n  class B implements A\r\n  {\r\n  }\r\n  $obj = new B;\r\n\r\n  var_dump($obj instanceof A);\r\n  echo \"<br>\";\r\n  var_dump($obj instanceof B);\r\n  ```\r\n\r\n  ```php\r\n  bool(true)\r\n  bool(true)\r\n  ```\r\n\r\n  雖然 instanceof 通常是直接與 class 名稱一起使用，但也可以使用字串來代替\r\n\r\n  ```php\r\n  interface A\r\n  {\r\n  }\r\n  class B implements A\r\n  {\r\n  }\r\n  $obj = new B;\r\n  $str1 = 'A';\r\n  $str2 = 'B';\r\n\r\n  var_dump($obj instanceof A);\r\n  echo \"<br>\";\r\n  var_dump($obj instanceof B);\r\n  echo \"<br>\";\r\n  var_dump($obj instanceof $str1);\r\n  echo \"<br>\";\r\n  var_dump($obj instanceof $str2);\r\n  ```\r\n\r\n  ```php\r\n  bool(true)\r\n  bool(true)\r\n  bool(true)\r\n  bool(true)\r\n  ```\r\n\r\n  若被檢測的變數不是物件，instanceof 並不會報錯，而是直接返回 false。另外，不能使用 instanceof 來檢測常數\r\n\r\n  ```php\r\n  $a = 1;\r\n  $b = NULL;\r\n  $c = imagecreate(5, 5);\r\n  var_dump($a instanceof stdClass);\r\n  echo '<br>';\r\n  var_dump($b instanceof stdClass);\r\n  echo '<br>';\r\n  var_dump($c instanceof stdClass);\r\n  echo '<br>';\r\n  var_dump(FALSE instanceof stdClass);\r\n  ```\r\n\r\n  ```php\r\n  bool(false)\r\n  bool(false)\r\n  bool(false)\r\n  bool(false)\r\n  ```\r\n\r\n## Autoload 自動載入\r\n\r\n一般可以透過 `include`, `include_once`, `require`, `require_once`，來將檔案引入到我們目前正在編寫的這個檔案。\r\n\r\n習慣上我們會將一個 class 存放在單一的 php 檔案中，例如 Member.php 相對於 Member class。\r\n\r\n但當程式需要引用到這個 class，就可以用上面的方法來引用此 class 以供後續操作。\r\n\r\n而 php autoload 機制可以讓我們在需要這個物件的時候，才去真正的引入這個 class，這個動作就是常聽到的 lazyload 延遲載入。\r\n\r\n- `__autoload`\r\n  php5 提供了 `__autoload()` 這個魔術方法實現上述 Autoload 機制，雖然這個方法效能及方便性並不是非常理想。\r\n\r\n## 魔術常數\r\n\r\n- 不分大小寫，但一般而言都會以大寫呈現\r\n\r\n### `__LINE__` 檔案中的當前行號\r\n\r\n```php\r\necho __LINE__ . PHP_EOL; // 1\r\necho __LINE__ . PHP_EOL; // 2\r\necho __LINE__ . PHP_EOL; // 3\r\n```\r\n\r\n### `__FILE__` 檔案的完整路徑和檔名\r\n\r\n- 若將其使用在 `include` 中，則返回包含檔案的名稱。\r\n- `__FILE__`總是包含一個絕對路徑(如果是符號連線，則是解析後的絕對路徑)。\r\n\r\n  ```php\r\n  echo __FILE__ . PHP_EOL; // D:\\phpproject\\php\\newblog\\php-magic-constant.php\r\n  ```\r\n\r\n### `__DIR__` 檔案所在的目錄\r\n\r\n- 如果用在被包括檔案中，則返回被包括的檔案所在目錄。\r\n- 其等同於 `dirname(__FILE__)`。\r\n- 除非是根目錄，否則目錄中名不包括末尾的斜線。\r\n\r\n  ```php\r\n  echo __DIR__ . PHP_EOL; // D:\\phpproject\\php\\newblog\r\n  ```\r\n\r\n### `__FUNCTION__` 返回該函數被定義時的名字\r\n\r\n```php\r\necho __FUNCTION__ . PHP_EOL; // 函數尚未被定義\r\n\r\nfunction testFunction()\r\n{\r\n  echo __FUNCTION__ . PHP_EOL; //  testFunction\r\n}\r\n\r\nclass TestClass\r\n{\r\n  function testFunctionButInClass()\r\n  {\r\n    echo __FUNCTION__ . PHP_EOL; // testFunctionButInClass\r\n  }\r\n}\r\n\r\ntestFunction();\r\n$test = new TestClass();\r\n$test->testFunctionButInClass();\r\n```\r\n\r\n### `__CLASS__` 返回類別名稱\r\n\r\n```php\r\necho __CLASS__ . PHP_EOL; // 類別尚未被宣\r\n\r\nfunction testClass()\r\n{\r\n    echo __CLASS__ . PHP_EOL; // 類別尚未被宣告\r\n}\r\n\r\ntrait TestClassTrait\r\n{\r\n    function testClass2()\r\n    {\r\n        echo __CLASS__ . PHP_EOL; // TestClassClass\r\n    }\r\n}\r\n\r\nclass TestClassClass\r\n{\r\n    use TestClassTrait;\r\n    function testClass1()\r\n    {\r\n        echo __CLASS__ . PHP_EOL; // TestClassClass\r\n    }\r\n}\r\n\r\ntestClass();\r\n$test = new TestClassClass();\r\n$test->testClass1();\r\n$test->testClass2();\r\n```\r\n\r\n### `__TRAIT__` Trait 的名字\r\n\r\n```php\r\necho __TRAIT__ . PHP_EOL; // 什麼也沒有\r\nfunction testTrait()\r\n{\r\n    echo __TRAIT__ . PHP_EOL; // 什麼也沒有\r\n}\r\n\r\ntrait TestTrait\r\n{\r\n    function testTrait2()\r\n    {\r\n        echo __TRAIT__ . PHP_EOL; // TestTrait\r\n    }\r\n}\r\n\r\nclass TestTraitClass\r\n{\r\n    use TestTrait;\r\n\r\n    function testTrait1()\r\n    {\r\n        echo __TRAIT__ . PHP_EOL; // 什麼也沒有\r\n    }\r\n}\r\n\r\ntestTrait();\r\n$test = new TestTraitClass();\r\n$test->testTrait1();\r\n$test->testTrait2();\r\n```\r\n\r\n### `__METHOD__` 類別的方法名稱，返回該方法被定義時的名字\r\n\r\n```php\r\necho __METHOD__ . PHP_EOL; // 尚無方法\r\n\r\nfunction testMethod() {\r\n  echo __METHOD__ . PHP_EOL; // testMethod\r\n}\r\n\r\nclass TestMethodClass\r\n{\r\n  function testMethodButinClass() {\r\n    echo __METHOD__ . PHP_EOL; // TestMethodClass::testMethodButinClass\r\n  }\r\n}\r\n\r\ntestMethod();\r\n$test = new TestClassClass();\r\n$test->testMethodButinClass();\r\n```\r\n\r\n### `__NAMESPACE__` 當前命名空間的名稱\r\n\r\n- 此常數是在編譯時定義的\r\n\r\n  ```php\r\n  echo __NAMESPACE__ . PHP_EOL; // test\\magic\\constant\r\n\r\n  class TestNameSpaceClass\r\n  {\r\n      function testNamespace() {\r\n          echo __NAMESPACE__ . PHP_EOL; // test\\magic\\constant\r\n      }\r\n  }\r\n\r\n  $test = new TestNameSpaceClass();\r\n  $test->testNamespace();\r\n  ```\r\n\r\n## 魔術方法\r\n\r\n> 參考資料：\r\n>\r\n> [PHP 之十六個魔術方法詳解](https://segmentfault.com/a/1190000007250604)\r\n\r\n### `__construct()` 類別的構造函數\r\n\r\nphp 中構造方法是物件創建完成後，第一個被物件自動呼叫的方法。在每個類別中，都有一個構造方法，如果沒有宣告，那麼類別中會預設存在一個沒有參數且內容為空的構造方法。\r\n\r\n1. 作用：通常構造方法被用來執行一些初始化任務，如對成員屬性在創建對象時，賦予初始值\r\n2. 在類別中的聲明格式：\r\n\r\n   ```php\r\n   function __construct (params) {\r\n    // code\r\n    // 通常用來對成員屬性進行初始化賦值\r\n   }\r\n   ```\r\n\r\n3. 在類別中聲明構造方法需要注意的事項\r\n\r\n   1. 在同一個類別中只能宣告一個構造方法\r\n   2. 必定是以雙底線開始\r\n\r\n      ```php\r\n      class Person\r\n      {\r\n        public $name;\r\n        public $age;\r\n        public $sex;\r\n        /**\r\n         * 顯示宣告一個構造函數且帶參數\r\n         */\r\n        public function __construct($name = \"\", $age = 22, $sex = \"man\") {\r\n          $this->name = $name;\r\n          $this->sex = $sex;\r\n          $this->age = $age;\r\n        }\r\n        /**\r\n         * say 方法\r\n         */\r\n        public function say()\r\n        {\r\n          echo \"我叫：\" . $this->name . \"，性別：\" . $this->sex . \"，年齡：\" . $this->age;\r\n        }\r\n      }\r\n\r\n      /**\r\n       * $person1\r\n       */\r\n      $person1 = new Person()\r\n      echo $person1->say(); // 我叫：，性別：男，年齡：27\r\n      /**\r\n       * $person2\r\n       *\r\n       * @param $name 小明\r\n       */\r\n      $person2 = new Person('小明');\r\n      echo $person2->say(); // 我叫：小明，性別：男，年齡：27\r\n      /**\r\n       * $person3\r\n       *\r\n       * @param $name 李四\r\n       * @param $sex 男\r\n       * @param $age 25\r\n       */\r\n      $person3 = new Person('李四', '男', '25')\r\n      echo $person3->say(); // 我叫：李四，性別：男，年齡：25\r\n      ```\r\n\r\n### `__destruct()` 類別的解構函數\r\n\r\n允許在銷毀一個類別之前，執行一些操作或完成一些功能，比如關閉文件，釋放結果集等\r\n\r\n1. 宣告格式\r\n\r\n   ```php\r\n   function __destruct()\r\n   {\r\n     // code\r\n   }\r\n   ```\r\n\r\n2. 解構函數的作用\r\n\r\n   ```php\r\n   class Person{\r\n       public $name;\r\n\r\n       public $age;\r\n\r\n       public $sex;\r\n\r\n       public function __construct($name=\"\", $sex=\"男\", $age=22)\r\n       {\r\n           $this->name = $name;\r\n           $this->sex  = $sex;\r\n           $this->age  = $age;\r\n       }\r\n\r\n       /**\r\n        * say 说话方法\r\n        */\r\n       public function say()\r\n       {\r\n           echo \"我叫：\".$this->name.\"，性别：\".$this->sex.\"，年齡：\".$this->age;\r\n       }\r\n\r\n       /**\r\n        * 声明一个析构方法\r\n        */\r\n       public function __destruct()\r\n       {\r\n           echo \"我覺得我還可以搶救一下，我的名字叫\".$this->name;\r\n       }\r\n   }\r\n\r\n   $Person = new Person(\"小明\");\r\n   unset($Person); // 銷毀上面建立的物件\r\n   ```\r\n\r\n### `__call()` 在物件中呼叫一個不可訪問的方法時，呼叫此方法\r\n\r\n此方法接受兩參數，`$function_name` 會自動接收不存在的方法名，`$arguments` 則以陣列的方式接收不存在方法的多個參數。\r\n\r\n1. 宣告此方法的格式\r\n\r\n   ```php\r\n   function __call(string $function_nama, array $arguments){\r\n     // code\r\n   }\r\n   ```\r\n\r\n2. 此方法的作用：為避免當呼叫的方法不存在而產生錯誤，導致意外的程序中止，可以使用 `__call()` 方法來避免。剛方法在呼叫的方法不存在時，會自動呼叫，程式仍會繼續執行下去。\r\n\r\n   ```php\r\n   class Person\r\n   {\r\n       function say()\r\n       {\r\n\r\n              echo \"Hello, world!<br>\";\r\n       }\r\n\r\n       /**\r\n        * 宣告此方法用來處理，當呼叫了此物件中不存在的方法\r\n        */\r\n       function __call($funName, $arguments)\r\n       {\r\n             echo \"你所呼叫的函数：\" . $funName . \"(參數：\" ;  // 輸出呼叫的不存在方法名稱\r\n             print_r($arguments); // 输出呼叫不存在方法的參數列表\r\n             echo \")不存在！<br>\\n\"; // 結束換行\r\n       }\r\n   }\r\n\r\n   $Person = new Person();\r\n   $Person->run(\"teacher\"); // 呼叫物件中不存在的方法，此時會自動呼叫物件中的 __call() 方法\r\n   $Person->eat(\"小明\", \"蘋果\");\r\n   $Person->say();\r\n   ```\r\n\r\n   輸出\r\n\r\n   ```php\r\n   你所调用的函数：run(参数：Array ( [0] => teacher ) )不存在！\r\n\r\n   你所调用的函数：eat(参数：Array ( [0] => 小明 [1] => 苹果 ) )不存在！\r\n\r\n   Hello, world!\r\n   ```\r\n\r\n### `__callStatic()` 用靜態方式呼叫一個不可訪問的方法時，呼叫此方法\r\n\r\n```php\r\n<?php\r\nclass Person\r\n{\r\n    function say()\r\n    {\r\n        echo \"Hello, world!<br>\";\r\n    }\r\n\r\n    /**\r\n     * 宣告此方法用來處理當靜態呼叫了不存在的方法時\r\n     */\r\n    public static function __callStatic($funName, $arguments)\r\n    {\r\n        echo \"你所呼叫的靜態方法：\" . $funName . \"(參數：\" ;  // 輸出呼叫不存在的方法名稱\r\n        print_r($arguments); // 输出呼叫不存在方法時傳入的參數\r\n        echo \")不存在！<br>\\n\"; // 结束换行\r\n    }\r\n}\r\n\r\n$Person = new Person();\r\n$Person::run(\"teacher\"); // 用於呼叫物件中不存在的靜態方法時，會自動呼叫物件中的__callStatic()方法\r\n$Person::eat(\"小明\", \"蘋果\");\r\n$Person->say();\r\n```\r\n\r\n### `__get()` 獲取一個類別的成員變數時呼叫\r\n\r\n在 php 物件導向中，若類別成員被設定為 private 時，若我們在外面呼叫他則會出現\"無法訪問某個私有屬性\"的錯誤。\r\n\r\n- 此方法的作用：在程式運行中，透過他可以在物件外面獲取私有屬性成員的值\r\n\r\n  ```php\r\n  class Person\r\n  {\r\n      private $name;\r\n      private $age;\r\n\r\n      function __construct($name=\"\", $age=1)\r\n      {\r\n          $this->name = $name;\r\n          $this->age = $age;\r\n      }\r\n\r\n      /**\r\n       * 在類別中添加__get()方法，在直接獲取屬性時，自動呼叫一次，以屬性名作為參數傳入並處理\r\n       * @param $propertyName\r\n       *\r\n       * @return int\r\n       */\r\n      public function __get($propertyName)\r\n      {\r\n          if ($propertyName == \"age\") {\r\n              if ($this->age > 30) {\r\n                  return $this->age - 10;\r\n              } else {\r\n                  return $this->$propertyName;\r\n              }\r\n          } else {\r\n              return $this->$propertyName;\r\n          }\r\n      }\r\n  }\r\n\r\n  $Person = new Person(\"小明\", 60);   // 透過將 Persian 類別實例化的物件，並透過建構函示為屬性添加預設值\r\n  echo \"姓名：\" . $Person->name . \"<br>\";   // 直接呼叫私有屬性 $name，自動呼叫了__get()方法可以間接獲取\r\n  echo \"年龄：\" . $Person->age . \"<br>\";    // 自動呼叫 __get()方法，根據物件本身的情況會返回不同的值\r\n  ```\r\n\r\n  ```php\r\n  姓名：小明\r\n  年齡：50\r\n  ```\r\n\r\n### `__set()` 設置一個類別的成員變數時呼叫\r\n\r\n- 作用：設置私有屬性，給一個未定義的屬性賦值，此方法會被觸發，傳入的參數是被設置的屬性名和值\r\n\r\n  ```php\r\n  class Person\r\n  {\r\n      private $name;\r\n\r\n      private $age;\r\n\r\n      public function __construct($name=\"\",  $age=25)\r\n      {\r\n          $this->name = $name;\r\n          $this->age  = $age;\r\n      }\r\n\r\n      /**\r\n       * 宣告此方法需兩個參數，直接為私有屬性賦值時自動呼叫，並可以排除非法賦值\r\n       *\r\n       * @param $property\r\n       * @param $value\r\n       */\r\n      public function __set($property, $value) {\r\n          if ($property==\"age\")\r\n          {\r\n              if ($value > 150 || $value < 0) {\r\n                  return;\r\n              }\r\n          }\r\n          $this->$property = $value;\r\n      }\r\n\r\n      /**\r\n       * 在類別中宣告 say()，將所有的私有屬性輸出\r\n       */\r\n      public function say(){\r\n          echo \"我叫\".$this->name.\"，今年\".$this->age.\"歲了\";\r\n      }\r\n  }\r\n\r\n  $Person= new Person(\"小明\", 25); // 注意，初始值將被下面所更改\r\n  // 自動呼叫 __set()，將數系名稱name傳遞給第一個參數，將屬性值\"小明\"傳遞給第二參數\r\n  $Person->name = \"小红\";     // 赋值成功。如果没有__set()，則出錯。\r\n  // 自動呼叫 __set() 函数，將屬性名稱 age 傳給第一個參數，將屬性值 26 傳給第二個參數\r\n  $Person->age = 16; //赋值成功\r\n  $Person->age = 160; //160是一个非法值，赋值失效\r\n  $Person->say();  //输出：我叫小红，今年 16 歲了\r\n  ```\r\n\r\n### `__isset()` 當私有屬性呼叫 isset() 或 empty() 時呼叫此方法\r\n\r\n## 方法\r\n\r\n### `foreach()`\r\n\r\n- `foreach()` 尋訪陣列\r\n\r\n  ```php\r\n  foreach ($array as $value) {\r\n    // 每次尋訪會將陣列的值存到value中，直到陣列結束\r\n  }\r\n  foreach ($array as $key => $value) {\r\n   // 每次尋訪會將陣列的值以及key，存到value中  key => 流水號\r\n  }\r\n  ```\r\n\r\n- `continue` 跳出本次循環，繼續執行下向執行\r\n\r\n- `array_key_first()` 取得陣列中第一個 key 值\r\n- `array_key_last()` 取得陣列中最後一個 key 值\r\n\r\n  ```php\r\n  $array  = array(\"dog\", \"rabbit\", \"horse\", \"rat\", \"cat\");\r\n  foreach($array as $index => $animal) {\r\n      if ($index === array_key_first($array))\r\n          echo $animal; // output: dog\r\n      if ($index === array_key_last($array))\r\n          echo $animal; // output: cat\r\n  }\r\n  ```\r\n\r\n- `break` 跳出迴圈\r\n\r\n  ```php\r\n  <?php\r\n  foreach (array('1','2','3') as $first) {\r\n      echo \"$first \";\r\n      foreach (array('3','2','1') as $second) {\r\n          echo \"$second \";\r\n          if ($first == $second) {\r\n              break;  // this will break both foreach loops\r\n          }\r\n      }\r\n      echo \". \";  // never reached!\r\n  }\r\n  echo \"Loop Ended\";\r\n  ?>\r\n  ```\r\n\r\n- 輸出\r\n\r\n  ```php\r\n  1 3 2 1 . 2 3 2 . 3 3 . Loop Ended\r\n  ```\r\n\r\n### `scandir()` 掃描指定的目錄，並返回為陣列\r\n\r\n- `scandir()` 掃描指定的目錄，並返回為陣列\r\n\r\n### `list()` 宣告陣列中的值，使其成為變數\r\n\r\n- `list(var1, var2...)` 宣告陣列中的值，使其成為變數\r\n\r\n  ```php\r\n  $my_array = array('dog', 'cat', 'horse');\r\n  list($a, $b, $c) = $my_array;\r\n  echo \"i have several animals, a $a, a $b, a $c. \";\r\n  // i have several animals, a dog, a cat and a horse.\r\n  ```\r\n\r\n### `append()` 將傳入的值附加進陣列\r\n\r\n- `append(var1, var2)`\r\n\r\n  ```php\r\n  // PHP function to illustrate the\r\n  // append() method\r\n  $arrObj = new ArrayObject(array('Geeks', 'for', 'Geeks'));\r\n  // Appending an array\r\n  $arrObj->append(array('welcomes', 'you'));\r\n  var_dump($arrObj);\r\n  ```\r\n\r\n- 輸出\r\n\r\n  ```php\r\n  object(ArrayObject)#1 (1) {\r\n    [\"storage\":\"ArrayObject\":private]=>\r\n    array(4) {\r\n      [0]=>\r\n      string(5) \"Geeks\"\r\n      [1]=>\r\n      string(3) \"for\"\r\n      [2]=>\r\n      string(5) \"Geeks\"\r\n      [3]=>\r\n      array(2) {\r\n        [0]=>\r\n        string(8) \"welcomes\"\r\n        [1]=>\r\n        string(3) \"you\"\r\n      }\r\n    }\r\n  }\r\n  ```\r\n\r\n### 在陣列中新增元素\r\n\r\n#### 直接賦值\r\n\r\n```php\r\n$array[] = $array;\r\n```\r\n\r\n```php\r\n$flower = array();\r\necho(\"The array is empty, as you can see. \\n\");\r\nprint_r($flowers);\r\necho(\"Now, we have added the values. \\n\");\r\n$flowers[] = \"Rose\";\r\n$flowers[] = \"Jasmine\";\r\n$flowers[] = \"Lili\";\r\n$flowers[] = \"Hibiscus\";\r\n$flowers[] = \"Tulip\";\r\nprint_r($flowers);\r\n```\r\n\r\n```php\r\nThe array is empty, as you can see.\r\nArray\r\n(\r\n)\r\nNow, we have added the values.\r\nArray\r\n(\r\n    [0] => Rose\r\n    [1] => Jasmine\r\n    [2] => Lili\r\n    [3] => Hibiscus\r\n    [4] => Tulip\r\n)\r\n```\r\n\r\n#### `array_push()` 在陣列最後新增元素\r\n\r\n- `array_push($array, $value1, $value2, ..., $valueN);`\r\n- `$array` 必須，目標新增元素的陣列\r\n- `$value1`, `$value2` 必須，欲新增至陣列的元素，可以為字串、整數、浮點數等\r\n\r\n  ```php\r\n  $flowers = array();\r\n  echo(\"The array is empty, as you can see. \\n\");\r\n  print_r($flowers);\r\n  echo(\"Now, we have added the values. \\n\");\r\n  array_push($flowers, \"Rose\", \"Jasmine\", \"Lili\", \"Hibiscus\", \"Tulip\");\r\n  print_r($flowers);\r\n  ```\r\n\r\n  ```php\r\n  The array is empty, as you can see.\r\n  Array\r\n  (\r\n  )\r\n  Now, we have added the values.\r\n  Array\r\n  (\r\n      [0] => Rose\r\n      [1] => Jasmine\r\n      [2] => Lili\r\n      [3] => Hibiscus\r\n      [4] => Tulip\r\n  )\r\n  ```\r\n\r\n#### `array_unshift()` 在陣列前端插入\r\n\r\n- `array_unshift($array, $value1, $value2, ..., $valueN)`\r\n- `$array` 必須，目標新增元素的陣列\r\n- `$value1`, `$value2` 必須，欲新增至陣列的元素，可以為字串、整數、浮點數等\r\n\r\n  ```php\r\n  $flowers = ['first', 'second'];\r\n  print_r($flowers);\r\n  echo(\"Now we have added the values. \\n\");\r\n  echo(array_unshift($flowers, \"Rose\", \"Jasmine\", \"Lili\", \"Hibiscus\", \"Tulip\"));\r\n  echo(\"\\n\");\r\n  print_r($flowers);\r\n  ```\r\n\r\n  ```php\r\n  Array\r\n  (\r\n    [0] => first\r\n    [1] => second\r\n  )\r\n  Now we have added the values.\r\n  7\r\n  Array\r\n  (\r\n    [0] => Rose\r\n    [1] => Jasmine\r\n    [2] => Lili\r\n    [3] => Hibiscus\r\n    [4] => Tulip\r\n    [5] => first\r\n    [6] => second\r\n  )\r\n  ```\r\n\r\n### `array_fill()` 以填充數值的方式，建立新陣列\r\n\r\n- `array_fill(int $start_index, int $count, mixed $value): array` 將傳入的`$value`，加入`$count` 個值到陣列，開始的 key 值由`$start_index` 指定\r\n\r\n- `$start_index` 回傳陣列的第一個 key 值，如為負數，返回的第一個 key 將會是 start_index 的值，而後面的 key 值由 0 開始。\r\n\r\n- `$count` 插入值的數量，需大於等於 0 ，否則拋出 E_WARNING。\r\n\r\n- `$value` 傳入陣列的值。\r\n\r\n  ```php\r\n  $a = array_fill(5, 6, 'banana');\r\n  $b = array_fill(-2, 4, 'pear');\r\n  print_r($a);\r\n  print_r($b);\r\n  ```\r\n\r\n  ```php\r\n  Array\r\n  (\r\n    [5]  => banana\r\n    [6]  => banana\r\n    [7]  => banana\r\n    [8]  => banana\r\n    [9]  => banana\r\n    [10] => banana\r\n  )\r\n  Array\r\n  (\r\n    [-2] => pear\r\n    [0] => pear\r\n    [1] => pear\r\n    [2] => pear\r\n  )\r\n  ```\r\n\r\n### `array_combine()` 將傳入的參數合併為陣列\r\n\r\n- `array_combine(array $keys, array $values): array` `$key`為 key 值，`$value` 為相對應的值。\r\n\r\n  ```php\r\n  $a = array('green', 'red', 'yellow');\r\n  $b = array('avocado', 'apple', 'banana');\r\n  $c = array_combine($a, $b);\r\n  print_r($c);\r\n  ```\r\n\r\n  ```PHP\r\n  Array\r\n  (\r\n    [green]  => avocado\r\n    [red]    => apple\r\n    [yellow] => banana\r\n  )\r\n  ```\r\n\r\n### `array_unique()` 從陣列中刪除重複的值\r\n\r\n- `array_unique($array, $flags)`\r\n\r\n- `$array` 要刪除重複值的陣列\r\n- `$flags` 指定陣列的排序模式，有五種型別\r\n- `SORT_REGULAR` 正常常比較元素\r\n- `SORT_NUMERIC` 以數字方式比較元素\r\n- `SORT_STRING` 以字串方式比較元素\r\n- `SORT_LOCALE_STRING` 基於當前的語言環境，以字串方式比較元素。\r\n\r\n### `array_diff()` 判斷陣列之間差異\r\n\r\n- `array_diff( $array1 , $array2 , $array3 , ... ):array` 後面每個陣列都跟第一個陣列做比較，此方法會回傳在第一陣列中有出現，但未出現在其他陣中的值，並會保留鍵名\r\n\r\n  ```php\r\n  $array1 = array('A','B','C','D');\r\n  $array2 = array('C','D','E','F');\r\n  $array3 = array('A','B','E','F');\r\n  $newArray1 = array_diff($array1,$array2);\r\n  print_r($newArray1);\r\n  $newArray2 = array_diff($array1,$array3);\r\n  print_r($newArray2);\r\n  ```\r\n\r\n  ```PHP\r\n  Array\r\n  (\r\n    [0] => A,\r\n    [1] => B\r\n  )\r\n  Array\r\n  (\r\n    [2] => C,\r\n    [3] => D\r\n  )\r\n  ```\r\n\r\n- 進階用法\r\n\r\n藉由其查詢兩個以上陣列之間的差異，並返回不存在陣列中的值之特性。\r\n\r\n因此可用來刪除陣列中多個值，而不影響其索引值。\r\n\r\n```php\r\n//Declare the array\r\n$flowers = [\r\n  \"Rose\",\r\n  \"Lili\",\r\n  \"Jasmine\",\r\n  \"Hibiscus\",\r\n  \"Tulip\",\r\n  \"Sun Flower\",\r\n  \"Daffodil\",\r\n  \"Daisy\"\r\n];\r\n\r\n$flowers = array_diff($flowers, array(\"Rose\",\"Lili\"));\r\necho \"The array is:\\n\";\r\nprint_r($flowers);\r\n```\r\n\r\n```php\r\nArray\r\n(\r\n[2] => Jasmine\r\n[3] => Hibiscus\r\n[4] => Tulip\r\n[5] => Sun Flower\r\n[6] => Daffodil\r\n[7] => Daisy\r\n)\r\n```\r\n\r\n### 日期/時間\r\n\r\n#### `date(string $format, ?int $timestamp = null)` 格式化 Unix timestamps\r\n\r\n- `$format` 指定的格式\r\n  - `Y` 年份，四位數\r\n  - `y` 年份二位數\r\n  - `F` 月份英文全名；如 'March'\r\n  - `M` 月份英文縮寫；如 'Mar'\r\n  - `m` 月份數字，不足二位前面補 0\r\n  - `n` 月份數字\r\n  - `D` 星期英文縮寫；如：'Fri'\r\n  - `l` 星期英文全稱；如：'Friday'\r\n  - `w` 星期數字\r\n  - `d` 幾日數字，不足二位前面補 0\r\n  - `j` 幾日數字\r\n  - `H` 24 小時制，不足二位前面補 0\r\n  - `h` 12 小時制，不足二位前面補 0\r\n  - `G` 24 小時制\r\n  - `g` 12 小時制\r\n  - `i` 分鐘\r\n  - `A` Am 或 Pm\r\n  - `a` am 或 pm\r\n  - `s` 秒\r\n  - `U` 總秒數\r\n  - `t` 指定月份的天數；如\"28\", \"31\"\r\n  - `z` 一年中的第幾天\r\n- `$timestamp` 時間戳(可選)\r\n\r\n#### `mktime($hour, $minute = null, $second = null, $month = null, $day = null, $year = null)` 取得指定日期的時間戳\r\n\r\n- 任何省略的變數，將依據本地時間設置\r\n\r\n#### `date_diff()` 獲取以分鐘為單位的時間差\r\n\r\n- `date_diff($StartDateTimeObject, $EndDateTimeObject)`\r\n  - `$StartDateTimeObject1` 必須，為一個 DataTime 物件，表示開始日期。\r\n  - `$EndDateTimeObject1` 必須，為一個 DataTime 物件，表示結束日期。\r\n  - 若失敗返回 false\r\n\r\n```php\r\n$date_time_start = date_create('2019-06-19')\r\n$date_time_end = date_create('2020-06-19')\r\n\r\n$difference = date_diff($date_time_start, $date_time_end);\r\n```\r\n\r\n### `sort` 陣列排序\r\n\r\n#### 依 value 排序\r\n\r\n- 由小到大排序值\r\n- `sort` 刪除 key\r\n- `asort` 保留 key\r\n- 由大到小排序值\r\n- `rsort` 刪除 key\r\n- `arsort` 保留 key\r\n\r\n#### 依 key 排序\r\n\r\n- `ksort` 由小到大排索引值\r\n- `krsort` 由大到小排索引值\r\n\r\n#### 自訂排序\r\n\r\n加上一個前綴 `u` 在相對應的方法\r\n\r\n- 範例一：\r\n  今天有一個陣列如下\r\n\r\n  ```php\r\n  $unsorted = [\r\n      ['name'   => 'good',\r\n       'sorter' => '1',],\r\n\r\n      ['name'   => 'bad',\r\n       'sorter' => '3',],\r\n\r\n      ['name'   => 'normal',\r\n       'sorter' => '2',],\r\n  ];\r\n  ```\r\n\r\n  我要透過 sorter 這個 key 的 value 來做排序\r\n\r\n  ```php\r\n  usort($unsorted, function ($a, $b) {\r\n      return $a['sorter'] > $b['sorter'];\r\n      // 如果 a > b 的話 就會輸出 1，而因為 usort 的 根基是 sort\r\n      // 意即是照 value 由小到大排序，所以輸出 1 的就會往後排，進而達到目的\r\n  });\r\n  ```\r\n\r\n  ```php\r\n  array(3) {\r\n   [0]=>\r\n   array(2) {\r\n     [\"name\"]=>\r\n     string(4) \"good\"\r\n     [\"sorter\"]=>\r\n     string(1) \"1\"\r\n   }\r\n   [1]=>\r\n   array(2) {\r\n     [\"name\"]=>\r\n     string(6) \"normal\"\r\n     [\"sorter\"]=>\r\n     string(1) \"2\"\r\n   }\r\n   [2]=>\r\n   array(2) {\r\n     [\"name\"]=>\r\n     string(3) \"bad\"\r\n     [\"sorter\"]=>\r\n     string(1) \"3\"\r\n   }\r\n  }\r\n  ```\r\n\r\n- 範例二：\r\n\r\n  如果一樣的陣列，但要用來比對的數值是重複的\r\n\r\n  ```php\r\n  $unsorted = [\r\n      ['name'   => 'good', 'sorter' => '1',],\r\n      ['name'   => 'bad', 'sorter' => '3',],\r\n      ['name'   => 'normal', 'sorter' => '3',],\r\n  ];\r\n  ```\r\n\r\n  可以增加一個比對條件\r\n\r\n  ```php\r\n  $unsorted = [\r\n      [\r\n        'name'   => 'good',\r\n        'sorter' => '1',\r\n        'newSorter'=> '2'\r\n      ],\r\n      [\r\n        'name'   => 'bad',\r\n        'sorter' => '3',\r\n        'newSorter'=> '3'\r\n      ],\r\n      [\r\n        'name'   => 'normal',\r\n        'sorter' => '3',\r\n        'newSorter' => '1'\r\n      ],\r\n      [\r\n        'name'   => 'hahaha',\r\n        'sorter' => '2',\r\n        'newSorter' => '1'\r\n      ],\r\n  ];\r\n  ```\r\n\r\n  依照 sorter 來進行排序，但如果 sorter 數值相同，則使用 newSorter 來進行排序\r\n\r\n  ```php\r\n  usort($unsorted, function ($a, $b)) {\r\n      return $a['sorter'] > $b['sorter'] || ($a['sorter'] == $b['sorter'] && $a['newSorter'] > $b['newSorter']);\r\n  }\r\n\r\n  // 或這樣寫\r\n  if ($a['sorter'] > $b['sorter'] || ($a['sorter'] == $b['sorter'] && $a['newSorter'] > $b['newSorter'])) {\r\n      return 1;\r\n  } elseif ($a['sorter'] < $b['sorter']) {\r\n      return -1;\r\n  } else {\r\n      return 0;\r\n  }\r\n  ```\r\n\r\n  ```php\r\n  array(4) {\r\n    [0]=>\r\n    array(3) {\r\n      [\"name\"]=>\r\n      string(4) \"good\"\r\n      [\"sorter\"]=>\r\n      string(1) \"1\"\r\n      [\"newSorter\"]=>\r\n      string(1) \"2\"\r\n    }\r\n    [1]=>\r\n    array(3) {\r\n      [\"name\"]=>\r\n      string(6) \"hahaha\"\r\n      [\"sorter\"]=>\r\n      string(1) \"2\"\r\n      [\"newSorter\"]=>\r\n      string(1) \"1\"\r\n    }\r\n    [2]=>\r\n    array(3) {\r\n      [\"name\"]=>\r\n      string(6) \"normal\"\r\n      [\"sorter\"]=>\r\n      string(1) \"3\"\r\n      [\"newSorter\"]=>\r\n      string(1) \"1\"\r\n    }\r\n    [3]=>\r\n    array(3) {\r\n      [\"name\"]=>\r\n      string(3) \"bad\"\r\n      [\"sorter\"]=>\r\n      string(1) \"3\"\r\n      [\"newSorter\"]=>\r\n      string(1) \"3\"\r\n    }\r\n  }\r\n  ```\r\n\r\n### 分割字串\r\n\r\n#### `explode()`\r\n\r\n- `explode( string $delimiter , string $string , int $limit )`\r\n\r\n- `$delimiter` - 字串的切割部位，請自行設定，字串形態，必填\r\n- `$string` - 被要處理的字串，字串形態，必填項目。\r\n- `$limit` - 設定字串切割後最多可輸出的數量，數字形態，可為正整數或負整數，如果填寫正整數，最後的的部份包含切割完剩下的所有部份，，如果填寫負整數，則倒數的部份若在負整數範圍 內將不會顯示，非必填項目\r\n\r\n  ```php\r\n  <?php\r\n    $str = 'Apple Dog Pig';\r\n    $str_sec = explode(\" \",$str);\r\n    print_r($str_sec);\r\n  ```\r\n\r\n  ```php\r\n  Array (\r\n  　[0] => Apple\r\n  　[1] => Dog\r\n  　[2] => Pig\r\n  )\r\n  ```\r\n\r\n- 加入`$limit` 參數\r\n\r\n  ```php\r\n  <?php\r\n    $str = 'Apple Dog Pig';\r\n    $str_sec_A = explode(\" \",$str,2);\r\n    $str_sec_B = explode(\" \",$str,-1);\r\n    print_r($str_sec_A);\r\n    print_r($str_sec_B);\r\n  ```\r\n\r\n  ```php\r\n  Array (\r\n  　[0] => Apple\r\n  　[1] => Dog Pig\r\n  )\r\n  Array (\r\n  　[0] => Apple\r\n  　[1] => Dog\r\n  )\r\n  ```\r\n\r\n#### `str_split()`\r\n\r\n- `str_split($string, $length)`\r\n\r\n- `string` 必需。規定要分割的字符串。\r\n- `length` 可選。規定每個數組元素的長度。默認是 1。\r\n\r\n  ```php\r\n  <?php\r\n    $NewString = \"M'L2\";\r\n    $Arr2=str_split($NewString,3);//根據每三個字元切割\r\n    print_r($Arr2);\r\n  ```\r\n\r\n  ```php\r\n  Array(\r\n      [0] => \"M'L\"\r\n      [1] => 2\r\n  )\r\n  ```\r\n\r\n#### `array_slice()`\r\n\r\n- `array_slice($array, $start, $length, $preserve)`\r\n\r\n- `array` 必填，傳入陣列。\r\n- `start` 必填，規定取出元素的開始位置，0 = 第一個元素，若傳入正數，則由前往後取值，若為負值由後往前取值。\r\n- `length` 選填，規定返回的陣列長度。\r\n- `preserve` 選填，`true` 保留 key 值，`false` 重置 key 值。\r\n\r\n  ```php\r\n  <?php\r\n  $a=array(\"red\",\"green\",\"blue\",\"yellow\",\"brown\");\r\n  print_r(array_slice($a,2));\r\n  ```\r\n\r\n  ```php\r\n  Array\r\n  (\r\n      [0] => blue\r\n      [1] => yellow\r\n      [2] => brown\r\n  )\r\n  ```\r\n\r\n### `implode()` 將陣列轉為字串\r\n\r\n- `implode($separator, $array)`\r\n\r\n- `separator` 可選。規定數組元素之間放置的內容。默認是 \"\"（空字符串）。\r\n- `array` 必需。要結合為字符串的數組。\r\n\r\n  ```php\r\n  $arr = [1,2,3,4,5,6];\r\n  print_r(implode('=', $arr));\r\n  ```\r\n\r\n  ```php\r\n  \"1=2=3=4=5=6\"\r\n  ```\r\n\r\n### `array_filter()` 過濾陣列元素(刪除陣列空值)\r\n\r\n- `array_filter($arrayName, $callbackFunction, $callbackParameter)`\r\n\r\n  - `$arrayName` 必須，目標陣列\r\n  - `$callbackFunction` 可選，指定刪除的參數，預設刪除陣列中等於 false 的值\r\n  - `$callbackParameter` 可選，引用傳遞給回傳函數的參數\r\n\r\n    - `ARRAY_FILTER_USE_KEY` 將 key 作為唯一參數傳遞給回調函數，而不是數組的值\r\n    - `ARRAY_FILTER_USE_BOTH` 將值和鍵都作為參數而不是值傳遞給回調\r\n\r\n      ```php\r\n      // PHP function to check for even elements in an array\r\n      function Even($array)\r\n      {\r\n          // returns if the input integer is even\r\n          if($array%2==0)\r\n             return TRUE;\r\n          else\r\n             return FALSE;\r\n      }\r\n      $array = array(12, 0, 0, 18, 27, 0, 46);\r\n      print_r(array_filter($array, \"Even\"));\r\n      ```\r\n\r\n      ```php\r\n        Array (\r\n            [0] => 12\r\n            [1] => 0\r\n            [2] => 0\r\n            [3] => 18\r\n            [5] => 0\r\n            [6] => 46\r\n        )\r\n      ```\r\n\r\n### `str_pad()` 填充字串為指定長度\r\n\r\n- `str_pad($string, $length, $pad_string, $pad_type)`\r\n\r\n- string 必填，要填充的字串。\r\n- length 必填，規定新字串的長度，若小於傳入的字串長度，則不進行操作。\r\n- pad_string 可選，提供填充的字串，預設為空白。\r\n- pad_type 可選，字串填充的方向。\r\n\r\n  - STR_PAD_BOTH 填充字串的兩側，若不為偶數，則將額外的字串填充至右側。\r\n  - STR_PAD_LEFT 填充到字串的左側。\r\n  - STR_PAD_RIGHT 填充到字串的右側(預設)。\r\n\r\n    ```php\r\n    $str = \"Hello world\";\r\n    echo str_pad($str, 20, \".\", STR_PAD_LEFT);\r\n    ```\r\n\r\n    ```php\r\n    .........Hello World\r\n    ```\r\n\r\n    ```php\r\n    $str = \"Hello world\";\r\n    echo str_pad($str, 20, \".:\", STR_PAD_BOTH);\r\n    ```\r\n\r\n    ```php\r\n    .:.:Hello World.:.:.\r\n    ```\r\n\r\n### 資料序列化及反序列化\r\n\r\n#### `string serialize()` 序列化\r\n\r\n- `string serialize( mixed $value )`\r\n\r\n- $value: 要序列化的對象或陣列\r\n\r\n  ```php\r\n  $sites = array('Google', 'Runoob', 'Facebook');\r\n  $serialized_data = serialize($sites);\r\n  echo  $serialized_data . PHP_EOL;\r\n  ```\r\n\r\n  ```php\r\n  a:3:{i:0;s:6:\"Google\";i:1;s:6:\"Runoob\";i:2;s:8:\"Facebook\";}\r\n  ```\r\n\r\n#### `mixed unserialize()` 反序列化\r\n\r\n- `mixed unserialize( string $str )`\r\n\r\n- $str: 序列化後的字串\r\n\r\n  ```php\r\n  $str = 'a:3:{i:0;s:6:\"Google\";i:1;s:6:\"Runoob\";i:2;s:8:\"Facebook\";}';\r\n  $unserialized_data = unserialize($str);\r\n  print_r($unserialized_data);\r\n  ```\r\n\r\n  ```php\r\n  Array\r\n  (\r\n      [0] => Google\r\n      [1] => Runoob\r\n      [2] => Facebook\r\n  )\r\n  ```\r\n\r\n### `file_get_contents()` 將本地文件存入一個變數中\r\n\r\n- `file_get_contents($path, $include_path, $context, $start, $max_length)`\r\n\r\n- path (必須) 文件的路徑\r\n- include_path (可選) 如果也想在 include_path 中搜尋文件，可以將該參數設為\"1\"\r\n- context (可選) 規定文件控制代碼的環境\r\n- start (可選) 指定在文件中開始讀取的位置。\r\n- max_length (可選) 規定讀取的位元組。\r\n\r\n### `str_pad()` 補足字串\r\n\r\n- `str_pad($str, $pad_length , $pad_string, $pad_type)`\r\n\r\n- `$str` 來源字串\r\n- `$pad_length` 補完後字串長度\r\n- `$pad_string` 補入的字元\r\n- `$pad_type` 補入的規則\r\n\r\n  - `STR_PAD_BOTH` 左右都補\r\n  - `STR_PAD_LEFT` 從左邊開始\r\n  - `STR_PAD_RIGHT` 從右邊開始\r\n\r\n  把 id 由左邊開始補 0，補到五位數\r\n\r\n  ```php\r\n  $id=01;\r\n  $id=str_pad($id,5,\"0\",STR_PAD_LEFT);\r\n  echo $id;\r\n  //00001\r\n  ```\r\n\r\n### `str_replace()` 替換字串\r\n\r\n### 將字串轉換為數值\r\n\r\n> 若字串開頭為 0，轉為數值後開頭的 0 會被省略\r\n\r\n- `number_format()` 若失敗則返回`E_WARNING`\r\n\r\n- 使用類型轉換\r\n\r\n  ```php\r\n  $num = \"1000.314\";\r\n  echo (int)$num\r\n  ```\r\n\r\n- 透過運算子將字串轉為數值，例如在字串中 + 0\r\n\r\n### `is_a()` 檢查物件是該類別，或該類別是此物件的父類別(boolean)\r\n\r\n- `is_a( object $object , string $class_name )`\r\n\r\n- 此函數在 php 5 之後已廢棄，改用 `instanceof` 型態運算子\r\n\r\n### `substr()` 取得部分字串，可設定字串長度\r\n\r\n- `substr( $string , $start , $length )`\r\n\r\n- $string 原始的字串\r\n- $start 要開始擷取的位置(須為數字，可為正數或負數)\r\n- $length 要擷取的字串長度(須為數字，可為正數或負數)\r\n\r\n### 轉換字母大小寫\r\n\r\n#### `ucfirst()` 將字串的首字母轉為大寫\r\n\r\n```php\r\n$foo = 'hello world!';\r\n$foo = ucfirst($foo);             // Hello world!\r\n```\r\n\r\n#### `strtolower()` 將字串換為小寫\r\n\r\n```php\r\n$str = \"Mary Had A Little Lamb and She LOVED It So\";\r\n$str = strtolower($str);\r\n// mary had a little lamb and she loved it so\r\n```\r\n\r\n#### `strtoupper()` 將字串換為大寫\r\n\r\n```php\r\n$str = \"Mary Had A Little Lamb and She LOVED It So\";\r\n$str = strtoupper($str);\r\n//  MARY HAD A LITTLE LAMB AND SHE LOVED IT SO\r\n```\r\n\r\n### `define()` 定義一個常數\r\n\r\n- `define(name,value,case_insensitive)`\r\n\r\n- name 必須，規定常數的名稱。通常為全大寫 + 下划線。\r\n- value 必須，規定常數的值。\r\n- case_insensitive 必須，規定常數是否大小寫敏感，預設為 false : 大小寫敏感。\r\n\r\n- 常數類似變數，但常數在設定之後，其值無法改變，常數名不用 `$` 開頭，作用域不影響對常數的存取，其值只能是字串或數值\r\n\r\n## 在 Linux 執行 php 檔\r\n\r\n### 方法一\r\n\r\n- 在程式的第一行加入路徑 -q\r\n\r\n  ```php\r\n  #! /usr/bin/php -q\r\n  $foo = 123;\r\n  ```\r\n\r\n- 將 php 檔賦予執行權限\r\n\r\n  ```bash\r\n  chmod +x testing.php\r\n  ```\r\n\r\n- d/n\r\n\r\n  ```bash\r\n  ./testing.php # 可以像其他 shell script 般執行\r\n  ```\r\n","date":"2023-06-13T09:08:23.989Z","matchingLines":["## 運算子、判斷\r","## Autoload 自動載入\r","## 魔術常數\r","## 魔術方法\r","## 方法\r","## 在 Linux 執行 php 檔\r"]},{"name":"Laravel Test.md","content":"# Laravel Test\r\n\r\n> Laravel 預設支援 PHPUnit 來進行測試\r\n>\r\n> 設定文件 phpunit.xml\r\n>\r\n> 在 test 資料夾中有兩個子資料夾\r\n>\r\n> Feature 功能測試是針對大面積的程式碼進行測試\r\n>\r\n> Unit 單元測試是針對單一方法單獨進行測試\r\n\r\n## 啟動測試\r\n\r\n建立測試文件\r\n\r\n```bash\r\n// 在 feature 資料夾下建立一個測試的 class\r\nphp artisan make:test UserTest\r\n\r\n// 在 unit 資料夾底下鍵立一個測試 class\r\nphp artisan make:test UserTest --unit\r\n```\r\n\r\n```php\r\nnamespace Tests\\Unit;\r\n\r\nuse PHPUnit\\Framework\\TestCase;\r\n\r\nclass ExampleTest extends TestCase\r\n{\r\n    public function testBasicTest()\r\n    {\r\n        $this->assertTrue(true);\r\n    }\r\n}\r\n```\r\n\r\n啟動測試\r\n\r\n```bash\r\nphp artisan test\r\n\r\n// 指定要運行的特定測試類別\r\nphp artisan test --filter ExampleTest\r\n\r\n// 運定特定的測試方法\r\nphp artisan test --filter ExampleTest::testExample\r\n\r\n// 傳遞參數\r\nphp artisan test --testsuite=Feature --stop-on-failure\r\n```\r\n","date":"2023-06-09T06:47:30.828Z","matchingLines":["## 啟動測試\r"]},{"name":"Redis 學習筆記.md","content":"# Redis 學習筆記\r\n\r\n- [Redis 學習筆記](#redis-學習筆記)\r\n  - [redis-cil](#redis-cil)\r\n  - [資料類型](#資料類型)\r\n    - [string](#string)\r\n    - [List](#list)\r\n    - [Set](#set)\r\n    - [Hash](#hash)\r\n    - [Sorted Set](#sorted-set)\r\n  - [redis Key](#redis-key)\r\n  - [Redis GUI](#redis-gui)\r\n  - [windows 安裝 phpredis](#windows-安裝-phpredis)\r\n\r\n## redis-cil\r\n\r\n```bash\r\n# redis-cli -h <host> -p <port>\r\nredis-cli -h 127.0.0.1 -p 6379\r\n```\r\n\r\n## 資料類型\r\n\r\n- redis 支援五種資料類型：\r\n  - string 字串\r\n  - hash 雜湊\r\n  - list 列表\r\n  - set 集合\r\n  - zset 有序集合\r\n\r\n### string\r\n\r\n一個 key 對應一個 value。\r\n\r\n字串類型為二進制，因此 string 可包含任何資料，如 jpg 圖片，或是一個序列化的物件。\r\n\r\nstring 最大可以儲存 512MB\r\n\r\n```redis\r\n# SET key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX]\r\n> SET phone Note10 EX 10          # 10 秒過期\r\n> SET price 23900\r\n\r\n# SETNX key value\r\n# SET if Not Exist，如果該 key 不存在才儲存\r\n> SETNX frameworks \"react vue angular\" # 回傳 1 表示成功，0 表示失敗（該 key 已經存在）\r\n\r\n# SETEX key seconds value  # 設定過期時間\r\n\r\n# 增加或減少數值\r\n> INCR price               # 23901，一次增加 1\r\n> DECR price               # 23900，一次減少 1\r\n> INCRBY price 1000        # 24900，一次增加 1000\r\n> DECRBY price 1000        # 23900，一次減少 1000\r\n```\r\n\r\n### List\r\n\r\n由於 Lists 本質上是 linked-list 的緣故，它在新增和刪除元素的速度是快的，但搜尋速度是相對慢的。可以使用 RPUSH 和 LPUSH 來新增元素，如果該 key 尚不存在的話，會回傳新的 List，如果該 key 已經存在，或它不是 List 的話，則會回傳錯誤。\r\n\r\n- 有順序性\r\n- 新增刪除速度相對快：適合用在只要取出頭尾元素的情況(ex: Quene)\r\n- 搜尋速度相對慢\r\n- 適用時機\r\n  - Message Quene: 只需取出頭尾的元素，不需要搜尋\r\n\r\n```redis\r\n# 在 List 中新增元素\r\n# RPUSH <key> <element> [element ...] / LPUSH <key> <element> [element ...]\r\n> RPUSH frameworks react vue angular  # 3\r\n> LPUSH frameworks svelte             # 4\r\n\r\n# 檢視 List 中的元素\r\n# LRANGE <key> <start> <stop>\r\n> LRANGE frameworks 0 -1  # 列出所有元素，-1 表示 list 中的最後一個元素\r\n\r\n# 檢視 List 數目\r\n# LLEN <key>\r\n> LLEN frameworks\r\n\r\n# 移除 list 中的元素\r\n# RPOP <key> / LPOP <key>\r\n> RPOP frameworks         # 移除 list 最後一個元素\r\n> LPOP frameworks\r\n```\r\n\r\n### Set\r\n\r\n由多個 redis 中的 string 以無序的方式所組成，其保證內部不會有重複的元素，此外 Redis 提供了多個 Set 之間交集、差集與聯集的操作。\r\n\r\n- 使用時機：\r\n\r\n  - 記錄每一個造訪的 ip\r\n  - 商品標籤\r\n\r\n- Set 的基礎操作\r\n  - CRUD: SADD SREM SMEMBERS SCARD SPOP\r\n  - 集合操作: SDIFF SINTER SUNION\r\n\r\n```redis\r\n# SADD <key> <member> [member ...]   # 新增元素到 Set 中\r\n> SADD languages english             # 1，新增的元素數目\r\n> SADD languages frensh chinese      # 2，新增的元素數目\r\n> SADD languages english             # 0，如果元素已經在該 Sets 中，會回傳 0\r\n\r\n# SREM <key> <member> [member...]     # 從 Set 中移除元素\r\n> SREM languages english              # 1，移除的元素數目\r\n\r\n# SMEMBERS <key>                      # 檢視 Set 中所有元素\r\n> SMEMBERS languages                  # 回傳的元素沒有順序性\r\n\r\n# SISMEMBER <key> <member>            # 檢視元素是否存在該 Set 中\r\n> SISMEMBER languages chinese         # 1，存在的話回傳 1，不存在則回傳 0\r\n\r\n# SUNION <key> [key...]               # 合併多個 Sets\r\n> SUNION languages programming-languages\r\n127.0.0.1:6379> SMEMBERS bike\r\n1) \"green\"\r\n2) \"white\"\r\n3) \"black\"\r\n4) \"red\"\r\n127.0.0.1:6379> SUNION car\r\n1) \"green\"\r\n2) \"yellow\"\r\n3) \"red\"\r\n127.0.0.1:6379> SUNION car bike\r\n1) \"yellow\"\r\n2) \"red\"\r\n3) \"white\"\r\n4) \"black\"\r\n5) \"green\"\r\n```\r\n\r\n### Hash\r\n\r\n為 key-value 的資料類型，也是 Redis 的主結構，非常適合用於儲存物件型資料，例如 User 物件有姓名、年齡、信箱等。當物件非常小時，Hash 會將資料壓縮後儲存，因此單台 redis 可以儲存數百萬個小物件。\r\n\r\n- Hash 的基礎操作\r\n  - CRUD: HSET HGET HDEL\r\n  - 多欄位讀: HGETALL HKEYS HMGET\r\n\r\n```redis\r\n# HSET <key> <field> <value> [field value...]   # 新增 field-value pairs 到 Hash 中\r\n> HSET phone name \"iphone\"       # 1，新增的數目\r\n> HSET phone price 22500     # 1，新增的數目\r\n> HSET phone name \"iphone mini\"  # 0，表示該 field 已經存在 hash 中，將會「更新」其 value\r\n\r\n# HGET <key> <field>             # 取得 field 的 value\r\n> HGET phone name                # \"iphone mini\"\r\n\r\n# HGETALL <key>                  # 取得所該 hash 對所有值\r\n> HGETALL phone\r\n\r\n# HMSET <key> <field> <value> [field value...]  # 和 HSET 相同\r\n# HMGET <key> <field> [field...]    # 一次取出多個 field 的值\r\n> HMGET phone name priceHSET\r\n```\r\n\r\n### Sorted Set\r\n\r\n為有序的 Set，其順序會依照傳入的權重值排序，在查找資料時，可使用 binary search，因此查找效率高。由於 Sorted Set 的高效能查詢，Sorted Set 可當做一組 Hash 資料的 index，將物件 id 以及 index field 儲存在 Sort Set，單筆物件的完整資料儲存在 Hash。\r\n\r\n- 有順序性，透過 `score` 產生連結來達到排序的作用，`score` 本身會是 `float`\r\n- 元素值仍然是唯一，但 `score` 可以不是唯一\r\n- 不論是 Add, Remove 或是 update 速度都很快，可以同時快速搜學中間的項目\r\n- 可以視為 `set` 和 `hash` 的混合\r\n- 使用上指令和 `set` 相似，只要將最開頭的 `S` 改成 `Z`\r\n- 使用時機\r\n\r\n  - 遊戲的計分板\r\n\r\n- Sorted Set 的基礎操作\r\n\r\n  - CRUD: ZADD ZRANGE ZREM\r\n  - Rank 操作: ZRANK 找元素位置，ZSCORE 設定元素權重值\r\n\r\n- option\r\n  - XX: 只更新存在的成員，不添加新成員\r\n  - NX: 不更新存在的成員，只添加新成員\r\n  - CN: 修改返回值為發生變化的成員總數，原始是返回新添加成員的總數(CH 為 change 的縮寫)。更改的元素是新增加的成員，已經存在的成員更新分數。所以在命令中指定的成員有相同的分數將不被計算在內。一般而言，ZADD 只會返回新增成員的數量\r\n  - INCR: 當 ZADD 指定這個選項時，成員的做就等同 ZINCRBY 命令，對成員的分數進行遞增操作。\r\n\r\n```redis\r\n# ZADD <key> [NX|XX] [CH] [INCR] <score> <member> [score member ...]，新增 sorted Set\r\n> ZADD students 1 aaron                  # 1\r\n> ZADD students 2 allison         # 1\r\n> ZADD students 3 bruce 4 derek          # 2\r\n\r\n# XX：只更新已存在的 member 的 score，絕不新增 member\r\n# NX：不更新已存在的 member 的 score，總是新增 member\r\n> ZADD students XX 10 aaron    # 如果 aaron 存在，則將 score 更新為 10\r\n> ZADD students NX 777 jen     # 如果 jen 不存在，則新增且將 score 設為 777\r\n\r\n# ZRANGE <key> <start> <stop> [WITHSCORES]，檢視 sorted set\r\n> ZRANGE students 0 -1                   # 檢視 sorted set 中所有元素\r\n\r\n# ZCARD <key>，檢視該 set 中的元素數目\r\n> ZCARD students\r\n\r\n# ZCOUNT <key> <min> <max>     # 檢視分數介於 min ~ max 間的元素拭目\r\n> ZCOUNT students 0 10\r\n\r\n# ZSCORE <key> <member>        # 檢視某 member 的 score\r\n> ZSCORE students aaron\r\n\r\n# ZINCRBY <key> <increment> <member>    # 幫 member 的 score 分數增加\r\n> ZINCRBY students 10 aaron             # 幫 aaron 的 score 加 10\r\n```\r\n\r\n## redis Key\r\n\r\n| 指令                                      | 描述                                      |\r\n| ----------------------------------------- | ----------------------------------------- |\r\n| DEL key                                   | 當 key 存在時，將其刪除                   |\r\n| DUMP key                                  | 序列化傳入的 key，並回傳被序列化的值      |\r\n| EXISTS key                                | 檢查傳入的 key 是否存在                   |\r\n| EXPIRE key seconds                        | 為傳入的 key 設定過期時間，以秒計         |\r\n| EXPIREAT key timestamp                    | 設定過期時間，接受 UNIX 時間戳 為時間參數 |\r\n| PEXPIRE key milliseconds                  | 設置過期時間以毫秒計                      |\r\n| PEXPIREAT key milliseconds-timestamp      | 設置過期時間的時間戳以毫秒計              |\r\n| KEYS pattern                              | 查找所有符合傳入模式 (pattem) 的 key      |\r\n| MOVE key db                               | 將目前資料庫中 key 移動到指定的資料庫中   |\r\n| PERSIST key                               | 移除 key 的過期時間，key 將永久保存       |\r\n| PTTL key                                  | 以毫秒為單位，回傳 key 剩餘的過期時間     |\r\n| TTL key                                   | 以秒為單位，回傳 key 剩餘的過期時間       |\r\n| RANDOMKEY                                 | 從資料庫中，隨機回傳一個 key              |\r\n| RENAME key newkey                         | 修改 key 的名稱                           |\r\n| RENAMENX key newkey                       | 當 newkey 不存在時，將 key 改名為 newkey  |\r\n| SCAN cursor [MATCH pattern] [COUNT count] | 迭代資料庫中的資料庫鍵                    |\r\n| TYPE key                                  | 返回 key 所儲存的值的類型                 |\r\n\r\n## Redis GUI\r\n\r\n> [Another Redis Desktop Manager](https://github.com/qishibo/AnotherRedisDesktopManager/)\r\n>\r\n> [[Tool] Redis 管理工具 - Another Redis Desktop Manager](https://marcus116.blogspot.com/2020/04/tool-redis-another-redis-desktop-manager.html)\r\n\r\n## windows 安裝 phpredis\r\n\r\n> 下載 phpredis 需要對應 php 的版本\r\n>\r\n> PHP Version `7.4.29`\r\n>\r\n> Architecture: `x64`\r\n>\r\n> PHP Extension Build: API20190902,`TS`,`VC15`\r\n\r\n[windows phpredis](https://windows.php.net/downloads/pecl/releases/redis/)\r\n\r\n5.3.7 -> php_redis-`5.3.7-7.4`-`ts-vc15`-`x64`.zip\r\n\r\n將下載的檔案解壓縮後，將資料夾內 `php_redis.dll` 和 `php_redis.pdb` 複製到 php 的擴充套件 `ext` 目錄之下\r\n\r\n最後在 php.ini 檔案中，加入兩行程式碼(注意順序)\r\n\r\n```txt\r\nextension=php_igbinary.dll\r\nextension=php_redis.dll\r\n```\r\n\r\n最後在 phpinfo 中檢查 php-redis 是否安裝成功\r\n","date":"2023-06-01T06:19:06.784Z","matchingLines":["## redis-cil\r","## 資料類型\r","## redis Key\r","## Redis GUI\r","## windows 安裝 phpredis\r"]},{"name":"Laravel Excel.md","content":"# Laravel Excel\r\n\r\n> 使用套件：\r\n>\r\n> - maatwebsite/Excel 3.1\r\n>\r\n> 環境要求：\r\n>\r\n> - PHP `^7.0`\r\n>\r\n> - Laravel `^5.5`\r\n>\r\n> 參考資料：\r\n>\r\n> - [maatwebsite/Excel 3.1 使用教程 （导入篇）](https://learnku.com/articles/32400)\r\n>\r\n> - [maatwebsite/Excel 3.1 使用教程 （导出篇）](https://learnku.com/articles/32391)\r\n\r\n## 安裝\r\n\r\n```bash\r\ncomposer require maatwebsite/excel\r\n```\r\n\r\n## excel 匯出\r\n\r\n建立匯出文件，匯入匯出的業務盡量不要和原來的業務耦合\r\n\r\n```bash\r\nphp artisan make:export UserExport --model=User\r\n```\r\n\r\n在 app 目錄下建立 Export 資料夾\r\n\r\n- UserExport.php\r\n\r\n```php\r\nnamespace App\\Exports;\r\n\r\nuse App\\User;\r\nuse Maatwebsite\\Excel\\Concerns\\FromCollection;\r\n\r\nclass UsersExport implements FromCollection\r\n{\r\n    protected $data;\r\n\r\n    public function __construct($data)\r\n    {\r\n        $this->data = $data;\r\n    }\r\n\r\n    // 陣列轉集合\r\n    public function collection()\r\n    {\r\n        return new Collection($this->createData());\r\n    }\r\n\r\n    // 商業邏輯\r\n    public function createData()\r\n    {\r\n      // to-do\r\n    }\r\n}\r\n```\r\n\r\n- UserController.php\r\n\r\n```php\r\nuse App\\Exports\\UsersExport;\r\nuse Maatwebsite\\Excel\\Facades\\Excel;\r\nuse App\\Http\\Controllers\\Controller;\r\n\r\nclass UsersController extends Controller\r\n{\r\n    public function export()\r\n    {\r\n        return Excel::download(new UsersExport, 'users.xlsx');\r\n    }\r\n}\r\n```\r\n\r\n### 欄位格式化：設定儲存格格式\r\n\r\n```php\r\nuse PhpOffice\\PhpSpreadsheet\\Style\\NumberFormat;\r\nuse Maatwebsite\\Excel\\Concerns\\WithColumnFormatting;\r\n\r\n// 新增 WithColumnFormatting\r\nclass UsersExport implements FromCollection, WithColumnFormatting\r\n{\r\n    public function columnFormats(): array\r\n    {\r\n        return [\r\n            'B' => NumberFormat::FORMAT_DATE_DDMMYYYY, // 日期\r\n            'C' => NumberFormat::FORMAT_NUMBER_00, // 取到小數點第二位\r\n        ];\r\n    }\r\n}\r\n```\r\n\r\n### 自動欄寬\r\n\r\n```php\r\nuse Maatwebsite\\Excel\\Concerns\\ShouldAutoSize;\r\n\r\n// 新增 ShouldAutoSize\r\nclass UsersExport implements FromCollection, ShouldAutoSize\r\n```\r\n\r\n### 匯出多個工作表(sheet)\r\n\r\n匯出多個表需要兩步驟，先組裝 sheet，後建立對應的 sheet 表。\r\n\r\n```php\r\nuse Maatwebsite\\Excel\\Concerns\\Exportable;\r\nuse Maatwebsite\\Excel\\Concerns\\WithMultipleSheets;\r\n\r\n// 新增 WithMultipleSheets\r\nclass UsersExport implements WithMultipleSheets\r\n{\r\n    use Exportable;\r\n\r\n    protected $year;\r\n\r\n    public function __construct(int $year)\r\n    {\r\n        $this->year = $year;\r\n    }\r\n\r\n    /**\r\n     * @return array\r\n     */\r\n    public function sheets(): array\r\n    {\r\n        $sheets = [];\r\n\r\n        for ($month = 1; $month <= 12; $month++) {\r\n            // 不同的資料可以呼叫不同的方法\r\n            $sheets[] = new UserPerMonthSheet($this->year, $month);\r\n        }\r\n\r\n        return $sheets;\r\n    }\r\n}\r\n```\r\n\r\n然後新增 UserPerMonthSheet Class\r\n\r\n```php\r\nnamespace App\\Exports;\r\n\r\nuse Maatwebsite\\Excel\\Concerns\\FromQuery;\r\nuse Maatwebsite\\Excel\\Concerns\\WithTitle;\r\n\r\nclass UserPerMonthSheet implements FromQuery, WithTitle\r\n{\r\n    private $month;\r\n    private $year;\r\n\r\n    public function __construct(int $year, int $month)\r\n    {\r\n        $this->month = $month;\r\n        $this->year  = $year;\r\n    }\r\n\r\n    /**\r\n     * @return Builder\r\n     */\r\n    public function query()\r\n    {\r\n        return User\r\n            ::query()\r\n            ->whereYear('created_at', $this->year)\r\n            ->whereMonth('created_at', $this->month);\r\n    }\r\n\r\n    /**\r\n     * sheet 工作表名稱\r\n     * @return string\r\n     */\r\n    public function title(): string\r\n    {\r\n        return 'Month ' . $this->month;\r\n    }\r\n}\r\n```\r\n\r\n### 事件模組：設定儲存格高度、垂直置中、字體顏色、背景顏色\r\n\r\n提供多種事件：BeforeExport, BeforeWriting, BeforeSheet, AfterSheet 等等，修改儲存格使用 AfterSheet\r\n\r\n```php\r\nnamespace App\\Exports;\r\n\r\nuse Maatwebsite\\Excel\\Concerns\\WithEvents;\r\nuse Maatwebsite\\Excel\\Events\\BeforeExport;\r\nuse Maatwebsite\\Excel\\Events\\BeforeWriting;\r\nuse Maatwebsite\\Excel\\Events\\BeforeSheet;\r\n\r\nclass UserExport implements WithEvents\r\n{\r\n    /**\r\n     * 註冊事件\r\n     * @return array\r\n     */\r\n    public function registerEvents(): array\r\n    {\r\n        return [\r\n            AfterSheet::class  => function(AfterSheet $event) {\r\n                // 作者\r\n                $event->writer->setCreator('Patrick');\r\n                // 列寬\r\n                $event->sheet->getDelegate()->getColumnDimension('A')->setWidth(50);\r\n                // 行高，$i 為資料行數\r\n                for ($i = 0; $i<=1265; $i++) {\r\n                    $event->sheet->getDelegate()->getRowDimension($i)->setRowHeight(50);\r\n                }\r\n                // 垂直置中\r\n                $event->sheet->getDelegate()->getStyle('A1:K1265')->getAlignment()->setVertical('center');\r\n                // 字體、顏色、背景，詳細設定查看 applyFromArray 方法\r\n                $event->sheet->getDelegate()->getStyle('A1:K6')->applyFromArray([\r\n                    'font' => [\r\n                        'name' => 'Arial',\r\n                        'bold' => true,\r\n                        'italic' => false,\r\n                        'strikethrough' => false,\r\n                        'color' => [\r\n                            'rgb' => '808080'\r\n                        ]\r\n                    ],\r\n                    'fill' => [\r\n                        'fillType' => 'linear', // 漸層效果\r\n                        'rotation' => 45, // 漸層角度\r\n                        'startColor' => [\r\n                            'rgb' => '000000' // 起始顏色\r\n                        ],\r\n                        // 結束顏色\r\n                        'endColor' => [\r\n                            'argb' => 'FFFFFF'\r\n                        ]\r\n                    ]\r\n                ]);\r\n                // 合併儲存格 mergeCells('A1:B1')\r\n                $event->sheet->getDelegate()->mergeCells('A1:B1');\r\n            }\r\n        ];\r\n    }\r\n}\r\n```\r\n\r\n### 搭配 vue 前端\r\n\r\n> 參考資料\r\n>\r\n> [Day17 使用 Laravel Excel 來匯出資料](https://ithelp.ithome.com.tw/articles/10302013)\r\n\r\n## excel 匯入\r\n","date":"2023-05-25T08:50:35.608Z","matchingLines":["## 安裝\r","## excel 匯出\r","## excel 匯入\r"]},{"name":"Postman 學習筆記.md","content":"# [Postman 學習筆記](https://tw.alphacamp.co/blog/postman-api-tutorial-for-beginners)\r\n\r\n## 參數區介紹\r\n\r\n### Params 網址參數頁\r\n\r\n設定 Query Params 搜尋參數 Path Variables 路徑變數\r\n\r\n- 預設只有 Query Params 搜尋參數，Path Variable 路徑變數，需要自行在網址上打上冒號＋變數名 (ex. \" : name \" )，才會出現\r\n- 設定方式都是採 Key - value ，可以根據情況彈性勾選\r\n\r\n### Authorization 驗證設定頁\r\n\r\n用來設定 Header 中的 Authorization 參數\r\n\r\n- No Auth | 不需要驗證\r\n- Basic Auth ｜帳號，密碼型驗證\r\n- token 驗證 ｜ token 型驗證\r\n\r\n### Header\r\n\r\n用來設定 Header 中的其他參數\r\n\r\npostman 把一些必要的參數隱藏起來，如需特殊設定，可以取消隱藏，進行修改。\r\n\r\n- User-Agent | 告知 Server，發出 Request 的 Client 瀏覽器、作業系統等資訊\r\n- Accept ｜告知 Server，Client 可以解讀的內容類型\r\n- Content-type | 告知 Server，Client 提交什麼類型內容\r\n\r\n### body\r\n\r\n較常用的是 form-data, x-www-form-urlencoded, raw，前兩者都是送出表單資料，最後一個提供較多彈性的資料格式。\r\n\r\n- form-data 不會針對內容進行編碼，可選擇 file 類型進行上傳檔案\r\n- x-www-form-urlencoded 會以 Key = val1 進行編碼，一般的表單資料使用\r\n- raw 放 postman JSON 資料\r\n\r\n## Laravel CSRF\r\n\r\n### 原因\r\n\r\n當使用 postman 發出 post 請求時，laravel 回傳 419 | expired\r\n\r\nlaravel 會透過應用程式自動產生一個 CSRF token 來管理每一個使用者的 session。\r\n\r\n這個 token 用於驗證已認證使用者，是否實際向應用程式發出請求。\r\n\r\n在`vender/laravel/framework/src/Illuminate/Session/Store.php`中可以看到，每次進入 laravel 專案的時候，都會檢查 session 中\\_token 是否存在，若不存在就會呼叫 `regenerateToken` 重新生成一個 token。\r\n\r\n```php\r\npublic function start()\r\n{\r\n    $this->loadSession();\r\n    if (! $this->has('_token')) {\r\n        $this->regenerateToken();\r\n    }\r\n\r\n    return $this->started = true;\r\n}\r\n```\r\n\r\n`regenerateToken` 實作，隨機產生亂數字元。\r\n\r\n```php\r\npublic function regenerateToken()\r\n{\r\n    $this->put('_token', Str::random(40));\r\n}\r\n```\r\n\r\n### postman 添加校驗 token\r\n\r\n先進入網站首頁取得 token\r\n\r\n將 token 放入 post request 的 header， X-XSRF-TOKEN 的欄位中。\r\n\r\n### 撰寫 javascript 自動獲取 token\r\n\r\n在進入網站首頁的 API 的 test 中，加入以下程式，以自動獲取 token。\r\n\r\n```php\r\npm.environment.set(\r\n    \"XSRF-TOKEN\",\r\n    decodeURIComponent(pm.cookies.get(\"XSRF-TOKEN\"))\r\n)\r\n```\r\n\r\n接著在 post 的 request 中的 header 加入 `X-XSRF-TOKEN:{{XSRF-TOKEN}}`\r\n\r\n## Postman 壓力測試(串行處理)\r\n\r\n在要測試的 request test 中定義測試的程式碼\r\n\r\n```javascript\r\n// 檢查 api 是否返回 200 status code\r\npm.test(\"Status code is 200\", function () {\r\n  console.log(JSON.parse(responseBody));\r\n  pm.response.to.have.status(200);\r\n});\r\n```\r\n\r\n開啟 Runner 選擇要測試的 api\r\n\r\n選擇 environment，調整請求次數: iterations，調整延遲時間：Delay\r\n\r\n## http status\r\n\r\n- 資訊回應 (informational responses) 100 - 199\r\n- 成功回應 (Successful responses) 200 - 299\r\n- 重定向 (Redirect) 300 - 399\r\n- 用戶端錯誤 (Client errors) 400 - 499\r\n- 伺服器端錯誤 (Server error) 500-599\r\n\r\n## postman 無法開啟 collection\r\n\r\n1. 將 postman 解除安裝\r\n2. 刪除 C:\\Users\\AppData\\Local\\Postman\r\n3. 刪除 C:\\Users\\AppData\\Roaming\\Postman\r\n4. 下載最新版本的 postman\r\n","date":"2023-05-15T03:40:34.420Z","matchingLines":["## 參數區介紹\r","## Laravel CSRF\r","## Postman 壓力測試(串行處理)\r","## http status\r","## postman 無法開啟 collection\r"]},{"name":"MySQL學習筆記.md","content":"# MySQL 學習筆記\r\n\r\n- [MySQL 學習筆記](#mysql-學習筆記)\r\n  - [環境設定](#環境設定)\r\n    - [設定時區](#設定時區)\r\n    - [MariaDB 設定命名時區](#mariadb-設定命名時區)\r\n      - [從 zoneinfo 匯入時區](#從-zoneinfo-匯入時區)\r\n      - [從 mysql 提供的指令碼匯入](#從-mysql-提供的指令碼匯入)\r\n  - [資料表語法](#資料表語法)\r\n  - [資料型態](#資料型態)\r\n  - [DB 命名原則](#db-命名原則)\r\n    - [資料庫命名](#資料庫命名)\r\n    - [資料表命名](#資料表命名)\r\n    - [欄位命名](#欄位命名)\r\n    - [索引命名](#索引命名)\r\n      - [外鍵索引](#外鍵索引)\r\n  - [Function](#function)\r\n    - [CONVERT\\_TZ(dt,from\\_tz,to\\_tz) 轉換時區](#convert_tzdtfrom_tzto_tz-轉換時區)\r\n    - [Event 事件](#event-事件)\r\n      - [範例](#範例)\r\n      - [基本使用](#基本使用)\r\n  - [使用情境](#使用情境)\r\n    - [外鍵 onDelete 約束情況](#外鍵-ondelete-約束情況)\r\n    - [ERROR: #1215 - Cannot add foreign key constraint](#error-1215---cannot-add-foreign-key-constraint)\r\n    - [刪除重複的資料](#刪除重複的資料)\r\n      - [使用 `DISTINCT` 去除重複值](#使用-distinct-去除重複值)\r\n    - [匯入 txt 檔](#匯入-txt-檔)\r\n    - [複合主鍵與聯合主鍵，索引與聯合(複合)索引](#複合主鍵與聯合主鍵索引與聯合複合索引)\r\n      - [複合主鍵與聯合主鍵](#複合主鍵與聯合主鍵)\r\n      - [索引、聯合(複合)索引](#索引聯合複合索引)\r\n\r\n## 環境設定\r\n\r\n### 設定時區\r\n\r\n- `show variables like '%time_zone%'` 查看當前時區\r\n  - 會返回兩行紀錄，第一行為 system_time_zone(系統時區)，第二行為 time_zone(資料庫時區)\r\n- `set time_zone='+8:00'` 設置當前請求的時區\r\n  - 不須重新連接 mysql\r\n  - 僅當前的請求有效，若關閉則回復原始值。\r\n- `set global time_zone='+8:00` 設定全域時區\r\n  - 全域請求有效，但必須重新連接 mysql 才會生效(exit 後重新 mysql -uroot -p 進行連接)。\r\n  - 不須重啟 mysql，重啟後回復原始值\r\n- 修改 mysql 設定文件\r\n  - 在 my.ini 中添加\r\n  - 須重啟 mysql\r\n\r\n```ini\r\n[mysqld]\r\ndefault-time-zone=+00:00\r\ncharacter-set-server=utf8mb4\r\n```\r\n\r\n### MariaDB 設定命名時區\r\n\r\n命名時區是指使用時區的名字，而不是標準時間的小時差。例如 `Asia/Taipei` 就是命名時區，而不是 +08:00。\r\n在 MariaDB 中域設有時區表，但預設為空，需要填充這些表後才能使用。\r\n\r\n#### 從 zoneinfo 匯入時區\r\n\r\n若系統環境為類 Unix 系統(Mac OS, Linux, FreeBSD, Sun Solaris)，zoneinfo 文件已經包含在系統中。\r\n輸入指令將時區表加入 MariaDB 中的 MySQL 資料庫中\r\n\r\n```bash\r\nmysql_tzinfo_to_sql /usr/share/zoneinfo | mariadb -u root -p mysql\r\n&\r\nmysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root -p mysql\r\n```\r\n\r\n#### 從 mysql 提供的指令碼匯入\r\n\r\n由於 windows 沒有 zoneinfo 資料庫，所以必須透過 sql 指令碼匯入時區表\r\n\r\n- 下載 sql 指令碼並解壓縮：[https://downloads.mysql.com/general/timezone_2022g_posix_sql.zip](https://downloads.mysql.com/general/timezone_2022g_posix_sql.zip)\r\n- 登入 mariaDB\r\n\r\n```bash\r\n.\\mysql.exe -u root -p\r\n# 輸入 root 使用者密碼\r\n```\r\n\r\n- 連接 MySQL 資料庫\r\n\r\n```bash\r\nUSE mysql\r\n```\r\n\r\n- 從 SQL 指令碼匯入資料\r\n\r\n```bash\r\nSOURCE C:\\Users\\Adam\\Downloads\\timezone_posix.sql\r\n```\r\n\r\n- 檢查是否正確匯入\r\n\r\n```bash\r\nSELECT * FROM mysql.time_zone_name;\r\n```\r\n\r\n```output\r\n+----------------------------------+--------------+\r\n| Name                             | Time_zone_id |\r\n+----------------------------------+--------------+\r\n| Africa/Abidjan                   |            1 |\r\n| Africa/Accra                     |            2 |\r\n| Africa/Addis_Ababa               |            3 |\r\n| Africa/Algiers                   |            4 |\r\n| Africa/Asmara                    |            5 |\r\n| Africa/Asmera                    |            6 |\r\n| Africa/Bamako                    |            7 |\r\n| Africa/Bangui                    |            8 |\r\n| Africa/Banjul                    |            9 |\r\n| Africa/Bissau                    |           10 |\r\n...\r\n...\r\n| Zulu                             |          597 |\r\n+----------------------------------+--------------+\r\n597 rows in set (0.000 sec)\r\n```\r\n\r\n## 資料表語法\r\n\r\n- 建立資料表\r\n\r\n  ```sql\r\n  CREATE TABLE 資料表名稱 (\r\n    欄位名稱  資料型態,\r\n    ...\r\n  )\r\n  ```\r\n\r\n- 增加資料表欄位\r\n\r\n  ```sql\r\n  ALTER TABLE 資料表 ADD 欄位名稱 資料型態;\r\n  ```\r\n\r\n- 增加資料表內容\r\n\r\n  ```sql\r\n  INSERT INTO 資料表 (欄位1, 欄位2, 欄位3, ...)\r\n  VALUES (值1,  值2,  值3, ...);\r\n  ```\r\n\r\n- 更新資料欄位\r\n\r\n  ```sql\r\n  UPDATE 資料表 SET 欄位1 = '資料1', 欄位2 = '資料2' WHERE 條件;\r\n  ```\r\n\r\n- 刪除資料欄位\r\n\r\n  ```sql\r\n  delete from 資料表 where 欄位 = ;\r\n  truncate table 資料表;\r\n  drop table 資料表\r\n\r\n  -- 刪除外鍵欄位\r\n  ALTER TABLE 資料表 DROP FOREIGN KEY FK_欄位 ; -- 先刪除外鍵名稱\r\n  ALTER TABLE 資料表 DROP `欄位`;               --  才能刪除欄位\r\n  ```\r\n\r\n- 選擇欄位\r\n\r\n  ```sql\r\n      SELECT 別名.欄位,\r\n      DISTINCT 別名.欄位          -- 欄位資料不重複\r\n      CONCAT(別名.欄位, 別名.欄位) -- 欄位合併\r\n      FROM 資料表 as 別名         -- 別名\r\n\r\n      join 資料表B on 資料表別名.欄位 = 資料表B別名.欄位\r\n\r\n      WHERE 別名.欄位 = \"內容\" AND 別名.欄位 = 內容  -- ...而且...\r\n      WHERE (別名.欄位 = \"內容\" OR 別名.欄位 = 內容) -- (..或者..)\r\n                                                  -- OR的前後要加上括弧，將條件限制住\r\n      WHERE 別名.欄位 LIKE \"%內容%\"                 -- 內容部分有符合者\r\n      WHERE 別名.欄位 BETWEEN 起始 and 結束         -- 連續不間段的區間\r\n      WHERE 別名.欄位 in (內容, 內容)               -- 挑選同一型態指定內容\r\n\r\n      GROUP BY                -- 相同的東西記錄在一起\r\n      HAVING                  -- 接在 GROUP BY 之後設定條件\r\n      UNION\r\n      ORDER BY 別名.欄位       -- 排序(預設由小到大)\r\n      ORDER BY 別名.欄位 DESC  -- 排序由大到小\r\n      LIMIT 起始位置, 資料筆數; -- 選擇資料中要顯示的項目\r\n  ```\r\n\r\n- 使用者定義變數\r\n\r\n  ```sql\r\n  SELECT @x; --> x值為NULL\r\n\r\n  SET @x = 1;\r\n  SELECT @x, ProductID  FROM Products;\r\n  ```\r\n\r\n- 子查詢:查詢裡面有查詢\r\n\r\n  ```sql\r\n  --> 檢查資料表302中的 ProductID，不存在於資料表301 的 ProductID\r\n  SELECT * FROM lab302\r\n  WHERE ProductID NOT in (SELECT ProductID FROM lab301)\r\n  ```\r\n\r\n- inner join | left join | right join | cross join\r\n\r\n  ```sql\r\n  -- 結合兩個表中某欄位具有相同資料，一起列出查詢結果\r\n  inner join\r\n  -- 列出左/右邊的表，另一邊的表列出有相同的部分，不足的欄位印出NULL\r\n  left join | right join\r\n  -- 將所有可能的組合通通列出來(交叉查詢)\r\n  cross join\r\n  ```\r\n\r\n## 資料型態\r\n\r\n- 字串類型\r\n\r\n  - `char()` 與 `varchar()` 的空間大小是以後面參數來表示欄位的大小，不同的地方在於`varchar()` 是以動態的方式儲存。\r\n\r\n    ```sql\r\n    char(10) = \"hello     \" -- 10 bytes  包含了五個空格\r\n    varchar(10) = \"hello\"   -- 5 bytes\r\n    ```\r\n\r\n  - `char()` 固定大小浪費空間，但是所需的計算時間少。\r\n  - `varchar()` 不固定長度，但是每一次抓取都要運算，花費 CPU 運算時間\r\n\r\n- 數值類型\r\n\r\n  |    type     | storage(bytes) |          signed          |    unsigned    |\r\n  | :---------: | :------------: | :----------------------: | :------------: |\r\n  |  `TINYINT`  |       1        |        -128 ~ 127        |    0 ~ 225     |\r\n  | `SMALLINT`  |       2        |      -32768 ~ 32767      |   0 ~ 65535    |\r\n  | `MEDIUMINT` |       3        |    -8388608 ~ 8388607    |  0 ~ 16777215  |\r\n  |    `int`    |       4        | -2147483648 ~ 2147483647 | 0 ~ 4294967295 |\r\n  |  `BIGINT`   |       8        |  $-2^{63}$ ~ $2^{63}-1$  | 0 ~ $2^{64}-1$ |\r\n\r\n- `DECIMAL(x, y)` : x = 數值長度(包含小數點)，y = 小數點後的位數(不足補零)\r\n\r\n- 時間類型\r\n\r\n  - `YEAR` : YYYY\r\n  - `TIME` : HH:MM:SS\r\n  - `DATE` : YYYY-MM-DD\r\n  - `DATETIM`E : YYYY-MM-DD HH:MM:SS\r\n\r\n- 鍵名\r\n\r\n  - `primary key` 主索引鍵(主鍵)\r\n  - `foreign key` 外部索引鍵(外來鍵)\r\n  - `UNIQUE` 唯一 不能有重複的資料\r\n  - `_INCREMENT` 流水號\r\n  - `DEFAULT =` 預設值\r\n  - `CHECK ()` 資料寫入前的檢查(預設標準)\r\n\r\n- functions | method | 方法 | 函式 | 副程式 | 函數\r\n\r\n  - `count()` : 計算數量\r\n  - `MAX()` : 找最大的那一個\r\n  - `AVG()` : 平均值\r\n  - `ABS()` : 取絕對值\r\n  - `ROUND()` : 小數點四捨五入\r\n\r\n  ***\r\n\r\n  - 取得現在時間\r\n    - `CURRENT_DATE()`\r\n    - `SYSDATE()`\r\n    - `NOW()`\r\n\r\n  ***\r\n\r\n  - `Year()` : 年\r\n\r\n  - `Month()` : 月\r\n\r\n  - `DAY()` : 日\r\n\r\n  - `LENGTH()` : 資料的大小 bytes\r\n\r\n  - `CHAR_LENGTH(`) : 字串的長度\r\n\r\n  ***\r\n\r\n  - `POWER(數值, N次方)` : 計算次方\r\n\r\n  - `SUBSTRING(欄位, 起始位置, 擷取長度)` : 擷取字串\r\n\r\n  - `INSTR(欄位, '指定的文字')` : 找出指定位置的位置，回傳數值\r\n\r\n  - `LEFT(欄位, 擷取長度)` : 從左邊開始擷取到指定長度\r\n\r\n  - `REPLACE(目標欄位, '目標字串', '要取代上字串')` :取代指定字元\r\n\r\n  - `RPAD(內容, 內容的長度, '取代的字')` : 內容不足或是超過的部分會被取代\r\n\r\n  - `REPEAT('要重複的字', 重複次數)` :重複輸入\r\n\r\n  ***\r\n\r\n  - 將字串轉換型態\r\n    - `CONVERT('字串', 型態)`\r\n    - `CAST('字串' AS 型態)`\r\n\r\n  ***\r\n\r\n  - `DATE_FORMAT(日期, \"%Y\")` :日期格式，取得日期中的項目\r\n\r\n  ***\r\n\r\n  - `IF(判斷條件, \"條件為T\", \"條件為F\")` :條件判斷為 true 返回 1，否則返回 2\r\n\r\n  - `ELT(數值、清單, '值1', '值2'......'值n')` :透過數值清單傳回指定之索引的項目\r\n\r\n  - `IFNULL(x, y)` : 如果 x 有值回傳 x，如果 x 為 NULL 回傳 y\r\n\r\n  - `ISNULL(x)` : 如果 x 為 NULL，ISNULL(x)會回傳 1，否則回傳 0\r\n\r\n  - `NULLIF(x, y)` : 如果 x = y 回傳 NULL，否則回傳 x\r\n\r\n  ***\r\n\r\n  - 類似 if else\r\n\r\n    ```sql\r\n    CASE\r\n      when condition(條件為true) then \"返回結果\"\r\n      --如果條件為false就繼續下一行判斷\r\n      when condition(條件為true) then \"返回結果\"\r\n      else \"返回結果\" -- 如果上述條件都不符，就返回此結果\r\n    end\r\n    ```\r\n\r\n  - 不等於：\r\n\r\n    - `<>`\r\n    - `!=`\r\n    - `NOT`\r\n\r\n  - 比較：\r\n    - `>=`\r\n    - `<=`\r\n\r\n## DB 命名原則\r\n\r\n- 命名只能使用英文字母、數字、下劃線，以英文字母開頭\r\n- 避免用 MySQL 的保留字如：backup、call、group 等\r\n- 所有資料庫物件使用小寫字母\r\n\r\n### 資料庫命名\r\n\r\n- 不超過 30 個字元\r\n\r\n### 資料表命名\r\n\r\n- 一律使用複數名詞\r\n- 不超過 30 個字元\r\n- 多對多關係中的中間表命名，為兩個表名稱，中間以`_`區額`，以單數命名 例如：`admins`和`members`，中間表命名為`admin_member`\r\n\r\n### 欄位命名\r\n\r\n- 各表之間相同意義的欄位必須同名\r\n- 多單詞以`_`\r\n- 外鍵約束欄位，以關聯的父層資料表名加上父層資料表欄位名來命名，中間以`_`區隔  \r\n  例:父層資料表名`admins`，父層資料表欄位名`id`，關聯欄位名`admin_id`\r\n\r\n### 索引命名\r\n\r\n#### 外鍵索引\r\n\r\n- 資料表名稱\\_關聯欄位名稱\\_foreign\r\n\r\n## Function\r\n\r\n### CONVERT_TZ(dt,from_tz,to_tz) 轉換時區\r\n\r\n- dt 日期/時間\r\n- from_tz 原始時區\r\n- to_tz 目標時區\r\n\r\n```sql\r\nSELECT CONVERT_TZ('2020-12-01 01:00:00','+00:00','+08:00') AS Result;\r\n```\r\n\r\n```output\r\n+---------------------+\r\n| Result              |\r\n+---------------------+\r\n| 2020-12-01 09:00:00 |\r\n+---------------------+\r\n```\r\n\r\n### Event 事件\r\n\r\n用於定期執行某些資料庫任務\r\n\r\n- 用途：\r\n  - 自動化維護\r\n  - 刪除過期數據\r\n  - 複製存檔、生成報告\r\n\r\n#### 範例\r\n\r\n- devices 資料表需要定時刪除已被標記 delete_at 的裝置\r\n\r\n```sql\r\nCREATE EVENT delete_old_devices\r\nON SCHEDULE\r\n-- 每半年檢查一次，並刪除超過半年以上的資料\r\nEVERY 6 MONTH\r\nDO\r\n  DELETE FROM devices WHERE deleted_at < DATE_SUB(NOW(), INTERVAL 6 MONTH);\r\n```\r\n\r\n#### 基本使用\r\n\r\n- 查詢、刪除\r\n\r\n```sql\r\nSHOW EVENTS; -- 查詢\r\n\r\nDROP EVENT IF EXISTS <event_name>; --刪除，IF EXISTS可以避免報錯\r\n```\r\n\r\n- 啟用事件排程\r\n\r\n```sql\r\nSET GLOBAL event_scheduler = ON;\r\n```\r\n\r\n- 查看目前正在執行的程序\r\n\r\n```sql\r\nSHOW PROCESSLIST;\r\n```\r\n\r\n## 使用情境\r\n\r\n### 外鍵 onDelete 約束情況\r\n\r\n- 沒有加入`onDelete`  \r\n  如果在關聯中的限制屬性，沒有加入`onDelete`，此時刪除外鍵約束的父層資料表中的欄位，會出現#1451 error\r\n\r\n  ```cmd\r\n  #1451 - Cannot delete or update a parent row: a foreign key constraint fails (`test0505`.`posts`, CONSTRAINT `posts_user_id_foreign` FOREIGN KEY (`user_id`)     REFERENCES `users` (`id`))\r\n  ```\r\n\r\n- onDelete('set null')\r\n  刪除父層資料表的欄位時，同時會將關聯的子資料表中的欄位設為`null`。\r\n- onDelete('cascade')\r\n  刪除父層資料表的欄位時，同時會將關聯的子資料表中的欄位刪除。\r\n\r\n### ERROR: #1215 - Cannot add foreign key constraint\r\n\r\n- 可能原因:\r\n  1. 添加外鍵約束時，目標欄位須和引用欄位具有相同的數據類型，int signed with int signed 或 int unsigned with int unsigned\r\n  2. 在 not null 的欄位加上 on delete/update set null 的外鍵約束，須將該欄位設為 DEFAULT NULL\r\n\r\n### 刪除重複的資料\r\n\r\n#### 使用 `DISTINCT` 去除重複值\r\n\r\n需求：查找 `02:81:85:34:ED:DC` 表中的數據，將表中 `i`, `p`, `ep`, `eq`, `pf`, `created_at` 這六個欄位均重複的資料刪除，並重新整理 id\r\n\r\n先建立一個表，接者使用 `SELECT DISTINCT` 去除重複的值，並把去除重複值的資料，存入新資料表中\r\n\r\n```sql\r\nCREATE TABLE `02:81:85:34:ED:DC_copy` (\r\n  `id` int(10) UNSIGNED NOT NULL,\r\n  `i` json DEFAULT NULL,\r\n  `p` json DEFAULT NULL,\r\n  `ep` json DEFAULT NULL,\r\n  `eq` json DEFAULT NULL,\r\n  `pf` json DEFAULT NULL,\r\n  `created_at` datetime DEFAULT NULL\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nINSERT INTO `02:81:85:34:ED:DC_copy` (`i`, `p`, `ep`, `eq`, `pf`, `created_at`)\r\nSELECT DISTINCT `i`, `p`, `ep`, `eq`, `pf`, `created_at` FROM `02:81:85:34:ED:DC`;\r\n```\r\n\r\n最後刪掉原表，並將複製的表改名\r\n\r\n```sql\r\ndrop tables `02:81:85:34:ED:DC`;\r\nalter table `02:81:85:34:ED:DC_copy` rename to `02:81:85:34:ED:DC`;\r\n```\r\n\r\n### 匯入 txt 檔\r\n\r\n建立資料表\r\n\r\n```sql\r\ncreate table `city_raw_data` (\r\n    `geonameid` int(10) NOT NULL,\r\n    `name` varchar(200) DEFAULT NULL,\r\n    `latitude` decimal(11, 8) DEFAULT NULL,\r\n    `longitude` decimal(11, 8) DEFAULT NULL,\r\n    `country code` varchar(10) DEFAULT NULL,\r\n    `timezone` varchar(40) DEFAULT NULL,\r\n    `modification date` date DEFAULT NULL\r\n) ENGINE = InnoDB DEFAULT CHARSET = utf8;\r\n```\r\n\r\n本地 txt 檔匯入\r\n在 txt 檔中，每一個欄位用 tab 鍵進行分隔\r\n\r\n```sql\r\nLOAD DATA INFILE \"C:/Users/RD/Desktop/ES.txt\" INTO TABLE `city_raw_data` (\r\n`geonameid`,`name`,`asciiname`,`alternatenames`,`latitude`,`longitude`,`feature class`,`feature code`,`country code`,`cc2`,`admin1 code`,`admin2 code``admin3 code`,`admin4 code`,`population`,`elevation`,`dem`,`timezone`,`modification date`\r\n)\r\n```\r\n\r\n或用指定的符號進行分隔，如：`|`\r\n\r\n```sql\r\nLOAD DATA INFILE \"C:/Users/RD/Desktop/ES.txt\" INTO TABLE `city_raw_data` FIELDS TERMINATED BY '|' (\r\n    `geonameid`,\r\n    `name`,\r\n    `latitude`,\r\n    `longitude`,\r\n    `country code`,\r\n    `timezone`,\r\n    `modification date`\r\n);\r\n```\r\n\r\n### 複合主鍵與聯合主鍵，索引與聯合(複合)索引\r\n\r\n#### 複合主鍵與聯合主鍵\r\n\r\n- **複合主鍵**：表的主鍵含有一個以上的欄位組成，不使用無業務含意的自增 id 作為主鍵\r\n\r\n```sql\r\ncreate table test\r\n(\r\n  'name' varchar(19) NOT NULL\r\n  'id' number\r\n  'value' varchar(10)\r\n  primary key ('name', 'id')\r\n)\r\n```\r\n\r\n`name` 和 `id` 欄位組合起來就是 test 表的複合主鍵，他的出現是因為 `name` 欄位可能會出現重複，所以要加上 `id` 欄位，如此可以保證紀錄的唯一性。\r\n\r\n一般而言，主見的欄位資料長度和字串字數越少越好。\r\n\r\n當表中只有一個主鍵時，他是唯一的索引；當表中有多個主鍵時，稱為複合主鍵，複合主鍵聯合保證唯一索引。\r\n\r\n某者個主鍵欄位值出現重複是沒問題的，只要不是有多筆資料的所有主鍵值完全一樣，就不算重複。\r\n\r\n- **聯合主鍵**：多個主鍵聯合形成一個主鍵組合。\r\n\r\n聯合主鍵的意義：用兩個字串(或多字串)來確定一條紀錄。這兩個字串都不唯一，可以分別重複。\r\n\r\n如：主鍵 A 和主鍵 B 組成聯合主鍵\r\n\r\n主鍵 A 跟主鍵 B 的資料可以完全相同，聯合就在於主鍵 A 和主鍵 B 形成的聯合主鍵是唯一的。\r\n下面的例子：主鍵 A 的數據是 1，主鍵 B 的數據也是 1，聯合主鍵其實是 11，11 是唯一值，不允許再出現 11 這個值。(即為多對多關係)\r\n\r\n| 主鍵 A | 主鍵 B |\r\n| :----: | :----: |\r\n|   1    |   1    |\r\n|   2    |   2    |\r\n|   3    |   3    |\r\n\r\n主鍵 A 與主鍵 B 的聯合主鍵值最多為：11, 12, 13, 21, 22, 23, 31, 32, 33\r\n\r\n#### 索引、聯合(複合)索引\r\n\r\n- **索引**：加快查詢速度的有效手段。\r\n\r\n  系統讀寫資料時，會自動選擇合適的索引作為存取路徑。\r\n\r\n  建立索引\r\n\r\n  ```sql\r\n  -- 建立索引\r\n  create [unique][cluster]index<索引名>\r\n\r\n  -- 刪除索引\r\n  drop index <索引名>\r\n  ```\r\n\r\n  索引是各種關係資料庫中，最常見的一種邏輯單元，是關係資料庫系統很重要的組成部分，對於提高檢索資料速度有很顯著的效果。\r\n  索引的原理是利用根據索引值得到行指針，然後快速定位到資料庫紀錄。\r\n\r\n  索引的使用：\r\n\r\n  1. 主鍵(預設自帶索引)和外鍵(以及一些可以跟其他表觀聯的字段)\r\n  2. where 子句中基常出現的字段。\r\n  3. 索引應該建立在小字段上，大數據字段(bit, image, test, blob)等，不適用\r\n\r\n- **聯合(複合)索引**\r\n\r\n```sql\r\n-- 建立聯合索引\r\ncreate index <索引名> on 表名(欄位1, 欄位2, ...);\r\n\r\n-- 例如：有聯合索引 (a, b, c, d)\r\nselect * from test where a=1 and b=2; -- a 和 b 索引都起作用\r\n```\r\n\r\n索引生效原則：按照聯合索引的順序，由前往後依次使用生效，如果中間某個索引沒有使用，那麼斷點前面的索引部份起作用，斷點後面的索引沒有起作用。\r\n\r\n例如\r\n\r\n```sql\r\nwhere a=1 and b=2 and d=4;\r\n```\r\n\r\n則只有 a 和 b 索引起作用，中間 c 斷了，則 d 索引不起作用。\r\n\r\nmysql 會一值向右尋找直到遇到範圍查詢(>, <, between, like)時停止。\r\n\r\n如：\r\n\r\n```sql\r\nwhere a = 1 and b = 2 and c > 3 and d = 4 ;\r\n```\r\n\r\n若建立 (a, b, c, d)順序的索引，則索引範圍不會到 b ，因為 c 出現 \">\"。\r\n如果建立(a, b, d, c)的順序，則\r\n\r\n```sql\r\nwhere a = 1 and b = 2 and c > 3 and d = 4\r\n```\r\n\r\n其中 abcd 都可以用到索引，並且 abd 的順序可以任意調整。\r\n\r\n```sql\r\nselect * from test where b=2 and d=4 and a=1and c>3;\r\n```\r\n\r\n以上 sql 語句中，a, b, c, d 都用到了索引\r\n\r\n**注意**\r\n\r\n1. 只要列中包含有 null 值，都將不會被包含在索引中，複合索引中只要有一列含有 null 值，那此列的複合索引就是無效的，因此在資料庫設計時盡量不要讓欄位的預設值為 null\r\n2. 使用 like 關鍵字須注意：`like \"%aaa%\"` 不會命中索引，`like \"aaa%\"` 才會命中索引。\r\n3. NOT IN 和操作都會變成全表掃描，not in 可以用 not exist 代替。\r\n","date":"2023-05-08T00:55:50.833Z","matchingLines":["## 環境設定\r","## 資料表語法\r","## 資料型態\r","## DB 命名原則\r","## Function\r","## 使用情境\r"]},{"name":"Laravel 學習筆記.md","content":"# Laravel 學習筆記\r\n\r\n> 請先完成 laravel 環境設置\r\n\r\n- [Laravel 學習筆記](#laravel-學習筆記)\r\n  - [基礎建立](#基礎建立)\r\n  - [連線資料庫將資料顯示在畫面上](#連線資料庫將資料顯示在畫面上)\r\n    - [mysql](#mysql)\r\n    - [redis](#redis)\r\n  - [新增一個 html 測試`input`到資料庫](#新增一個-html-測試input到資料庫)\r\n    - [將變數傳入 `view` 的三種方法](#將變數傳入-view-的三種方法)\r\n  - [Controller](#controller)\r\n    - [生成 controller](#生成-controller)\r\n    - [resource controller function](#resource-controller-function)\r\n    - [controller 傳入參數](#controller-傳入參數)\r\n    - [參數預設值](#參數預設值)\r\n  - [Route](#route)\r\n    - [route 基本寫法](#route-基本寫法)\r\n    - [resource controller 資源控制器](#resource-controller-資源控制器)\r\n    - [route 分組](#route-分組)\r\n  - [Laravel 功能實現](#laravel-功能實現)\r\n    - [儲存檔案並刪除舊檔](#儲存檔案並刪除舊檔)\r\n  - [Class not found](#class-not-found)\r\n  - [框架設計模式](#框架設計模式)\r\n    - [每一層的職責](#每一層的職責)\r\n    - [MVC 框架](#mvc-框架)\r\n    - [Web API Service](#web-api-service)\r\n\r\n## 基礎建立\r\n\r\n- 建立新的專案\r\n\r\n  ```cmd\r\n  laravel new ProjectName\r\n  ```\r\n\r\n- 安裝指定本版\r\n\r\n  ```cmd\r\n  composer create-project laravel/laravel=6.* ProjectName\r\n  ```\r\n\r\n- 同時建立 migration controller model\r\n\r\n  ```cmd\r\n  php artisan make:model New -mcr\r\n  ```\r\n\r\n- 建立 Controller\r\n\r\n  - 控制器路徑 app/Http/controllers/NewController.php\r\n  - 控制器名稱字首需大寫\r\n\r\n  ```cmd\r\n  php artisan make:controller NewController\r\n  ```\r\n\r\n- 啟動 Laravel 伺服器\r\n\r\n  ```cmd\r\n  php artisan serve\r\n  ```\r\n\r\n- 使用路由\r\n\r\n  ```php\r\n  // routes/web.php\r\n  Route::get('/home/news', \"App\\Http\\Controllers\\NewController@index\");\r\n\r\n  // app/Http/controllers/NewController.php\r\n  public function index()\r\n  {\r\n    return \"<h1>OK</h1>\";\r\n  }\r\n  ```\r\n\r\n## 連線資料庫將資料顯示在畫面上\r\n\r\n### mysql\r\n\r\n- Laravel 資料庫設定檔 `.env`\r\n\r\n  ```php\r\n  APP_NAME=Laravel        （專案的名稱）\r\n  APP_ENV=local           （專案開發的環境，local / staging）\r\n  APP_KEY=                (APP KEY)\r\n  APP_DEBUG=true          （提供在瀏覽器中顯示詳細的錯誤訊息來進行debug）\r\n  APP_URL=http://localhost（專案網址，EX. http://example.com，使用方法url()時便可取得該網址）\r\n\r\n  LOG_CHANNEL=stack\r\n\r\n  DB_CONNECTION=mysql (使用的資料庫)\r\n  DB_HOST=127.0.0.1   (資料庫主機位置)\r\n  DB_PORT=3306        (資料庫的埠號)\r\n  DB_DATABASE=test    (資料庫名稱)\r\n  DB_USERNAME=        （資料庫帳號）\r\n  DB_PASSWORD=        （資料庫密碼）\r\n  ```\r\n\r\n- 建立一個 model\r\n\r\n  - model 路徑 app/Models/News.php\r\n\r\n  ```cmd\r\n  php artisan make:model News\r\n  ```\r\n\r\n- Controller 參用 News model\r\n\r\n  ```php\r\n  use App\\Models\\News;\r\n  ```\r\n\r\n- 如何把陣列顯示在前台 (回傳`json`格式)\r\n\r\n  ```php\r\n  public function index()\r\n  {\r\n    $dataList = News::all();\r\n\r\n    return json_encode($dataList);\r\n  }\r\n  ```\r\n\r\n- 接收 `Route::post` 的路由接引到 `store(`) 完成資料庫的新增\r\n\r\n  ```php\r\n  Route::post('/home/news', \"App\\Http\\Controllers\\NewController@store\");\r\n  ```\r\n\r\n### redis\r\n\r\n> 需先在環境安裝 redis\r\n\r\n- 安裝 `predis`\r\n\r\n  ```bash\r\n  composer require predis/predis\r\n  ```\r\n\r\n- redis 預設有 16 個資料庫，Laravel 會使用預設的資料庫`0`\r\n- 修改 `env`\r\n\r\n  ```config\r\n  REDIS_HOST=127.0.0.1\r\n  REDIS_PASSWORD=null\r\n  REDIS_PORT=6379\r\n  REDIS_CLIENT=predis\r\n  REDIS_PREFIX=\"\"\r\n  ```\r\n\r\n- 使用方法\r\n\r\n  ```php\r\n  use Illuminate\\Support\\Facades\\Redis;\r\n  Redis::set('name', 'Vic');\r\n  Redis::get('name');\r\n  ```\r\n\r\n- redis-cil\r\n\r\n  ```bash\r\n  $ redis-cli\r\n  $ select 0   //選擇資料庫0\r\n  $ keys *     //列出所有keys\r\n  $ get laravel_database_name  //取得key value\r\n  ```\r\n\r\n- 須注意 laravel 預設的 redis key 會有 `laravel_database_` 這個前綴：`$ get laravel_database_${your_key}`。這個前綴設定可以在 `env` 中的 `REDIS_PREFIX` 修改\r\n\r\n## 新增一個 html 測試`input`到資料庫\r\n\r\n- 修改 controller\r\n\r\n  ```php\r\n  store(Request $request){\r\n    $newItem = new News();\r\n    $newItem->title = $request->input(\"title\");\r\n    $newItem->title = $request->input(\"ymd\");\r\n    $newItem->save();\r\n\r\n    return \"進來了\";\r\n  }\r\n  ```\r\n\r\n- 修改 `VerifyCsrfToken.php`，先略過資料傳送的資安問題\r\n\r\n  - 路徑 `/home` 底下都先忽略\r\n\r\n  ```php\r\n  protected $except = [\r\n    \"/home/*\"\r\n  ];\r\n  ```\r\n\r\n- 在 model 增加\r\n\r\n  ```php\r\n  public $timestamps = false;\r\n  // redirect => 重新導向\r\n  ```\r\n\r\n### 將變數傳入 `view` 的三種方法\r\n\r\n1. with: 用於簡單傳遞變數，但不易擴充傳遞變數，所以不常用到\r\n\r\n   ```php\r\n   $name = \"test\";\r\n   $age = 23; \r\n\r\n   return view('my_laravel')->with('name', $name);\r\n   // &\r\n   return view('my_laravel')->with('name', $name)->with('age', $age);\r\n\r\n   // 用陣列包起來\r\n   $data = [\r\n     'name' = 'test',\r\n     'age'  =26\r\n   ];\r\n\r\n   return view('my_laravel')->with('data', $data);\r\n\r\n   // view\r\n   {{ $data['name'] }}\r\n   ```\r\n\r\n2. Array\r\n\r\n   ```php\r\n   $data = [\r\n     'name' => 'test',\r\n     'age' => 26\r\n   ]\r\n\r\n   return view('my_laravel', $data)\r\n\r\n   // view\r\n   {{ $name }}\r\n   ```\r\n\r\n3. compact\r\n\r\n   ```php\r\n   // 常用於複雜變數，不用包裝成新的變數名稱\r\n   $data = [\r\n     'name' => 'test',\r\n     'age' => 26\r\n   ];\r\n   $title = 'title';\r\n\r\n   return view('my_laravel', compact('data', 'title'));\r\n\r\n   // view\r\n   {{ $data['name'] }}  // 因為在 data 陣列中 \r\n   {{ $title }}  // 變數值直接使用\r\n   ```\r\n\r\n## Controller\r\n\r\n### 生成 controller\r\n\r\n```bash\r\nphp artisan make:controller NewController\r\n```\r\n\r\n- `--resource`\r\n\r\n  ```bash\r\n  php artisan make:controller function/NewController --resource\r\n  ```\r\n\r\n  - 在`function/` 的目錄下，新增一個資源控制器\r\n  - 生成`index()` `create()` `store()` `show()` `edit()` `update()` `destroy()`\r\n\r\n- `--api`\r\n\r\n  ```bash\r\n  php artisan make:controller api/NewController --api\r\n  ```\r\n\r\n  - 一般 api 控制器會新增在 Controller/api 的目錄之下\r\n  - 生成`index()` `store()` `show()` `update()` `destroy()`，省略 `create()` `edit()` 方法\r\n\r\n### resource controller function\r\n\r\n- `index()`: 顯示所有資料的列表\r\n\r\n- `create()`: 顯示新增畫面\r\n- `store()`: 新增資料\r\n- `show()`: 顯示指定 id 的資料\r\n- `edit()`: 顯示編輯的畫面\r\n- `update()`: 更新資料\r\n- `destroy()`: 刪除資料\r\n\r\n### controller 傳入參數\r\n\r\n一般參數\r\n\r\n```php\r\npublic function show($id)\r\n{\r\n   return response()->json(New::find($id), 200);\r\n}\r\n```\r\n\r\n構造函數注入(Constructor Injection)\r\n\r\n```php\r\npublic function show(New $new)\r\n{\r\n    return response()->json($new, 200);\r\n}\r\n```\r\n\r\n### 參數預設值\r\n\r\n當傳入 controller 的參數為空時，參數返回預設值。\r\n\r\n```php\r\n// route/api.php:\r\nRoute::post('new/{new?}', 'NewController@show');\r\n\r\n// NewController.php:\r\nclass NewController extends Controller\r\n{\r\n    public function show($new = \"nothing news\")\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n## Route\r\n\r\nlaravel 中 route 有兩種:`routes/web.php` `routes/api.php`，分別為一般頁面和 api\r\n\r\n### route 基本寫法\r\n\r\n- 一般參數\r\n\r\n  ```php\r\n  Route::get(‘new’, ‘api\\NewController@index’);\r\n  Route::get(‘new/{id}’, ‘api\\NewController@show’);\r\n  Route::post(‘new’, ‘api\\NewController@store’);\r\n  Route::put(‘new/{id}’, ‘api\\NewController@update’);\r\n  Route::delete(‘new/{id}’, ‘api\\NewController@destroy’);\r\n  ```\r\n\r\n- 構造函數注入\r\n\r\n  ```php\r\n  Route::get(‘new’, ‘api\\NewController@index’);\r\n  Route::get(‘new/{new}’, ‘api\\NewController@show’);\r\n  Route::post(‘new’, ‘api\\NewController@store’);\r\n  Route::put(‘new/{new}’, ‘api\\NewController@update’);\r\n  Route::delete(‘new/{new}’, ‘api\\NewController@destroy’);\r\n  ```\r\n\r\n  - 第一個參數是對應的路徑，後面有`{}`代表傳入的參數\r\n  - 第二個參數是對應的 controller @後面為 controller 內要呼叫的方法\r\n\r\n### resource controller 資源控制器\r\n\r\n```php\r\nRoute::Resource('new', 'NewController');\r\n\r\n// api資源控制器\r\nRoute::apiResource('new', 'api\\NewController');\r\n```\r\n\r\n### route 分組\r\n\r\n- prefix: 前綴用來設定 URL 開始共同的部分。\r\n\r\n```php\r\nRoute::prefix(\"new\")->group(function () {\r\n    Route::get('view', 'NewController@show');\r\n    Route::post('create', 'NewController@create');\r\n    Route::put('update', 'NewController@edit');\r\n    // ...\r\n});\r\n\r\n```\r\n\r\n- namespace: 若要綁定的 controller 不在預設的 app/Http/Controller 裡，而是有更進一步的分類，可以設定 namespace()方便管理。\r\n\r\n```php\r\n// app/Http/Controller/New\r\nRoute::namespace(\"new\")->group(function () {\r\n    Route::get('new/view/{id}', 'NewController@show');\r\n    Route::post('new/create', 'NewController@create');\r\n    Route::put('new/update', 'NewController@edit');\r\n    // ...\r\n});\r\n```\r\n\r\n- middleware: laravel 進入 action 之前會先對 http request 進行檢查\r\n\r\n```php\r\nRoute::middleware('adminonly')->group(function () {\r\n    Route::get('new/create', 'NewController@create');\r\n    Route::get('new/{id}/delete', 'NewController@delete');\r\n    // ...\r\n});\r\n```\r\n\r\n## Laravel 功能實現\r\n\r\n### 儲存檔案並刪除舊檔\r\n\r\n```php\r\npublic function updateProfile(Request $request)\r\n{\r\n  $user = auth()->user();\r\n  // 表單驗證規則\r\n  $validated = $this->validateUserProfile($request->all(), $user->id)->validate();\r\n  if ($request->has('image')) {\r\n    // 取得資料表中原始資料\r\n    $originalData = User::find(auth()->user()->id)->getAttributes();\r\n    if ($originalData['image']) {\r\n      $filename = $originalData['image'];\r\n      $storage = Storage::disk('upload');\r\n      // 如果資料表中有紀錄，那就刪除檔案\r\n      if ($storage->exists($filename)) {\r\n        $storage->delete($filename);\r\n      }\r\n    }\r\n    // 原始$request['image']的值為暫存路徑，現將其改為資料表中的路徑\r\n    if ($request->hasFile('image')) {\r\n      $validated['image'] = $request->file('image')->store('images/users', 'upload');\r\n    }\r\n  }\r\n  $user->update($validated);\r\n}\r\n```\r\n\r\n## Class not found\r\n\r\n當出現 `Class 'xxx\\\\xxx\\\\xxx\\\\xxx' not found` 時，可能原因為 composer autoload 尚未註冊或是註冊錯誤。\r\n\r\n解決方法：\r\n\r\n- 方法一\r\n\r\n  ```terminal\r\n  composer dump-autoload -o\r\n  ```\r\n\r\n- 方法二\r\n\r\n  檢查 vendor/composer 下面的 autoload 資料夾中的檔案 autoload_classmap.php 和 autoload_static.php\r\n\r\n## 框架設計模式\r\n\r\n在小型專案中，典型的 MVC 架構沒什麼問題，但隨著系統越來越複雜，必須再細分更多層，於是衍生出 View - Presenter - Controller - Service - Repository - Model 六層框架設計模式。\r\n\r\n### 每一層的職責\r\n\r\n- Model 盡可能隱藏操作資料的 know-how，將資料抽象化，作為一個 Object Relational Mapping。\r\n- Repository 藉由操作 Model，幫助 Service 實現各種商務邏輯對應的資料庫操作方法。\r\n- Service 實現商務邏輯，並且讓 Controller 僅需要專注在溝通上。\r\n- Controller 作為 View 與商務邏輯間的溝通橋樑。\r\n- Presenter 負責 \"如何處理資料\"\r\n- View 負責\"要給客戶看到什麼\"\r\n\r\n### MVC 框架\r\n\r\n> 參考資料：\r\n>\r\n> [Laravel 加入 Repository 與 Service](https://vocus.cc/article/5fa7fe49fd8978000125da22)\r\n\r\n若將這六個 layer 的職責對應到 MVC 框架中，小專案下的 model 其實就是 Business Model，包含商業邏輯以及和資料庫溝通。而 View 也不會刻意把資料操作邏輯與資料處理方式獨立成一個 Presenter，因此\r\n小型專案的 View 往往混著一些邏輯判斷。\r\n\r\n- Model\r\n  - Service\r\n  - Repository\r\n  - Model\r\n- Controller\r\n  - Controller\r\n- View\r\n  - View\r\n  - Presenter\r\n\r\n### Web API Service\r\n\r\n通 Web API Service 僅僅是將 service 送來的資料變成 JSON format 輸出到 View 上，所以有時 Controller 就涵蓋了 Presenter 的職責，View 純粹只是 JSON, XML 等格式資料。\r\n\r\n- Model\r\n  - Service\r\n  - Repository\r\n  - Model\r\n- Controller\r\n  - Presenter\r\n  - Controller\r\n- View\r\n  - View\r\n","date":"2023-05-02T06:00:41.966Z","matchingLines":["## 基礎建立\r","## 連線資料庫將資料顯示在畫面上\r","## 新增一個 html 測試`input`到資料庫\r","## Controller\r","## Route\r","## Laravel 功能實現\r","## Class not found\r","## 框架設計模式\r"]},{"name":"Laravel 資料庫設計範例.md","content":"# Laravel 資料庫設計範例\r\n\r\n## 建立新專案\r\n\r\n```cmd\r\nlaravel new blog\r\n```\r\n\r\n## 編輯 .env\r\n\r\n```php\r\nDB_CONNECTION=mysql\r\nDB_HOST=127.0.0.1\r\nDB_PORT=3306\r\nDB_DATABASE=your_database\r\nDB_USERNAME=your_name\r\nDB_PASSWORD=your_password\r\n```\r\n\r\n- XAMPP 預設的密碼是空白，phpEnv 要先行設定資料庫密碼\r\n\r\n## 同時建立 migration controller model\r\n\r\n終端機執行\r\n\r\n```cmd\r\nphp artisan make:model Employee -mcr\r\n```\r\n\r\n完成後產生三個檔案\r\n\r\n- database\\migrations\\yyyy_mm_dd_time_create_employees_table.php\r\n- app\\Http\\Controllers\\EmployeeController.php\r\n- app\\Models\\Employee.php\r\n\r\n修改 migration 檔案，將 up() 函式改成\r\n\r\n```php\r\npublic function up()\r\n{\r\n    Schema::create('employees', function (Blueprint $table) {\r\n        $table->bigIncrements('id');\r\n        $table->string('firstName');\r\n        $table->string('lastName');\r\n        $table->timestamps();\r\n    });\r\n}\r\n```\r\n\r\n執行 migrate ，在資料庫中建立資料表\r\n\r\n```cmd\r\nphp artisan migrate\r\n```\r\n\r\n## 建立資料\r\n\r\n終端機開啟 tinker 工具程式\r\n\r\n```cmd\r\nphp artisan tinker\r\n```\r\n\r\n依序輸入指令\r\n\r\n```cmd\r\n1 + 2\r\nDB::table('employees')->insert(['firstName' => 'Jeremy', 'lastName' => 'Lin', 'created_at' => new Datetime, 'updated_at' => new Datetime ])\r\nDB::table('employees')->insert(['firstName' => 'Derek', 'lastName' => 'Jeter', 'created_at' => new Datetime, 'updated_at' => new Datetime ])\r\nDB::table('employees')->insert(['firstName' => 'Lionel', 'lastName' => 'Messi', 'created_at' => new Datetime, 'updated_at' => new Datetime ])\r\nDB::table('employees')->insert(['firstName' => 'test', 'lastName' => 'test', 'created_at' => new Datetime, 'updated_at' => new Datetime ])\r\n\r\nDB::table('employees')->get();\r\nDB::table('employees')->find(1)\r\nDB::table('employees')->where('lastName', 'test')->first()\r\nDB::table('employees')->where('lastName', 'test')->delete()\r\n\r\nApp\\Models\\Employee::all();\r\nApp\\Models\\Employee::find(1);\r\n\r\nexit\r\n```\r\n\r\n## 渲染員工清單\r\n\r\n編輯 web.php\r\n\r\n```php\r\nRoute::get('/', 'App\\Http\\Controllers\\EmployeeController@index');\r\nRoute::resource('employees', 'App\\Http\\Controllers\\EmployeeController');\r\n```\r\n\r\n編輯 EmployeesController，需參用 Employee 類別\r\n\r\n```php\r\nuse App\\Models\\Employee;\r\n```\r\n\r\n修改 index()\r\n\r\n```php\r\npublic function index() {\r\n        $employeeList = Employee::all();\r\n        return view('employees.index', compact('employeeList'));\r\n    }\r\n```\r\n\r\n建立 resources\\views\\employees\\index.blade.php\r\n\r\n```php\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <title>Employee</title>\r\n  <meta charset=\"utf-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css\">\r\n  <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js\"></script>\r\n  <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js\"></script>\r\n</head>\r\n<body>\r\n\r\n<div class=\"container\">\r\n  <h2>Employee List\r\n    <a href=\"/employees/create\" class=\"btn btn-md btn-success pull-right\">\r\n      <span class=\"glyphicon glyphicon-plus\"></span> 新增\r\n    </a>\r\n  </h2>\r\n  <table class=\"table table-hover\">\r\n    <thead>\r\n      <tr>\r\n        <th>Firstname</th>\r\n        <th>Lastname</th>\r\n        <th>&nbsp;</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n    <tr>\r\n        <td>firstName1</td>\r\n        <td>lastName1</td>\r\n        <td>\r\n            <span class=\"pull-right\">\r\n                <form method=\"post\" action=\"/employees/1\">\r\n                    <a href=\"/employees/1/edit\" class=\"btn btn-xs btn-info\">\r\n               <span class=\"glyphicon glyphicon-pencil\"></span> 修改\r\n              </a> |\r\n                    @csrf\r\n                    @method('DELETE')\r\n                    <button type=\"submit\" class=\"btn btn-xs btn-danger\">\r\n               <span class=\"glyphicon glyphicon-remove\"></span> 刪除\r\n              </button>\r\n                </form>\r\n            </span>\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td>firstName2</td>\r\n        <td>lastName2</td>\r\n        <td>\r\n            <span class=\"pull-right\">\r\n                <form method=\"post\" action=\"/employees/2\">\r\n                    <a href=\"/employees/2/edit\" class=\"btn btn-xs btn-info\">\r\n               <span class=\"glyphicon glyphicon-pencil\"></span> 修改\r\n              </a> |\r\n                    @csrf\r\n                    @method('DELETE')\r\n                    <button type=\"submit\" class=\"btn btn-xs btn-danger\">\r\n               <span class=\"glyphicon glyphicon-remove\"></span> 刪除\r\n              </button>\r\n                </form>\r\n            </span>\r\n        </td>\r\n    </tr>\r\n    <tr>\r\n        <td>firstName3</td>\r\n        <td>lastName3</td>\r\n        <td>\r\n            <span class=\"pull-right\">\r\n                <form method=\"post\" action=\"/employees/3\">\r\n                    <a href=\"/employees/3/edit\" class=\"btn btn-xs btn-info\">\r\n               <span class=\"glyphicon glyphicon-pencil\"></span> 修改\r\n              </a> |\r\n                    @csrf\r\n                    @method('DELETE')\r\n                    <button type=\"submit\" class=\"btn btn-xs btn-danger\">\r\n               <span class=\"glyphicon glyphicon-remove\"></span> 刪除\r\n              </button>\r\n                </form>\r\n            </span>\r\n        </td>\r\n    </tr>\r\n    </tbody>\r\n  </table>\r\n</div>\r\n</body>\r\n</html>\r\n```\r\n\r\n啟動 Web 伺服器\r\n\r\n```cmd\r\nphp artisan serve\r\n```\r\n\r\n## 動態渲染員工資料\r\n\r\n修改 resources\\views\\employees\\index.blade.php\r\n\r\n```php\r\n<tbody>\r\n    @foreach ($employeeList as $emp)\r\n     <tr>\r\n         <td>{{$emp->firstName}}</td>\r\n         <td>{{$emp->lastName}}</td>\r\n         <td>\r\n             <span class=\"pull-right\">\r\n                 <form method=\"post\" action=\"/employees/{{$emp->id}}\">\r\n                     <a href=\"/employees/{{$emp->id}}/edit\" class=\"btn btn-xs btn-info\">\r\n          <span class=\"glyphicon glyphicon-pencil\"></span> 修改\r\n         </a> |\r\n                     @csrf\r\n                     @method('DELETE')\r\n                     <button type=\"submit\" class=\"btn btn-xs btn-danger\">\r\n          <span class=\"glyphicon glyphicon-remove\"></span> 刪除\r\n         </button>\r\n                  </form>\r\n             </span>\r\n         </td>\r\n     </tr>\r\n    @endforeach\r\n</tbody>\r\n```\r\n\r\n## 新增員工資料\r\n\r\n修改 EmployeesController.php\r\n\r\n```php\r\npublic function create()\r\n    {\r\n        return view(\"employees.create\");\r\n    }\r\n```\r\n\r\n新增檔案 resources\\views\\employees\\create.blade.php\r\n\r\n```php\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <title>Employee</title>\r\n    <meta charset=\"utf-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n    <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css\">\r\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js\"></script>\r\n    <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js\"></script>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"container\">\r\n        <form class=\"form-horizontal\">\r\n     @csrf\r\n            <fieldset>\r\n                <!-- Form Name -->\r\n                <legend>Employee Data</legend>\r\n                <!-- Text input-->\r\n                <div class=\"form-group\">\r\n                    <label class=\"col-md-4 control-label\" for=\"firstName\">First Name:</label>\r\n                    <div class=\"col-md-4\">\r\n                        <input id=\"firstName\" name=\"firstName\" type=\"text\" placeholder=\"\" class=\"form-control input-md\">\r\n                    </div>\r\n                </div>\r\n                <!-- Text input-->\r\n                <div class=\"form-group\">\r\n                    <label class=\"col-md-4 control-label\" for=\"lastName\">Last Name:</label>\r\n                    <div class=\"col-md-4\">\r\n                        <input id=\"lastName\" name=\"lastName\" type=\"text\" placeholder=\"\" class=\"form-control input-md\">\r\n                    </div>\r\n                </div>\r\n                <!-- Button (Double) -->\r\n                <div class=\"form-group\">\r\n                    <label class=\"col-md-4 control-label\" for=\"okOrCancel\"></label>\r\n                    <div class=\"col-md-8\">\r\n                        <button type=\"submit\" id=\"okOrCancel\" name=\"okOrCancel\" class=\"btn btn-success\">\r\n                         OK\r\n                        </button>\r\n         <button type=\"submit\" id=\"okOrCancel\" name=\"okOrCancel\" class=\"btn btn-danger\">\r\n                         Cancel\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            </fieldset>\r\n        </form>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n修改 EmployeesController.php\r\n\r\n```php\r\npublic function store(Request $request)\r\n    {\r\n        $emp = new Employee();\r\n        $emp->firstName = $request->firstName;\r\n        $emp->lastName = $request->lastName;\r\n        $emp->save();\r\n        return redirect(\"/employees\");\r\n    }\r\n```\r\n\r\n## 修改會員資料\r\n\r\n修改 EmployeesController.php\r\n\r\n```php\r\npublic function edit($id)\r\n    {\r\n        $emp = Employee::find($id);\r\n        return view('employees.edit', compact('emp'));\r\n    }\r\n```\r\n\r\n新增檔案 resources\\views\\employees\\edit.blade.php\r\n\r\n```php\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n    <title>Employee</title>\r\n    <meta charset=\"utf-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n    <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/css/bootstrap.min.css\">\r\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js\"></script>\r\n    <script src=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.4.0/js/bootstrap.min.js\"></script>\r\n</head>\r\n\r\n<body>\r\n    <div class=\"container\">\r\n        <form class=\"form-horizontal\">\r\n     @csrf\r\n  @method('PUT')\r\n            <fieldset>\r\n                <!-- Form Name -->\r\n                <legend>Employee Data</legend>\r\n                <!-- Text input-->\r\n                <div class=\"form-group\">\r\n                    <label class=\"col-md-4 control-label\" for=\"firstName\">First Name:</label>\r\n                    <div class=\"col-md-4\">\r\n                        <input id=\"firstName\" name=\"firstName\" value=\"{{ $emp->firstName }}\" type=\"text\" placeholder=\"\" class=\"form-control input-md\">\r\n                    </div>\r\n                </div>\r\n                <!-- Text input-->\r\n                <div class=\"form-group\">\r\n                    <label class=\"col-md-4 control-label\" for=\"lastName\">Last Name:</label>\r\n                    <div class=\"col-md-4\">\r\n                        <input id=\"firstName\" name=\"firstName\" value=\"{{ $emp->lastName }}\" type=\"text\" placeholder=\"\" class=\"form-control input-md\">\r\n                    </div>\r\n                </div>\r\n                <!-- Button (Double) -->\r\n                <div class=\"form-group\">\r\n                    <label class=\"col-md-4 control-label\" for=\"okOrCancel\"></label>\r\n                    <div class=\"col-md-8\">\r\n                     <button type=\"submit\" id=\"okOrCancel\" name=\"okOrCancel\" class=\"btn btn-success\">\r\n                         OK\r\n                        </button>\r\n         <button type=\"submit\" id=\"okOrCancel\" name=\"okOrCancel\" class=\"btn btn-danger\">\r\n                         Cancel\r\n                        </button>\r\n                    </div>\r\n                </div>\r\n            </fieldset>\r\n        </form>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n修改 EmployeesController.php\r\n\r\n```php\r\npublic function update(Request $request, $id)\r\n    {\r\n        $emp = Employee::find($id);\r\n        $emp->firstName = $request->firstName;\r\n        $emp->lastName = $request->lastName;\r\n        $emp->save();\r\n        return redirect(\"/employees\");\r\n    }\r\n```\r\n\r\n## 刪除會員資料\r\n\r\n修改 EmployeesController.php\r\n\r\n```php\r\npublic function destroy($id)\r\n    {\r\n        $emp = Employee::find($id);\r\n        $emp->delete();\r\n        return redirect(\"/employees\");\r\n    }\r\n```\r\n","date":"2023-04-28T01:41:44.769Z","matchingLines":["## 建立新專案\r","## 編輯 .env\r","## 同時建立 migration controller model\r","## 建立資料\r","## 渲染員工清單\r","## 動態渲染員工資料\r","## 新增員工資料\r","## 修改會員資料\r","## 刪除會員資料\r"]},{"name":"Ubuntu 學習筆記.md","content":"# ubuntu 學習筆記\r\n\r\n<!-- TOC -->\r\n\r\n- [ubuntu 學習筆記](#ubuntu-學習筆記)\r\n  - [ubuntu 檔案結構](#ubuntu-檔案結構)\r\n  - [權限](#權限)\r\n    - [概述](#概述)\r\n    - [指令](#指令)\r\n      - [`chown` 更改檔案所有權給其他使用者](#chown-更改檔案所有權給其他使用者)\r\n      - [`chmod` 更改檔案權限](#chmod-更改檔案權限)\r\n      - [`&` 背景執行程式](#-背景執行程式)\r\n      - [`jobs` 檢視任務](#jobs-檢視任務)\r\n      - [`fg` 將任務切換至前景執行，`bg` 將任務切換至背景執行](#fg-將任務切換至前景執行bg-將任務切換至背景執行)\r\n      - [`disown` 卸除目前預設的背景行程](#disown-卸除目前預設的背景行程)\r\n      - [`ps aux | less` 顯示所有正在執行中的進程](#ps-aux--less-顯示所有正在執行中的進程)\r\n      - [`kill 10000` 刪除執行中的進程，`kill` 加上 PID 的數字即可](#kill-10000-刪除執行中的進程kill-加上-pid-的數字即可)\r\n      - [`nohup` 讓程式可以在離線或是登出系統後繼續執行](#nohup-讓程式可以在離線或是登出系統後繼續執行)\r\n  - [安裝 php](#安裝-php)\r\n  - [安裝 MySQL](#安裝-mysql)\r\n    - [更新軟體庫](#更新軟體庫)\r\n    - [升級軟體庫](#升級軟體庫)\r\n    - [安裝指令](#安裝指令)\r\n    - [查看 MySQL 版本](#查看-mysql-版本)\r\n    - [設定 root 密碼](#設定-root-密碼)\r\n    - [移除 MySQL](#移除-mysql)\r\n  - [nginx](#nginx)\r\n    - [service nginx restart 執行出現 fail](#service-nginx-restart-執行出現-fail)\r\n    - [完全移除 nginx](#完全移除-nginx)\r\n  - [找不到 sudo](#找不到-sudo)\r\n  - [安裝 composer](#安裝-composer)\r\n    - [更新系統的套件資訊](#更新系統的套件資訊)\r\n    - [下載 composer 並將其設定為全域可執行的指令](#下載-composer-並將其設定為全域可執行的指令)\r\n  - [安裝 Git](#安裝-git)\r\n  - [安裝 Docker](#安裝-docker)\r\n  - [logrotate 記錄檔管理工具](#logrotate-記錄檔管理工具)\r\n    - [安裝](#安裝)\r\n    - [設定檔](#設定檔)\r\n    - [基本設定](#基本設定)\r\n    - [紀錄檔輪替頻率設定](#紀錄檔輪替頻率設定)\r\n    - [紀錄檔壓縮](#紀錄檔壓縮)\r\n    - [測試 logrotate 設定](#測試-logrotate-設定)\r\n\r\n<!-- /TOC -->\r\n\r\n## ubuntu 檔案結構\r\n\r\n- `/bin` 存放 linux / ubuntu 系統啟動和運行時會使用到的執行檔\r\n- `/boot` linux 核心和 RAM disk Image 存放的地方，同時為啟動選單設定檔存放的地方\r\n- `/dev` 所有 linux 核心有認識的設備和裝置的資訊都存放在此資料夾\r\n- `/etc` 所有影響到系統運作的設定檔\r\n- `/home` 系統上所有使用者的家目錄都會放在此資料夾下的資料夾\r\n- `/lib` 此資料夾存放 linux / ubuntu 系統會用到的程式庫及核心模組\r\n- `/lost+found` 若 ubuntu 的檔案系統掛掉了，系統回復後，會將所有無法正確回復的資料放進此資料夾中\r\n- `/media` 作為隨身碟或 CD 之類的可移除裝置的掛載點\r\n- `/mnt` 早期 linux 版本所使用的可移除裝置的掛載點，在 ubuntu 上用來專門做掛載暫時性的檔案系統用\r\n- `/opt` 無法透過套件安裝的軟體，會將程式安裝在此資料夾\r\n- `/proc` 此為一個虛擬的檔案系統，裡面放的是系統正在運行的程序，linux 核心透過此資料夾內的檔案來傳送訊息給執行中的程序\r\n- `/root` 此為 root 帳號的家目錄\r\n- `/sbin` 此資料夾內的檔案大多是超級使用者或 root 可以使用的管理用指令程式\r\n- `/tmp` 系統、軟體和程式用來存放暫時性資料的地方\r\n- `/usr/bin` 無論是 ubuntu 預載的或是使用者自己安裝的程式或軟體，都會被安裝到此資料夾\r\n- `/usr/lib` 此資料夾文存放 /usr/bin 的程式會用到的程式庫\r\n- `/usr/local` 通常透過自己編譯案安裝的程式會被放到此資料夾之下\r\n- `/usr/share` 此資料夾用來存放 /usr/bin 的程式的共用資料\r\n- `/usr/share/doc` 所有軟體的說明文件會放在這邊\r\n- `/var` 用來存放系統上的動態資料，像是網站、log 和郵件類型的資料\r\n- `/selinux` 此資料夾用來存放 SELinux 套件，預設並沒有安裝，因此為空\r\n- `/srv` 為相容 FHS 標準，因此會需要將架網站或 FTP server 等網路服務改放到此資料夾\r\n- `/sys` 此資料夾和 /proc 一樣為虛擬的檔案系統，用途為提供目前系統的各項資訊\r\n\r\n## 權限\r\n\r\n> [參考資料](https://shian420.pixnet.net/blog/post/344938711-%5Blinux%5D-chmod-****%E6%AA%94%E6%A1%88%E6%AC%8A%E9%99%90%E5%A4%A7%E7%B5%B1%E6%95%B4!)\r\n\r\n### 概述\r\n\r\nLinux 為多用戶系統，可同時間讓與多用戶使用。\r\n\r\n每個文件和目錄都分配了三種類型的身分\r\n\r\n- `owner` 創建檔案的人\r\n- `group` 一個 group 可以有很多 user，如果這個 group 的權限為讀跟寫，那此 group 中的 user 都可以讀跟寫\r\n- `others` 所有人\r\n\r\n與三種權限\r\n\r\n- `r` 可以開啟和讀取檔案。若為資料夾，則可以查看目錄下的內容，但無法修改(重新命名、移動、剪下、刪除)\r\n- `w` 可以新增、刪除、修改檔案。若檔案有 write 的權限，但資料夾沒有，則只能修改檔案內容，無法更改資料夾結構(修改檔名，移動檔案、刪除檔案)\r\n- `x` 執行程式碼的權限。windows 系統中，只要副檔名為 `.exe` 就可以執行，但在 linux 中需要有 execute permission。read 和 write 權限僅能修改程式碼\r\n- `-` 無權限\r\n\r\n```bash\r\nroot@rexlitemqtt://home/rexlite_public# ll\r\ntotal 80\r\ndrwxr-xr-x 6 rexlite_public rexlite_public  4096 Aug 30 05:34 ./\r\ndrwxr-xr-x 4 root           root            4096 Dec 16  2020 ../\r\n-rw------- 1 rexlite_public rexlite_public 14451 Sep  2 01:38 .bash_history\r\n-rw-r--r-- 1 rexlite_public rexlite_public   220 Feb 25  2020 .bash_logout\r\n-rw-r--r-- 1 rexlite_public rexlite_public  3771 Feb 25  2020 .bashrc\r\ndrwx------ 3 rexlite_public rexlite_public  4096 Apr 12  2021 .cache/\r\ndrwxrwxr-x 3 rexlite_public rexlite_public  4096 Apr 12  2021 .config/\r\ndrwxrwxr-x 3 rexlite_public rexlite_public  4096 Apr 12  2021 .local/\r\n-rw------- 1 rexlite_public rexlite_public   102 Dec 16  2020 .mysql_history\r\n-rw-r--r-- 1 rexlite_public rexlite_public   807 Feb 25  2020 .profile\r\ndrwx------ 2 rexlite_public rexlite_public  4096 Sep  2 01:10 .ssh/\r\n-rw------- 1 rexlite_public rexlite_public  3994 Aug 29 06:15 .viminfo\r\n-rw-rw-r-- 1 rexlite_public rexlite_public   584 May 19 10:15 README.md\r\n-rw-rw-r-- 1 rexlite_public rexlite_public  6774 Dec 16  2021 max-system.fishbonetw.com.zip\r\n-rw-rw-r-- 1 rexlite_public rexlite_public  4275 Jul 26  2021 max-system.japhne.com-bluehost.zip\r\n-rw-r--r-- 1 root           root               0 Dec 16  2020 var_log.json\r\n```\r\n\r\n第一個字元， `d` 代表 directory，`-` 代表 file\r\n\r\n接下來為三個字元一組，分別代表 `user(owner)`、`group`、`other` 及其擁有的權限\r\n\r\n- 各權限的分數\r\n\r\n  | 字元 | 分數 |\r\n  | :--: | :--: |\r\n  |  r   |  4   |\r\n  |  w   |  2   |\r\n  |  x   |  1   |\r\n  |  -   |  0   |\r\n\r\n  分數是累加的，例如 `-rwxrwx---`\r\n\r\n  |  字元  | 權限 |  分數   |\r\n  | :----: | :--: | :-----: |\r\n  | owner  | rwx  | 4+2+1=7 |\r\n  | group  | rwx  | 4+2+1=7 |\r\n  | others | ---  | 0+0+0=0 |\r\n\r\n  所以該檔的權限數字為 770\r\n\r\n第一個帳號為擁有者，第二個群組\r\n\r\n### 指令\r\n\r\n#### `chown` 更改檔案所有權給其他使用者\r\n\r\n- `-R` 針對檔案或是目錄下檔案做遞歸處理(整個目錄下每一個檔案不遺漏處理)\r\n\r\n- 將 home 底下 video 目錄所有者，改為 user\r\n\r\n  ```bash\r\n  chown user /home/video\r\n  ```\r\n\r\n- 將 home 底下 video 目錄的所有者，改成 user，擁有群組改為 video\r\n\r\n  ```bash\r\n  chown user:video /home/video\r\n  ```\r\n\r\n- 將 home 底下 video 目錄與目錄裡面所有檔案，擁有者改為 user\r\n\r\n  ```bash\r\n  chown -R user /home/video\r\n  ```\r\n\r\n#### `chmod` 更改檔案權限\r\n\r\n- 用數字類型改變檔案權限\r\n\r\n  ```bash\r\n  chmod -R xyz < filename | directory >\r\n  ```\r\n\r\n  - 若要將.bashrc 這個檔案所有權限都設為啟用\r\n\r\n    ```bash\r\n    chmod 777 .bashrc\r\n    ```\r\n\r\n  - 若要將檔案權限，改為可執行檔，且不開放修改。  \r\n    則權限為 `-rwxr-xr-x` ，其分數為 755。\r\n\r\n  - 若要檔案不希望其他人看到。  \r\n    其權限為 `-rwxr-----`，分數為 740。\r\n\r\n- 符號類型改變檔案權限\r\n\r\n  - `+` 加入\r\n  - `-` 除去\r\n  - `=` 設定\r\n\r\n  ```bash\r\n  chmod [ u | g | o | a ] [ + | - | = ] [ r | w | x ] < filename | directory >\r\n  ```\r\n\r\n  - 若要將 `.bashrc` 權限設為 `-rwxr-xr-x`\r\n\r\n    - `user` 可讀、可寫、可執行\r\n    - `group` | `others` 可讀、可執行\r\n\r\n    ```bash\r\n    chmod u=rwx, go=rx .bashrc\r\n    ```\r\n\r\n  - 若權限為 `-rwxr-xr--`\r\n\r\n    ```bash\r\n    chmod u=rwx, g=rx, o=r < filename >\r\n    ```\r\n\r\n  - 若不知道此檔案的權限，但想要將此檔案設定為全部人都可以寫入  \r\n    `chmod a+w < filename >`\r\n  - 若要將權限去除，而不更動其他已存在的權限  \r\n    `chmod a-x < filename >`\r\n\r\n#### `&` 背景執行程式\r\n\r\n- 在執行程式後面加上 `&` 使程式可以在背景執行\r\n\r\n```bash\r\nphp subscribe_with_auth.php &\r\n```\r\n\r\n#### `jobs` 檢視任務\r\n\r\n```bash\r\njobs -l\r\n[1]+ 1040421 Running php subscribe_with_auth.php &\r\n```\r\n\r\n#### `fg` 將任務切換至前景執行，`bg` 將任務切換至背景執行\r\n\r\n```bash\r\njobs -l\r\n[1]+ 1040421 Running php subscribe_with_auth.php &\r\n```\r\n\r\n#### `disown` 卸除目前預設的背景行程\r\n\r\n- `disown -a` 卸除所有工作，無論其狀態是否在執行中或是暫停\r\n- `disown -ar` 僅卸除所有執行中的工作\r\n- `disown -h` 不要卸除工作，只是單純讓程式可以在登出後繼續執行。\r\n\r\n```bash\r\njobs -l\r\n[1]+ 1040421 Running php subscribe_with_auth.php &\r\n```\r\n\r\n#### `ps aux | less` 顯示所有正在執行中的進程\r\n\r\n#### `kill 10000` 刪除執行中的進程，`kill` 加上 PID 的數字即可\r\n\r\n```bash\r\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\r\nroot           1  0.0  0.3 173272 12812 ?        Ss    2022  85:07 /lib/systemd/systemd --system --deserialize 23\r\nroot           2  0.0  0.0      0     0 ?        S     2022   0:06 [kthreadd]\r\nroot           3  0.0  0.0      0     0 ?        I<    2022   0:00 [rcu_gp]\r\nroot           4  0.0  0.0      0     0 ?        I<    2022   0:00 [rcu_par_gp]\r\nroot           5  0.0  0.0      0     0 ?        I<    2022   0:00 [netns]\r\nroot           7  0.0  0.0      0     0 ?        I<    2022   0:00 [kworker/0:0H-events_highpri]\r\nroot           9  0.0  0.0      0     0 ?        I<    2022   2:45 [kworker/0:1H-events_highpri]\r\n```\r\n\r\n#### `nohup` 讓程式可以在離線或是登出系統後繼續執行\r\n\r\n當 Linux 使用者登出系統後正在執行的程式會接收到 SIGHUP(hangup) 信號，收到信號的程式會立刻停止執行。\r\n\r\n```bash\r\nnohup /path/my_program &\r\n```\r\n\r\n## 安裝 php\r\n\r\n```bash\r\napt install -y php7.4 php7.4-cli php7.4-fpm php7.4-mbstring php7.4-xml php7.4-bcmath php7.4-curl php7.4-gd php7.4-mysql php7.4-opcache php7.4-zip php7.4-sqlite3\r\n```\r\n\r\n- 查看是否安裝成功\r\n\r\n  ```bash\r\n  php -v\r\n  ```\r\n\r\n- 安裝最新版 php\r\n\r\n由於通常 ubuntu 的套件資訊不會包含最新版本的 php，若需要最新版本，需添加第三方的套件資訊\r\n\r\n```bash\r\napt install -y software-properties-common\r\n```\r\n\r\n將第三方套件資訊加入 ubuntu 套件資訊庫\r\n\r\n```bash\r\nadd-apt-repository -y ppa:ondrej/php\r\n```\r\n\r\n更新套件資訊\r\n\r\n```bash\r\napt-get update\r\n```\r\n\r\n更新後即可安裝最新的 php\r\n\r\n## 安裝 MySQL\r\n\r\n### 更新軟體庫\r\n\r\n```zsh\r\napt update\r\n```\r\n\r\n### 升級軟體庫\r\n\r\n```zsh\r\napt upgrade\r\n```\r\n\r\n### 安裝指令\r\n\r\n```zsh\r\napt install mysql-server -y\r\n```\r\n\r\n### 查看 MySQL 版本\r\n\r\n```zsh\r\nmysql --version\r\n# output\r\nmysql  Ver 8.0.31-0ubuntu0.22.04.1 for Linux on x86_64 ((Ubuntu))\r\n```\r\n\r\n### 設定 root 密碼\r\n\r\n```zsh\r\nroot@DESKTOP-O8SANAT ~ sudo service mysql start\r\n\r\nroot@DESKTOP-O8SANAT ~ sudo mysql\r\n\r\nmysql>  ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'SetRootPasswordHere';\r\nQuery OK, 0 rows affected (0.01 sec)\r\n\r\nmysql> exit\r\nBye\r\n\r\nroot@DESKTOP-O8SANAT ~ sudo mysql_secure_installation\r\nEnter password for user root:\r\n# 輸入：SetRootPasswordHere\r\n```\r\n\r\n- [設定 root 帳號與初始權限](https://www.albert-yu.com/blog/mysql%E8%A8%AD%E5%AE%9Aroot%E5%B8%B3%E8%99%9F%E5%AF%86%E7%A2%BC%E8%88%87%E5%88%9D%E5%A7%8B%E6%AC%8A%E9%99%90ubuntu-20-04/)\r\n\r\n### 移除 MySQL\r\n\r\n- 移除 MySQL\r\n\r\n```bash\r\napt-get purge --auto-remove mysql-common mysql-server mariadb-server\r\napt-get autoremove\r\napt-get autoclean\r\n```\r\n\r\n- 刪除 mysql 使用者\r\n\r\n```bash\r\nkillall -9 mysql (或 killall -9 mysqld) userdel mysql\r\n```\r\n\r\n- 刪除設定檔\r\n\r\n```bash\r\nrm -rf /etc/mysql rm -rf /var/lib/mysql\r\n```\r\n\r\n## nginx\r\n\r\n### service nginx restart 執行出現 fail\r\n\r\n[參考資料](https://weijutu.github.io/2019/03/12/web/ubuntu-nginx-restart-fail/)\r\n\r\n### 完全移除 nginx\r\n\r\n- 停止 nginx 服務\r\n\r\n```bash\r\nsudo service nginx stop\r\n```\r\n\r\n- 刪除 nginx 及設定文件\r\n\r\n```bash\r\nsudo apt-get purge nginx\r\n```\r\n\r\n- 自動刪除不使用的軟體包\r\n\r\n```bash\r\nsudo apt-get autoremove\r\n```\r\n\r\n- 列出與 nginx 相關的軟體，並刪除\r\n\r\n```bash\r\ndpkg --get-selections | grep nginx\r\n\r\nsudo apt-get purge nginx\r\nsudo apt-get purge nginx-common\r\nsudo apt-get purge nginx-full\r\n```\r\n\r\n- 確認 nginx 是否完全刪除\r\n\r\n```bash\r\nwhich nginx\r\n```\r\n\r\n## 找不到 sudo\r\n\r\n- 先檢查 `/etc/sudoers.d` 檔案是否在，若無則下安裝命令\r\n\r\n```bash\r\napt-get install sudo\r\n```\r\n\r\n- 若系統中已經存在 `/etc/sudoers.d` 檔案，表示系統已經安裝 sudo 但尚未設定環境。\r\n  - 用文件編輯器 (vim) 開啟 `/etc/sudoers.d`，找到 `secure_path` 添加路徑\r\n\r\n```bash\r\nDefaults    secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin\r\n```\r\n\r\n## 安裝 composer\r\n\r\n> 安裝前須先安裝 PHP Command-Line Interface（PHP-CLI)\r\n\r\n### 更新系統的套件資訊\r\n\r\n```bash\r\nsudo apt-get update && sudo apt-get upgrade -y\r\n```\r\n\r\n### 下載 composer 並將其設定為全域可執行的指令\r\n\r\n- 從官網下載 composer 安裝檔至 tmp 資料夾\r\n\r\n  ```bash\r\n  php -r \"copy('https://getcomposer.org/installer', '/tmp/composer-setup.php')\"\r\n  ```\r\n\r\n- 驗證下載的安裝檔\r\n\r\n  使用 composer 官方提供的 SHA-384 簽章來驗證安裝檔 [Composer Public Keys / Checksums](https://composer.github.io/pubkeys.html)\r\n\r\n  輸入驗證的簽章\r\n\r\n  ```bash\r\n  php -r \"if (hash_file('SHA384', '/tmp/composer-setup.php') === '55ce33d7678c5a611085589f1f3ddf8b3c52d662cd01d4ba75c0ee0459970c2200a51f492d557530c71c15d8dba01eae') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('/tmp/composer-setup.php'); } echo PHP_EOL;\"\r\n  ```\r\n\r\n- 安裝 composer\r\n  為了要讓 composer 在全域中使用，所以要將 composer 安裝到 `usr/local/bin` 的資料夾中，以及將 `Composer` 重新命名為 `composer`。\r\n\r\n  ```bash\r\n  sudo php /tmp/composer-setup.php --install-dir=/usr/local/bin --filename=composer\r\n  ```\r\n\r\n- 查看 composer 版本\r\n\r\n  ```bash\r\n  composer -V\r\n  ```\r\n\r\n- 刪除 composer 的安裝檔\r\n\r\n  ```bash\r\n  rm /tmp/composer-setup.php\r\n  ```\r\n\r\n## 安裝 Git\r\n\r\n```bash\r\nsudo apt-get install git\r\n```\r\n\r\n## 安裝 Docker\r\n\r\n```bash\r\nsudo apt install docker.io\r\n```\r\n\r\n確認安裝\r\n\r\n```bash\r\ndocker --version\r\n```\r\n\r\n啟動 docker\r\n\r\n```bash\r\nsudo systemctl start docker\r\n\r\n# 啟動時運行\r\nsudo systemctl enable docker\r\n```\r\n\r\n## logrotate 記錄檔管理工具\r\n\r\n### 安裝\r\n\r\n一般而言 linux 發行版都會安裝好 logrotate\r\n\r\n```bash\r\n# 安裝 logrotate（Ubuntu/Debian）\r\nsudo apt install logrotate\r\n\r\n# 安裝 logrotate（RHEL/CentOS）\r\nsudo yum install logrotate\r\n```\r\n\r\n### 設定檔\r\n\r\nlogrotate 設定檔位於 `/etc/logrotate.conf`，裡面會包含一些預設的設定值，例如紀錄檔的輪替頻率，保留數量等等\r\n\r\n```bash\r\n# 每週進行一次記錄檔輪替\r\nweekly\r\n\r\n# 記錄檔擁有者與群組為 root 與 syslog\r\nsu root syslog\r\n\r\n# 保留 4 次輪替的記錄檔\r\nrotate 4\r\n\r\n# 輪替之後，自動建立新的記錄檔\r\ncreate\r\n\r\n# 壓縮輪替後的記錄檔\r\ncompress\r\n\r\n# 套用一般套件的記錄檔設定\r\ninclude /etc/logrotate.d\r\n\r\n# ...\r\n```\r\n\r\n個別套件或服務的紀錄檔設定會放在`/etc/logrotate.d` 目錄中，透過這裡的 `include` 來套用個別套件的紀錄檔設定。\r\n\r\n```bash\r\n# nginx 記錄檔輪替設定\r\n/var/log/nginx/*.log { # 記錄檔位置\r\n    daily                # 每日輪替一次\r\n    missingok            # 忽略記錄檔不存在問題\r\n    rotate 14            # 保留 14 次輪替的記錄檔\r\n    compress             # 壓縮輪替後的記錄檔\r\n    delaycompress        # 延遲壓縮記錄檔\r\n    notifempty           # 不輪替空的記錄檔\r\n    create 0640 www-data adm # 記錄檔擁有者/群組為 www-data/adm，權限為 0640\r\n    sharedscripts        # 所有記錄檔輪替，只執行一次 prerotate 與 postrotate 指令稿\r\n    prerotate            # 輪替前指令稿\r\n        if [ -d /etc/logrotate.d/httpd-prerotate ]; then \\\r\n            run-parts /etc/logrotate.d/httpd-prerotate; \\\r\n        fi \\\r\n    endscript\r\n    postrotate           # 輪替後指令稿\r\n        invoke-rc.d nginx rotate >/dev/null 2>&1\r\n    endscript\r\n}\r\n```\r\n\r\n若在個別服務設定中沒有指定的話，就會套用 `/etc/logrotate.conf` 中預設的設定。\r\n\r\n### 基本設定\r\n\r\n| 指令           | 說明                                |\r\n| -------------- | ----------------------------------- |\r\n| su root syslog | 紀錄檔擁有者與群組為 root 與 syslog |\r\n| missingok      | 忽略紀錄檔不存在的問題              |\r\n| notifempty     | 不輪替空檔案                        |\r\n| ifempty        | 輪替空檔案                          |\r\n| rotate 7       | 保留七次輪替紀錄                    |\r\n\r\n### 紀錄檔輪替頻率設定\r\n\r\n| 指令      | 說明            |\r\n| --------- | --------------- |\r\n| daily     | 每日輪替        |\r\n| weekly    | 每週輪替        |\r\n| monthly   | 每月輪替        |\r\n| yearly    | 每年輪替        |\r\n| size 100k | 當檔案超過 100K |\r\n| size 2m   | 當檔案超過 2M   |\r\n| size 1G   | 當檔案超過 1G   |\r\n\r\n進階設定\r\n\r\n| 指令         | 說明                                                            |\r\n| ------------ | --------------------------------------------------------------- |\r\n| minage 3     | 三天以內建立的檔案不輪替                                        |\r\n| maxage 30    | 不保留三十天以前的紀錄檔                                        |\r\n| maxsize 100k | 搭配 daily 等間隔條件使用，檔案超過 100k 或達到間隔條件時輪替   |\r\n| minsize 100k | 搭配 daily 等間隔條件使用，檔案超過 100k 同時達到間隔條件時輪替 |\r\n\r\n### 紀錄檔壓縮\r\n\r\n| 指令            | 說明                 |\r\n| --------------- | -------------------- |\r\n| compress        | 壓縮輪替後的舊紀錄檔 |\r\n| nocompress      | 不壓縮輪替後的檔案   |\r\n| delaycompress   | 延遲壓縮紀錄檔       |\r\n| nodelaycompress | 不延遲壓縮紀錄檔     |\r\n\r\n### 測試 logrotate 設定\r\n\r\n修改完設定後，可以用以下指令測試設定檔是否正確\r\n\r\n```bash\r\n# 測試 logrotate 設定\r\nsudo logrotate -d /etc/logrotate.conf\r\n```\r\n\r\n如果沒出現錯誤訊息，就完成了\r\n\r\nlogrotate 是透過 cron 來觸發的，通常是寫在 /etc/cron.daily/logrotate 中，所以更改 logrotate 設定檔之後，只要確認設定無誤，就會自動生效，不需要重新載入設定檔的動作。\r\n","date":"2023-04-25T01:31:57.265Z","matchingLines":["## ubuntu 檔案結構\r","## 權限\r","## 安裝 php\r","## 安裝 MySQL\r","## nginx\r","## 找不到 sudo\r","## 安裝 composer\r","## 安裝 Git\r","## 安裝 Docker\r","## logrotate 記錄檔管理工具\r"]},{"name":"Carbon 學習筆記.md","content":"# Carbon 學習筆記\r\n\r\n> php 常用處理時間格式的套件\r\n>\r\n> 在 laravel 5.0 之後為預設套件\r\n>\r\n> 底層是使用 PHP `Datetime` 的 `strtotime` 方法\r\n>\r\n> ---\r\n>\r\n> 參考資料：\r\n>\r\n> [Carbon 使用技巧整理 (上)](https://reurl.cc/eWWbLm)\r\n>\r\n> [Carbon 使用技巧整理 (下)](https://reurl.cc/X55rGD)\r\n>\r\n> [Laravel 5 學習筆記 - Carbon 時間套件](https://www.kancloud.cn/kancloud/laravel-5-learning-notes/50163)\r\n\r\n## 目錄\r\n\r\n- [Carbon 學習筆記](#carbon-學習筆記)\r\n  - [目錄](#目錄)\r\n  - [物件建立](#物件建立)\r\n    - [建立當下時間](#建立當下時間)\r\n    - [解析並產生時間物件](#解析並產生時間物件)\r\n    - [依規則建立](#依規則建立)\r\n    - [Bug 與安全模式](#bug-與安全模式)\r\n  - [時間格式(時區、本地化)](#時間格式時區本地化)\r\n    - [本地語系](#本地語系)\r\n    - [Format](#format)\r\n  - [Getter \\& Setter](#getter--setter)\r\n    - [時間屬性](#時間屬性)\r\n    - [時間與語系](#時間與語系)\r\n    - [Setter](#setter)\r\n  - [比較](#比較)\r\n    - [大於、小於和等於](#大於小於和等於)\r\n    - [之間、最小最大與最近最遠](#之間最小最大與最近最遠)\r\n    - [和今天比較](#和今天比較)\r\n  - [時間運算](#時間運算)\r\n    - [Overflow 溢出](#overflow-溢出)\r\n  - [差異](#差異)\r\n    - [一般差異](#一般差異)\r\n    - [Real Difference](#real-difference)\r\n  - [口語化修改器](#口語化修改器)\r\n\r\n## 物件建立\r\n\r\n### 建立當下時間\r\n\r\n```php\r\n$now = new Carbon();\r\n$now = Carbon::now();\r\n$now = new Carbon('first day of January 2022', 'America/Vancouver');  //  2022-01-01 00:00:00.0 America/Vancouver (-08:00)\r\n```\r\n\r\n- 直接建立可以解析文字，且指定時區\r\n\r\n### 解析並產生時間物件\r\n\r\n```php\r\nCarbon::parse('first day of December 2022');    // 2022-12-01 00:00:00.0 UTC (+00:00)\r\nCarbon::parse('2022/4/01');                     // 2022-04-01\r\nCarbon::parse('2022/04/01');                    // 2022-04-01\r\nCarbon::parse('2022-04-01');                    // 2022-04-01\r\n```\r\n\r\n### 依規則建立\r\n\r\n```php\r\nCarbon::create($year, $month, $day, $hour, $minute, $second, $tz);  // 通用變數順序\r\nCarbon::createFromDate($year, $month, $day, $tz);\r\nCarbon::createFromTime($hour, $minute, $second, $tz);\r\nCarbon::createFromTimeStamp('1601735792.198956');                   // 2020-10-03 14:36:32.198956\r\n```\r\n\r\n- 若傳入的資料不完整，亦能產生時間物件，預設為最小值\r\n- 也可以用 `parse` 的方式操作 `create`\r\n- 若不帶值，則會產生 `0001-01-01`\r\n\r\n```php\r\nCarbon::create($year, $month);  // 2020-10-03 00:00:00\r\nCarbon::create('2022/4/01');    // 2022-04-01 00:00:00.0\r\nCarbon::create();               // 0000-01-01\r\n```\r\n\r\n### Bug 與安全模式\r\n\r\n- `createFrom()` 其預設帶值的特性是取的當下時間，因此若在大月的月底使用，容易有跨月的問題\r\n\r\n```php\r\nCarbon::createFromDate(2022, 4);    // 未帶入的參數，會預設為當下的時間\r\n// 當下為 30 號：2022-04-30\r\n// 若為 31 號：2022-05-01\r\n```\r\n\r\n- 使用 `createSafe()` 安全模式建立，會幫忙檢查其合理性。若傳入不合法的數值，會回傳 Exception。\r\n\r\n```php\r\nCarbon::create(2022, 1, 35);        // 2022-02-04\r\nCarbon::createSafe(2022, 1, 35);    //  throw InvalidDateException\r\n```\r\n\r\n## 時間格式(時區、本地化)\r\n\r\n|         單位          | 縮寫 |\r\n| :-------------------: | :--: |\r\n|      年(四位數)       |  Y   |\r\n|      年(二位數)       |  y   |\r\n|       月(英文)        |  F   |\r\n|     月(英文縮寫)      |  M   |\r\n|   月(補 0 至二位數)   |  m   |\r\n|   日(補 0 至二位數)   |  d   |\r\n|          日           |  j   |\r\n|      星期(英文)       |  l   |\r\n|    星期(英文縮寫)     |  D   |\r\n| 星期(英文縮寫 + 逗號) |  r   |\r\n|      星期(數字)       |  w   |\r\n|        時(24)         |  G   |\r\n|        時(12)         |  g   |\r\n| 時(24, 補 0 至二位數) |  H   |\r\n| 時(12, 補 0 至二位數) |  h   |\r\n|          分           |  i   |\r\n|          秒           |  s   |\r\n|         毫秒          |  S   |\r\n|         時區          |  e   |\r\n|         時區          |  T   |\r\n|         時差          |  P   |\r\n|        時間戳         |  U   |\r\n\r\n### 本地語系\r\n\r\n- Laravel 程式預設\r\n\r\n```php\r\n$date = Carbon::now()->locale('zh-tw');\r\n$date->diffForHumans();     // 1 秒前\r\n$date->monthName;           // 十一月\r\n$date->isoFormat('LLLL');   // 2022年11月17日星期四 02:01\r\n```\r\n\r\n- 手動設定\r\n\r\n```php\r\n// 通用設定\r\n$factory = new Factory([\r\n    'locale' => 'zh-tw',\r\n    'timezone' => 'Asia/Taipei'\r\n]);\r\n$factory->now();\r\n\r\n// 暫時設定\r\nCarbon:now()->settings([\r\n    'locale' => 'fr-FR',\r\n    'timezone' => 'Europe/Paris'\r\n]);\r\n```\r\n\r\n### Format\r\n\r\n```php\r\nCarbon::now()->format('Y-m-d H:m:s l');             // 2022-11-17 02:11:55 Thursday\r\nCarbon::now()->translatedFormat('Y-m-d H:m:s l');   // 2022-11-17 02:11:55 星期四\r\n```\r\n\r\n- 除了利用 `format()` 輸出時間格式，也可以使用 `toDateString()`, `toTimeString()`, `toISOString()` 等方法，將時間物件轉換成字串，亦有提供 `toArray()`, `toObject()` 方法。\r\n\r\n```php\r\nCarbon::hasFormat('2022-11-11', 'Y-m-d')                // true\r\nCarbon::hasFormat('2022~11~11', 'Y~m~d')                // true\r\nCarbon::hasFormatWithModifiers('2022-11-11', 'Y#m#d')   // true\r\nCarbon::hasFormatWithModifiers('2022/11/11', 'Y#m#d')   // true\r\nCarbon::hasFormatWithModifiers('2022~11~11', 'Y#m#d')   // false\r\n```\r\n\r\n- 利用 `hasFormat()` 來判斷 `format` 格式\r\n- `hasFormatWithModifiers()` 為模糊比對，可以用 `#` 區隔時間縮碼，可以同時判斷 `/`, `-`\r\n\r\n## Getter & Setter\r\n\r\n### 時間屬性\r\n\r\n```php\r\n$date = Carbon::parse('2022-02-28');\r\n$date->year;        // 2022\r\n$date->month;       // 2\r\n$date->dayOfYear;   // 59\r\n$date->dayOfMonth;  // 28\r\n```\r\n\r\n### 時間與語系\r\n\r\n- 判斷時間事件的語系有沒有符合應用程式，及有沒有使用 UTC 國際標準時區\r\n\r\n```php\r\nCarbon::now()->local;                       // bool(true)，檢查時區符合應用程式\r\nCarbon::now('America/Vancouver')->local;    // bool(false)\r\nCarbon::now()->utc;                         // bool(false)，檢查標準時區\r\n```\r\n\r\n### Setter\r\n\r\n- 直接依單位設定時間\r\n\r\n```php\r\n$date = Carbon::now();\r\n$date->setYear(2005);\r\n$date->year;           // 2005\r\n```\r\n\r\n```php\r\n$sourcel = new Carbon('2010-05-16 22:40:10.1');\r\n$date-> new Carbon('2001-01-01 01:01:01.2');\r\n$date->setTimeFrom($sourcel);   // 2001-01-01 22:40:10\r\n```\r\n\r\n- `setTimeFrom()` 保持日期，只設定時分秒\r\n- `setDateFrom()`\r\n- `setDateTimeFrom()`\r\n- **注意！以上作法不會改變時區**\r\n\r\n## 比較\r\n\r\n### 大於、小於和等於\r\n\r\n```php\r\n$first = Carbon::create(2022, 11, 11, 0, 0, 0);\r\n$second = Carbon::create(2022, 11, 11, 0, 0, 0, 'America/Vancouver'); // 時區設定\r\n\r\n$first->equalTo($second); // false\r\n$first->notEqualTo($second); // true\r\n```\r\n\r\n```php\r\n$first = Carbon::parse('2022-11-11 00:00:00');\r\n$second = Carbon::parse('2022-11-11 12:00:00');\r\n\r\n$first->greaterThan($second);           // false  大於\r\n$first->greaterThanOrEqualTo($second);  // false 大於等於\r\n$first->gt($second);                    // 可以使用縮寫\r\n$first->gte($second);\r\n$first >= $second;                      // 也可以使用運算式\r\n\r\n$first->lessThan($second);              // true  小於\r\n$first->lessThanOrEqualTo($second);     // true 小於等於\r\n$first->lt($second);\r\n$first->lte($second);\r\n$first <= $second;\r\n\r\n$first>equalTo($second);                // false 等於\r\n$first>notEqualTo($second);             // true 不等於\r\n```\r\n\r\n### 之間、最小最大與最近最遠\r\n\r\n```php\r\n$first = Carbon::parse('2022-11-11');\r\n$second = Carbon::parse('2022-11-15');\r\n$data = Carbon::parse('2022-11-15');\r\n$data->between($first, $second);        // true\r\n$data->between($first, $second, false); // 嚴格模式 false\r\n```\r\n\r\n```php\r\n$first = Carbon::parse('2022-11-11');\r\n$second = Carbon::parse('2022-11-15');\r\n\r\n$first->min($second);   // '2022-11-11'\r\n$first->max($second);   // '2022-11-15'\r\n\r\n$data = Carbon::parse('2022-11-14');\r\n$data->closest($first, $second);    // 2022-11-15\r\n$data->farthest($first, $second);   // 2022-11-11\r\n```\r\n\r\n- `closest` 和 `farthest` 函式可以找出兩個時間物件中，與特定時間物件最接近或最遙遠的物件\r\n\r\n### 和今天比較\r\n\r\n```php\r\n// 假設今天是 2022-11-10\r\n$date = Carbon::parse('2022-11-11');\r\n\r\n$date->isSameWeek();    // true\r\n$date->isSameMonth();   // true\r\n$date->isCurrentDay();  // false\r\n```\r\n\r\n- 另外還有 `isMonday()` `isTomorrow()` `isToday()`，`isBirthday()` 可以判斷是否為不同年的同一天\r\n\r\n## 時間運算\r\n\r\n**重要觀念**：carbon 物件在運算過程中會改變原始物件，因此在運算之前要加上 `copy()` 語法。\r\n\r\n```php\r\n$date = Carbon::create(2022, 11, 11);\r\n$date->copy()->addDay();    // 2022-11-12\r\n// 複數運算，時間單位要加上 s\r\n$date->addDays(2);          // 2022-11-13\r\nprint_r($date);             // 2022-11-13\r\n\r\n$date->copy()->subDay(); // 2022-11-12\r\n```\r\n\r\n### Overflow 溢出\r\n\r\n```php\r\n$date = Carbon::create(2022, 1, 31);\r\n$date->copy()->addMonth(); // 2022-03-03\r\n```\r\n\r\n- 一般而言，加上一個月後應該要是二月底(2/28 或 2/29)，為避免不合理的狀況發生，須加上 `NoOverflow` 關鍵字，讓運算結果不會溢出\r\n\r\n```php\r\n$date = Carbon::create(2022, 1, 31);\r\n$date->copy()->addMonthNoOverflow(); // 2022-02-28\r\n$date->copy()->subMonthNoOverflow(2); // 2022-11-30\r\n```\r\n\r\n另外亦可以使用 `addUnitNoOverflow` 針對溢出的單位做控管，也可以在設定值，規定不可以溢出\r\n\r\n```php\r\n$date = Carbon::parse('2022-01-31');\r\n\r\n// UnitNoOverflow(運算單位，值，限制防溢出單位)\r\n$date->copy()->addUnitNoOverflow('hour', 7, 'day') // 07:00\r\n$date->copy()->addUnitNoOverflow('hour', 48, 'day') // 23:59\r\n\r\nCarbon::parse('2022-02-01')->copy()->setUnitNoOverflow('day', 31, 'month'); // 2022-02-28\r\n```\r\n\r\n## 差異\r\n\r\n### 一般差異\r\n\r\n- 無條件捨去，滿一個時間單位，才會回傳 1\r\n\r\n```php\r\n$date->diffInMinths($date->copy()->addMonthNoOverflow()); // 1\r\n```\r\n\r\n- 除了整數的差異，也可以比對到小數點單位的時間差\r\n\r\n```php\r\nCarbon::parse('06:01:23')->floatDiffInminutes('06:02:34');              // 1.1833\r\nCarbon::parse('2022-01-01 12:00')->floatDiffInDays('2022-02-11 06:00')  // 40.75\r\n```\r\n\r\n- 不建議用做計算月份，會有 bug\r\n\r\n```php\r\nCarbon::parse('2022-01-31')->floatDiffInmonthss('2022-03-01');\r\n// 一般而言應回傳 1.xx，但實際回傳 0.9xx 因為跨到二月不足三十天\r\n```\r\n\r\n### Real Difference\r\n\r\n```php\r\n$date = new Carbon('2014-03-30 00:00:00', 'Europe/London');]\r\n$date->addRealHours(25);      // 2014-03-31 02:00:00.0 Europe/London (+01:00)\r\n\r\n$date->diffInRealHours('2014-03-30 00:00:00');  // 25\r\n$date->diffInHours('2014-03-30 00:00:00');      // 26\r\n```\r\n\r\n- 運算時，若出現跨日的情形，時間物件的時區會自動針對該值做增減，而在比較兩個時間點的差異時，若未用 `real` 則會計算出表面的時間差。\r\n\r\n## 口語化修改器\r\n\r\n```php\r\n$date = Carbon::parse('2022-11-11 12:00:00');\r\n$date->startOfDay();    // 2022-11-11 00:00:00\r\n$date->endOfDay();      // 2022-11-11 23:59:59\r\n\r\n$date->startOfMonth();  // 2022-11-01 00:00:00\r\n$date->endOfMonth();    // 2022-11-30 23:59:59\r\n```\r\n\r\n- 亦支援 `today()`, `yesterday()`, `next()`\r\n","date":"2023-04-20T03:52:14.997Z","matchingLines":["## 目錄\r","## 物件建立\r","## 時間格式(時區、本地化)\r","## Getter & Setter\r","## 比較\r","## 時間運算\r","## 差異\r","## 口語化修改器\r"]},{"name":"JavaScript 物件.md","content":"# JavaScript 物件\r\n\r\n> 物件(object)類型是電腦程式的一種資料類型，用抽象化概念來比喻人類現實世界中的物體。\r\n>\r\n> 在 javascript 中，除了原始的資料類型(數字、字串、布林等等)，所有的資料類型都是物件。不過 javascript 的物件與其他目前流行的物件導向程式語言有明顯不同，他一開始是使用原型基礎(prototype-based)的設計，而其他的物件導向程式語言，大部分都是使用類別基礎(class-based)的設計。\r\n>\r\n> 物件在 javascript 中可以分為兩種應用層面：\r\n>\r\n> - 主要用於資料的描述，他扮演類似關聯陣列的資料結構，儲存 key value 的成對資料。常見到用陣列中包含物件資料來代表複數的資料集合。\r\n> - 主要用於物件導向的程式設計，可以設計出各種的物件，其中包含各種方法，就像已經介紹過的各種包裝物件，如：字串、陣列等等的包裝物件。\r\n>   物件類型使用以屬性與方法為主要組成部分，這兩種和稱為物件成員(member)`:\r\n>\r\n> - 屬性：物件基本可被描述的量化資料。例如水果這個物件包含：顏色、產地、大小、重量、甜度等等屬性\r\n> - 方法：物件的可被反應動作或行為。例如車子這個物件，他的行為有加速、剎車、轉彎、打方向燈等行為或可執行的動作。\r\n\r\n## 物件定義的方式\r\n\r\n### 物件字面(Object Literals)\r\n\r\n用於資料描述的物件定義，使用大括號(`{}`)作為宣告區域，其中加入無關順序的\"key-value\"成對值，屬性的值可以是任何合法的值，可以包括陣列、函式、或其他物件。\r\n\r\n而在物件定義中的\"key-value\"，如果是一般的值的情況，稱為`屬性(property/prop)`，如果是一個函式，稱之為`方法(method)`。屬性與方法我們通常和稱為物件中的`(member)`。\r\n\r\n```javascript\r\nconst emptyObject = {};\r\n\r\nconst player = {\r\n  fullName: \"ivan\",\r\n  age: 16,\r\n  gender: \"man\",\r\n  hairColor: \"black\",\r\n};\r\n```\r\n\r\n在定義與獲取值方面，物件和陣列的情況相當類似。\r\n\r\n```javascript\r\nconst aArray = [];\r\nconst aObject = {};\r\n\r\nconst bArray = [\"foo\", \"bar\"];\r\nconst bObject = {\r\n  firstKey: \"foo\",\r\n  secondKey: \"bar\",\r\n};\r\n\r\nbArray[2] = \"yes\";\r\nbObject.thirdKey = \"yes\";\r\n\r\nconsole.log(bArray[2]); //yes\r\nconsole.log(bObject.thirdKey); //yes\r\n```\r\n\r\n不過，對於陣列的有序索引值，而且只有索引值的情況，我們更加關心物件中`key`的存在。\r\n物件中的 member(屬性與方法)，都是使用物件上加點`.`符號來獲取。\r\n\r\n## 類別(class)\r\n\r\n類別是先裡面定義好物件的整體結構藍圖，然後再用這個類別定義，來產生相同結構的東個物件實例，類別在定義時不會直接產生出物件，要經過實例化的過程(new 關鍵字)，才會產生真正的物件實例。另外，目前因為類別定義方式還是很新的語法，在實作時，除了比較新的函式庫或框架，才會開始使用他來撰寫。\r\n\r\n```javascript\r\nclass Player {\r\n  constructor(fullName, age, gender, hairColor) {\r\n    this.fullName = fullName;\r\n    this.age = age;\r\n    this.gender = gender;\r\n    this.hairColor = hairColor;\r\n  }\r\n\r\n  toString() {\r\n    return \"Name: \" + this.fullName + \", Age:\" + this.age;\r\n  }\r\n}\r\n\r\nconst inori = new Player(\"Inori\", 16, \"girl\", \"pink\");\r\nconsole.log(inori.toString());\r\nconsole.log(inori.fullName);\r\n\r\nconst tsugumi = new Player(\"Tsugumi\", 14, \"girl\", \"purple\");\r\nconsole.log(tsugumi.toString());\r\n```\r\n\r\n### this\r\n\r\n在這個物件的類別定義中，我們第一次見識到 this 關鍵字的用法，this 簡單來說，是物件實體專屬的指向變數，this 指向的就是\"這個\"物件實體。以上面的例子：當物件真正實體化時，this 變數會指向這個物件實體。this 是怎麼知道要指向哪一個物件實體？是因為 new 關鍵字造成的結果。\r\n\r\nthis 變數是 javascript 的一個特性，他是隱藏的內部變數之一，當函式呼叫或是物件實體化時，都會以這個 this 變數的指向對象作為執行期間的依據。\r\n\r\nthis 呼叫的情境：\r\n\r\n1. 函式呼叫：在一般情況下的函式呼叫，this 通常都會指向全域物件(global object)\r\n2. 建構式呼叫(construct)：透過 new 將物件實例化，等於呼叫類型的建構式，this 會指向新建立的物件實例\r\n3. 物件中的方法呼叫：this 指向呼叫這個方法的物件實體\r\n\r\n所以當建構式呼叫時，也就是使用 new 運算福建立物件時，this 會指向新建立的物件實例，也就是下面這段程式碼：\r\n\r\n```javascript\r\nconst ivan = new Player(\"ivan\", 16, \"boy\", pink);\r\n```\r\n\r\n因此在建構式中的指定值的語句，裡面的 this 值就會指向是這個新建立的物件，也就是`ivan`：\r\n\r\n```javascript\r\nconstructor(fullName, age, gender, hairColor) {\r\n        this.fullName = fullName\r\n        this.age = age\r\n        this.gender = gender\r\n        this.hairColor = hairColor\r\n    }\r\n```\r\n\r\n也就是說，在建立物件後，經建構式的執行語句，這個`ivan`物件中的屬性值就會被指定完成，所以可以用下面的語法來存取屬性：\r\n\r\n```javascript\r\nivan.fullName\r\nivan.age\r\nivan.gender\r\nivan.hairColor\r\n```\r\n\r\n第三種情況是呼叫物件中的方法，也就是向下面的 code，this 會指向這個呼叫 toString 方法的物件，也就是 ivan\r\n\r\n```javascript\r\nivan.toString();\r\n```\r\n","date":"2023-03-23T09:04:57.849Z","matchingLines":["## 物件定義的方式\r","## 類別(class)\r"]},{"name":"Laravel 實作權限.md","content":"# Laravel 實作權限\r\n\r\n## Gates\r\n\r\n### 使用者角色\r\n\r\n將使用者區分為:\r\n\r\n- 系統管理者: admin\r\n- 一般管理者: manager\r\n- 一般使用者: user\r\n\r\n編輯`app/User.php`，加入帳號角色名稱常數，並將`role`欄位加入 `fillable` 中\r\n\r\n```php\r\nclass User extends Authenticatable\r\n{\r\n    // ...\r\n\r\n    const ROLE_ADMIN = 'admin';\r\n    const ROLE_MANAGER = 'manager';\r\n    const ROLE_USER = 'user';\r\n\r\n    protected $fillable = [\r\n        'name', 'email', 'password', 'role',\r\n    ];\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n### 資料庫 migration\r\n\r\n建立一個 `migration` 設定檔，在 `users` 資料表中加入儲存帳號角色的 `role` 欄位\r\n\r\n```php\r\nclass AddRoleColumnToUsersTable extends Migration\r\n{\r\n    /**\r\n     * Run the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function up()\r\n    {\r\n        Schema::table('users', function (Blueprint $table) {\r\n            $table->string('role')->default(Admin::ROLE_USER);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reverse the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function down()\r\n    {\r\n        Schema::table('users', function (Blueprint $table) {\r\n            $table->dropColumn('role');\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n修改完成後，執行 migrate\r\n\r\n### 使用者註冊 Controller\r\n\r\n編輯`app/Http/Controllers/Auth/RegisterController.php`，設定使用者註冊時，預設角色為一般使用者\r\n\r\n```php\r\nprotected function create(array $data)\r\n{\r\n    return User::create([\r\n        'name' => $data['name'],\r\n        'email' => $data['email'],\r\n        'password' => Hash::make($data['password']),\r\n        'role' => User::ROLE_USER,  // 預設為一般使用者\r\n    ]);\r\n}\r\n```\r\n\r\n### 建立 Gate 規則權限\r\n\r\n編輯`app/Providers/AuthServiceProvider.php`，加入自訂的 Gates 規則\r\n\r\n```php\r\nuse App\\User;\r\n\r\nclass AuthServiceProvider extends ServiceProvider\r\n{\r\n    // ..\r\n\r\n    public function boot()\r\n    {\r\n        $this->registerPolicies();\r\n\r\n        // 系統管理者 Gate 規則\r\n        Gate::define('admin', function ($user) {\r\n            return $user->role === User::ROLE_ADMIN;\r\n        });\r\n\r\n        // 一般管理者 Gate 規則\r\n        Gate::define('manager', function ($user) {\r\n            return $user->role === User::ROLE_MANAGER;\r\n        });\r\n\r\n        // 一般使用者 Gate 規則\r\n        Gate::define('user', function ($user) {\r\n            return $user->role === User::ROLE_USER;\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n### 在 Blade 運用 Gate 權限設定\r\n\r\n在 Blade 樣板中可以運用 `@can`、`@cannot` 或 `@canany` 來判斷使用者的權限\r\n\r\n```php\r\n@can('admin')\r\n    <!-- 系統管理者 -->\r\n@elsecan('manager')\r\n    <!-- 一般管理者 -->\r\n@else\r\n    <!-- 一般使用者 -->\r\n@endcan\r\n```\r\n\r\n### Controller 運用 Gate 權限設定\r\n\r\n在 Controller 中則可使用 `Gate::allows` 或 `Gate::denies` 判斷使用者權限\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Gate;\r\n\r\nclass Controller extends BaseController\r\n{\r\n    // ...\r\n\r\n    public function someAction()\r\n    {\r\n        if (Gate::allows('admin')) {\r\n            return '系統管理者。';\r\n        }\r\n\r\n        if (Gate::denies('admin')) {\r\n            return '非系統管理者！';\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n運用 `authorize` 直接限制整個函數的執行權限\r\n\r\n```php\r\nclass Controller extends BaseController\r\n{\r\n    // ...\r\n\r\n    // 只有系統管理者可以執行\r\n    public function adminAction()\r\n    {\r\n        $this->authorize('admin');\r\n\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n### Middleware 運用 Gate 權限設定\r\n\r\n應用在 Route\r\n\r\n```php\r\n// 只有系統管理者可以執行\r\nRoute::get('/someAction', 'MyController@someAction') -> middleware('can:admin');\r\n```\r\n\r\n## Policy\r\n\r\n可以針對一個 Model 或資源實作限制權限\r\n\r\n```php\r\nphp artisan make:policy PostPolicy --model=Post\r\n```\r\n\r\n到`app/Providers/AuthServiceProvider`註冊剛建立好的 Policy\r\n\r\n```php\r\nprotected $policies = [\r\n    // 'App\\Model' => 'App\\Policies\\ModelPolicy',\r\n    Post::class => PostPolicy::class,\r\n];\r\n```\r\n\r\n到`app/Policies/PostPolicy`修改條件\r\n\r\n```php\r\npublic function update(User $user, Post $post)\r\n{\r\n    return $user->id === $post->user_id;\r\n}\r\n```\r\n","date":"2023-03-09T06:53:16.903Z","matchingLines":["## Gates\r","## Policy\r"]},{"name":"Laravel Collections & Helper.md","content":"# Laravel Collections & Helper\r\n\r\n- [Laravel Collections \\& Helper](#laravel-collections--helper)\r\n  - [Collections 集合](#collections-集合)\r\n    - [運算類](#運算類)\r\n      - [Integer](#integer)\r\n        - [`count()` 計數](#count-計數)\r\n      - [Boolean](#boolean)\r\n        - [`contains()` 判斷集合是否包含指定的條件](#contains-判斷集合是否包含指定的條件)\r\n      - [Array](#array)\r\n        - [`diff()` 比較集合或陣列的值](#diff-比較集合或陣列的值)\r\n    - [迭代類](#迭代類)\r\n      - [`filter()` 傳入匿名函式篩選集合](#filter-傳入匿名函式篩選集合)\r\n      - [`map()` 遍歷集合](#map-遍歷集合)\r\n    - [分組類](#分組類)\r\n      - [`countBy()` 計算指定數值](#countby-計算指定數值)\r\n    - [變形類](#變形類)\r\n      - [維度與順序](#維度與順序)\r\n        - [`collapse()` , `flatten()`](#collapse--flatten)\r\n        - [`sort()` 將陣列重新排列](#sort-將陣列重新排列)\r\n      - [組合](#組合)\r\n        - [`combine()` 將一個集合的值作為 key，用來和另一陣列或集合的值進行組合](#combine-將一個集合的值作為-key用來和另一陣列或集合的值進行組合)\r\n        - [`merge()` 合併指定的陣列或是集合到原集合](#merge-合併指定的陣列或是集合到原集合)\r\n        - [`concat()` 將傳入的值追加到集合的末端](#concat-將傳入的值追加到集合的末端)\r\n        - [`push()` 把指定的值加入集合的末端](#push-把指定的值加入集合的末端)\r\n        - [`prepend()` 將指定的值加入集合的開頭](#prepend-將指定的值加入集合的開頭)\r\n      - [擷取](#擷取)\r\n        - [`except()` 擷取除了 a, b 以外的](#except-擷取除了-a-b-以外的)\r\n        - [`only()` 只擷取 a, b](#only-只擷取-a-b)\r\n        - [`get()` 取得特定 key 的值](#get-取得特定-key-的值)\r\n        - [`forget()` 直接刪除指定 key 值對應的 value](#forget-直接刪除指定-key-值對應的-value)\r\n        - [`pull()` 和 `get()` 雷同，會修改原本的 collection](#pull-和-get-雷同會修改原本的-collection)\r\n        - [`pluck()` 取得集合中所有陣列的 key 值](#pluck-取得集合中所有陣列的-key-值)\r\n        - [`intersect` 從原集合中移除在指定陣列中或集合中不存在的值](#intersect-從原集合中移除在指定陣列中或集合中不存在的值)\r\n        - [`keys()`, `values()` 取出集合中的 key 或 value](#keys-values-取出集合中的-key-或-value)\r\n      - [轉型](#轉型)\r\n        - [`toArray()`, `toJson()` 提供轉成陣列或是 json 等常用格式](#toarray-tojson-提供轉成陣列或是-json-等常用格式)\r\n    - [Where](#where)\r\n      - ['first' 返回陣列中指令條件的第一元素](#first-返回陣列中指令條件的第一元素)\r\n    - [軟體操作類](#軟體操作類)\r\n      - [`collect()` 複製一個新的 collection，記憶體位置不衝突](#collect-複製一個新的-collection記憶體位置不衝突)\r\n  - [Helper 輔助函數](#helper-輔助函數)\r\n    - [`Arr::add()` 將數值加入陣列](#arradd-將數值加入陣列)\r\n    - [`after()` 返回傳入的字串的值後面所有的內容](#after-返回傳入的字串的值後面所有的內容)\r\n\r\n## Collections 集合\r\n\r\n> 參考資料\r\n>\r\n> [Laravel — Collection 用途大解析](https://medium.com/johnliu-%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%80%9D%E7%B6%AD/laravel-collection-%E7%94%A8%E9%80%94%E5%A4%A7%E8%A7%A3%E6%9E%90-1e2dbc6e2c93)\r\n\r\n### 運算類\r\n\r\n方便進行數學運算，或是判斷是否含有特定值，也能比較兩個 collection 之間的不同\r\n\r\n#### Integer\r\n\r\n##### `count()` 計數\r\n\r\n```php\r\n$collection = collect([1, 2, 3, 4]);\r\n\r\n$collection->count();\r\n\r\n// 4\r\n```\r\n\r\n#### Boolean\r\n\r\n##### `contains()` 判斷集合是否包含指定的條件\r\n\r\n傳入值\r\n\r\n```php\r\n$collection = collect(['name' => 'Desk', 'price' => 100]);\r\n\r\n$collection->contains('Desk');\r\n\r\n// true\r\n\r\n$collection->contains('New York');\r\n\r\n// false\r\n```\r\n\r\n傳入陣列\r\n\r\n```php\r\n$collection = collect([\r\n    ['product' => 'Desk', 'price' => 200],\r\n    ['product' => 'Chair', 'price' => 100],\r\n]);\r\n\r\n$collection->contains('product', 'Bookcase');\r\n\r\n// false\r\n```\r\n\r\n傳遞匿名函數\r\n\r\n```php\r\n$collection = collect([1, 2, 3, 4, 5]);\r\n\r\n$collection->contains(function ($value, $key) {\r\n    return $value > 5;\r\n});\r\n\r\n// false\r\n```\r\n\r\n- `containsStrict()` 方法和 `contains()` 類似，但他在比較時更嚴格。\r\n\r\n#### Array\r\n\r\n##### `diff()` 比較集合或陣列的值\r\n\r\n返回不存在此方法參數中的值\r\n\r\n```php\r\n$diff = collect([1, 2, 3, 4, 5])->diff([2, 4, 6, 8]);\r\n$diff->all();\r\n\r\n// 返回[1, 3, 5]，原集合內與diff方法中相同的數值被剔除。\r\n```\r\n\r\n### 迭代類\r\n\r\n#### `filter()` 傳入匿名函式篩選集合\r\n\r\n返回通過篩選的項目\r\n\r\n```php\r\n$filtered = collect([1, 2, 3, 4])->filter(function (item) {\r\n    return $item > 2\r\n});\r\n\r\n$filtered->all();\r\n\r\n// [3, 4]\r\n```\r\n\r\n#### `map()` 遍歷集合\r\n\r\n將集合的值透過傳入的匿名函數修改並返回，生成修改過的新集合\r\n\r\n```php\r\n$collection = collect([1, 2, 3, 4, 5]);\r\n\r\n$multiplied = $collection->map(function ($item, $key) {\r\n    return $item * 2;\r\n});\r\n\r\n$multiplied->all();\r\n\r\n// [2, 4, 6, 8, 10]\r\n```\r\n\r\n### 分組類\r\n\r\n#### `countBy()` 計算指定數值\r\n\r\n```php\r\n$collection = collect([1, 2, 2, 2, 3]);\r\n\r\n$counted = $collection->countBy();\r\n\r\n$counted->all();\r\n\r\n// [1 => 1, 2 => 3, 3 => 1]\r\n```\r\n\r\n可以傳入匿名函數來自訂要計數的值\r\n\r\n```php\r\n$collection = collect(['alice@gmail.com', 'bob@yahoo.com', 'carlos@gmail.com']);\r\n\r\n$counted = $collection->countBy(function ($email) {\r\n    return substr(strrchr($email, \"@\"), 1);\r\n});\r\n\r\n$counted->all();\r\n\r\n// ['gmail.com' => 2, 'yahoo.com' => 1]\r\n```\r\n\r\n### 變形類\r\n\r\n將 collection 改變資料結構\r\n\r\n#### 維度與順序\r\n\r\n##### `collapse()` , `flatten()`\r\n\r\n兩者都是將維度從多維降為一維，collapse 較適用 Array 形式的資料，flatten 更適合有 Key-Value 形式的資料。\r\n兩個函式的用途，都是將例如 [[1,2,3], [4,5,6]] 轉變成 [1,2,3,4,5,6]\r\n\r\n##### `sort()` 將陣列重新排列\r\n\r\n```php\r\nuse Illuminate\\Support\\Arr;\r\n\r\n$array = ['Desk', 'Table', 'Chair'];\r\n\r\n$sorted = Arr::sort($array);\r\n\r\n// ['Chair', 'Desk', 'Table']\r\n```\r\n\r\n根據傳入匿名函數返回的結果，對陣列進行排序\r\n\r\n```php\r\nuse Illuminate\\Support\\Arr;\r\n\r\n$array = [\r\n    ['name' => 'Desk'],\r\n    ['name' => 'Table'],\r\n    ['name' => 'Chair'],\r\n];\r\n\r\n$sorted = array_values(Arr::sort($array, function ($value) {\r\n    return $value['name'];\r\n}));\r\n\r\n/*\r\n    [\r\n        ['name' => 'Chair'],\r\n        ['name' => 'Desk'],\r\n        ['name' => 'Table'],\r\n    ]\r\n*/\r\n```\r\n\r\n利用 key 值替陣列排序\r\n\r\n```php\r\n$list = [\r\n  5 => 1\r\n  4 => 2\r\n  2 => 4\r\n  1 => 5\r\n  6 => 6\r\n];\r\n\r\nArr::sort($list, function ($value, $key) {\r\n    return $key;\r\n})\r\n```\r\n\r\n輸出\r\n\r\n```log\r\narray:5 [\r\n  1 => 5\r\n  2 => 4\r\n  4 => 2\r\n  5 => 1\r\n  6 => 6\r\n]\r\n```\r\n\r\n#### 組合\r\n\r\n##### `combine()` 將一個集合的值作為 key，用來和另一陣列或集合的值進行組合\r\n\r\n```php\r\n$collection = collect(['name', 'age']);\r\n\r\n$combined = $collection->combine(['George', 29]);\r\n\r\n$combined->all();\r\n\r\n// ['name' => 'George', 'age' => 29]\r\n```\r\n\r\n##### `merge()` 合併指定的陣列或是集合到原集合\r\n\r\n若傳入的集合中的 key 值與原集合中的 key 值相同，則傳入的值將會將原集合中的值覆蓋。\r\n\r\n```php\r\n$collection = collect(['product_id' => 1, 'price' => 100]);\r\n\r\n$merged = $collection->merge(['price' => 200, 'discount' => false]);\r\n\r\n$merged->all();\r\n\r\n// ['product_id' => 1, 'price' => 200, 'discount' => false]\r\n```\r\n\r\n若傳入的集合項為數字，則這些值將會追加在集合的最後面。\r\n\r\n```php\r\n$collection = collect(['Desk', 'Chair']);\r\n\r\n$merged = $collection->merge(['Bookcase', 'Door']);\r\n\r\n$merged->all();\r\n\r\n// ['Desk', 'Chair', 'Bookcase', 'Door']\r\n```\r\n\r\n##### `concat()` 將傳入的值追加到集合的末端\r\n\r\n```php\r\n$collection = collect(['John Doe']);\r\n\r\n$concatenated = $collection->concat(['Jane Doe'])->concat(['name' => 'Johnny Doe']);\r\n\r\n$concatenated->all();\r\n\r\n// ['John Doe', 'Jane Doe', 'Johnny Doe']\r\n```\r\n\r\n##### `push()` 把指定的值加入集合的末端\r\n\r\n```php\r\n$collection = collect([1, 2, 3, 4]);\r\n$collection->push(5);\r\n$collection->all();\r\n\r\n// [1, 2, 3, 4, 5]\r\n```\r\n\r\n##### `prepend()` 將指定的值加入集合的開頭\r\n\r\n```php\r\n$collection = collect([1, 2, 3, 4, 5]);\r\n\r\n$collection->prepend(0);\r\n\r\n$collection->all();\r\n\r\n// [0, 1, 2, 3, 4, 5]\r\n```\r\n\r\n#### 擷取\r\n\r\n##### `except()` 擷取除了 a, b 以外的\r\n\r\n##### `only()` 只擷取 a, b\r\n\r\n##### `get()` 取得特定 key 的值\r\n\r\n##### `forget()` 直接刪除指定 key 值對應的 value\r\n\r\n##### `pull()` 和 `get()` 雷同，會修改原本的 collection\r\n\r\n##### `pluck()` 取得集合中所有陣列的 key 值\r\n\r\n```php\r\n$collection = collect([\r\n    ['product_id' => 'prod-100', 'name' => 'Desk'],\r\n    ['product_id' => 'prod-200', 'name' => 'Chair'],\r\n])\r\n\r\n$picked = $collection->pluck('name');\r\n\r\n$pluck->all();\r\n\r\n// ['Desk', 'Chair']\r\n```\r\n\r\n##### `intersect` 從原集合中移除在指定陣列中或集合中不存在的值\r\n\r\n```php\r\n$collection = collect(['a', 'b', 'c']);\r\n$intersect = $collection->intersect(['a', 'c', 'e', 'f']);\r\n$intersect->all(); // [0 => 'a', 2 => 'c']\r\n```\r\n\r\n##### `keys()`, `values()` 取出集合中的 key 或 value\r\n\r\n#### 轉型\r\n\r\n##### `toArray()`, `toJson()` 提供轉成陣列或是 json 等常用格式\r\n\r\n### Where\r\n\r\ncollection 和 laravel 本身的 ORM 系統 Eloquent 密不可分，因此也配合支援許多 where 語法，使用方法類似 MySQL。\r\n\r\n#### 'first' 返回陣列中指令條件的第一元素\r\n\r\n```php\r\ncollect([1, 2, 3, 4, 5, 6])->first(function ($value, $key) {\r\n    return $value > 2;\r\n});\r\n\r\n// 3\r\n```\r\n\r\n若 `first` 方法不傳入參數，則返回集合中第一元素。若集合為空，則返回 `null`\r\n\r\n```php\r\ncollect([1, 2])->first();\r\n\r\n// 1\r\n```\r\n\r\n### 軟體操作類\r\n\r\n#### `collect()` 複製一個新的 collection，記憶體位置不衝突\r\n\r\n## Helper 輔助函數\r\n\r\n### `Arr::add()` 將數值加入陣列\r\n\r\n```php\r\nuse Illuminate\\Support\\Arr;\r\n\r\n$array = Arr::add(['name' => 'Desk'], 'price', 100);\r\n\r\n// ['name' => 'Desk', 'price' => 100]\r\n\r\n$array = Arr::add(['name' => 'Desk', 'price' => null], 'price', 100);\r\n\r\n// ['name' => 'Desk', 'price' => 100]\r\n\r\n```\r\n\r\n### `after()` 返回傳入的字串的值後面所有的內容\r\n\r\n如果傳入的值不存在，將返回整個字串\r\n\r\n```php\r\nuse Illuminate\\Support\\Str;\r\n\r\n$slice = Str::of('This is my name')->after('This is');\r\n\r\n// ' my name'\r\n```\r\n","date":"2023-02-21T02:04:17.045Z","matchingLines":["## Collections 集合\r","## Helper 輔助函數\r"]},{"name":"語意化版本.md","content":"# 語意化版本\r\n\r\n> 參考資料：\r\n>\r\n> [語意化版本 2.0.0](https://semver.org/lang/zh-TW/)\r\n\r\n## 摘要\r\n\r\n版本格式：主板號.次版號.修訂號，版號遞增規則如下：\r\n\r\n1. 主板號：當推出一個不相容的 API 修改。\r\n2. 次版號：當推出一個向下相容的功能性新增。\r\n3. 修訂號：當推出一個向下相容的問題修正。\r\n\r\n先行版號及版本編譯資訊可以加到 \"主版本號.次版本號.修訂號\" 的後面作為延伸。\r\n\r\n## 簡介\r\n\r\n當系統規模越大，加入的套件越多，就越有可能在未來的某一天發現自己身陷絕望之中。\r\n\r\n再相依性高的系統中發佈新版本套件，可能很快就會變成惡夢。如果相依性關係過高，可能面臨版本控制被鎖死的風險(必須對每一個相依套件改版，才能完成某次升級)。而如果相依性過於鬆散\r\n，又將無法避免版本混亂(假設相容於未來的多個版本已超出合理數量)。當你專案的進展因為版本相依被鎖死或版本混亂變得不夠簡便和可靠，就意味你正處於相依性地獄中。\r\n\r\n而語意化版本就是這個問題的解決方案之一。這些規則是根據(但不局限於)各種已經封閉、開放源碼軟體所廣泛應用的慣例所設計。為了讓這套理論運作，你必須先定義好的公共 API。這可以透過文件定義或程式碼強制要求來實限。無論如何，這套 API 的清楚明瞭是十分重要的。一旦你定義了公共 API。這可以透過修改相應的版號來向大家說明你的修改。考慮使用這樣的版號格式：X.Y.Z(主版號.次版號.修訂號)修復問題但不影響 API 時，遞增修訂號；API 保持向下相容的新增修改時，地增次版號；進行不向下相同的修改時，遞增主版號。\r\n\r\n## 語意版本控制規範\r\n\r\n1. 使用語意化版本控制的軟體必須(MUST)定義公共 API。該 API 可以在程式碼中被定義出來或出現於嚴謹的文件內。無論何種形式都應該(SHOULD)力求精確且完整。\r\n2. 標準的版號必須(MUST)採用 X.Y.Z 格式，其中 X、Y 和 Z 為非負的整數，且禁止(MUST NOT)在數字前方補零。X 為主版號，Y 為次版號，Z 為修訂號。每個元素必須(MUST)以數值來遞增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\r\n3. 標記版號的軟體發行後，禁止(MUST NOT)改變該版本軟體的內容。任何修改都必須(MUST)以新版本發行。\r\n4. 主版本號為零(0.y.z)的軟體處於開發初始階段，一切都可以(MAY)隨時改變。這樣的公共 API 不應該(SHOULD NOT)被視為穩定版。\r\n5. 1.0.0 的版號用於界定公共 API 的形成。這一版之後所有的版號更新都基於公共 API 及其修改內容。\r\n6. 修訂號 z 必須(MUST)在只做了向下相容的修正時才遞增。這裡的修正指的是針對不正確結果而進行的內部修改。\r\n7. 次版號 y 必須(MUST)在有向下相容的新功能出現時遞增。在任何公共 API 的功能被標記為棄用時，也必需(MUST)遞增。也可以(MAY)在內部程式有大量新功能或改進被加入時遞增，其中可以(MAY)包括修訂級別的改變。每當次版號遞增時，修訂號必須(MUST)歸零。\r\n8. 主版號 x 必須(MUST)在有任何不相容的修改被加入公共 API 時遞增。其中可以(MAY)包括次版號及修訂級別的改變。每當主版號遞增時，次版號和修訂號必須(MUST)歸零。\r\n9. 先行版號可以(MAY)被標註在修訂版之後，先加上一個連接號再加上一連串以句點分隔的標示符號來修飾。標示符號必須(MUST)由 ASCII 碼的英數字和連接號組成，且禁止(MUST NOT)留白。數字型的標示符號禁止(MUST NOT)在前方補零。先行版的優先級低於相關聯的標準版。被標上先行版號則表示這個版號並非穩定且可能無法達到相容的需求。範例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92、1.0.0-x-y-z.–。\r\n10. 版本編譯資訊可以(MAY)被標註在修訂版或先行版之後，先加上一個加號再加上一連串以句點分隔的標示符號來修飾。標示符號必須(MUST)由 ASCII 的英數字和連接號組成，且禁止(MUST NOT)留白。當判斷版本的優先層級時，版本編譯資訊必須(MUST)被忽略。因此當兩個版本只有在版本編譯資訊有差別時，屬於相同的優先層級。範例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85、1.0.0+21AF26D3—-117B344092BD。\r\n11. 版本的優先層級指的是不同版本在排序時如何比較。\r\n    1. 判斷優先層級時，必須(MUST)把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較(版本資訊不在此比較的範疇中)。\r\n    2. 由左到右依序比較每個標示符號，第一個差異值用來決定優先層級：主辦號、次版號及修訂號以數值比較。例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。\r\n    3. 當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。例如：1.0.0-alpha < 1.0.0。\r\n    4. 有相同主版號、次版號及修訂號的兩個先行版號，其優先必須(MUST)透過由左到右每個被句點分隔的標示符號來做比較，值到找到一個差異值後決。\r\n","date":"2023-02-16T08:52:31.272Z","matchingLines":["## 摘要\r","## 簡介\r","## 語意版本控制規範\r"]},{"name":"SOLID 物件導向原則.md","content":"# SOLID 物件導向原則\r\n\r\n> 參考資料\r\n>\r\n> [物件導向設計原則 SOLID](https://clouding.city/php/solid/)\r\n\r\n## SPR 單一職責原則\r\n\r\n> Single Responsibility Principle\r\n\r\n### 定義\r\n\r\n應該且僅有一個原因引起類別的變更，讓類別只有一個職責。\r\n\r\n### 秘訣\r\n\r\n- 關注點分離\r\n- 不應該因為貪圖方便塞在一起\r\n- 若切分太細，會有類別太多的問題\r\n\r\n### 提醒\r\n\r\n- 設計階段就可以避開類別職責太大的問題\r\n- 在維護階段需小心別又讓類別職責變多\r\n\r\nBad\r\n\r\n```php\r\nclass UserSettings\r\n{\r\n    private $user;\r\n\r\n    public function __construct(User $user)\r\n    {\r\n        $this->user = $user;\r\n    }\r\n\r\n    public function changSettings(array $settings): void\r\n    {\r\n        if ($this->verifyCredentials()) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private function verifyCredentials(): bool\r\n    {\r\n        //\r\n    }\r\n}\r\n```\r\n\r\nGood\r\n\r\n```php\r\nclass UserAuth\r\n{\r\n    private $user;\r\n\r\n    public function __construct(User $user)\r\n    {\r\n        $this->user = $user;\r\n    }\r\n\r\n    public function verifyCredentials(): bool\r\n    {\r\n        //\r\n    }\r\n}\r\n\r\nclass UserSetters\r\n{\r\n    private $user;\r\n\r\n    private $auth;\r\n\r\n    public function __construct(User $user)\r\n    {\r\n        $this->user = $user;\r\n        $this->auth = new UserAuth($user);\r\n    }\r\n\r\n    public function ChangSettings(array $settings): void\r\n    {\r\n        if ($this->auth->verifyCredentials()) {\r\n            //\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Open Closed Principle 開放封閉原則\r\n\r\n### 定義\r\n\r\n軟體中的對象(類別、函數)，對於擴展是開放的，對於修改是封閉的。\r\n\r\n### 秘訣\r\n\r\n- 只考慮抽象層級的介面互動\r\n- 把變化委託給其他類別處理\r\n- 只異動 metadata 或 config\r\n\r\n### 提醒\r\n\r\n- 不是所有程式都遵守 OCP\r\n- 可能一開始無法預想到要擴充，但可以透過重構完成\r\n- 不要過度用繼承的方式來進行擴充\r\n\r\nBad\r\n\r\n```php\r\nabstract class Adapter\r\n{\r\n    protected $name;\r\n\r\n    public function getName(): string\r\n    {\r\n        return $this->name;\r\n    }\r\n}\r\n\r\nclass AjaxAdapter extends Adapter\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct();\r\n\r\n        $this->name = 'ajaxAdapter';\r\n    }\r\n}\r\n\r\nclass NodeAdapter extends Adapter\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct();\r\n\r\n        $this->name = 'nodeAdapter';\r\n    }\r\n}\r\n\r\nclass HttpRequester\r\n{\r\n    private $adapter;\r\n\r\n    public function __construct(Adapter $adapter)\r\n    {\r\n        $this->adapter = $adapter;\r\n    }\r\n\r\n    public function fetch(string $url): promise\r\n    {\r\n        $adapterName = $this->adapter->getName();\r\n\r\n        if ($adapterName === 'ajaxAdapter') {\r\n            return $this->makeAjaxCall($url);\r\n        } elseif ($adapterName === 'httpNodeAdapter') {\r\n            return $this->makeHttpCall($url);\r\n        }\r\n    }\r\n\r\n    private function makeAjaxCall(string $url): promise\r\n    {\r\n        // request and return promise\r\n    }\r\n\r\n    private function makeHttpCall(string $url): promise\r\n    {\r\n        // request and return promise\r\n    }\r\n}\r\n```\r\n\r\nGood\r\n\r\n```php\r\ninterface Adapter\r\n{\r\n    public function request(string $url): promise;\r\n}\r\n\r\nclass AjaxAdapter implements Adapter\r\n{\r\n    public function request(string $url): promise\r\n    {\r\n        // request and return promise\r\n    }\r\n}\r\n\r\nclass NodeAdapter implements Adapter\r\n{\r\n    public function request(string $url): promise\r\n    {\r\n        // request and return promise\r\n    }\r\n}\r\n\r\nclass HttpRequester\r\n{\r\n    private $adapter;\r\n\r\n    public function __construct(Adapter $adapter)\r\n    {\r\n        $this->adapter = $adapter;\r\n    }\r\n\r\n    public function fetch(string $url): promise\r\n    {\r\n        return $this->adapter->request($url);\r\n    }\r\n}\r\n```\r\n\r\n## Liskov Substitution Principle 里氏替換原則\r\n\r\n### 定義\r\n","date":"2023-02-04T02:20:34.116Z","matchingLines":["## SPR 單一職責原則\r","## Open Closed Principle 開放封閉原則\r","## Liskov Substitution Principle 里氏替換原則\r"]},{"name":"PHP namespace.md","content":"# PHP 命名空間\r\n\r\n> 參考資料：\r\n>\r\n> [namespace 命名空間詳解](https://learnku.com/articles/15064/namespace-namespace-detailed-explanation)\r\n\r\n## 什麼是命名空間\r\n\r\n在 php 中，語法規則不允許`變數`、`類別名稱`、`const 常數`在一個請求中出現多個相同的命名，若有應用程序不得不出現多個同名的`變數`、`類別名稱`、`const 常數`，此時可以將其放到不同的空間進行請求。\r\n\r\n這個不同的空間就稱作`命名空間 namespace`。空間可以作為一個`容器`、`儲存類別`、`函數`、`const 常數`的容器。\r\n\r\n- 同名元素在同一空間：\r\n\r\n  ```php\r\n  function getInfo(){\r\n    echo \"hello\";\r\n  }\r\n\r\n  function getInfo(){\r\n    echo \"hello\";\r\n  }\r\n  getInfo();\r\n  ```\r\n\r\n  同名稱的兩個 function 在同一個空間存取會報錯，錯誤碼：\r\n\r\n  ```log\r\n  Fatal error: Cannot redeclare getInfo() (previously declared in...)\r\n  ```\r\n\r\n- 同名元素在不同空間\r\n\r\n  ```php\r\n  namespace Test1;\r\n\r\n  function getInfo() {\r\n    echo \"hello from test 1\";\r\n  }\r\n  getInfo();\r\n  echo \"<br>\";\r\n\r\n  namespace Test2;\r\n\r\n  function getInfo() {\r\n    echo \"hello from test 2\";\r\n  }\r\n  getInfo();\r\n  ```\r\n\r\n  相同命名的兩個 function 放到不同空間進行存取，最後輸出：\r\n\r\n  ```log\r\n  hello from test 1\r\n  hello from test 2\r\n  ```\r\n\r\n## 使用命名空間\r\n\r\n### 命名規則\r\n\r\n- 透過 namespace 關鍵字宣告命名空間\r\n\r\n  ```php\r\n  namespace 空間名稱  // 空間名稱依照 php 正確的命名方式定義即可\r\n  ```\r\n\r\n  namespace 針對 function、類別名稱、const 常數三個部份起作用，並統稱為元素。\r\n\r\n### 常數的宣告\r\n\r\n- define ($name, $value);\r\n\r\n  在類別外部宣告常數，和命名空間沒有關係。同名稱的常數只能 define 一次\r\n\r\n  ```php\r\n  namespace Test1;\r\n  define ('IVAN', 'hello world');\r\n\r\n  namespace Test2;\r\n  define ('IVAN', 'hello world');\r\n\r\n  // Notice: Constants IVAN already defined in...\r\n  ```\r\n\r\n- const NAME = $value;\r\n  和空間命名有關係。const 可以在類別的內部宣告常數值(類別常數)，也可以在類別外部宣告(正常常數)。\r\n\r\n  使用空間命名的時候，const 可以放到類別外面宣告。相同名稱的多個常數，可以分別定義報不同的命名空間裡面。\r\n\r\n  ```php\r\n  namespace Test1;\r\n  const USER = \"ivan_1\";\r\n  echo USER;\r\n  echo \"<br>\";\r\n\r\n  namespace Test2;\r\n  const USER = \"ivan_2\";\r\n  echo USER;\r\n  ```\r\n\r\n  ```log\r\n  ivan_1\r\n  ivan_2\r\n  ```\r\n\r\n### 命名空間中 const 和 define 的區別\r\n\r\n`const` 針對命名空間產生影響，`define` 不發生影響。\r\n\r\n`const` 可以宣告多個相同名稱的常數。\r\n\r\n`define` 宣告的名稱具有唯一性。\r\n\r\n## 間單的元素存取\r\n\r\n```php\r\n// 空間的名稱與具體父層目錄沒有直接關係\r\n// 按照 php 正確的命名方式定義即可\r\nnamespace Test1;\r\n\r\nfunction getInfo() {\r\n  echo \"test_1\";\r\n}\r\n\r\nconst USER = \"ivan_1\";\r\n\r\nnamespace Test2;\r\n\r\nfunction getInfo(){\r\n  echo \"test_2\";\r\n}\r\nconst USER = \"ivan_2\";\r\n\r\n// 存取元素\r\n// 當元素沒有任何限制的時候，會存取\"目前空間\"的元素\r\n// 目前空間：離此呼叫 function 最近的命名空間\r\ngetInfo(); // test_2\r\necho USER; // ivan_2\r\n\r\n// 當元素指定存取的命名空間\r\n// 存取其他命名空間的元素：\\空間\\元素;\r\n\\Test1\\getInfo(); // test_1\r\necho \\Test1\\USER; // ivan_1\r\n```\r\n\r\n## 子級(多級)空間\r\n\r\n命名空間可以讓我們存放許多元素(函數、類別、常數)，當元素較多時，為了方便管理，可以對元素進行分類儲存，將命名空間設定為多級空間。\r\n\r\n多級空間的最後一級空間就稱為子級空間。\r\n\r\n- 空間元素存取的三種型式：\r\n\r\n  - 非限定名稱方式\r\n  - 完全限定名稱方式\r\n  - 限定名稱\r\n\r\n- 多級命名空間使用\r\n\r\n  ```php\r\n  // 多級命名空間使用\r\n  namespace AAA\\aaa\\test;\r\n\r\n  class Shop\r\n  {\r\n    public $impression = 'beautiful';\r\n  }\r\n\r\n  namespace BBB\\bbb\\test;\r\n\r\n  class Shop\r\n  {\r\n    public $impression = 'science and technology';\r\n  }\r\n\r\n  // 非限定方式存取元素\r\n  // 預設存取當前的空間元素\r\n  $obj = new Shop();\r\n  echo $obj->impression; // science and technology\r\n\r\n  // 完全限定名稱方式存取元素\r\n  // 存取其他空間元素\r\n  $obj_1 = new \\AAA\\aaa\\test\\Shop();\r\n  echo $obj_1->impression; // beautiful\r\n  ```\r\n\r\n- 多級空間使用\r\n\r\n  ```php\r\n  namespace AAA\\aaa\\test\\library;\r\n  const USER = 'ivan_1';\r\n\r\n  namespace BBB\\bbb\\test;\r\n  const USER = \"ivan_2\";\r\n\r\n  namespace AAA\\aaa\\test;\r\n  const USER = \"ivan_3\";\r\n\r\n  // 限定名稱存取元素\r\n  // 此方法存取元素規則：目前空間 + 本身空間\\元素\r\n\r\n  echo library\\USER; // 命名空間為 \\AAA\\aaa\\test\\library\\USER;\r\n  // ivan_1\r\n  ```\r\n\r\n- 非限定名稱方式\r\n  `echo Shop::$impression;` 就近存取上面與其最近的空間內的 Shop() 元素。類似 php 引入文件 `include(\"common.php\");` 使用相對路徑引入當前目錄下的 common.php 文件。\r\n- 限定名稱\r\n  `echo library\\Shop::$impression;` 將當前空間和 library 空間聯合，獲得 Shop() 元素。類似 `include(\"Common/Conf/config.php\");` 相對路徑。\r\n- 完全限定名稱方式\r\n  `echo BBB\\Shop::$impression;` 存取 BBB 空間的 Shop 元素。類似 `include(\"D:/web/1121/Conf/common.php);` 使用絕對路徑引入文件。\r\n\r\n## 引入機制\r\n\r\n命名空間可宣告為多級空間，此一多級空間元素在其他的空間內部存取的時候，不可以需要透過`完全限定名稱`，此一方法不方便維護及開發。\r\n\r\n為了降低程式碼的複雜度，可以在當前的空間將指定的空間引入，進而透過`限定名稱`的形式，使用其他空間的元素。\r\n\r\n### 空間引入\r\n\r\n- use 空間\r\n\r\n  ```php\r\n  // 引入機制：空間引入\r\n  namespace AAA\\aaa\\test;\r\n\r\n  const USER = 'ivan';\r\n  const HOST = 'localhost:80';\r\n\r\n  function getInfo() {\r\n    echo 'test';\r\n  }\r\n\r\n  namespace BBB\\bbb\\library;\r\n\r\n  const USER = 'cindy';\r\n  const HOST = 'localhost:443';\r\n  function getInfo() {\r\n    echo 'test';\r\n  }\r\n\r\n  /**\r\n   * 項目需要頻繁存取其他空間元素\r\n   * 為了降低存取其他空間的複雜度，可以將頻繁存取的空間引入當前的空間\r\n   * 進而透過\"限定名稱\"方式存取元素\r\n   * 限定名稱：被引入間的最後一級空間的名稱\r\n   */\r\n\r\n  use AAA\\aaa\\test;\r\n\r\n  echo test\\USER; // ivan\r\n  test\\getInfo(); // test\r\n  echo test\\HOST; // localhost:80\r\n  // 返回最近的空間元素\r\n  echo USER; // cindy\r\n  ```\r\n\r\n- 類別元素引入：\r\n\r\n`use 空間\\空間\\空間\\類元素;`\r\n\r\n空間引入可以解決完全限定名稱訪問元素的繁瑣性，但是還需要透過限定名稱方式訪問空間。\r\n\r\n若引入空間的元素是 class，就可以直接將這個類別引入到當前空間，使用的時候也就可以透過非限定名稱的方式訪問。\r\n\r\n程式碼相對較為簡潔。\r\n\r\n- 類別元素引入\r\n\r\n  ```php\r\n  namespace AAA\\aaa\\test;\r\n\r\n  class Shop\r\n  {\r\n    static $name = 'ivan';\r\n  }\r\n\r\n  namespace BBB\\bbb\\test;\r\n  const USER = 'cindy';\r\n\r\n  // 將 AAA\\aaa\\test\\Shop 類別元素引入\r\n  use AAA\\aaa\\test\\Shop;\r\n\r\n  // 透過非限定名稱在此命名空間中存取引入的類別中的元素\r\n  echo Shop::$name; // ivan\r\n  ```\r\n\r\n- 類別元素在引入時的特殊狀況\r\n  當引入類別的命名和當前空間的類別名稱相同時：\r\n\r\n  ```php\r\n  namespace AAA\\aaa\\test;\r\n  class Shop\r\n  {\r\n    static $name = 'ivan';\r\n  }\r\n\r\n  namespace BBB\\bbb\\test;\r\n  const USER = 'cindy';\r\n  class Shop\r\n  {\r\n    static $name = 'jack';\r\n  }\r\n\r\n  // 將 AAA\\aaa\\test 類別元素直接引入\r\n  use AAA\\aaa\\test\\Shop;\r\n\r\n  // 透過非限定名稱存取引入的類別\r\n  echo Shop::$name; // error\r\n\r\n  // Fatal error: Cannot use AAA\\aaa\\test\\Shop as Shop because the name is already in use in...\r\n  ```\r\n\r\n  解決方法：使用別名\r\n\r\n  `use 空間\\元素 as 別名;`\r\n\r\n  把其他空間的一個類別元素引入到當前空間，若當前空間也已有一個同名的類別元素，則引入元素與當前空間的元素就會產生衝突，為了避免衝突，可以給引入的空間元素取一個別名。\r\n\r\n  引入的 Shop 與當前空間的 Shop 有衝突取別名：\r\n\r\n  ```php\r\n    namespace AAA\\aaa\\test;\r\n  class Shop\r\n  {\r\n    static $name = 'ivan';\r\n  }\r\n\r\n  namespace BBB\\bbb\\test;\r\n  const USER = 'cindy';\r\n  class Shop\r\n  {\r\n    static $name = 'jack';\r\n  }\r\n\r\n  // 將 AAA\\aaa\\test 類別元素直接引入\r\n  use AAA\\aaa\\test\\Shop as IntShop;\r\n\r\n  // 透過別名存取引入的類別\r\n  echo IntShop::$name; // ivan\r\n  echo Shop::$name; // jack\r\n  ```\r\n\r\n### 公共空間\r\n\r\n一個 php 文件裡面沒有 namespace 關鍵字宣告，則該文件的元素都存在於公共空間。\r\n\r\n存取公共空間的元素統一設為：`\\元素`\r\n\r\n### CommonSpace.php include 引入 CommonSpace1.php\r\n\r\n- CommonSpace.php\r\n\r\n  ```php\r\n  namespace AAA;\r\n\r\n  function f1() {\r\n    echo \"in good mood\";\r\n  }\r\n\r\n  // 在公共空間的檔案會被引入，針對當前空間不發生影想\r\n\r\n  include(\"CommonSpace1.php\"); // 公共空間\r\n\r\n  // 存取元素\r\n  f1(); // in good mood 當前空間就是 AAA 空間\r\n  echo \\NAME; // 存取公共空間的元素\r\n\r\n  // 本身有命名空間，引入的檔案是公共空間，本身的空間存取不到時，會到別的空間去尋找此元素\r\n  ```\r\n\r\n- CommonSpace1.php\r\n\r\n  ```php\r\n  const NAME = 'ivan';\r\n\r\n  function f1() {\r\n    echo \"okay\";\r\n  }\r\n\r\n  function f2() {\r\n    echo 'all good';\r\n  }\r\n  ```\r\n\r\nCommonSpace.php 有 namespace，CommonSpace1.php 沒有(CommonSpace1.php 處於公共空間)。被引入的檔案空間，此時被引入的文件 CommonSpace1.php 屬於公共空間，針對當前空間不發生影響。\r\n\r\n- 透過非限定名稱呼叫一個元素(function、常數)\r\n  - 首先取得本空間元素\r\n  - 其次取得公共空間元素\r\n\r\n若在 CommonSpace.php 中將 function fi() 註解，此時 f1() 呼叫的 function 為公共空間 function f1()，輸出：\r\n\r\n```log\r\nokay\r\nivan\r\n```\r\n\r\n將 CommonSpace.php 的 function f1() 取消註解，此時 f1() 呼叫的是 AAA 命名空間的 function f1()。\r\n\r\n```log\r\nin good mood\r\nivan\r\n```\r\n\r\n### ReverseCommonSpace.php include 引入 ReverseCommonSpace １.php\r\n\r\n- ReverseCommonSpace.php\r\n\r\n  ```php\r\n  function f1() {\r\n    echo \"in good mood\";\r\n  }\r\n\r\n  const NAME = \"cindy\";\r\n\r\n  function f2() {\r\n    echo \"good\";\r\n  }\r\n\r\n  include(\"ReverseCommonSpace1.php\") // 有命名空間\r\n\r\n  \\f2(); // good 存取公共空間需要有\"反斜線\"，提高程式碼可讀性\r\n  echo NAME;\r\n  echo \\AAA\\NAME;\r\n  // f3(); // 無法存取會報錯，正確的存取寫法為： \\AAA\\f3();\r\n  \\AAA\\f3();\r\n\r\n  // 本身是公共空間，引入的檔案是有命名空間的，本身的空間無法存取時，不會到別的空間去找尋元素。\r\n  ```\r\n\r\n  若 f3(); 沒有註解掉會報錯：\r\n\r\n  ```log\r\n  good\r\n  cindy\r\n  ivan\r\n\r\n  (!) Fatal error: Uncaught Error: Call to undefined function f3() in...\r\n  ```\r\n\r\n  將其註解後輸出：\r\n\r\n  ```log\r\n  good\r\n  cindy\r\n  ivan\r\n  buy book\r\n  ```\r\n\r\n- ReverseCommonSpace1.php\r\n\r\n  ```php\r\n  namespace AAA;\r\n\r\n  const NAME = 'ivan';\r\n\r\n  function f2() {\r\n    echo 'good';\r\n  }\r\n\r\n  function f3(){\r\n    echo \"buy book\";\r\n  }\r\n  ```\r\n\r\n## 範例與總結\r\n\r\n### 錯誤範例\r\n\r\n```php\r\nconst USER = 'ivan';\r\n\r\nnamespace AAA;\r\n\r\nfunction getInfo() {\r\n  echo 'OK';\r\n}\r\n\r\n// Fatal error: Namespace declaration statement has to be the very first statement or after any declare call in the script in...\r\n```\r\n\r\n正確做法：\r\n\r\n```php\r\nnamespace AAA;\r\n\r\nconst USER = 'ivan';\r\n\r\nfunction getInfo() {\r\n  echo 'OK';\r\n}\r\n\r\ngetInfo(); // OK\r\n```\r\n\r\n不能宣告常數在公共空間，而 function 在命名空間。\r\n\r\n宣告命名空間時，在 namespace 關鍵字前面不能有任何程式碼，包刮 header 也要寫在下面。\r\n\r\n### 命名空間總結\r\n\r\n1. 宣告命名空間時，在 namespace 關鍵字前面不能有任何程式碼(可以註解)，包刮 header 也要寫在下面。\r\n2. 命名空間是虛擬抽象的空間，非真實的檔案路徑。\r\n3. 同一請求多檔案可以使用相同的命名空間，只要這些檔案中不會出現多的同名稱、同類型的元素(function, const)即可。\r\n","date":"2023-02-03T03:10:53.322Z","matchingLines":["## 什麼是命名空間\r","## 使用命名空間\r","## 間單的元素存取\r","## 子級(多級)空間\r","## 引入機制\r","## 範例與總結\r"]},{"name":"在 GCP 部署 laravel 專案.md","content":"# 在 GCP 部署 laravel 專案\r\n\r\n> [執行環境設定](https://bugswarehouse.blogspot.com/2018/07/gcpgceubuntuapachelaravel56.html)\r\n>\r\n> - Ubuntu 20.04.1 LTS \\n \\l\r\n> - Apache/2.4.41 (Ubuntu)\r\n> - mysql Ver 8.0.29-0ubuntu0.20.04.3 for Linux on x86_64 ((Ubuntu))\r\n> - PHP 7.4.3\r\n> - git 2.25.1\r\n> - Composer 2.0.12\r\n\r\n## 設置專案\r\n\r\n### clone git repo\r\n\r\n將目錄切換到`/srv/www`，將託管在 git repo 的專案 clone 下來並依 laravel 上線環境設定流程執行。\r\n一般而言會將文件名稱設為域名。\r\n將目錄切換到 Apache 主機放公開程式的地方`/var/www`，將設定軟連結指向專案位置\r\n\r\n```bash\r\nln -s /srv/www/your_project.com /var/www/your_project.com\r\n```\r\n\r\n### 上線環境設定\r\n\r\n1. 安裝 compsoer 排除 dev 項目\r\n\r\n   ```bash\r\n   composer install --optimize-autoloader --no-dev\r\n   ```\r\n\r\n2. `.env`設定轉為線上並且關閉錯誤提示\r\n\r\n   ```php\r\n   APP_NAME=專案名稱\r\n   APP_ENV=production\r\n   APP_KEY=\r\n   APP_DEBUG=false\r\n   APP_URL=https://正式網址\r\n   ```\r\n\r\n3. 設定快取\r\n\r\n   ```bash\r\n   php artisan config:cache\r\n\r\n   #　下次更新程式記得更新config\r\n   php artisan config:clear\r\n   ```\r\n\r\n4. Composer 緩存\r\n\r\n   ```bash\r\n   composer dumpautoload -o\r\n   # 每次更新 composer install 後，都要再執行一次\r\n   ```\r\n\r\n5. 建立 keygen\r\n\r\n   ```bash\r\n   php artisan key:generate\r\n   ```\r\n\r\n6. 執行資料庫 migrate (須注意資料庫狀態)\r\n\r\n   ```bash\r\n   # 遷移資料表\r\n   php artisan migrate\r\n\r\n   # 填充資料\r\n   php artisan db:seed\r\n   ```\r\n\r\n7. 障礙排除\r\n\r\n   - 清除快取\r\n\r\n   ```bash\r\n   php artisan config:clear\r\n   ```\r\n\r\n   - migrate 指令\r\n\r\n   ```bash\r\n   # 還原 --step 此參數為後退多少版本\r\n   php artisan migrate:rollback\r\n   php artisan migrate:rollback --step=5\r\n\r\n   # 重置所有migration\r\n   php artisan migrate:refresh\r\n\r\n   # 重置所有migration，並填充資料\r\n   php artisan migrate:refresh --seed\r\n   ```\r\n\r\n### 設定專案文件夾的權限\r\n\r\n```bash\r\nsudo chgrp -R www-data /srv/www/your_project.com\r\nsudo chmod -R 775 /srv/www/your_project.com/storage\r\n```\r\n\r\n## 2. 設定 Apache\r\n\r\n- 設定 Apache server\r\n\r\n```bash\r\ncd /etc/apache2/sites-available\r\ncp 000-default.conf your_project.com.conf\r\n```\r\n\r\n- 編輯 conf 文件\r\n  - ServerName : 設定伺服器 Domain Name ，此名稱必須已經註冊\r\n  - ServerAdmin : 設定虛擬主機的管理者信箱，不一定要和本機的網站管理者相同\r\n  - ServerAlias : 設定伺服器網域別名\r\n  - DocumentRoot : 指定虛擬主機的網站主目錄\r\n  - ErrorLog : 設定 error_log 所存放的路徑\r\n  - CustomLog : 設定 access_log 所存放的路徑\r\n\r\n```vim\r\n<VirtualHost *:80>\r\n    ServerName your_project.com\r\n\r\n    ServerAdmin webmaster@localhost\r\n    DocumentRoot /var/www/your_project.com/public\r\n\r\n    <Directory /var/www/your_project.com>\r\n        AllowOverride All\r\n    </Directory>\r\n\r\n    ErrorLog ${APACHE_LOG_DIR}/error.log\r\n    CustomLog ${APACHE_LOG_DIR}/access.log combined\r\n</VirtualHost>\r\n```\r\n\r\n- 啟用 Apache 站點\r\n\r\n```bash\r\n# 關閉預設站點\r\nsudo a2dissite 000-default.conf\r\n\r\n# 啟用新站點\r\nsudo a2ensite your_project.com.conf\r\n\r\n# 首次設定需開啟\r\nsudo a2enmod rewrite\r\n\r\n# 重啟Apache\r\nsudo service apache2 restart\r\n```\r\n \r\n## 參考資料\r\n\r\n[Run Laravel on Google Compute Engine](https://medium.com/imarishwa-solutions/run-laravel-on-google-compute-engine-b0403a6a9240)\r\n\r\n[GCP/GCE/Ubuntu/Apache/Laravel5.6 踩雷筆記](https://bugswarehouse.blogspot.com/2018/07/gcpgceubuntuapachelaravel56.html)\r\n\r\n## 延伸閱讀\r\n\r\n[詳解 Ubuntu/CentOS 下 Apache 多站點配置](https://codertw.com/%E4%BC%BA%E6%9C%8D%E5%99%A8/377669/)\r\n\r\n[Apache 之——多虛擬主機多站點配置的兩種實現方案](https://www.796t.com/content/1546761795.html)\r\n\r\n[ubuntu設定apache部署多個站點](https://www.796t.com/content/1545633208.html)\r\n\r\n[SSL憑證設定](https://ithelp.ithome.com.tw/articles/10081759)\r\n\r\n[輕鬆部署 Laravel 應用](https://learnku.com/blog/Wi1dcard/tags/easy-deployment-of-laravel-applications_50034)","date":"2023-01-13T02:42:51.309Z","matchingLines":["## 設置專案\r","## 2. 設定 Apache\r","## 參考資料\r","## 延伸閱讀\r"]},{"name":"Docker 學習筆記.md","content":"# Docker 學習筆記\r\n\r\n- [Docker 學習筆記](#docker-學習筆記)\r\n  - [安裝 Docker (Docker for Windows)](#安裝-docker-docker-for-windows)\r\n  - [基本概念](#基本概念)\r\n    - [Image](#image)\r\n    - [Container](#container)\r\n    - [Repository](#repository)\r\n  - [Hello World](#hello-world)\r\n    - [確認 Image 存在於 Repository](#確認-image-存在於-repository)\r\n    - [建立 Container 並執行](#建立-container-並執行)\r\n    - [列出所有已建立的 container](#列出所有已建立的-container)\r\n    - [移除 container](#移除-container)\r\n  - [ubuntu](#ubuntu)\r\n    - [pull](#pull)\r\n    - [啟動](#啟動)\r\n  - [For Laravel: Laradock](#for-laravel-laradock)\r\n    - [環境要求](#環境要求)\r\n    - [資料結構](#資料結構)\r\n      - [laradock/.env](#laradockenv)\r\n      - [mysql](#mysql)\r\n      - [PhpMyAdmin](#phpmyadmin)\r\n      - [apache2](#apache2)\r\n      - [nginx](#nginx)\r\n    - [啟動](#啟動-1)\r\n\r\n> 參考資料：\r\n>\r\n> [Docker 基本知識 以及 Docker Compose 實戰經驗](https://hackmd.io/@leonsnoopy/Sya_DevI7#Docker-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AD%98-%E4%BB%A5%E5%8F%8A-Docker-Compose%E5%AF%A6%E6%88%B0%E7%B6%93%E9%A9%97)\r\n>\r\n> [基礎系統及 docker hub 指令](https://joshhu.gitbooks.io/dockercommands/content/Basics/Basics.html)\r\n>\r\n> [How to Deploy Laravel with Docker on Ubuntu 18.04](https://help.clouding.io/hc/en-us/articles/360010679999-How-to-Deploy-Laravel-with-Docker-on-Ubuntu-18-04)\r\n>\r\n> [Laravel 實戰經驗分享 - Day26 Dockerize 你的 Laravel 專案](https://ithelp.ithome.com.tw/articles/10251844)\r\n\r\n## 安裝 Docker (Docker for Windows)\r\n\r\n> Windows 10\r\n> 需啟用 Hyper-v\r\n> 控制台 -> 程式和功能 -> 開啟或關閉 Windows 功能\r\n> 將\"Hyper-v\"和\"容器\"設為開啟\r\n\r\n- 下載[Docker for Windows](https://docs.docker.com/desktop/get-started/)\r\n\r\n## 基本概念\r\n\r\n- docker 主要元件：\r\n  - `image` 映像檔\r\n  - `container` 容器\r\n  - `repository` 倉庫\r\n\r\n執行 docker 的主機稱為 Host，當 Host 執行 `docker run` 指令時，Docker 會操作這三個元素。\r\n\r\n- Image、container、repository 之間的關係就像光碟一樣：早期世紀帝國等光碟遊戲，會需要搭配其他可讀寫空間（如硬碟），才有辦法執行。\r\n  - image 像光碟片，唯獨且無法獨立執行。\r\n  - container 像硬碟，可讀可寫可執行。\r\n  - repository 像光碟盒，儲存 image。\r\n  - registry 則是光碟零售商。\r\n\r\n### Image\r\n\r\n- image 包裝了一個執行特定環境所需要的資源。\r\n  每個 image 都有獨一無二的 digest，這是從 image 內容作 sha256 產生的。這個是能讓 image 無法隨意更變內容，維持資料的一致性。\r\n\r\n雖然 image 裡有必要的資源，但他無法獨立執行，必須靠 container 間接執行。\r\n\r\n### Container\r\n\r\n- 基於 image 可以建立出 Container。\r\n  他的概念像是建立一個可讀寫內容的外層，架在 image 之上。實際存取 container 會經過可讀寫層與 image，因此看到的內容會是兩者合併後的結果。\r\n\r\nContainer 特性與 image 不一樣，因為有可讀寫層，所以 container 可以讀寫，也可以拿來執行。\r\n\r\n### Repository\r\n\r\n- repository 是存放 image 的空間\r\n  docker 的設計類似`分散式版本控制`的方法來存的方法來存放各種 image，而分散式架構就會有類似 git 的 pull/push 行為，實際做的事情也跟 git 類似：為了要跟遠端的 repository 同步。\r\n\r\n另一個與 repository 很像，但容易混用的詞為 Registry。Registry 涵蓋範圍更廣，包含了更多 repository 與身分驗證功能等，通常比較常討論的也是 registry。\r\n\r\n目前 docker 上面預設的 registry 為 DockerHub，大多數程式或服務的 image 都可以在上面找到。\r\n\r\n## Hello World\r\n\r\n```bash\r\n$ docker run hello-world\r\nUnable to find image 'hello-world:latest' locally\r\nlatest: Pulling from library/hello-world\r\n0e03bdcc26d7: Pull complete\r\nDigest: sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5\r\nStatus: Downloaded newer image for hello-world:latest\r\n\r\nHello from Docker!\r\n```\r\n\r\n- `docker run <image name>` 會建立一個 container 並執行，而因為 container 需要基於 image 建立，所以 docker run 有一個必要參數為 `image name`。\r\n\r\n### 確認 Image 存在於 Repository\r\n\r\n首先先確認 `hello-world` 是否存在於本機的 repository，本機找不到的話，就需要從遠端的 repository 下載。\r\n\r\n```bash\r\nUnable to find image 'hello-world:latest' locally\r\nlatest: Pulling from library/hello-world\r\n0e03bdcc26d7: Pull complete\r\nDigest: sha256:7f0a9f93b4aa3022c3a4c147a449bf11e0941a1fd0bf4a8e6c9408b2600777c5\r\nStatus: Downloaded newer image for hello-world:latest\r\n```\r\n\r\n### 建立 Container 並執行\r\n\r\n確認 image 存在後，即可建立 container 並執行。\r\n\r\n- `docker run` 預設的行為是：\r\n  1. 前景建立並執行 container\r\n  2. 等待執行程式結束後，會回到前景的命令提示字元\r\n  3. 該 container 會被標記為結束狀態。\r\n\r\n### 列出所有已建立的 container\r\n\r\n```bash\r\ndocker ps -a\r\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES\r\n6d7e00198a56        hello-world         \"/hello\"            12 seconds ago      Exited (0) 11 seconds ago                       relaxed_bhabha\r\n```\r\n\r\n`STATUS` 表示 container 的狀態，`Exited(0)` 後面的數字為程式結束後回傳的狀態碼，通常 0 為正常結束，非 0 則唯有錯誤。\r\n\r\n`CONTAINER ID` 和 `NAMES` 為獨一無二，執行多次 `docker run` 後，會生不一樣名字的 container。\r\n\r\n### 移除 container\r\n\r\n若一直執行 `docker run` 會使 container 數量不斷增加，一般而言沒有再用到的 container 就會將他移除\r\n\r\n```bash\r\n# 移除時使用 CONTAINER ID 和 NAMES 都可以。\r\ndocker rm 6d7e00198a56\r\n\r\n#移除後再檢查一次\r\ndocker ps -a\r\n```\r\n\r\n## ubuntu\r\n\r\n### pull\r\n\r\n```bash\r\n# 搜尋 ubuntu\r\ndocker search ubuntu\r\n# 將 ubuntu 的 image pull 下來\r\ndocker pull ubuntu\r\n```\r\n\r\n查看 docker 的 image，應可以看到最新版本的 ubuntu\r\n\r\n```bash\r\ndocker images\r\n```\r\n\r\n| REPOSITORY | TAG    | IMAGE ID     | CREATED     | SIZE   |\r\n| ---------- | ------ | ------------ | ----------- | ------ |\r\n| ubuntu     | latest | 6b7dfa7e8fdb | 3 weeks ago | 77.8MB |\r\n\r\n### 啟動\r\n\r\n```bash\r\n> docker run -itd --name ubuntu-test ubuntu\r\n6ffebdd2bce193afe7e3fbaa53c6f2e1dffa845e2c8ec55fef899ba191470dbc\r\n```\r\n\r\n進入容器\r\n\r\n```bash\r\n> docker exec -it ubuntu-test bash\r\nroot@6ffebdd2bce1:/#\r\n```\r\n\r\n## For Laravel: Laradock\r\n\r\n### 環境要求\r\n\r\n> Git\r\n> docker\r\n> docker-compose\r\n\r\n- 將 laradock 的 repository clone 下來\r\n\r\n  ```bash\r\n  git clone https://github.com/Laradock/laradock.git Laradock\r\n  ```\r\n\r\n### 資料結構\r\n\r\n#### laradock/.env\r\n\r\n- 在 laradock 的資料夾中複製 .env.example 並改名為 .env\r\n\r\n  ```bash\r\n  cp .env.example .env\r\n  ```\r\n\r\n- 編輯 .env 中的設定\r\n\r\n```vim\r\n### Paths #################################################\r\n# Point to the path of your applications code on your host\r\n# 專案要放在本機的哪個資料夾中\r\n# 這邊放在與 laradock 同層級的 test 資料夾中\r\nAPP_CODE_PATH_HOST=../test\r\n\r\n# Point to where the `APP_CODE_PATH_HOST` should be in the container\r\n# 設定專案要同步到 container 中的哪一個路徑，預設為 /var/www\r\nAPP_CODE_PATH_CONTAINER=/var/www\r\n\r\n# You may add flags to the path `:cached`, `:delegated`. When using Docker Sync add `:nocopy`\r\nAPP_CODE_CONTAINER_FLAG=:cached\r\n\r\n# Choose storage path on your machine. For all storage systems\r\n# 設定你的儲存資料(ex. database, redis 內的數據)要存放在哪。\r\n# 這邊是放在跟 laradock 專案同層級的 data 資料夾中\r\nDATA_PATH_HOST=../data\r\n```\r\n\r\n#### mysql\r\n\r\n若 PhpMyAdmin 登不進去，可能是版本問題\r\n\r\n```vim\r\n# 預設值\r\nMYSQL_VERSION=latest\r\n\r\n# 改為\r\nMYSQL_VERSION=5.7\r\n```\r\n\r\n#### PhpMyAdmin\r\n\r\n```vim\r\n### PHP MY ADMIN ##########################################\r\n\r\n# Accepted values: mariadb - mysql\r\n# 連接的 BD (預設為 mysql)\r\nPMA_DB_ENGINE=mysql\r\n\r\n# Credentials/Port:\r\n\r\n# 預設的使用者\r\nPMA_USER=default\r\n# 預設密碼\r\nPMA_PASSWORD=secret\r\n# sql root 帳號的密碼\r\nPMA_ROOT_PASSWORD=secret\r\n# phpMyAdmin 執行的 port 號\r\nPMA_PORT=8081\r\nPMA_MAX_EXECUTION_TIME=600\r\nPMA_MEMORY_LIMIT=256M\r\nPMA_UPLOAD_LIMIT=2G\r\n```\r\n\r\n#### apache2\r\n\r\n#### nginx\r\n\r\n### 啟動\r\n\r\n- 啟動 laradock\r\n\r\n```bash\r\ndocker-compose up -d apache2 phpMyAdmin nginx ...想啟動的服務\r\n```\r\n\r\nLaradock 會自動啟動包括 php-fpm 在內的 php-fpm 及 workspace，啟動 phpMyAdmin 時也會連帶啟動 mysql\r\n\r\n- 進入 laravel 專案\r\n\r\n在啟動 laradock 之後，會建立一個 workspace 的 container，此時進入 workspace 建立 laravel 專案\r\n\r\n```bash\r\ndocker-compose exec workspace bash\r\n```\r\n\r\n進入後，terminal 會顯示自己在 `/var/www` 中，此時 `/var/www` 是連接我們在 .env 中設定的資料夾 `../test`\r\n\r\n","date":"2023-01-12T09:35:25.726Z","matchingLines":["## 安裝 Docker (Docker for Windows)\r","## 基本概念\r","## Hello World\r","## ubuntu\r","## For Laravel: Laradock\r"]},{"name":"TCP 連線溝通方式.md","content":"# TCP 連線溝通方式\r\n\r\nTCP 會在兩個端點間建立一個連線來確保雙方的溝通順暢，就像是一條電話專線一樣，在這個連線之中，會在來源與目的各指定一個 port (連接埠)，作為確認這個連線的編號。\r\n由於 TCP 是基於 IP 的上面一層，TCP 的連線都在同一個 IP address 下，可以理解為都與同一台設備進行連線。但兩個設備間的連線可能不只一個，就會需要編號來分開不同連線。用 port 來命名編號，就像是在同一個地區(同一個 IP address)有不同的港口。\r\n\r\nTCP 通訊過程可以分為三個階段。且必須正確建立連接在一個很多步驟的交握處理(handshake process)然後才進入建立連接(connection establishment)，再進入資料傳輸(data transfer)階段。資料傳輸完成，最後連接終止(connection termination)建立的虛擬通道關閉並釋放所有分配的資源。\r\n\r\n一個 TCP 連接是由 OS 管理，TCP 連接基本上經歷底下這些變化：\r\n\r\n1. listen: 如果是服務程式的話，指的是等待連接請求從任何遠端的客戶端。\r\n2. syn-sent: 等待遠端點對點發回一個 TCP segment 並帶有 SYN 和 ACK flag。通常做這件事的為 TCP 客戶端。\r\n3. syn-received: 等待遠端通道的另一端發回一個確認後，發回確認連接到遠端節點。通做這件事的為 TCP 服務端。\r\n4. established: port 準備好接收/發送數據到遠端節點。\r\n5. fin-wait-1\r\n6. fin-wait-2\r\n7. close-watt\r\n8. closing\r\n9. last-ack\r\n10. time-wait: 指等待足後的時間，以確保通過遠端對等機器收到確認其連接終止請求。根據 RFC 793 中的連接，最大等待時間為四分鐘。\r\n11. closed\r\n","date":"2023-01-12T05:04:16.336Z","matchingLines":[]},{"name":"Visual Studio Code環境設置.md","content":"# Visual Studio Code 環境設置\r\n\r\n- [Visual Studio Code 環境設置](#visual-studio-code-環境設置)\r\n  - [擴充套件](#擴充套件)\r\n    - [中文化](#中文化)\r\n    - [美化 code](#美化-code)\r\n    - [html, css](#html-css)\r\n    - [VUE](#vue)\r\n    - [PHP Laravel](#php-laravel)\r\n    - [Markdown](#markdown)\r\n    - [Git](#git)\r\n    - [小工具](#小工具)\r\n  - [調整設定](#調整設定)\r\n  - [快速鍵](#快速鍵)\r\n\r\n## 擴充套件\r\n\r\n### 中文化\r\n\r\n- Chinese (Traditional) Language Pack for Visual Studio Code\r\n\r\n### 美化 code\r\n\r\n- Bracket Pair Colorizer\r\n- Auto Rename Tag\r\n- Prettier - Code formatter\r\n\r\n### html, css\r\n\r\n- Live server：它會幫使用者自動開啟一個服務器，保存的時候便自動刷新瀏覽器頁面\r\n  設定預設開啟的瀏覽器：齒輪符號 > 進行延伸模組設定 > Live Server Settings: Custom Browser\r\n- open in browser\r\n- IntelliSense for CSS class names in HTML\r\n\r\n### VUE\r\n\r\n- [參考資料](https://ithelp.ithome.com.tw/articles/10237074)\r\n\r\n### PHP Laravel\r\n\r\n- PHP IntelliSense (felixfbecker.php-intellisense)\r\n- PHP Server (brapifra.phpserver)\r\n- php cs fixer\r\n- PHP DocBlocker\r\n- PHP Getters & Setters\r\n- PHP import checker\r\n- PHP Namespace Reaolver\r\n- phpcs fixer\r\n- PHP Extension Pack\r\n- Laravel Blade Snippets (onecentlin.laravel-blade)\r\n- Laravel Blade formatter\r\n- Laravel Blade Wrapper\r\n- Laravel Create View\r\n- laravel Extension Pack\r\n- Laravel Extra Intellisese\r\n- Laravel Goto Controller\r\n- Laravel goto view\r\n- laravel-goto-components\r\n\r\n### Markdown\r\n\r\n- markdownlint\r\n- Markdown All in One\r\n- Markdown Preview Github Styling\r\n- Markdown TOC  \r\n  markdown 自動生成目錄，作者：CharlesWan\r\n\r\n### Git\r\n\r\n- GitLens — Git supercharged\r\n- Git Graph\r\n- GitHub Theme\r\n- gitignore\r\n- Git Extension Pack\r\n- GitHub Repositories\r\n- Open in GitHub, Bitbucket, Gitlab, VisualStudio\r\n- Remote Repositories\r\n\r\n### 小工具\r\n\r\n- Draw.io Integration(繪製表格、流程圖)\r\n\r\n## 調整設定\r\n\r\n- 檔案 → 喜好設定 → 設定 → 文字編輯器 → 字型 → Font Size\r\n- 檔案 → 喜好設定 → 設定 → 工作台 → 外觀 → Tree:Indent\r\n- 檔案 → 喜好設定 → 設定 → 延伸模組\r\n\r\n## 快速鍵\r\n\r\n- 開啟終端機 Command + `\r\n- 註解行 `Command + /`\r\n- 選取一段字詞 `Command + D`\r\n- 開啟搜尋 `Command + F`\r\n- 儲存 `Command + S`\r\n- 回上一步 `Command + Z`\r\n- 移動當前行向上向下 `option + ↑ / ↓`\r\n- 複製當前行向上向下 `shift + option + ↑ / ↓`\r\n- 觸發建議 `control + space`\r\n- 參數建議 `shift + option + space`\r\n- 格式化 `shift + option + space`\r\n","date":"2022-12-27T06:08:52.220Z","matchingLines":["## 擴充套件\r","## 調整設定\r","## 快速鍵\r"]},{"name":"RESTful API.md","content":"# RESTful API\r\n\r\n> RESTful API 是一種設計模式\r\n>\r\n> 定義一組\"物件\"(object)，他們是可以被操作的。\r\n> 物件運用一組固定\"動作\"(action)簡稱(CRUD)\r\n>\r\n> - 創建(create)\r\n> - 刪除(delete)\r\n> - 更新(update)\r\n> - 讀取(read)\r\n>\r\n> 主流以 JSON 格式做資料傳遞\r\n> 基本上會包含 URL\\Object\\Action\r\n\r\n## 常用 HTTP 動詞\r\n\r\n- GET: 讀取資源(不會變動或是更改到伺服器的資訊，主要用來查資料)\r\n- POST: 新增資料\r\n- DELETE: 刪除資料\r\n- PUT: 替換資源\r\n- PATCH: 更新資源\r\n\r\n如以 Post(文章)這個物件舉例\r\n\r\n| HTTP 動詞 |      URL       |           功能           |                                       說明                                       |\r\n| :-------: | :------------: | :----------------------: | :------------------------------------------------------------------------------: |\r\n|   POST    |  api/v1/posts  |       發表一篇文章       |        如果有相同的請求送第二次，會回傳新的一筆資料，內容一樣只有 ID 不同        |\r\n|  DELETE   | api/v1/posts/1 |     刪除 id=1 的文章     |                 如果發送兩次請求，第二次回傳找不到資源的錯誤訊息                 |\r\n|    PUT    | api/v1/posts/1 |    id=1 資料整筆替換     |                  替換整筆資料，有點像舊資料的刪除，寫入新的資料                  |\r\n|   PATCH   | api/v1/posts/1 | 更新文件 id=1 的部分內容 | 只替代掉部分內容，內容會依照發送請求的資料作修改。如果沒有填寫的部分保留原始資料 |\r\n\r\n- 其他不符合以上類別的動作用 POST\r\n\r\n## Laravel RESTful API\r\n\r\n### 建立 controller\r\n\r\n```bash\r\nphp artisan make:controller Api/TestController --api\r\n```\r\n\r\n```php\r\nnamespace App\\Http\\Controllers\\Api;\r\n\r\nuse App\\Http\\Controllers\\Controller;\r\nuse Illuminate\\Http\\Request;\r\n\r\nclass TestController extends Controller\r\n{\r\n    public function index()\r\n    {\r\n        // 列出所有\r\n    }\r\n\r\n    public function store(Request $request)\r\n    {\r\n        // 建立資料\r\n    }\r\n\r\n    public function show($id)\r\n    {\r\n        // 顯示指定 id 的資料\r\n    }\r\n\r\n    public function update(Request $request, $id)\r\n    {\r\n        // 更新指定 id 的資料\r\n    }\r\n\r\n    public function destroy($id)\r\n    {\r\n        // 刪除指定 id 的資料\r\n    }\r\n}\r\n```\r\n\r\n### 加入 api\r\n\r\nroutes/api.php\r\n\r\n```php\r\nRoute::middleware('auth:api')->group(function () {\r\n    Route::apiResource('test', 'TestController');\r\n});\r\n```\r\n\r\n### URL\r\n\r\n| action |                 url                  | Controller function |\r\n| :----: | :----------------------------------: | :-----------------: |\r\n|  get   |     `{{ server-url }}/api/test`      |        index        |\r\n|  post  |     `{{ server-url }}/api/test`      |        store        |\r\n|  get   | `{{ server-url }}/api/test/{{ id }}` |        show         |\r\n| patch  | `{{ server-url }}/api/test/{{ id }}` |       update        |\r\n| delete | `{{ server-url }}/api/test/{{ id }}` |       destroy       |\r\n","date":"2022-12-27T06:08:35.667Z","matchingLines":["## 常用 HTTP 動詞\r","## Laravel RESTful API\r"]},{"name":"Laravel Migration & Seeder & Factory.md","content":"# Laravel Migration & Seeder & Factory\r\n\r\n- [Laravel Migration \\& Seeder \\& Factory](#laravel-migration--seeder--factory)\r\n  - [Migration](#migration)\r\n    - [產生 Migration 檔案](#產生-migration-檔案)\r\n    - [執行 Migrate](#執行-migrate)\r\n    - [還原 Migrate](#還原-migrate)\r\n    - [重置 Migration](#重置-migration)\r\n  - [Seed](#seed)\r\n    - [產生 Seeder 檔案](#產生-seeder-檔案)\r\n    - [執行 Seeder](#執行-seeder)\r\n  - [Factory](#factory)\r\n    - [產生 Factory 檔案](#產生-factory-檔案)\r\n    - [Faker Formatters](#faker-formatters)\r\n\r\n## Migration\r\n\r\n### 產生 Migration 檔案\r\n\r\n```cmd\r\nphp artisan make:migration create_your_table\r\n```\r\n\r\n- 產生出來的 Migration 檔案，內有 up() 和 down() 兩個方法。\r\n\r\n```php\r\n    public function up()\r\n    {\r\n        Schema::create('room_user', function (Blueprint $table) {\r\n            $table->id();\r\n            $table->unsignedBigInteger('user_id');\r\n            $table->bigInteger('parent_id')->comment('將此成員加入系統的使用者');\r\n            $table->unsignedBigInteger('room_id')->nullable();\r\n            $table->bigInteger('role_id')->comment('使用者身分');\r\n            $table->timestamps();\r\n        });\r\n\r\n        Schema::table('room_user', function (Blueprint $table) {\r\n            $table->foreign('user_id')\r\n                ->references('id')\r\n                ->on('users')\r\n                ->onDelete('cascade');\r\n            $table->foreign('room_id')\r\n                ->references('id')\r\n                ->on('rooms')\r\n                ->nullOnDelete();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reverse the migrations.\r\n     *\r\n     * @return void\r\n     */\r\n    public function down()\r\n    {\r\n        Schema::table('room_user', function (Blueprint $table) {\r\n            $table->dropForeign('room_user_user_id_foreign');\r\n        });\r\n        Schema::dropIfExists('model_has_user');\r\n    }\r\n```\r\n\r\n### 執行 Migrate\r\n\r\n```cmd\r\nphp artisan migrate\r\n```\r\n\r\n### 還原 Migrate\r\n\r\n- 實際上他會實作 down() ，並將資料表內的資料刪掉。\r\n\r\n```cmd\r\nphp artisan migrate:rollback\r\nphp artisan migrate:rollback --step=5 // 還原最後 5 個 Migration\r\n```\r\n\r\n- 如果今天將 down() 註解掉，一樣會進行 Migrate 刪除 table 中的資料，但不會刪除資料表。\r\n\r\n### 重置 Migration\r\n\r\n```cmd\r\n//重置所有 Migration\r\nphp artisan migrate:refresh\r\n\r\n//重置所有 Migration 並同時建立資料\r\nphp artisan migrate:refresh --seed\r\n```\r\n\r\n## [Seed](https://ithelp.ithome.com.tw/articles/10216376)\r\n\r\n### 產生 Seeder 檔案\r\n\r\n```cmd\r\nphp artisan make:seed PersonTableSeeder\r\n```\r\n\r\n此時會多出一個檔案`database/seeds/PersonTableSeeder.php`，\r\n在`database/seeds/DatabaseSeeder.php`中，修改要呼叫的 Seeder：\r\n\r\n```php=\r\n$this->call(PersonTableSeeder::class);\r\n```\r\n\r\n執行 Seeder 時會呼叫 seeder 類別裡預設的 run() 方法。\r\n\r\n在`PersonTableSeeder.php`中加入要產生的資料。\r\n\r\n```php=\r\npublic function run()\r\n    {\r\n        DB::table('users')->insert([\r\n            'last_name' => str_random(10),\r\n            'email' => str_random(10).'@gmail.com',\r\n            'password' => bcrypt('secret'),\r\n        ]);\r\n    }\r\n```\r\n\r\n也可以使用模型工廠 factory 來大量生產資料。\r\n\r\n```php=\r\nfactory(App\\Person::class, 50)->create();\r\n// 使用 Person 的 factory\r\n```\r\n\r\n### 執行 Seeder\r\n\r\n用`--class`來指定特定的 Seeder Class\r\n\r\n```cmd\r\nphp artisan db:seed\r\n\r\nphp artisan db:seed --class=UsersTableSeeder\r\n```\r\n\r\n## [Factory](https://learnku.com/docs/laravel/6.x/database-testing/5185)\r\n\r\n> [深入了解 Faker](https://learnku.com/laravel/t/62386)\r\n\r\n### 產生 Factory 檔案\r\n\r\n```cmd\r\nphp artisan make:factory PersonFactory --model=Person\r\n```\r\n\r\n`--model=Person`選項用在指定 Factory 創建的 model 名稱，將會為指定 model 產生 Factory 文件。\r\n\r\n到`/database/factories/PersonFactory.php`，設定要填充的資料欄位。\r\n\r\n```php=\r\n$factory->define(Person::class, function (Faker $faker) {\r\n    return [\r\n        'last_name' => $faker->lastName,\r\n        'email'     => $faker->safeEmail,\r\n        'password'  => $faker->password\r\n    ];\r\n});\r\n```\r\n\r\n### [Faker Formatters](https://github.com/fzaninotto/Faker#formatters)\r\n\r\n- Faker 使用中文\r\n\r\n在 config\\app.php 下新增一行，指定 Faker 使用 zh_TW 語言\r\n\r\n```php=\r\n'faker_locale' => 'zh_TW',\r\n```\r\n","date":"2022-12-27T06:08:14.999Z","matchingLines":["## Migration\r","## [Seed](https://ithelp.ithome.com.tw/articles/10216376)\r","## [Factory](https://learnku.com/docs/laravel/6.x/database-testing/5185)\r"]},{"name":"Laravel Middleware.md","content":"# [Laravel Middleware](https://learnku.com/docs/laravel/8.x/middleware/9366)\r\n\r\n## 定義 middleware\r\n\r\n```bash\r\nphp artisan make:middleware CheckAge\r\n```\r\n\r\n在 `app/Http/Middleware` 目錄之下產生一個新的 CheckAge class，並在其中建立規則：僅允許 `age` 參數大於 200 的請求路徑進行訪問，否則將重新導向至 `home` 頁面\r\n\r\n```php\r\nnamespace App\\Http\\Middleware;\r\n\r\nuse Closure;\r\n\r\nclass CheckAge\r\n{\r\n    /**\r\n     * 处理传入的请求\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @param  \\Closure  $next\r\n     * @return mixed\r\n     */\r\n    public function handle($request, Closure $next)\r\n    {\r\n        if ($request->age <= 200) {\r\n            return redirect('home');\r\n        }\r\n\r\n        return $next($request);\r\n    }\r\n}\r\n```\r\n\r\n可以設定 middleware 的動作是在 request 之前或是之後\r\n\r\n```php\r\n// 在request 之前\r\nclass BeforeMiddleware\r\n{\r\n    public function handle($request, Closure $next)\r\n    {\r\n        // Perform action\r\n\r\n        return $next($request);\r\n    }\r\n}\r\n\r\n// 在request 之後\r\nclass AfterMiddleware\r\n{\r\n    public function handle($request, Closure $next)\r\n    {\r\n        $response = $next($request);\r\n\r\n        // Perform action\r\n\r\n        return $response;\r\n    }\r\n}\r\n```\r\n\r\n## 註冊 Middleware\r\n","date":"2022-12-27T06:02:37.129Z","matchingLines":["## 定義 middleware\r","## 註冊 Middleware\r"]},{"name":"Laravel Eloquent ORM.md","content":"# Laravel Eloquent ORM\r\n\r\n- [Laravel Eloquent ORM](#laravel-eloquent-orm)\r\n  - [models](#models)\r\n    - [建立 Model](#建立-model)\r\n    - [基本屬性](#基本屬性)\r\n  - [關聯](#關聯)\r\n    - [多型態關聯](#多型態關聯)\r\n      - [多形一對一關聯](#多形一對一關聯)\r\n      - [多型一對多關聯](#多型一對多關聯)\r\n      - [多型多對多關聯](#多型多對多關聯)\r\n      - [自訂多型型別](#自訂多型型別)\r\n  - [Laravel ORM 將資料存至資料庫](#laravel-orm-將資料存至資料庫)\r\n    - [save](#save)\r\n    - [修改多對多中間表](#修改多對多中間表)\r\n  - [ORM N+1](#orm-n1)\r\n    - [什麼是 N+1](#什麼是-n1)\r\n    - [解決 N+1 的問題](#解決-n1-的問題)\r\n  - [序列化](#序列化)\r\n    - [將 collection 序列化](#將-collection-序列化)\r\n      - [array](#array)\r\n      - [JSON](#json)\r\n    - [隱藏 JSON 屬性](#隱藏-json-屬性)\r\n      - [臨時修改屬性可見度](#臨時修改屬性可見度)\r\n    - [追加 JSON 值](#追加-json-值)\r\n      - [臨時追加屬性](#臨時追加屬性)\r\n    - [日期序列化](#日期序列化)\r\n      - [自訂任意屬性的日期格式](#自訂任意屬性的日期格式)\r\n  - [刪除](#刪除)\r\n    - [普通刪除](#普通刪除)\r\n    - [軟刪除](#軟刪除)\r\n      - [啟用軟刪除](#啟用軟刪除)\r\n      - [軟刪除應用](#軟刪除應用)\r\n      - [實現中間表的軟刪除](#實現中間表的軟刪除)\r\n      - [清除舊的軟刪除資料](#清除舊的軟刪除資料)\r\n\r\n## models\r\n\r\n### 建立 Model\r\n\r\n```php\r\nphp artisan make:model New\r\n```\r\n\r\n建立 Model 同時建立與其相關的 class\r\n\r\n```php\r\n// migration\r\nphp artisan make:model New -m\r\n\r\n// factory\r\nphp artisan make:model New -f\r\n\r\n// seed\r\nphp artisan make:model New -s\r\n\r\n// controller\r\nphp artisan make:model New -c\r\n\r\n// 同時建立多個class\r\nphp artisan make:model New -mfsc\r\n\r\n```\r\n\r\n### 基本屬性\r\n\r\n```php\r\nclass UserInfo extends Model\r\n{\r\n    protected $table = 'user_data';  // 資料表名稱\r\n\r\n    protected $primaryKey = 'id';   // 主鍵\r\n\r\n    public $timestamps = false;\r\n\r\n    protected $fillable = [\r\n        'userId',\r\n        'userName',\r\n        'account',\r\n        'password',\r\n        'email'\r\n    ];\r\n\r\n    protected $casts = [\r\n        'is_admin' => 'boolean',\r\n    ];\r\n}\r\n```\r\n\r\n- public $timestamps = false // 關閉時間戳記，預設為開啟\r\n- 批量賦值：調用 create() update() 時，可以大量新增、修改的欄位。若沒有添加這個屬性，新增修改的動作將無法實現。\r\n\r\n  - $fillable 設定可以大量新增的欄位（白名單）\r\n\r\n    ```php\r\n    protected $fillable = ['userId','userName','account','pw','email'];\r\n    ```\r\n\r\n  - $guarded 設定需要被保護的欄位（黑名單）\r\n\r\n    ```php\r\n    protected $guarded = [‘uuid’, ‘pw’];\r\n    ```\r\n\r\n- 屬性類型轉換：`$casts` 可以將屬性轉換為指定的類型，支援的類型有\r\n  - `integer`\r\n  - `real`\r\n  - `float`\r\n  - `double`\r\n  - `decimal:<digits>` 需定義小數位的個數，如 `decimal:2`\r\n  - `string`\r\n  - `boolean`\r\n  - `object`\r\n  - `array`\r\n  - `collection`\r\n  - `date`\r\n  - `datetime`\r\n  - `timestamps`\r\n\r\n## 關聯\r\n\r\n### 多型態關聯\r\n\r\n> [參考資料](https://laravelacademy.org/post/9725)\r\n>\r\n> 多型態關聯可以讓一張表同時關連到兩張以上的資料表\r\n>\r\n> 優點:\r\n> 可以合一管理資類類似的資料結構與處理邏輯\r\n> 缺點:\r\n> 耦合提高，變動邏輯時容易影響到某一方的操作\r\n\r\n假設我們有 user 跟 post 兩種資料，而他們各自有所屬的 image 資料表\r\n\r\n| users |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n| user_images |\r\n| :---------: |\r\n|     id      |\r\n|   user_id   |\r\n|     url     |\r\n\r\n| posts |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n| post_images |\r\n| :---------: |\r\n|     id      |\r\n|   post_id   |\r\n|     url     |\r\n\r\n如果 image 的資料結構和處理邏輯相似，就可以使用多型態關聯，將表單合成一張\r\n\r\n| users |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n| posts |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n|     images     |\r\n| :------------: |\r\n|       id       |\r\n| imaginable_type |\r\n|  imaginable_id  |\r\n|      url       |\r\n\r\n- imaginable_id : 關聯的主鍵值\r\n- imaginable_type : 指定這筆資料是關聯 users 資料表還是 posts 資料表，欄內儲存的是類別名稱，型態為字串，如：'App\\Models\\User' 'App\\Models\\Post'\r\n\r\n#### 多形一對一關聯\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Image extends Model\r\n{\r\n    public function imaginable()\r\n    {\r\n        return $this->morphTo();\r\n    }\r\n}\r\n\r\nclass Post extends Model\r\n{\r\n\r\n    public function image()\r\n    {\r\n        return $this->morphOne(Image::class, 'imaginable');\r\n    }\r\n}\r\n\r\nclass User extends Model\r\n{\r\n\r\n    public function image()\r\n    {\r\n        return $this->morphOne(Image::class, 'imaginable');\r\n    }\r\n}\r\n```\r\n\r\n- `morphOne`: hasOne 的多型態版本\r\n\r\n  和 hasOne 相比，標類別後面多了一個 name 參數 imaginable，Eloquent 會根據這個 name 預設目標表單上的查詢欄位，以 imaginable 為例的話就是查詢 imaginable_type 跟 imaginable_id\r\n\r\n  - 自訂目標的查詢欄位名稱\r\n\r\n    ```php\r\n    // morphOne(目標表單名稱，多形名稱，目標的型別欄位名稱，目標的外鍵欄位名稱，自己的關聯鍵)\r\n     $this->morphOne(Image::class, 'imaginable','imaginable_type',  'imaginable_id','id');\r\n    ```\r\n\r\n- `morphTo`: belongsTo 的多型態版本\r\n\r\n  ```php\r\n  // 使用時要注意函式的名稱\r\n  public function imaginable()\r\n  {\r\n      return $this->morphTo();\r\n  }\r\n  ```\r\n\r\n  如果沒有帶入參數的話預設會用函式的名稱產出預設名稱，像這裡的函式名稱是 imaginable ，那查詢時就會以型別欄位 imaginable_type 查對應的資料表，以及鍵值欄位 imaginable_id 查資料。\r\n\r\n  - 自訂預設名稱\r\n\r\n    ```php\r\n    $this->morphTo('imaginable');\r\n    ```\r\n\r\n  - 自訂查詢欄位的名稱\r\n\r\n    ```php\r\n    // morphOne(多形名稱，型別欄位名稱，外鍵欄位名稱)\r\n    $this->morphTo('imaginable'，'imaginable_type','imaginable_id');\r\n    ```\r\n\r\n#### 多型一對多關聯\r\n\r\n和一對一的關聯差不多，差別在 morphOne 改成 morphMany，查詢得到的資料不是一筆而是一組\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Image extends Model\r\n{\r\n    public function imaginable()\r\n    {\r\n        return $this->morphTo();\r\n    }\r\n}\r\n\r\nclass Post extends Model\r\n{\r\n\r\n    public function image()\r\n    {\r\n        return $this->morphMany(Image::class, 'imaginable');\r\n    }\r\n}\r\n\r\nclass User extends Model\r\n{\r\n\r\n    public function image()\r\n    {\r\n        return $this->morphMany(Image::class, 'imaginable');\r\n    }\r\n}\r\n```\r\n\r\n#### 多型多對多關聯\r\n\r\n> 和普通多對多關聯相比，中介表為多型態\r\n\r\n影片和文章有相同的 tag，一篇文章和影片同時會有多個 tag，一個 tag 也會同時關連到多個影片或文章\r\n| videos |\r\n| :----: |\r\n| id |\r\n| name |\r\n\r\n| posts |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n|   taggable   |\r\n| :-----------: |\r\n|      id       |\r\n|    tag_id     |\r\n| taggable_type |\r\n|  taggable_id  |\r\n\r\n| tags |\r\n| :--: |\r\n|  id  |\r\n| name |\r\n\r\n多型的一方，會用 morphToMany 方法\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Video extends Model\r\n{\r\n    /**\r\n     * Get all of the tags for the post.\r\n     */\r\n    public function tags()\r\n    {\r\n        return $this->morphToMany(Tag::class, 'taggable');\r\n    }\r\n}\r\n\r\nclass Post extends Model\r\n{\r\n    /**\r\n     * Get all of the tags for the post.\r\n     */\r\n    public function tags()\r\n    {\r\n        return $this->morphToMany(Tag::class, 'taggable');\r\n    }\r\n}\r\n```\r\n\r\n反向關聯會使用 morphedByMany 方法\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Tag extends Model\r\n{\r\n    /**\r\n     * Get all of the posts that are assigned this tag.\r\n     */\r\n    public function posts()\r\n    {\r\n        return $this->morphedByMany(Post::class, 'taggable');\r\n    }\r\n\r\n    /**\r\n     * Get all of the videos that are assigned this tag.\r\n     */\r\n    public function videos()\r\n    {\r\n        return $this->morphedByMany(Video::class, 'taggable');\r\n    }\r\n}\r\n```\r\n\r\n- `morphToMany`: belongsToMany 的多型態版\r\n- `morphedByMany`: 多對多的反向多型關聯\r\n\r\n  需要帶多型的名稱參數才能查詢資料\r\n\r\n  ```php\r\n  // morphOne(目標表單名稱，多形名稱)\r\n   $this->morphToMany(Tag::class, 'taggable');\r\n  ```\r\n\r\n  - 自訂名稱\r\n\r\n    ```php\r\n    public function morphedByMany(\r\n      $related,                 // 目標表單名稱\r\n      $name,                    // 多型名稱\r\n      $table = null,            // 中介表單名稱\r\n      $foreignPivotKey = null,  // 中介表單上參照自己的外鍵\r\n      $relatedPivotKey = null,  // 中介表單上參照目標的外鍵\r\n      $parentKey = null,        // 目標的關聯鍵\r\n      $relatedKey = null        // 自己的關聯鍵\r\n    )\r\n\r\n    $this->morphToMany(\r\n      Tag::class, 'taggable','taggable','taggable_id','tag_id','id','id'\r\n    );\r\n    ```\r\n\r\n#### 自訂多型型別\r\n\r\n預設 laravel 會使用類別的完整名稱來儲存 model type。\r\n\r\n可以透過自訂多型型別，使用簡單的字串作為 model type，將這些值從專案的內部結構中解耦出來。\r\n\r\n如此一來，即使修改 model 名稱，資料庫中的多型 type 欄位也會繼續有效。\r\n\r\n- 例如：  \r\n  Commit Model 可以隸屬於 Post Model 或 Video Model。因此，comments 資料表中的 commentable_type 欄位分別會記載 App\\Models\\Post 或 App\\Models\\Video。\r\n\r\n  此時可以在 `App\\Providers\\AppServiceProvider` 中的 `boot` 方法，呼叫`enforceMorphMap`方法。將 post 及 video 等簡單字串作為 model type。\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\Relations\\Relation;\r\n\r\nRelation::enforceMorphMap([\r\n    'post' => 'App\\Models\\Post',\r\n    'video' => 'App\\Models\\Video',\r\n]);\r\n```\r\n\r\n## Laravel ORM 將資料存至資料庫\r\n\r\n### save\r\n\r\n將表格第一筆資料的名字，改成小華\r\n\r\n```php\r\nUser::find(1)->save(['name' => '小華']);\r\n```\r\n\r\n也可以一次編輯多個欄位\r\n\r\n```php\r\nUser::find(1)->save([\r\n  'name'=>'小華',\r\n  'email'=>'flower@gmail.com'\r\n  'sex'=>'male'\r\n]);\r\n```\r\n\r\n### 修改多對多中間表\r\n\r\n- articles\r\n\r\n| id  | article_name |\r\n| :-: | :----------: |\r\n|  1  |   article1   |\r\n|  2  |   article2   |\r\n|  3  |   article3   |\r\n|  4  |   article5   |\r\n\r\n- tags\r\n\r\n| id  | tag_name |\r\n| :-: | :------: |\r\n|  1  |   tech   |\r\n|  2  |  music   |\r\n|  3  |   art    |\r\n|  4  |   food   |\r\n\r\n- article_tag\r\n\r\n| article_id | tag_id |\r\n| :--------: | :----: |\r\n|     1      |   2    |\r\n|     1      |   3    |\r\n|     1      |   4    |\r\n|     3      |   4    |\r\n\r\n建立和控制多對多關係的方法\r\n\r\n- 建立:\r\n\r\n  - `attach()`\r\n\r\n    ```php\r\n    // id=3 的文章原有的標籤[4]\r\n    Article::find(3)->tags()->attach([1,2]);\r\n    // id=3 的文章加入標籤[1, 2]\r\n    // id=3 的文章的標籤有[1, 2, 4]\r\n    ```\r\n\r\n  - `save()`\r\n\r\n    ```php\r\n    Article::find(3)->tags()->saveMany([\r\n        Tag::find(1),\r\n    Tag::find(2)\r\n    ]);\r\n    // save輸入的類型須為model\r\n    // 多個時要用saveMany\r\n    ```\r\n\r\n    |   方法   | 單個 id | 多個 id | 單個 model |   多個 model    |\r\n    | :------: | :-----: | :-----: | :--------: | :-------------: |\r\n    | attach() |    V    |    V    |     V      |                 |\r\n    |  sync()  |    V    |    V    |     V      |                 |\r\n    |  save()  |         |         |     V      | 要用 saveMany() |\r\n\r\n- 刪去: `detach()`\r\n\r\n  ```php\r\n  $article = Article::find(1);\r\n\r\n  // 從文章上移除指定tag\r\n  $article->tags()->detach($tag_id);\r\n\r\n  // 移除文章所有tag\r\n  $article->tags()->detach();\r\n  ```\r\n\r\n- 同步\r\n\r\n  - `sync`\r\n\r\n    ```php\r\n    // 更新有傳入值的該筆資料，其他資料會被刪除\r\n    $user->roles()->sync([1, 2, 3]);\r\n\r\n    // 透過id傳入額外的值到中間表\r\n    $user->roles()->sync([1 => ['expires' => true], 2, 3]);\r\n    ```\r\n\r\n  - `syncWithoutDetaching`\r\n\r\n    ```php\r\n    // 更新有傳入值的該筆資料，並保留原有的資料\r\n    $user->roles()->syncWithoutDetaching([1, 2, 3]);\r\n    ```\r\n\r\n  - `updateExistingPivot`\r\n\r\n    ```php\r\n    // 更新一筆已存在的資料，接受中間表的外鍵和要更新的值進行更新\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    $user->roles()->updateExistingPivot($roleId, $attributes);\r\n    ```\r\n\r\n- 切換: `toggle()`\r\n\r\n  ```php\r\n  $article->tags()->toggle([1, 2 ,3]);\r\n  // 用來切換傳入id的附加狀態，如果傳入的id目前已經被附加，他將會被卸除。\r\n  // 若已經被卸除，將會被附加\r\n  ```\r\n\r\n## ORM N+1\r\n\r\n> 紀錄 ORM 對資料庫的查詢語法\r\n>\r\n> ```php\r\n> // 開始紀錄\r\n> DB::enableQueryLog();\r\n>\r\n> // 結束並印出\r\n> dd(DB::getQueryLog());\r\n> ```\r\n\r\n### 什麼是 N+1\r\n\r\n資料表中有關聯關係，以論壇文章為例。\r\n\r\n- 一名使用者，可以發布多篇文章。\r\n- 一篇文章只屬於一名使用者。\r\n\r\n使用者與文章的關係為一對多。當我們要取得多名使用者，並同時取得這些使用者過去發布的所有文章時：\r\n\r\n```php\r\nuse App\\Models\\User;\r\nuse Illuminate\\Support\\Facades\\Route;\r\n\r\nRoute::get('lazy-loading', function () {\r\n  // 開啟 Query Log\r\n  DB::enableQueryLog();\r\n\r\n  // 取得所有使用者\r\n  $users = User::get();\r\n\r\n  // 使用迴圈取得每一位使用者所發布的文章\r\n  foreach ($users as $user) {\r\n      $posts = $user->posts;\r\n      dump($posts->toArray());\r\n  }\r\n\r\n  // dump 對資料庫的查詢語法\r\n  dump(DB::getQueryLog());\r\n});\r\n```\r\n\r\n這時就會產生 n+1 的問題。\r\n\r\n第一筆查詢是取得所有用戶。\r\n\r\n```php\r\n// 取得所有使用者\r\n$users = User::get();\r\n```\r\n\r\n接下來每一筆是取得各用戶發布的文章。\r\n\r\n```php\r\n// 使用迴圈取得每一位使用者所發布的文章\r\nforeach ($users as $user) {\r\n  $posts = $user->posts;\r\n}\r\n```\r\n\r\n### 解決 N+1 的問題\r\n\r\n可以使用 laravel 所提供的預加載功能 `with()`\r\n\r\n```php\r\nRoute::get('lazy-loading', function () {\r\n  // 開啟 Query Log\r\n  DB::enableQueryLog();\r\n\r\n  // 取得所有使用者，並預先加載 Post 的資料\r\n  // 這裡的 'posts' 對應到 User Model 中的 posts()\r\n  $users = User::with('posts')->get();\r\n\r\n  // 使用迴圈取得每一位使用者所發布的文章\r\n  foreach ($users as $user) {\r\n      $posts = $user->posts;\r\n      dump($posts->toArray());\r\n  }\r\n\r\n  // dump 對資料庫的查詢語法\r\n  dump(DB::getQueryLog());\r\n});\r\n```\r\n\r\n這時僅執行了兩個查詢\r\n\r\n```sql\r\nselect * from users\r\n\r\nselect * from posts where id in (1, 2, 3, 4, 5, ...)\r\n```\r\n\r\n可以指定不需要某些資料\r\n\r\n```php\r\n$users = User::without('posts')->get();\r\n```\r\n\r\n或是只需要其他資料\r\n\r\n```php\r\n$users = User::withOnly('loginRecords')->get();\r\n```\r\n\r\n也可以加載多個關聯\r\n\r\n```php\r\n$users = User::with(['posts', 'commit'])->get();\r\n```\r\n\r\n## 序列化\r\n\r\n> 建構 JSON API 時，針對 model 及其取得關連的值，將其轉化為 array 或是 JSON\r\n\r\n### 將 collection 序列化\r\n\r\n#### array\r\n\r\n- `toArray()` 所有的屬性和關聯(包括關聯的關聯)，當將轉化為陣列。\r\n\r\n  ```php\r\n  $user = App\\Models\\User::with('roles')->first();\r\n\r\n  return $user->toArray();\r\n\r\n  // 將整個 model collection 序列化\r\n  $users = App\\Models\\User::all();\r\n\r\n  return $users->toArray();\r\n  ```\r\n\r\n- `attributesToArray()` 僅將 model 的屬性轉換為陣列\r\n\r\n  ```php\r\n  $user = App\\Models\\User::first();\r\n\r\n  return $user->attributesToArray();\r\n  ```\r\n\r\n#### JSON\r\n\r\n- `toJson` 所有的屬性和關聯(包括關聯的關聯)，當將轉化為 JSON。\r\n\r\n  ```php\r\n  $user = App\\Models\\User::find(1);\r\n\r\n  return $user->toJson();\r\n\r\n  // 指定PHP支援的JSON編碼選項\r\n  return $user->toJson(JSON_PRETTY_PRINT);\r\n  ```\r\n\r\n- 將 model 或 collection 轉為字串時，會自動調用`toJson()`，因此可以應用在 route 或 controller 中直接返回。\r\n\r\n  ```php\r\n  Route::get('users', function () {\r\n      return App\\Models\\User::all();\r\n  });\r\n\r\n  $user = App\\Models\\User::find(1);\r\n\r\n  return (string) $user;\r\n  ```\r\n\r\n- 關聯屬性：當 model 被轉化為 JSON 的時候，他加載的關聯關係也將自動轉化為 JSON 對象被包含進來，同時透過小駝峰定義的關聯方式，關聯的 JSON 屬性將會是蛇底式命名。\r\n\r\n### 隱藏 JSON 屬性\r\n\r\n> 有時需要將 model array 或 JSON 中某些屬性進行隱藏，如：密碼。\r\n\r\n- `$hidden`\r\n\r\n  ```php\r\n  namespace App\\Models;\r\n\r\n  use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n  class User extends Model\r\n  {\r\n      /**\r\n       * 数组中的属性会被隐藏\r\n       *\r\n       * @var array\r\n       */\r\n      protected $hidden = ['password'];\r\n  }\r\n  ```\r\n\r\n- `$visible` 定義一個 model array 和 JSON 可見的白名單。經過定義後，序列化此 model 不會出現白名單以外的屬性。\r\n\r\n  ```php\r\n  namespace App\\Models;\r\n\r\n  use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n  class User extends Model\r\n  {\r\n      /**\r\n       * 数组中的属性会被展示\r\n       *\r\n       * @var array\r\n       */\r\n      protected $visible = ['first_name', 'last_name'];\r\n  }\r\n  ```\r\n\r\n#### 臨時修改屬性可見度\r\n\r\n- `makeVisible`\r\n\r\n  ```php\r\n  return $user->makeVisitable('attribute')->toArray();\r\n  ```\r\n\r\n- `makeHidden`\r\n\r\n  ```php\r\n  return $user->makeHidden('attribute')->toArray();\r\n  ```\r\n\r\n### 追加 JSON 值\r\n\r\n> 在 array 或是 JSON 中添加一些不存在於資料庫的欄位。\r\n\r\n定義 `getAttribute`\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass User extends Model\r\n{\r\n    /**\r\n     * Get the administrator flag for the user.\r\n     *\r\n     * @return bool\r\n     */\r\n    public function getIsAdminAttribute()\r\n    {\r\n        return $this->attributes['admin'] === 'yes';\r\n    }\r\n}\r\n```\r\n\r\n然後在 model 中宣告屬性 `appends`。\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass User extends Model\r\n{\r\n    /**\r\n     * The accessors to append to the model's array form.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $appends = ['is_admin'];\r\n}\r\n```\r\n\r\n- **Notice:** 在`getAttribute`中使用駝峰命名，但在宣告屬性時，通常以蛇底式命名。\r\n\r\n宣告 `append` 追加屬性後，其將會被包含在 model array 和 JSON 中。追加屬性也會遵循 model 宣告的`visible`及`hidden`屬性。\r\n\r\n#### 臨時追加屬性\r\n\r\n可以在單一 model 實例，使用`append`方法蘭追加屬性。或者使用`setAppends`方法來重寫追加屬性的陣列。\r\n\r\n```php\r\nreturn $user->append('is_admin')->toArray();\r\n\r\n// 重寫整個追加屬性的陣列\r\nreturn $user->setAppends(['is_admin'])->toArray();\r\n```\r\n\r\n### 日期序列化\r\n\r\n- `serializeDate` 此方法可自訂預設的日期序列化格式\r\n\r\n```php\r\n/**\r\n * 為array / JSON 序列化準備一個日期\r\n *\r\n * @param  \\DateTimeInterface  $date\r\n * @return string\r\n */\r\nprotected function serializeDate(DateTimeInterface $date)\r\n{\r\n    return $date->format('Y-m-d');\r\n}\r\n```\r\n\r\n#### 自訂任意屬性的日期格式\r\n\r\n可以在 Eloquent 宣告屬性轉換，單獨為資料庫中為日期屬性的欄位定義其格式\r\n\r\n```php\r\nprotected $casts = [\r\n    'birthday' => 'date:Y-m-d',\r\n    'joined_at' => 'datetime:Y-m-d H:00',\r\n];\r\n```\r\n\r\n## 刪除\r\n\r\n### 普通刪除\r\n\r\n```php\r\n$contact = Contact::find(5);\r\n$contact->delete();\r\n```\r\n\r\n透過 id 刪除\r\n\r\n```php\r\nContact::destroy(1);\r\n// or\r\nContact::destroy([1, 5, 7]);\r\n```\r\n\r\n刪除查詢結果\r\n\r\n```php\r\nContact::where('updated_at', '<', now()->subYear())->delete();\r\n```\r\n\r\n### 軟刪除\r\n\r\n> 透過在資料表中增加一個 delete_at 的欄位，來標記要刪除的資料，而不是直接將資料刪除。\r\n>\r\n> 優點：刪除的資料可以被復原、可以記錄資料刪除的時間點。\r\n>\r\n> 缺點：中間表無法使用軟刪除、需要定時清理軟刪除的資料，以免資料庫日益肥大。\r\n\r\n#### 啟用軟刪除\r\n\r\n將 `Illuminate\\Database\\Eloquent\\SoftDeletes` Trait 加到 Model 上\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\r\n\r\nclass Flight extends Model\r\n{\r\n    use SoftDeletes;\r\n}\r\n```\r\n\r\n利用 migration 將 delete_at 欄位加入資料表\r\n\r\n```php\r\nuse Illuminate\\Database\\Schema\\Blueprint;\r\nuse Illuminate\\Support\\Facades\\Schema;\r\n\r\npublic function up() {\r\n    Schema::table('flights', function (Blueprint $table) {\r\n        $table->softDeletes();\r\n    });\r\n}\r\n\r\npublic function down() {\r\n    Schema::table('flights', function (Blueprint $table) {\r\n        $table->dropSoftDeletes();\r\n    });\r\n}\r\n```\r\n\r\n當在 model 上呼叫 delete 方法時，會自動更新 delete_at 欄位，並設為當前時間。\r\n\r\n#### 軟刪除應用\r\n\r\n- 判斷是否已被軟刪除\r\n\r\n  ```php\r\n  if ($flight->trashed()) {\r\n      //\r\n  }\r\n  ```\r\n\r\n- 恢復軟刪除\r\n\r\n  ```php\r\n  $flight->restore();\r\n\r\n  // 恢復多個\r\n  Flight::withTrashed()\r\n      ->where('airline_id', 1)\r\n      ->restore();\r\n  ```\r\n\r\n  - 永久刪除 model\r\n\r\n  ```php\r\n  $flight->forceDelete();\r\n  ```\r\n\r\n- 查詢軟刪除的 model\r\n\r\n  - 包含軟刪除的 model\r\n\r\n    ```php\r\n    use App\\Models\\Flight;\r\n\r\n    $flights = Flight::withTrashed()\r\n                    ->where('account_id', 1)\r\n                    ->get();\r\n    ```\r\n\r\n  - 只取得被刪除的 model\r\n\r\n    ```php\r\n    $flights = Flight::onlyTrashed()\r\n                    ->where('airline_id', 1)\r\n                    ->get();\r\n    ```\r\n\r\n#### 實現中間表的軟刪除\r\n\r\n> 一般不建議對 pivot 進行軟刪除。\r\n\r\n在 pivot 表，添加一個 bool 欄位，ex: is_deleted。\r\n\r\n- `updateExistingPivot()` 此方法可以修改這欄位\r\n- `wherePivot('is_deleted', true)` 可以篩選數據\r\n\r\n```php\r\nBook::find(1)->buyers()->wherePivot('is_deleted', true)->get()\r\n\r\nBook::find(1)->buyers()->updateExistingPivot(11, ['is_deleted' => false])\r\n```\r\n\r\n或者在關聯中，定義兩者的關係\r\n\r\n```PHP\r\nfunction buyers() {\r\n    return $this->belongToMany('App\\User')->wherePivot('is_deleted', false);\r\n}\r\n\r\nfunction buyersWithDeleted() {\r\n    return $this->belongToMany('App\\User');\r\n}\r\n```\r\n\r\n#### 清除舊的軟刪除資料\r\n\r\n[參考資料](https://github.com/tighten/quicksand)\r\n","date":"2022-12-27T06:00:03.480Z","matchingLines":["## models\r","## 關聯\r","## Laravel ORM 將資料存至資料庫\r","## ORM N+1\r","## 序列化\r","## 刪除\r"]},{"name":"Laravel API Format.md","content":"# Laravel API Format\r\n\r\n> api 返回資料若以原生格式返回，沒有經過任何處理，可能包含敏感資訊\r\n>\r\n> 利用 transformer 可以將 api 響應的訊息系統化規則，進行統一輸出，方便管理與編輯\r\n>\r\n> 參考資料：\r\n>\r\n> [Laravel API 系列教程（三）：使用 API Resource 来创建自己的 {JSON:API} 格式 API](https://laravelacademy.org/post/9203)\r\n>\r\n> [Laravel 構建 API 伺服器之響應資料處理](https://www.796t.com/content/1545181747.html)\r\n>\r\n> [Laravel 8 中文文檔 API 资源](https://learnku.com/docs/laravel/8.x/eloquent-resources/9410)\r\n\r\n- [Laravel API Format](#laravel-api-format)\r\n  - [spatie/laravel-fractal 套件](#spatielaravel-fractal-套件)\r\n    - [建立 transformer](#建立-transformer)\r\n    - [在 controller 中使用 transformer](#在-controller-中使用-transformer)\r\n  - [API Resource](#api-resource)\r\n\r\n## spatie/laravel-fractal 套件\r\n\r\n```bash\r\ncomposer require spatie/laravel-fractal\r\n```\r\n\r\n安裝完成後，在 laravel 中註冊\r\n\r\n```bash\r\nphp artisan vendor:publish --provider=\"Spatie\\Fractal\\FractalServiceProvider\"\r\n```\r\n\r\n### 建立 transformer\r\n\r\n在 app/Http 的目錄下建立 Transformers 目錄\r\n\r\n```bash\r\nphp artisan make:transformer TestTransformer\r\n```\r\n\r\n```php\r\nnamespace App\\Transformers;\r\n\r\nuse League\\Fractal\\TransformerAbstract;\r\n\r\nclass TeatTransformer extends TransformerAbstract\r\n{\r\n    /**\r\n     * List of resources to automatically include\r\n     *\r\n     * @var array\r\n     */\r\n    protected $defaultIncludes = [\r\n        //\r\n    ];\r\n\r\n    /**\r\n     * List of resources possible to include\r\n     *\r\n     * @var array\r\n     */\r\n    protected $availableIncludes = [\r\n        //\r\n    ];\r\n\r\n    /**\r\n     * A Fractal transformer.\r\n     *\r\n     * @return array\r\n     */\r\n    public function transform()\r\n    {\r\n        return [\r\n            'id' => $user->id,\r\n            'name' => $user->name,\r\n            'signature' => $user->signature,\r\n            'created_at' => $user->created_at->toDateTimeString()\r\n        ];\r\n    }\r\n}\r\n```\r\n\r\n返回的陣列代表真實要響應的 json 資料格式\r\n\r\n### 在 controller 中使用 transformer\r\n\r\n匯入 transformer 命名空間\r\n\r\n```php\r\nclass UserController extends Controller\r\n{\r\n\r\n    /**\r\n     * 使用者列表介面\r\n     */\r\n    public function index()\r\n    {\r\n      $users = User::all();\r\n\r\n      return $this->response->collection($users, new TestTransformer());\r\n    }\r\n\r\n}\r\n```\r\n\r\n輸出：\r\n\r\n```json\r\n{\r\n  \"data\": [\r\n    {\r\n      \"id\": 1,\r\n      \"name\": \"張三\",\r\n      \"signature\": \"Hello, World\",\r\n      \"created_at\": \"2018-11-02 16:21:20\"\r\n    },\r\n    {\r\n      \"id\": 2,\r\n      \"name\": \"李四\",\r\n      \"signature\": \"這個人很懶...什麼也沒有留下\",\r\n      \"created_at\": \"2018-11-02 16:21:20\"\r\n    }\r\n  ],\r\n  \"meta\": {\r\n    // ...自動生成的元資料，如果你查詢出的資料帶有分頁資料（laravel中的Paginate）\r\n    // 那麼Transformer將會自動幫你把分頁資料加入在此處\r\n  }\r\n}\r\n```\r\n\r\n## API Resource\r\n\r\nLaravel 5.5 新增的 API Resource，和 transformer 功能與思路基本上一樣\r\n\r\n但由於是 laravel 官方釋出，因此與 Laravel Eloquent model 各種功能結合的更加緊密\r\n\r\n```bash\r\nphp artisan make:resource ArticleResource\r\n```\r\n\r\n生成的檔案位於 app/Http/Resources 目錄底下\r\n\r\n```php\r\nnamespace App\\Http\\Resources;\r\n\r\nuse Illuminate\\Http\\Resources\\Json\\Resource;\r\n\r\nclass TestResource extends Resource\r\n{\r\n    /** * Transform the resource into an array.\r\n     *\r\n     * @param \\Illuminate\\Http\\Request $request\r\n     * @return array\r\n     */\r\n    public function toArray($request)\r\n    {\r\n        return [\r\n            'id' => $user->id,\r\n            'name' => $user->name,\r\n            'signature' => $user->signature,\r\n            'created_at' => $user->created_at->toDateTimeString()\r\n        ];\r\n    }\r\n}\r\n```\r\n\r\n在 controller 中將 transformer 實例化\r\n\r\n```php\r\npublic function show(User $user)\r\n{\r\n    return new ArticleResource($user);\r\n}\r\n```\r\n\r\n```json\r\n{\r\n  \"data\": {\r\n        {\r\n          \"id\": 1,\r\n          \"name\": \"張三\",\r\n          \"signature\": \"Hello, World\",\r\n          \"created_at\": \"2018-11-02 16:21:20\"\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n預設數據會被包在 data 的物件裡面，可以透過 `withoutWrapping()` 來將其去除\r\n\r\n```php\r\npublic function show(User $user)\r\n{\r\n    TestResource::withoutWrapping();\r\n    return new TestResource($user);\r\n}\r\n```\r\n","date":"2022-12-27T05:49:30.473Z","matchingLines":["## spatie/laravel-fractal 套件\r","## API Resource\r"]},{"name":"Laravel 服務容器.md","content":"# Laravel 服務容器\r\n\r\n> **參考資料**：\r\n> [Laravel 學習筆記—— 神奇的服務容器\r\n> ](https://learnku.com/articles/789/laravel-learning-notes-the-magic-of-the-service-container)\r\n>\r\n> 容器，字面上理解就是裝東西的東西。\r\n> 常見的變量、物件屬性等都可以算是容器。\r\n> 一個容器能夠裝什麼，全部取決於你對該容器的定義。\r\n> 當然，有這樣一種容器，它存放的不是文本、數值，而是物件、物件的描述(類別、介面)或者是提供物件的回調，\r\n> 通過這種容器，我們得以實現許多高級的功能，其中最常提到的，就是\"解耦\"、\"依賴注入(DI)\"。本文就從這裡開始。\r\n\r\n## IoC 容器 laravel 的核心\r\n\r\nLaravel 的核心就是一個 IoC 容器，根據官方文件，稱其為\"服務容器\"，顧名思義，該容器提供了整個框架中需要的一系列服務。作為初學者，很多人會在這一個概念上犯難，因此，我打算從一些基礎的內容開始講解，通過理解面向物件開發中依賴的產生和解決方法，來逐漸揭開\"依賴注入\"的面紗，逐漸理解這一神奇的設計理念。\r\n\r\n## IoC 容器誕生的故事\r\n\r\n超人和超能力，依賴的產生！\r\n物件導向程式碼，有以下幾樣東西無時不刻的接觸：介面、類別還有物件。這其中，介面是類別的原型，一個類別必須要遵守其實現的介面；物件則是一個類別實例化後的產物，我們稱其為一個實例。當然這樣說肯定不利於理解，我們就實際的寫點中看不中用的代碼輔助學習。\r\n\r\n> 怪物橫行的世界，總歸需要點超級人物來擺平。\r\n\r\n我們把一個\"超人\"作為一個類別，\r\n\r\n```php\r\nclass Superman {}\r\n```\r\n\r\n我們可以想像，一個超人誕生的時候肯定擁有至少一個超能力，這個超能力也可以抽象為一個物件，為這個物件定義一個描述他的類別吧。一個超能力肯定有多種屬性、(操作)方法，這個盡情的想像，但是目前我們先大致定義一個只有屬性的\"超能力\"，至於能幹啥，我們以後再豐富：\r\n\r\n```php\r\nclass Power\r\n{\r\n    /**\r\n    * 能力值\r\n    */\r\n    protected $ability;\r\n\r\n    /**\r\n     * 能力範圍或距離\r\n     */\r\n    protected $range;\r\n\r\n    public function __construct($ability, $range) {\r\n        $this->ability = $ability;\r\n        $this->range = $range;\r\n    }\r\n}\r\n```\r\n\r\n這時候我們回過頭，修改一下之前的\"超人\"類別，讓一個\"超人\"創建的時候被賦予一個超能力：\r\n\r\n```php\r\nclass Superman\r\n{\r\n    protected $power;\r\n\r\n    public function __construct()\r\n    {\r\n        $this->power = new Power(999, 100);\r\n    }\r\n\r\n}\r\n```\r\n\r\n這樣的話，當我們創建一個\"超人\"實例的時候，同時也創建了一個\"超能力\"的實例，但是，我們看到了一點，\"超人\"和\"超能力\"之間不可避免的產生了一個依賴。\r\n\r\n> 所謂\"依賴\"，就是\"我若依賴你，少了你就沒有我\"。\r\n\r\n在一個貫徹物件導向程式碼的項目中，這樣的依賴隨處可見。少量的依賴並不會有太過直觀的影響，我們隨著這個例子逐漸鋪開，讓大家慢慢意識到，當依賴達到一個量級時，是怎樣一番噩夢般的體驗。當然，我也會自然而然的講述如何解決問題。\r\n\r\n### 一堆亂麻——可怕的依賴\r\n\r\n之前的例子中，超能力類別實例化後是一個具體的超能力，但是我們知道，超人的超能力是多元化的，每種超能力的方法、屬性都有不小的差異，沒法通過一種類別描述完全。我們現在進行修改，我們假設超人可以有以下多種超能力：\r\n\r\n- 飛行，屬性有：飛行速度、持續飛行時間\r\n- 蠻力，屬性有：力量值\r\n- 能量彈，屬性有：傷害值、射擊距離、同時射擊個數\r\n\r\n我們建立以下類別：\r\n\r\n```php\r\nclass Flight\r\n{\r\n    protected $speed;\r\n    protected $hold_time;\r\n    public function __construct($speed, $hold_time) {}\r\n}\r\n\r\nclass Force\r\n{\r\n    protected $force;\r\n    public function __construct($force) {}\r\n}\r\n\r\nclass Shot\r\n{\r\n    protected $atk;\r\n    protected $range;\r\n    protected $limit;\r\n    public function __construct($atk, $range, $limit) {}\r\n}\r\n\r\n```\r\n\r\n**這邊沒有詳細寫出 `__construct()` 這個構造函數的全部，只寫了需要傳遞的參數**\r\n\r\n好了，這下我們的超人有點\"忙\"了。在超人初始化的時候，我們會根據需要來實例化其擁有的超能力嗎，大致如下：\r\n\r\n```php\r\nclass Superman\r\n{\r\n    protected $power;\r\n\r\n    public function __construct()\r\n    {\r\n        $this->power = new Fight(9, 100);\r\n        // $this->power = new Force(45);\r\n        // $this->power = new Shot(99, 50, 2);\r\n        /*\r\n        $this->power = array(\r\n            new Force(45),\r\n            new Shot(99, 50, 2)\r\n        );\r\n        */\r\n    }\r\n\r\n}\r\n```\r\n\r\n我們需要自己手動的在構造函數內(或者其他方法裡)實例化一系列需要的類別，這樣並不好。可以想像，假如需求變更(不同的怪物橫行地球)，需要更多的有針對性的 新的 超能力，或者需要 變更 超能力的方法，我們必須 重新改造 超人。換句話說就是，改變超能力的同時，我還得重新製造個超人。效率太低了！新超人還沒創造完成世界早已被毀滅。\r\n\r\n> 這時，靈機一動的人想到：為什麼不可以這樣呢？超人的能力可以被隨時更換，只需要添加或者更新一個芯片或者其他裝置啥的(想到鋼鐵人沒)\r\n> 這樣的話就不要整個重新來過了。\r\n\r\n對，就是這樣的。\r\n\r\n我們不應該手動在\"超人\"類別中固化了他的\"超能力\"初始化的行為，而轉由外部負責，由外部創造超能力模組、裝置或者芯片等(我們後面統一稱為\"模組\")，植入超人體內的某一個介面，這個介面是一個既定的，只要這個\"模組\"滿足這個介面的裝置都可以被超人所利用，可以提升、增加超人的某一種能力。這種由外部負責其依賴需求的行為，我們可以稱其為`控制反轉(IoC)`。\r\n\r\n### 工廠模式，依賴轉移\r\n\r\n當然，實現控制反轉的方法有幾種。在這之前，不如我們先了解一些好玩的東西。\r\n\r\n> 我們可以想到，組件、工具(或者超人的模組)，是一種可被生產的玩意兒，生產的地方當然是\"工廠(Factory)\"，於是有人就提出了這樣一種模式：`工廠模式`。\r\n\r\n工廠模式，顧名思義，就是一個類別所以依賴的外部事物的實例，都可以被一個或多個\"工廠\"創建的這樣一種開發模式，就是工廠模式。\r\n\r\n我們為了給超人製造超能力模組，我們創建了一個工廠，它可以製造各種各樣的模組，且僅需要通過一個方法：\r\n\r\n```php\r\nclass SuperModuleFactory\r\n{\r\n    public function makeModule($moduleName, $options) {\r\n        switch ($moduleName) {\r\n            case 'Fight':\r\n                return new Fight($options[0], $options[1]);\r\n            case 'Force':\r\n                return new Force($options[0]);\r\n            case 'Shot':\r\n                return new Shot($options[0], $options[1], $options[2]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n這時候，超人創建之初就可以使用這個工廠！\r\n\r\n```php\r\nclass Superman\r\n{\r\nprotected $power;\r\n\r\n    public function __construct()\r\n    {\r\n        // 初始化工廠\r\n        $factory = new SuperModuleFactory;\r\n\r\n        // 通過工廠提供的方法制造需要的模組\r\n        $this->power = $factory->makeModule('Fight', [9, 100]);\r\n        // $this->power = $factory->makeModule('Force', [45]);\r\n        // $this->power = $factory->makeModule('Shot', [99, 50, 2]);\r\n        /*\r\n        $this->power = array(\r\n            $factory->makeModule('Force', [45]),\r\n            $factory->makeModule('Shot', [99, 50, 2])\r\n        );\r\n        */\r\n    }\r\n\r\n}\r\n```\r\n\r\n可以看得出，我們不再需要在超人初始化之初，去初始化許多第三方類別，只需初始化一個工廠類別，即可滿足需求。但這樣似乎和以前區別不大，只是沒有那麼多 new 關鍵字。其實我們稍微改造一下這個類別，你就明白，工廠類別的真正意義和價值了。\r\n\r\n```php\r\nclass Superman\r\n{\r\n    protected $power;\r\n\r\n    public function __construct(array $modules)\r\n    {\r\n        // 初始化工廠\r\n        $factory = new SuperModuleFactory;\r\n\r\n        // 通過工廠提供的方法制造需要的模組\r\n        foreach ($modules as $moduleName => $moduleOptions) {\r\n            $this->power[] = $factory->makeModule($moduleName, $moduleOptions);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// 建立超人\r\n$superman = new Superman([\r\n    'Fight' => [9, 100],\r\n    'Shot' => [99, 50, 2]\r\n]);\r\n```\r\n\r\n現在修改的結果令人滿意。現在，\"超人\"的創建不再依賴任何一個\"超能力\"的類別，我們如若修改了或者增加了新的超能力，只需要針對修改 `SuperModuleFactory` 即可。擴充超能力的同時不再需要重新編輯超人的類別文件，使得我們變得很輕鬆。但是，這才剛剛開始。\r\n\r\n### 再進一步！IoC 容器的重要組成—— 依賴注入\r\n\r\n由\"超人\"對\"超能力\"的依賴變成\"超人\"對\"超能力模組工廠\"的依賴後，對付小怪獸們變得更加得心應手。但這也正如你所看到的，依賴並未解除，只是由原來對多個外部的依賴變成了對一個\"工廠\"的依賴。假如工廠出了點麻煩，問題變得就很棘手。\r\n\r\n> 其實大多數情況下，工廠模式已經足夠了。\r\n> 工廠模式的缺點就是：介面未知(即沒有一個很好的契約模型，關於這個我馬上會有解釋)、產生物件類別型單一。\r\n> 總之就是，還是不夠靈活。\r\n> 雖然如此，工廠模式依舊十分優秀，並且適用於絕大多數情況。\r\n> 不過我們為了講解後面的依賴注入，這裡就先誇大一下工廠模式的缺陷咯。\r\n\r\n我們知道，超人依賴的模組，我們要求有統一的介面，這樣才能和超人身上的注入介面對接，最終起到提升超能力的效果。\r\n\r\n事實上，我之前說謊了，不僅僅只有一堆小怪獸，還有更多的大怪獸。嘿嘿。額，這時候似乎工廠的生產能力顯得有些不足—— 由於工廠模式下，所有的模組都已經在工廠類別中安排好了，如果有新的、高級的模組加入，我們必須修改工廠類別(好比增加新的生產線)：\r\n\r\n```php\r\nclass SuperModuleFactory\r\n{\r\n    public function makeModule($moduleName, $options){\r\n        switch ($moduleName) {\r\n            case 'Fight':\r\n                return new Fight($options[0], $options[1]);\r\n            case 'Force':\r\n                return new Force($options[0]);\r\n            case 'Shot':\r\n                return new Shot($options[0], $options[1], $options[2]);\r\n            // case 'more': .......\r\n            // case 'and more': .......\r\n            // case 'and more': .......\r\n            // case 'oh no! its too many!': .......\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n噩夢般的感受！\r\n\r\n> 其實靈感就差一步！你可能會想到更為靈活的辦法！對，下一步就是我們今天的主要配角—— DI (依賴注入)\r\n\r\n由於對超能力模組的需求不斷增大，我們需要集合整個世界的高智商人才，一起解決問題，不應該僅僅只有幾個工廠壟斷負責。不過高智商人才們都非常自負，認為自己的想法是對的，創造出的超能力模組沒有統一的介面，自然而然無法被正常使用。這時我們需要提出一種契約，這樣無論是誰創造出的模組，都符合這樣的介面，自然就可被正常使用。\r\n\r\n```php\r\ninterface SuperModuleInterface\r\n{\r\n    /*\r\n     * 超能力啟動方法\r\n     *\r\n     * 任何一個超能力都得有該方法，並擁有一個參數\r\n     * @param array $target 針對目標，可以是一個或多個，自己或他人\r\n     */\r\n    public function activate(array $target);\r\n}\r\n```\r\n\r\n上文中，我們定下了一個介面(超能力模組的規範、契約)，所有被創造的模組必須遵守該規範，才能被生產。\r\n\r\n> 其實，這就是 php 中 介面( interface ) 的用處和意義！\r\n> 很多人覺得，為什麼 php 需要介面這種東西？難道不是 java 、 C# 之類別的語言才有的嗎？\r\n> 這麼說，只要是一個正常的物件導向程式碼語言(雖然 php 可以程序式程式設計)，都應該具備這一特性。\r\n> 因為一個 物件(object) 本身是由他的模板或者原型——類別(class)，經過實例化後產生的一個具體事物，\r\n> 而有時候，實現同一種方法且不同功能(或特性)的時候，會存在很多的類別(class)，\r\n> 這時候就需要有一個契約，讓大家編寫出可以被隨時替換卻不會產生影響的介面。\r\n> 這種由程式碼語言本身提出的硬性規範，會增加更多優秀的特性。\r\n>\r\n> 雖然有些繞，但通過我們接下來的實例，大家會慢慢領會介面帶來的好處。\r\n\r\n這時候，那些提出更好的超能力模組的高智商人才，遵循這個介面，創建了下述(模組)類別：\r\n\r\n```php\r\n/**\r\n *\r\n * X-超能量\r\n */\r\nclass XPower implements SuperModuleInterface\r\n{\r\n    public function activate(array $target) {\r\n        //\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * 終極炸彈\r\n */\r\nclass UltraBomb implements SuperModuleInterface\r\n{\r\n    public function activate(array $target)\r\n    {\r\n        //\r\n    }\r\n}\r\n```\r\n\r\n同時，為了防止有些\"磚家\"自作聰明，或者一些叛徒惡意搗蛋，不遵守契約胡亂製造模組，影響超人，我們對超人初始化的方法進行改造：\r\n\r\n```php\r\nclass Superman\r\n{\r\n    protected $module;\r\n\r\n    public function __construct(SuperModuleInterface $module)\r\n    {\r\n        $this->module = $module\r\n    }\r\n\r\n}\r\n```\r\n\r\n改造完畢！現在，當我們初始化\"超人\"類別的時候，提供的模組實例必須是一個 `SuperModuleInterface` 介面的實現。否則就會提示錯誤。\r\n\r\n正是由於超人的創造變得容易，一個超人也就不需要太多的超能力，我們可以創造多個超人，並分別注入需要的超能力模組即可。這樣的話，雖然一個超人只有一個超能力，但超人更容易變多，我們也不怕怪獸啦！\r\n\r\n> 現在有人疑惑了，你要講的 依賴注入 呢？\r\n>\r\n> 其實，上面講的內容，正是依賴注入。\r\n\r\n什麼叫做依賴注入？\r\n\r\n本文從開頭到現在提到的一系列依賴，只要不是由內部生產(比如初始化、構造函數 \\_\\_construct 中通過工廠方法、自行手動 new 的)，而是由外部以參數或其他形式註入的，都屬於依賴注入(DI)。是不是豁然開朗？事實上，就是這麼簡單。下面就是一個典型的依賴注入：\r\n\r\n```php\r\n// 超能力模组\r\n$superModule = new XPower;\r\n\r\n// 初始化一個超人，並注入一個超能力模组依賴\r\n$superMan = new Superman($superModule);\r\n\r\n```\r\n\r\n關於依賴注入這個本文的主要配角，也就這麼多需要講的。理解了依賴注入，我們就可以繼續深入問題。慢慢走近今天的主角……\r\n\r\n### 更為先進的工廠—— IoC 容器\r\n\r\n剛剛列了一段代碼：\r\n\r\n```php\r\n$superModule = new XPower;\r\n\r\n$superMan = new Superman($superModule);\r\n```\r\n\r\n讀者應該看出來了，手動的創建了一個超能力模組、手動的創建超人並註入了剛剛創建超能力模組。呵呵，手動。\r\n\r\n現代社會，應該是高效率的生產，乾淨的現場，完美的自動化生產。\r\n\r\n一群怪獸來了，如此低效率產出超人是不現實，我們需要自動化—— 最多一條指令，千軍萬馬來相見。我們需要一種高級的生產現場，我們只需要向生產現場提交一個腳本，工廠便能夠通過指令自動化生產。這種更為高級的工廠，就是工廠模式的昇華—— IoC 容器。\r\n\r\n```php\r\nclass Container\r\n{\r\n    protected $binds;\r\n\r\n    protected $instances;\r\n\r\n    public function bind($abstract, $concrete)\r\n    {\r\n        if ($concrete instanceof Closure) {\r\n            $this->binds[$abstract] = $concrete;\r\n        } else {\r\n            $this->instances[$abstract] = $concrete;\r\n        }\r\n    }\r\n\r\n    public function make($abstract, $parameters = [])\r\n    {\r\n        if (isset($this->instances[$abstract])) {\r\n            return $this->instances[$abstract];\r\n        }\r\n\r\n        array_unshift($parameters, $this);\r\n\r\n        return call_user_func_array($this->binds[$abstract], $parameters);\r\n    }\r\n\r\n}\r\n```\r\n\r\n這時候，一個十分粗糙的容器就誕生了。現在的確很簡陋，但不妨礙我們進一步提升他。先著眼現在，看看這個容器如何使用吧！\r\n\r\n```php\r\n// 创建一個容器(后面称作超级工廠)\r\n$container = new Container;\r\n\r\n// 向該 超级工廠 添加 超人 的生產脚本\r\n$container->bind('superman', function($container, $moduleName) {\r\n    return new Superman($container->make($moduleName));\r\n});\r\n\r\n// 向該 超级工廠 添加 超能力模组 的生產脚本\r\n$container->bind('xpower', function($container) {\r\nreturn new XPower;\r\n});\r\n\r\n// 同上\r\n$container->bind('ultrabomb', function($container) {\r\nreturn new UltraBomb;\r\n});\r\n\r\n// ****************** 华丽丽的分割线 **********************\r\n// 開始啟動生產\r\n$superman_1 = $container->make('superman', 'xpower');\r\n$superman_2 = $container->make('superman', 'ultrabomb');\r\n$superman_3 = $container->make('superman', 'xpower');\r\n// ...随意添加\r\n```\r\n\r\n看到沒？通過最初的 绑定(bind) 操作，我們向超級工廠註冊了一些生產腳本，這些生產腳本在生產指令下達之時便會執行。發現沒有？我們徹底的解除了超人與超能力模組的依賴關係，更重要的是，容器類別也絲毫沒有和他們產生任何依賴！我們通過註冊、綁定的方式向容器中添加一段可以被執行的回調(可以是匿名函數、非匿名函數、類別的方法)作為生產一個類別的實例的腳本，只有在真正的 生產(make) 操作被調用執行時，才會觸發。\r\n\r\n這樣一種方式，使得我們更容易在創建一個實例的同時解決其依賴關係，並且更加靈活。當有新的需求，只需另外綁定一個\"生產腳本\"即可。\r\n\r\n> 實際上，真正的 IoC 容器更為高級。\r\n> 我們現在的例子中，還是需要手動提供超人所需要的模組參數，\r\n> 但真正的 IoC 容器會根據類別的依賴需求，自動在註冊、綁定的一堆實例中搜尋符合的依賴需求，並自動注入到構造函數參數中去。\r\n> Laravel 框架的服務容器正是這麼做的。\r\n>\r\n> 這種自動搜尋依賴需求的功能，是通過 `反射(Reflection)` 實現的，恰好的，php 完美的支持反射機制！\r\n>\r\n> [PHP 官方文件 - 反射](https://www.php.net/manual/zh/book.reflection.php)\r\n\r\n現在，到目前為止，我們已經不再懼怕怪獸們了。高智商人才集思廣益，井井有條，根據介面契約創造規範的超能力模組。超人開始批量產出。最終，人人都是超人，你也可以是哦！\r\n\r\n## 回歸正常世界。我們開始重新審視 laravel 的核心\r\n\r\n現在，我們開始慢慢解讀 laravel 的核心。其實，laravel 的核心就是一個 IoC 容器，也恰好是我之前所說的高級的 IoC 容器。\r\n\r\n可以說，laravel 的核心本身十分輕量，並沒有什麼很神奇很實質性的應用功能。很多人用到的各種功能模組比如 Route(路由)、Eloquent ORM(資料庫 ORM 组件)、Request and Response(乞求和響應)等等等等，實際上都是與核心無關的類別模組提供的，這些類別從註冊到實例化，最終被你所使用，其實都是 laravel 的服務容器負責的。\r\n\r\n我們以大家最常見的 Route 類別作為例子。大家可能經常見到路由定義是這樣的：\r\n\r\n```php\r\nRoute::get('/', function() {\r\n    // bla bla bla...\r\n});\r\n```\r\n\r\n實際上，Route 類別被定義在這個命名空間：Illuminate\\Routing\\Router，文件 vendor/laravel/framework/src/Illuminate/Routing/Router.php。\r\n\r\n我們通過打開發現，這個類別的這一系列方法，如 get，post，any 等都不是靜態(static)方法，這是怎麼一回事兒？不要急，我們繼續。\r\n\r\n服務提供者\r\n我們在前文介紹 IoC 容器的部分中，提到了，一個類別需要綁定、註冊至容器中，才能被\"製造\"。\r\n\r\n對，一個類別要被容器所能夠提取，必須要先註冊至這個容器。既然 laravel 稱這個容器叫做服務容器，那麼我們需要某個服務，就得先註冊、綁定這個服務到容器，那麼提供服務並綁定服務至容器的東西，就是服務提供者(ServiceProvider)。\r\n\r\n雖然，綁定一個類別到容器不一定非要通過服務提供者(ServiceProvider)。\r\n\r\n但是，我們知道，有時候我們的類別、模組會有需要其他類別和組件的情況，為了保證初始化階段不會出現所需要的模組和組件沒有註冊的情況，laravel 將註冊和初始化行為進行拆分，註冊的時候就只能註冊，初始化的時候就是初始化。拆分後的產物就是現在的服務提供者。\r\n\r\n服務提供者主要分為兩個部分，register(注册)和 boot(引導、初始化)，具體參考官方文件。register 負責進行向容器註冊\"腳本\"，但要注意註冊部分不要有對未知事物的依賴，如果有，就要移步至 boot 部分。\r\n\r\n正面\r\n我們現在解答之前關於 Route 的方法為何能以靜態方法訪問的問題。實際上這個問題官方文件上有寫，簡單說來就是模擬一個類別，提供一個靜態魔術方法\\_\\_callStatic，並將該靜態方法對應到真正的方法上。\r\n\r\n我們使用的 Route 類別實際上是 Illuminate\\Support\\Facades\\Route 通過 class_alias() 函數創造的 别名 而已，這個類別被定義在文件 vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php。\r\n\r\n我們打開文件一看…… 誒？怎麼只有這麼簡單的一段代碼呢？\r\n\r\n```php\r\nnamespace Illuminate\\Support\\Facades;\r\n\r\n/**\r\n * @see \\Illuminate\\Routing\\Router\r\n */\r\nclass Route extends Facade {\r\n\r\n    /**\r\n     * Get the registered name of the component.\r\n     *\r\n     * @return string\r\n     */\r\n    protected static function getFacadeAccessor() {\r\n        return 'router';\r\n    }\r\n}\r\n```\r\n\r\n其實仔細看，會發現這個類別繼承了一個叫做 Facade 的類別，到這裡謎底差不多要解開了。\r\n\r\n上述簡單的定義中，我們看到了 getFacadeAccessor 方法返回了一個 route，這是什麼意思呢？事實上，這個值被一個 ServiceProvider 註冊過，大家應該知道註冊了個什麼，當然是那個真正的路由類別！\r\n","date":"2022-12-27T05:43:41.731Z","matchingLines":["## IoC 容器 laravel 的核心\r","## IoC 容器誕生的故事\r","## 回歸正常世界。我們開始重新審視 laravel 的核心\r"]},{"name":"Laravel 命名原則.md","content":"# laravel 命名原則\r\n\r\n- 對於類、介面/契約、特性：使用 大駝峰式「PascalCase」\r\n- 對於常量：使用「TITLE_CASE」\r\n- 對於函式/方法、類屬性和變數：使用 小駝峰式「camelCase」\r\n- 對於陣列索引/資料庫欄位名/模型可填充項/模型關係：使用 蛇形命名法「lower_snake_case」\r\n- 對於路由：使用 短橫線「lower-kebab-case」\r\n\r\n|                         |            命名方式             |                 範例                  |\r\n| :---------------------: | :-----------------------------: | :-----------------------------------: |\r\n|       Controller        |          單數、大駝峰           |            UserController             |\r\n|          Route          |              複數               |              articles/1               |\r\n| Named Route - 路由命名  |       使用點標記的蛇底式        |           users.show_active           |\r\n|          Model          |              單數               |                 User                  |\r\n| hasOne, belongTo 的關聯 |           單數/小駝峰           |            articleComment             |\r\n|        其他關連         |           複數/小駝峰           |            articleComments            |\r\n|         資料表          |           複數/蛇底式           |           article_comments            |\r\n|   Pivot Table 中介表    | 以字母順序排列的單數 Model 名稱 |             article_user              |\r\n|       資料表欄位        |    蛇底式/不包含 model 名稱     |              meta_title               |\r\n|       model 屬性        |             蛇底式              |          $model->created_at           |\r\n|   Foreign Key - 外鍵    | 以單數 Model 名稱後方加上 \\_id  |              article_id               |\r\n|          方法           |             小駝峰              |                getAll                 |\r\n|    測試類別中的方法     |             小駝峰              |       testGuestCannotSeeArticle       |\r\n|          變數           |             小駝峰              |          $articlesWithAuthor          |\r\n|       Collection        |         描述性名稱/複數         | $activeUsers = User::active()->get()  |\r\n|          物件           |         描述性名稱/單數         | $activeUser = User::active()->first() |\r\n| 設定檔及語系檔的索引鍵  |             蛇底式              |           articles_enabled            |\r\n|          View           |           kebab-case            |        show-filtered.blade.php        |\r\n|         設定檔          |             蛇底式              |          google_calendar.php          |\r\n|     Contract (界面)     |          形容詞或名詞           |        AuthenticationInterface        |\r\n|          trait          |             形容詞              |              Notifiable               |\r\n","date":"2022-12-27T05:43:24.815Z","matchingLines":[]},{"name":"Laravel 事件.md","content":"# Laravel 事件\r\n\r\n> Event 類別一般儲存在 app/Event 目錄下\r\n> Listener 類別則存在 app/Listeners 目錄下\r\n\r\n## 註冊 Event 與 Listener\r\n\r\n首先在 laravel 專案中的 App\\Providers\\EventServiceProvider 註冊事件和監聽者\r\n\r\n- `$listen` 屬性是一個陣列，包含所有 `Event`(key) 和其 `listener`(value)\r\n- 可以使用 `php artisan event:list` 來列出所有註冊的 `Event` 和 `listener`\r\n\r\n```php\r\nnamespace App\\Providers;\r\n\r\nuse App\\Events\\OrderShipped;\r\nuse App\\Listeners\\SendShipmentNotification;\r\n\r\n/**\r\n * The event listener mappings for the application.\r\n *\r\n * @var array\r\n */\r\nprotected $listen = [\r\n    OrderShipped::class => [\r\n        SendShipmentNotification::class,\r\n    ],\r\n];\r\n```\r\n\r\n### 產生 Event Listener\r\n\r\n在 EventServiceProvider 中註冊後，使用 artisan 指令，即可產生 EventServiceProvider 中已註冊但尚未生成的 Event 和 Listener\r\n\r\n```bash\r\nphp artisan event:generate\r\n```\r\n\r\n或者也可以分別建立 Event 和 Listener\r\n\r\n```bash\r\nphp artisan make:event PodcastProcessed\r\n\r\nphp artisan make:listener SendPodcastNotification --event=PodcastProcessed\r\n```\r\n\r\n此時會產生兩個文件，分別為：\r\napp\\Events\\OrderShipped.php\r\napp\\Listeners\\SendShipmentNotification.php\r\n\r\n### 手動註冊\r\n\r\n除了在 EventServiceProvider 的 class 中宣告 $listen 屬性外，也可以在 class 中的 boot() 方法手動註冊基於 class 或是匿名函數的 Listener\r\n\r\n```php\r\nuse App\\Events\\PodcastProcessed;\r\nuse App\\Listeners\\SendPodcastNotification;\r\nuse Illuminate\\Support\\Facades\\Event;\r\n\r\n/**\r\n * Register any other events for your application.\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Event::listen(\r\n        PodcastProcessed::class,\r\n        [SendPodcastNotification::class, 'handle']\r\n    );\r\n\r\n    Event::listen(function (PodcastProcessed $event) {\r\n        //\r\n    });\r\n}\r\n```\r\n\r\n#### 一個 Listener 處理多個 Event\r\n\r\n使用 `*` 作為萬用字元參數來註冊 Listener，實現一個監聽者對應多個事件\r\n\r\n```php\r\nEvent::listen('event.*', function ($eventName, array $data) {\r\n    //\r\n});\r\n```\r\n\r\n- 此監聽者接收事件名作為第一個參數，並將整個事件數據，作為第二個參數\r\n\r\n### Event Discovery 事件發現\r\n\r\n啟用事件發現時，laravel 會搜尋專案的 `app/Listener` 目錄自動尋找並註冊事件與監聽器。  \r\n此外，列在 `EventServiceProvider` 中有被正確定義的事件也會被註冊。\r\n\r\n在預設中，事件發現預設是關閉，可以在 `EventServiceProvider` 上複寫 `shouldDiscoverEvents()` 方法來啟用\r\n\r\n```php\r\n/**\r\n * Determine if events and listeners should be automatically discovered.\r\n *\r\n * @return bool\r\n */\r\npublic function shouldDiscoverEvents()\r\n{\r\n    return true;\r\n}\r\n```\r\n\r\n## 定義 Event\r\n\r\nEvent class 基本上就是一個資料容器，用來保存與該事件相關的資訊。\r\n\r\n假設有一個事件會接收 Eloquent ORM 的物件，`App\\Events\\OrderShipped`\r\n\r\n在 class 中加入 $order 屬性，並在建構子中加入 $this->order = $order\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Events;\r\n\r\nuse App\\Models\\Order;\r\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\r\nuse Illuminate\\Foundation\\Events\\Dispatchable;\r\nuse Illuminate\\Queue\\SerializesModels;\r\n\r\nclass OrderShipped\r\n{\r\n    use Dispatchable, InteractsWithSockets, SerializesModels;\r\n\r\n    /**\r\n     * The order instance.\r\n     *\r\n     * @var \\App\\Models\\Order\r\n     */\r\n    public $order;\r\n\r\n    /**\r\n     * Create a new event instance.\r\n     *\r\n     * @param  \\App\\Models\\Order  $order\r\n     * @return void\r\n     */\r\n    public function __construct(Order $order)\r\n    {\r\n        $this->order = $order;\r\n    }\r\n}\r\n```\r\n\r\n- 在 Event class 中不包含邏輯，只作為已付款訂單 `App\\Models\\Order` 實體的容器\r\n\r\n## 定義 Listener\r\n\r\n事件監聽器會在 handle() 中接收 Event 實體，當使用 artisan 指定建立監聽器時，會自動載入相對應的 Event class，並在 handle() 做 Event 的型別提示\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Listeners;\r\n\r\nuse App\\Events\\OrderShipped;\r\n\r\nclass SendShipmentNotification\r\n{\r\n    /**\r\n     * Create the event listener.\r\n     *\r\n     * @return void\r\n     */\r\n    public function __construct()\r\n    {\r\n        //\r\n    }\r\n\r\n    /**\r\n     * Handle the event.\r\n     *\r\n     * @param  \\App\\Events\\OrderShipped  $event\r\n     * @return void\r\n     */\r\n    public function handle(OrderShipped $event)\r\n    {\r\n        // Access the order using $event->order...\r\n        // ex: dd($event->order);\r\n    }\r\n}\r\n```\r\n\r\n### 停止事件的傳播\r\n\r\n若要停止將某個事件傳播到另一個監聽器上，只要在監聽器的 handle 方法是回傳 false 即可\r\n\r\n## 觸發事件\r\n\r\n將 order 物件傳入 controller，listener 的 handle 方法中可以拿到 event 中的 order 變數，後續就可以觸發事件的邏輯\r\n\r\n```php\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Models\\Order;\r\nuse App\\Events\\OrderShipped;\r\nuse App\\Http\\Controllers\\Controller;\r\n\r\nclass OrderController extends Controller\r\n{\r\n    public function ship() {\r\n        $orderId = 1;\r\n        $order = Order::findOrFail($orderId);\r\n\r\n        // 訂單出貨的邏輯\r\n        // 觸發 event\r\n        event(new OrderShipped($order));\r\n\r\n        return response()->json([\r\n            'status' => 'success',\r\n            'message' => ''\r\n        ]);\r\n    }\r\n}\r\n```\r\n\r\n## 分派 Event\r\n\r\n呼叫事件上的靜態方法 `dispatch` ，此方法由 `Illuminate\\Foundation\\Events\\Dispatchable` 提供\r\n\r\n任何傳入此方法的值，會被傳給 Event 的 Constructor\r\n\r\n```PHP\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Events\\OrderShipped;\r\nuse App\\Http\\Controllers\\Controller;\r\nuse App\\Models\\Order;\r\nuse Illuminate\\Http\\Request;\r\n\r\nclass OrderShipmentController extends Controller\r\n{\r\n    /**\r\n     * Ship the given order.\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return \\Illuminate\\Http\\Response\r\n     */\r\n    public function store(Request $request)\r\n    {\r\n        $order = Order::findOrFail($request->order_id);\r\n\r\n        // Order shipment logic...\r\n\r\n        OrderShipped::dispatch($order);\r\n    }\r\n}\r\n```\r\n\r\n## 實作範例\r\n\r\n> [最簡單易懂的 laravel 事件，這個功能非常的有用](https://segmentfault.com/a/1190000010730545)\r\n\r\n### 情境\r\n\r\n在用戶註冊時，發送幫助電子郵件給用戶\r\n\r\n以下為原始的註冊方法\r\n\r\n```php\r\nnamespace  App\\Htt\\Controllers;\r\n\r\nuse  Illuminate\\Http\\Request;\r\n\r\nclass  UserController  extends  Controller\r\n {\r\n     public  function  register ( Request $request )\r\n     {\r\n        //獲取參數\r\n        //驗證參數\r\n        //寫入資料庫\r\n        //return 註冊信息\r\n    }\r\n}\r\n```\r\n\r\n現在有一個需求，註冊成功之後，向用戶的電子信箱發送一個廣告\r\n\r\n```php\r\nnamespace  App\\Htt\\Controllers;\r\n\r\nuse  Illuminate\\Http\\Request;\r\n\r\nclass  UserController  extends  Controller\r\n {\r\n     public  function  register ( Request $request )\r\n     {\r\n        //獲取參數\r\n        //驗證參數\r\n        //寫入資料庫\r\n\r\n        //發送廣告電子郵件\r\n        //return 註冊信息\r\n\r\n    }\r\n}\r\n```\r\n\r\n此時再增加一個發送簡訊的需求\r\n\r\n```php\r\nnamespace  App\\Htt\\Controllers;\r\n\r\nuse  Illuminate\\Http\\Request;\r\n\r\nclass  UserController  extends  Controller\r\n {\r\n     public  function  register ( Request $request )\r\n     {\r\n        //獲取參數\r\n        //驗證參數\r\n        //寫入資料庫\r\n\r\n        //發送廣告電子郵件\r\n        //發送簡訊\r\n        //return 註冊信息\r\n    }\r\n}\r\n```\r\n\r\n接著又有新的需求：發送 IM 消息，雖然將許多的功能寫在一個 function 中很直觀，但當多人協作時，會產生各種不便。\r\n\r\n### 事件功能\r\n\r\nlaravel 事件功能實際上更傾向於一種管理手段 + 實現的體現。\r\n\r\n我們可以透過 laravel 事件功能，宏觀的看到所有的事件，而不需每次都要打開 controller 的方法才能知道註冊之後發生什麼事\r\n\r\n我們要在註冊之後作一系列事情，首先在註冊完之後調用一個事件，然後這個事件在做各式各樣的事。\r\n\r\n```php\r\nnamespace  App\\Htt\\Controllers;\r\n\r\nuse  Illuminate\\Http\\Request;\r\n //我們先引入一個事件類，名字自定義的，之後再一步一步創建\r\nuse  App\\Events\\Register;\r\n\r\nclass  UserController  extends  Controller\r\n {\r\n     public  function  register ( Request $request )\r\n     {\r\n        // 獲取參數\r\n        // 驗證參數\r\n        // 寫入資料庫\r\n        // 觸發事件，以後所有需要註冊後要做的事情，都不需要再這裡加代碼了，我們只需要管理事件就好了\r\n        // event 方法是 laravel 自帶方法, $uid是外部參數，看你需要做什麼，傳什麼參數了。註冊之後肯定有 $uid 的嘛\r\n        event ( new  Register ( $uid ));\r\n        // return 註冊信息\r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\n找到 app\\Providers\\EventServiceProvider.php 文件，並加入關係\r\n\r\n```php\r\nnamespace  App\\Providers;\r\n\r\nuse  Laravel\\Lumen\\Providers\\EventServiceProvider  as  ServiceProvider;\r\n\r\nclass  EventServiceProvider  extends  ServiceProvider\r\n {\r\n     /**\r\n     * The event listener mappings for the application.\r\n     *\r\n     * @var array\r\n     */\r\n    protected  $listen = [\r\n        // 用戶註冊後的事件\r\n        'App\\Events\\Register' => [\r\n            // 發送廣告電子郵件\r\n            'App\\Listeners\\SendAdMail',\r\n            // 發送簡訊\r\n            'App\\Listeners\\SendSms',\r\n            // 發送幫助信息\r\n            'App\\Listeners\\SendHelpInformation',\r\n        ],\r\n    ];\r\n}\r\n```\r\n\r\n這是註冊事件的入口，相當於一個總目錄，這樣就可以跟註冊的程式碼，未來增加功能時，便不須再查看註冊方法的程式碼\r\n\r\n註冊完成後會觸發 App\\Events\\Register 類別，然後這個類會被 App\\Listeners\\SendAdMail, App\\Listeners\\SendSms, App\\Listeners\\SendHelpInformation 監聽到\r\n\r\n此時進入 App\\Events 目錄，建立 Register 這個 class\r\n\r\n```php\r\nnamespace  App\\Events;\r\n\r\nclass  Register\r\n {\r\n\r\n    public  $uid;\r\n\r\n    /**\r\n     * 創建一個新的事件實例.\r\n     *\r\n     * @param   Order $order\r\n     * @return void\r\n     */\r\n    public  function  __construct ( $uid )\r\n     {\r\n         $this ->uid = $uid;\r\n    }\r\n}\r\n```\r\n\r\n接著在 app\\Listeners 目錄底下建立各種事件監聽 class\r\n\r\n```php\r\nnamespace  App\\Listeners;\r\n\r\nuse  App\\Event\\Register;\r\nuse  App\\Models\\User;\r\nuse  Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\nclass  SendHelpInformation  implements  ShouldQueue\r\n {\r\n\r\n\r\n    public  function  __construct ()\r\n    {\r\n        //\r\n    }\r\n\r\n\r\n    public  function  handle ( Register $event )\r\n    {\r\n        $uid = $event ->uid;\r\n\r\n        $user = User :: find ( $uid );\r\n\r\n        //......各種實現\r\n    }\r\n}\r\n```\r\n","date":"2022-12-27T05:43:05.905Z","matchingLines":["## 註冊 Event 與 Listener\r","## 定義 Event\r","## 定義 Listener\r","## 觸發事件\r","## 分派 Event\r","## 實作範例\r"]},{"name":"CSS學習筆記.md","content":"# CSS 學習筆記\r\n\r\n- [CSS 學習筆記](#css-學習筆記)\r\n  - [後裔選擇器](#後裔選擇器)\r\n    - [基本類型](#基本類型)\r\n    - [複合型](#複合型)\r\n  - [屬性選擇器`[]`](#屬性選擇器)\r\n  - [表格](#表格)\r\n  - [偽元素](#偽元素)\r\n  - [`display:none`和`visibility:hidden`的差別](#displaynone和visibilityhidden的差別)\r\n  - [Display](#display)\r\n    - [Display Outside](#display-outside)\r\n      - [Block 區塊元素](#block-區塊元素)\r\n      - [Inline 行內元素](#inline-行內元素)\r\n    - [Display Inside](#display-inside)\r\n      - [Table](#table)\r\n      - [Flex](#flex)\r\n        - [Flex-direction 方向性](#flex-direction-方向性)\r\n        - [justify-content 調整內容](#justify-content-調整內容)\r\n        - [align-items 對齊物件](#align-items-對齊物件)\r\n        - [align-self 自身對齊](#align-self-自身對齊)\r\n      - [Wrap 斷行](#wrap-斷行)\r\n    - [Global 全域屬性](#global-全域屬性)\r\n      - [inherit 跟隨父層屬性](#inherit-跟隨父層屬性)\r\n      - [initial 變回原本屬性](#initial-變回原本屬性)\r\n    - [Display-Box 影響用箱子裝起來的所有元素](#display-box-影響用箱子裝起來的所有元素)\r\n      - [none](#none)\r\n    - [Display-Legacy 此屬性繼承兩者的特性](#display-legacy-此屬性繼承兩者的特性)\r\n      - [inline-block](#inline-block)\r\n      - [inline-table](#inline-table)\r\n      - [inline-flex](#inline-flex)\r\n\r\n> 將所有物件加上外框\r\n>\r\n> ```css\r\n> * {\r\n>   outline: 1px solid #000;\r\n> }\r\n> ```\r\n\r\n## 後裔選擇器\r\n\r\n### 基本類型\r\n\r\n- 標籤 `#id` `.class`\r\n\r\n- div 標籤和 span 標籤\r\n\r\n  ```css\r\n  div,\r\n  span {\r\n    //\r\n  }\r\n  ```\r\n\r\n### 複合型\r\n\r\n- div 標籤底下，為 span 標籤\r\n\r\n  ```css\r\n  div > span {\r\n    //\r\n  }\r\n  ```\r\n\r\n- div 標籤內所有的 span 標籤\r\n\r\n  ```css\r\n  div span {\r\n    //\r\n  }\r\n  ```\r\n\r\n- div 標籤之後的第一個 span 標籤\r\n\r\n  ```css\r\n  div + span {\r\n    //\r\n  }\r\n  ```\r\n\r\n- div 標籤之後的所有 span 標籤\r\n\r\n  ```css\r\n  div ~ span {\r\n    //\r\n  }\r\n  ```\r\n\r\n## 屬性選擇器`[]`\r\n\r\n可直接查找任何屬性內元素(ex:`class`, `div`, `title`, `href`,....)，亦可使用於直接指定屬性\r\n\r\n- `|` 符號為屬性，包含`[foo]`且必在開頭，須為獨立字元、特定單詞，以及字元後加上連接符號 `-`\r\n\r\n  ```css\r\n  p[class|=\"red\"] {\r\n    //\r\n  }\r\n  ```\r\n\r\n- `~` 符號為屬性只要有包含`[foo]`，無順序問題，需為獨立字元、特定單詞\r\n\r\n  ```css\r\n  a[herf~=\"apple\"] {\r\n    //\r\n  }\r\n  ```\r\n\r\n- `^` 符號為屬性使用`[foo]`開頭，不特定獨立字元\r\n\r\n  ```css\r\n  a[herf^=\"http\"] {\r\n    //\r\n  }\r\n  ```\r\n\r\n- `$` 符號為屬性使用`[foo]`結尾，不特定獨立字元\r\n\r\n  ```css\r\n  a[herf$=\"selectors.asp\"] {\r\n    //\r\n  }\r\n  ```\r\n\r\n- `*` 符號為屬性內含有`[foo]`，不特定獨立字元\r\n\r\n  ```css\r\n  a[herf*=\"pseudo\"] {\r\n    //\r\n  }\r\n  ```\r\n\r\n## 表格\r\n\r\n- 將標籤做成表格\r\n\r\n  ```css\r\n  .class {\r\n    display: grid;\r\n    //\r\n  }\r\n  ```\r\n\r\n## 偽元素\r\n\r\n- 在原本的元素「之前」加入內容\r\n\r\n  ```css\r\n  ::before ;\r\n  ```\r\n\r\n- 在原本的元素「之後」加入內容\r\n\r\n  ```css\r\n  ::after ;\r\n  ```\r\n\r\n- 兩者都是以 display: inline-block;屬性存在\r\n- 偽元素會「繼承」原本元素的屬性\r\n- 偽元素一定要加上 content 的屬性，沒有 content 偽元素不會出現在畫面上\r\n\r\n## `display:none`和`visibility:hidden`的差別\r\n\r\n當使用 `visibility:hidden` 時，物件是確實的被隱藏的，但依然保有物件的位置\r\n\r\n例如：當表格內的標籤加上 `visibility:hidden` 時，其儲存格中的值會被隱藏，但儲存格不會消失\r\n\r\n當使用 `display:none` 時，物件及其原本的位置都會被隱藏\r\n\r\n## Display\r\n\r\n### Display Outside\r\n\r\n#### Block 區塊元素\r\n\r\n- 總是以新的一行開始，所以無論設定多少寬度，他基本容器的寬度，還是會撐滿整個空間。\r\n- 即使容器中的元素已經被調整成 50%，但他還是會將後面的元素排擠在下面。\r\n\r\n#### Inline 行內元素\r\n\r\n- 又稱線內元素，元素本身高度多少他就是多少，無法調整寬高，此外他可以設定 padding 的上下左右，而 margin 只能設定他的左右。\r\n- inline 屬性預設元素的排列為由左到右，直到裝滿容器。\r\n\r\n### Display Inside\r\n\r\n#### Table\r\n\r\n- 可以將元素直接模擬成 table 來使用。\r\n\r\n  - Table-Row 對應 `<tr>`\r\n  - Table-Row-Group 對應 `<tbody>`\r\n  - Table-Cell `<td>`\r\n  - Table-caption `<caption`\r\n  - Table-Column `<col>`\r\n  - Table-Column-Group `<colgroup>`\r\n  - Table-Header-Group `<thead>`\r\n  - Table-Footer-Group `<tfooder>`\r\n\r\n#### Flex\r\n\r\n- 設定 flex 屬性之前，需先設定父層容器 display: flex\r\n\r\n##### Flex-direction 方向性\r\n\r\n- 水平方向(瀏覽器預設)：row, row-reverse(水平方向反轉)\r\n- 垂直方向：column, column-reverse(垂直方向反轉)\r\n\r\n##### justify-content 調整內容\r\n\r\n- 改變 flex 物件在主軸上的對齊(預設為水平方向)，若 flex-direction 為 column，則對齊方向改為垂直方向(y 軸)\r\n  - justify-content: flex-start 以起點為基準\r\n  - justify-content: flex-end 以尾端為基準\r\n  - justify-content: center 以中間為基準\r\n  - justify-content: space-between 會將物件依容器大小均分\r\n  - justify-content: space-around 會將物件依容器大小均分，並會給左右空間\r\n\r\n##### align-items 對齊物件\r\n\r\n- 改變橫軸上所有 flex 物件的對齊(預設為垂直方向)，若 flex-direction 為 column，則對其方向會改為水平方向(x 軸)\r\n  - align-items: flex-start 以起點為基準\r\n  - align-items: flex-end 以尾端為基準\r\n  - align-items: center 以中間為基準\r\n  - align-items: baseline 以物件基準線為基準\r\n  - align-items: strrtch 以起點為基準，但會撐滿容器(瀏覽器預設)\r\n\r\n##### align-self 自身對齊\r\n\r\n- 單獨改變物件在橫軸上的對齊(預設為垂直方向)，若 flex-direction 為 column，則對齊方向則改為水平方向(x 軸)\r\n  - align-seelf: flex-start 以起點為基準\r\n  - align-seelf: flex-end 以尾端為基準\r\n  - align-seelf: center 以中間為基準\r\n  - align-seelf: baseline 以物件基準線為基準\r\n  - align-seelf: strrtch 以起點為基準，但會撐滿容器(瀏覽器預設)\r\n\r\n#### Wrap 斷行\r\n\r\n- Flex-Nowrap：強制不斷行。\r\n- Flex-Wrap：裝滿容器會強制斷行。\r\n- Flex-Wrap-Reverse：裝滿容器會強制斷行，但排列順序是相反的。\r\n\r\n### Global 全域屬性\r\n\r\n- 除了 display 以外，齊他任意屬性都能使用\r\n\r\n#### inherit 跟隨父層屬性\r\n\r\n- 當父層屬性為 block，子層下 Display:Inherit 時，子層屬性也會變成 block\r\n\r\n#### initial 變回原本屬性\r\n\r\n- 假如我 div 屬性在某種情況下更改為 inline 屬性，那我後面有吃到同樣 CSS 的 div 想改回 Block，我只要下 Display:Initial，就會變回 Div 原本的 Block 屬性\r\n\r\n### Display-Box 影響用箱子裝起來的所有元素\r\n\r\n#### none\r\n\r\n- 若被 display: none; 的 div 裝起來的元素，會被隱藏。\r\n\r\n### Display-Legacy 此屬性繼承兩者的特性\r\n\r\n#### inline-block\r\n\r\n- 讓許多區塊自動浮起來水平排列，且不用額外設定 clear 也不會讓接著的元素浮上來蓋住區塊\r\n\r\n#### inline-table\r\n\r\n#### inline-flex\r\n\r\n- flex 時父元素為 block，而 inline-flex 則是父元素變成 inline，他會根據子元素所有的 div 大小自適應寬度和高度\r\n","date":"2022-12-27T05:37:20.155Z","matchingLines":["## 後裔選擇器\r","## 屬性選擇器`[]`\r","## 表格\r","## 偽元素\r","## `display:none`和`visibility:hidden`的差別\r","## Display\r"]},{"name":"撰寫 API 文件.md","content":"# 撰寫 API 文件\r\n\r\n> 文件內容包括：用途，路由、參數、回傳值\r\n> 更詳細的會包括：參數放置的位置(route, queryString, body)、參數是否必填，回傳的 JSON 範例\r\n\r\n範例\r\n\r\n```markdown\r\n## GET /card/{id}\r\n\r\n**查詢指定編號的卡片**\r\n\r\n### Parameter\r\n\r\n- Route\r\n  - `id (int, required)` 卡片編號\r\n\r\nexample: https://exampleProjN.com/api/card/1\r\n\r\n### Response\r\n\r\n200: 回傳對應的卡片\r\n{\r\n\"id\": 0,\r\n\"name\": \"string\",\r\n\"description\": \"string\",\r\n\"attack\": 0,\r\n\"health\": 0,\r\n\"cost\": 0\r\n}\r\n\r\n404: 找不到\r\n```\r\n\r\n### postman 的描述區域\r\n\r\n- API 用途\r\n- 參數說明，除了 request body 說明之外，也能說明 uri 參數從哪來的。\r\n- 成功或失敗案例的說明：因為目前我還不知道怎麼在 Response 加上註解。\r\n- 別名，類似中文名稱。\r\n\r\n## 編輯房間\r\n\r\n### 用途\r\n\r\n- 編輯房間\r\n- 同時處理增、刪、修動作\r\n- 可以陣列傳入 room_id\r\n\r\n### header\r\n\r\n|      key      |        值        | 備註  |\r\n| :-----------: | :--------------: | :---: |\r\n| Authorization | Bearer {{token}} | token |\r\n\r\n### 參數\r\n\r\n|   key   |   值   |             驗證規則              |\r\n| :-----: | :----: | :-------------------------------: |\r\n| account | string |             required              |\r\n|  role   | string | required, string, in:member,guest |\r\n| room_id | array  |     required, exists:rooms,id     |\r\n\r\n./postman_doc_gen [C:\\Users\\RD\\Desktop\\V5-Cloud.postman_collection.json] -o [C:\\Users\\RD\\Desktop]\r\n","date":"2022-12-27T05:35:08.690Z","matchingLines":["## GET /card/{id}\r","## 編輯房間\r"]},{"name":"數位憑證(SSL)要錢，誰還要數位憑證？.md","content":"# 數位憑證(SSL)要錢，誰還要數位憑證？\r\n\r\n> 目前 Chrome 全面在未採用 HTTPS 加密的網站，顯示紅色的不安全警告，一律視為不安全。\r\n\r\n## 免費 SSL VS. 付費 SSL\r\n\r\n### 1. 憑證公信力\r\n\r\n免費的 SSL 身分驗證不夠確實，可能導致釣魚網站也能冒名安裝其他業者的憑證，且被瀏覽器發現的話，更將會全面否定此間憑證供應商的憑證公信力，同時撤回相同 SSL 的其他網站安全認可。\r\n\r\n### 2. 網站身分的驗證方式\r\n\r\n免費的數位憑證通常只採電子郵件驗證。而付費的憑證，依付費方案類型的不同，會有更加嚴謹的驗證方式，也會加入第三方的驗證，以避免憑證誤頒的狀況發生。\r\n\r\n### 3. 憑證有效期限\r\n\r\n付費憑證因為檢驗機制完整且嚴謹，所以通常具備多年方案。\r\n\r\n### 4. 企業名稱揭示\r\n\r\n付費 SSL 會完整顯示企業資訊，增強品牌安全公信力。\r\n\r\n### 5. 損害賠償責任\r\n\r\n根據電子簽章法規定，因此無論是國內外憑證業者，均有制定損害賠償金額。若網站在有安裝此憑證下資料仍不幸遭竊，將有對應理賠金額。\r\n\r\n### 6. 憑證安裝協助\r\n\r\n付費 SSL 提供售後服務或是客服支援，協助 SSL 安裝導入。\r\n\r\n### 7. 多網域使用限制\r\n\r\n付費 SSL 則可依據企業需求，升級子網域與跨網域方案\r\n\r\n### 8. 憑證的安全標章\r\n\r\n付費 SSL 會提供安全標章供用戶置入於網站，提高網站信任感。\r\n\r\n### 9. 憑證供應商對於資安的重視與防護\r\n\r\n付費 SSL 具備完整資安防護機制\r\n","date":"2022-12-27T05:33:09.774Z","matchingLines":["## 免費 SSL VS. 付費 SSL\r"]},{"name":"物聯網.md","content":"# 物聯網\r\n\r\n## 物聯網的架構\r\n\r\n主要可以分為三層\r\n\r\n- 感知層\r\n- 網路層\r\n- 應用層\r\n\r\n### 感知層\r\n\r\n感測器 (Sensor) 將擷取到的信號，透過 TCP/IP、RS485、RS232、USB、RFID、ZigBee、Bluetooth 等傳輸協定轉送給網路層\r\n\r\n- 關鍵技術\r\n\r\n  - 無線感測技術\r\n    - 加速度感測、濕度感測器、壓力感測器、位移感測器......\r\n  - 辨識技術\r\n    - RFID 辨識\r\n    - 一維條碼\r\n    - QR code\r\n\r\n### 網路層\r\n\r\n處理下層傳來的資訊，判斷是要送往雲端，或是直接採取適當的動作。或提供進入雲端之後，大眾經常會用到的服務：搜尋引擎、網路硬碟、web mell、web office、GS 等\r\n\r\n- 關鍵技術\r\n\r\n  - 有線網路技術\r\n    - 電信網\r\n    - 有線電視網\r\n    - 電腦網路\r\n  - 無線網路技術\r\n  - body area networks\r\n    - 以人為中心，服務範圍不超過兩公尺\r\n    - 標準協定：IEEE 802.15.6\r\n  - Personal Areas Networks\r\n    - 短距離應用在家庭環境中，服務範圍不超過 10 公尺\r\n    - IEEE 標準協定： Zigbee, Bluetooth, UWB\r\n  - Wireless Local Areas Networks\r\n    - 介於子網路及外部網路之間\r\n    - 標準協定：IEEE 802.11\r\n  - Metropolitan Area Network\r\n    - 介於 LAN 和 WAN 之間能傳輸語音與資料的公用網路，服務範圍 2 到 4 公里\r\n    - 標準協定：IEEE 802.16\r\n  - 3G(3rd-generation)\r\n    - 是指支持高速數據傳輸的細胞移動通訊技術。3G 服務能夠同時傳送聲音（通話）及數據資訊（電子郵件、即時通訊等）。3G 的 代表特徵是 提供高速數據業務，速率一般在幾百 kpbs 以上\r\n  - LTE(Long Term Evolution)\r\n  - 資料互通性\r\n  - 雲端處理技術\r\n\r\n### 應用層\r\n\r\n- 從家庭及個人的食、衣、住、行、育、樂，乃至工業、農業、醫療、學習、及企業/政府所需的環境監控、交通管理、資源管理等\r\n- 將網路層蒐集到的資訊做後製處理\r\n","date":"2022-12-27T05:32:35.204Z","matchingLines":["## 物聯網的架構\r"]},{"name":"MQTT 學習筆記.md","content":"# MQTT\r\n\r\n> 目前最新版本為 v5.0 (但 v3.1 版較為普及)\r\n\r\n- [MQTT](#mqtt)\r\n  - [概述](#概述)\r\n    - [MQTT 訊息格式](#mqtt-訊息格式)\r\n    - [重要特色](#重要特色)\r\n  - [在 windows 建立 MQTT 測試主機(Eclipse Mosquitto)](#在-windows-建立-mqtt-測試主機eclipse-mosquitto)\r\n  - [在虛擬主機建立 MQTT Broker (Mosquitto)](#在虛擬主機建立-mqtt-broker-mosquitto)\r\n  - [Mosquitto conf 設定與啟動](#mosquitto-conf-設定與啟動)\r\n    - [設定使用者須使用帳號密碼連線](#設定使用者須使用帳號密碼連線)\r\n    - [重新啟動 Mosquitto](#重新啟動-mosquitto)\r\n    - [啟動 MQTT Broker](#啟動-mqtt-broker)\r\n  - [測試 Broker](#測試-broker)\r\n    - [Chrome 瀏覽器擴充程式：MQTTLens](#chrome-瀏覽器擴充程式mqttlens)\r\n    - [MQTT Explorer](#mqtt-explorer)\r\n  - [安裝身分驗證套件(mosquitto-auth-plugin)](#安裝身分驗證套件mosquitto-auth-plugin)\r\n    - [設置 mosquitto](#設置-mosquitto)\r\n    - [安裝 mosquitto-auth-plug 套件](#安裝-mosquitto-auth-plug-套件)\r\n    - [若 mosquitto 無法正常運行](#若-mosquitto-無法正常運行)\r\n  - [安裝身分驗證套件(mosquitto-go-auth)](#安裝身分驗證套件mosquitto-go-auth)\r\n    - [設置 mosquitto (同 mosquitto-auth-plug 套件)](#設置-mosquitto-同-mosquitto-auth-plug-套件)\r\n    - [安裝 mosquitto-go-auth](#安裝-mosquitto-go-auth)\r\n    - [acl 權限設定](#acl-權限設定)\r\n  - [MQTT Client](#mqtt-client)\r\n    - [安裝](#安裝)\r\n    - [設定 mqtt-client 連線](#設定-mqtt-client-連線)\r\n\r\n## 概述\r\n\r\n適用於 Server 與 Client 訊息傳 遞的通訊協定\r\n\r\n利用訂閱(Subscribe)與發佈(Public)的機制來進行訊息傳遞\r\n\r\n因其訊息結構簡單且輕量化，因此非常適合用於硬體效能較低的控制器，或作為物聯網的輕量資料收集應用。\r\n\r\n在此架構下，會有三種角色：\r\n\r\n- `Broker`: 代理人\r\n- `Publisher`: 訊息發佈人\r\n- `Subscriber`: 訊息訂閱者\r\n\r\n訊息發佈者(Publisher)多為感測器，發送資料。訊息訂閱者(Subscriber)為使用者的裝置(pc, 手機)，代理人(Broker)接收來自感測器的資料，透過 Topic 來辨別目標的使用者裝置。有訂閱 Topic 的訊息訂閱，會收到相對應的資料。\r\n\r\n### MQTT 訊息格式\r\n\r\n- `Control Header`(1 byte)\r\n- `Remaining Length`(1 - 4 bytes)\r\n- `Variable Header`\r\n- `Payload`\r\n\r\nControl Header 和 Remaining Length 為必須，後面的 Variable Header 和 Payload 則是依需求決定。\r\n\r\n在傳遞的過程中，Publisher 不需要知道 Subscriber 的 IP ，只需要知道 Broker 的位址就可以進行訊息傳遞。\r\n\r\nTopic 有階層式設計，用`/`分開，並且有大小寫的差異。\r\n\r\n### 重要特色\r\n\r\nMQTT 可以針對網路品質(QoS)，決定操作等級\r\n\r\n- `QoS Level0`: Publisher 丟訊息給 Broker 後不理\r\n- `QoS Level1`: Publisher 丟出訊息後，Broker 必回傳 PUBACK 以確定訊息有收到，倘若沒收到 PUBACK，Publisher 會再重傳一次資料。(缺點為若回傳 PUBACK 時斷線，Publisher 會判斷傳送失敗而再重傳一次資料，將導致 Subscriber 重複收到相同的資料)\r\n- `QoS Level2`: 在 Publisher 確認 Broker 有收到訊息後，Broker 才將資料傳遞給 Subscriber，且 Subscriber 收到訊息後，也須回傳 PUBACK 給 Publisher，可避免收到重複的訊息，但較佔頻寬。\r\n\r\n## 在 windows 建立 MQTT 測試主機(Eclipse Mosquitto)\r\n\r\n- 在[官網](https://mosquitto.org/download/)下載。\r\n- 在 `Choose Components` 中，如果勾選 `service` 的選項，MQTT Broker 就會變成 windows 的服務，當開機時便會被執行。(若測試環境，建議手動開啟即可)\r\n- 設定 windows 防火牆：在 MQTT 預設的通訊埠號為 1883 在 windows 是關閉的。\r\n  - 開啟 windows Defender 防火牆設定頁面，按下進階設定。\r\n  - 輸入規則，按下新增規則\r\n  - 選擇連接埠\r\n  - 選擇 TPC 通訊協定與特定本機連接埠 1833\r\n  - 選擇允許連線\r\n  - 選擇私人連線\r\n  - 設定名字，即可完成針對 TPC 連線的 1833 port 輸入規則\r\n  - 接著設定輸出規則，步驟相同，一樣指定 TPC 與埠號 1833\r\n  - 最後確認輸入及輸出正常啟用即可\r\n\r\n## 在虛擬主機建立 MQTT Broker (Mosquitto)\r\n\r\n- 下載 mosquitto 程式庫\r\n\r\n  ```bash\r\n  sudo apt-add-repository ppa:mosquitto-dev/mosquitto-ppa\r\n  ```\r\n\r\n- 更新程式庫\r\n\r\n  ```bash\r\n  sudo apt-get update\r\n  ```\r\n\r\n- 安裝 mosquitto\r\n\r\n  ```bash\r\n  sudo apt-get install mosquitto\r\n  ```\r\n\r\n  - 安裝好後，broker 會自動運行\r\n\r\n- 控制指令\r\n\r\n  ```bash\r\n  # 查詢 mosquitto 服務狀態\r\n  systemctl status mosquitto\r\n\r\n  # 啟動 mosquitto 服務\r\n  sudo systemctl start mosquitto\r\n\r\n  # 停止 mosquitto 服務\r\n  sudo systemctl stop mosquitto\r\n\r\n  # 重新啟動 mosquitto 服務\r\n  sudo systemctl restart mosquitto\r\n  ```\r\n\r\n- 確認運行\r\n\r\n  - 查看 server 狀態\r\n\r\n  ```bash\r\n  sudo service mosquitto status\r\n  ```\r\n\r\n  - 列舉目前作用中的連線：mosquitto server 預設運作於 port: 1833\r\n\r\n  ```bash\r\n  rexlite_public@rexlitemqtt:~$ netstat -an\r\n  Active Internet connections (servers and established)\r\n  Proto Recv-Q Send-Q Local Address           Foreign Address         State\r\n  tcp        0      0 0.0.0.0:1833            0.0.0.0:*               LISTEN\r\n  ```\r\n\r\n- 本機測試\r\n\r\n  - `-d` debug 模式\r\n  - `-t` 訂閱的主題\r\n  - `-h` broker 的 IP\r\n  - `-m` 發送的內容\r\n  - `-v` 顯示主題名稱\r\n\r\n  - 訂閱\r\n\r\n    ```bash\r\n    mosquitto_sub -v -d -t <topic> -u <user> -P <Password>\r\n    ```\r\n\r\n  - 推送\r\n\r\n    ```bash\r\n    mosquitto_pub -d -t <Topic> -m <Message> -u <User> -P <Password>\r\n    ```\r\n\r\n- 開啟 server 防火牆的 port: 1883\r\n\r\nmosquitto 的 broker 通訊埠號預設為：1833，因此需要在 server 的防火牆開通道\r\n\r\n讓外界可以透過這個通道跟 MQTT Broker 溝通\r\n\r\n- 打開資訊欄 => 虛擬私有雲網路 => 防火牆 => CREATE FIREWALL rule\r\n- 填入\r\n  - 名稱：自訂名稱\r\n  - 目標：選擇網路中所有執行個體\r\n  - 來源 ip 範圍：0.0.0.0/0\r\n- 通訊協定和通訊埠：\r\n  - 指定的通訊協定和通訊埠：tcp:1883\r\n- 點擊建立\r\n\r\n## Mosquitto conf 設定與啟動\r\n\r\n移動到軟體檔案安裝的目錄下(linux: /etc/mosquitto)，用編輯器打開 mosquitto.conf。\r\n\r\n### 設定使用者須使用帳號密碼連線\r\n\r\n用 `mosquitto_passwd`，來建立密碼\r\n\r\n```bash\r\nmosquitto_passwd -c <password file> <username>\r\n```\r\n\r\n- 參數 `-c` 為建立密碼文件，若指定的檔案已存在，將會被覆蓋\r\n\r\n若要將更多的使用者添加到現有的文件中，則省略 `-c` 參數\r\n\r\n```bash\r\nmosquitto_passwd <password file> <username>\r\n```\r\n\r\n若要從密碼文件中刪除用戶\r\n\r\n```bash\r\nmosquitto_passwd -D <password file> <username>\r\n```\r\n\r\n```txt\r\nallow_anonymous false\r\npassword_file C:\\你的路徑\\mosquitto\\usrlist.txt\r\nlistener 1883\r\n```\r\n\r\n- `allow_anonymous false`: 不允許匿名登入\r\n- `password_file` : 指定帳號清單的目錄\r\n- `listener` : 指定遠端登入時可以使用的 PORT\r\n\r\n### 重新啟動 Mosquitto\r\n\r\n```bash\r\nsudo systemctl restart mosquitto\r\n```\r\n\r\n### 啟動 MQTT Broker\r\n\r\n在安裝目錄下輸入\r\n\r\n```bash\r\n./mosquitto.exe -c mosquitto.conf -v\r\n```\r\n\r\n- `-c` 指定 config 檔\r\n- `-v` verbose mode 詳細模式\r\n\r\n當啟動成功會顯示所有 broker 的即時資訊\r\n\r\n## 測試 Broker\r\n\r\n### Chrome 瀏覽器擴充程式：MQTTLens\r\n\r\n- [MQTT 教學（四）：使用 MQTTLens 訂閱與發布 MQTT 訊息](https://swf.com.tw/?p=1009)\r\n\r\n### MQTT Explorer\r\n\r\n- [| ESP32 教學 | Mosquitto conf 設定與 MQTT 測試](https://jimirobot.tw/esp32-mosquitto-conf-mqtt-tutorial/)\r\n\r\n## 安裝身分驗證套件(mosquitto-auth-plugin)\r\n\r\n> Ubuntu 20\r\n>\r\n> Mosquitto 2.0  \r\n> [mosquitto-auth-plugin](https://github.com/jpmens/mosquitto-auth-plug)  \r\n> MySQL\r\n>\r\n> [Mosquitto 2.0 + mosquitto-auth-plugin + MySQL](https://www.jmeze.net/2021/06/mosquitto-20-mosquitto-auth-plugin-mysql.html)\r\n>\r\n> [Ubuntu 18 使用 apt 安装 mosquitto auth plugin 与 MySQL](https://www.jianshu.com/p/08b42c170a6a)\r\n>\r\n> [mosquitto 权限验证](https://tongxinmao.com/Article/Detail/id/166)\r\n\r\n### 設置 mosquitto\r\n\r\n- 安裝所需套件\r\n\r\n  ```bash\r\n  apt install gcc g++ make xsltproc docbook-xsl libwebsockets-dev libmysqlclient-dev\r\n  ```\r\n\r\n- 卸載舊版本的 Mosquitto\r\n\r\n  ```bash\r\n  apt purge mosquitto\r\n  ```\r\n\r\n- 從官方安裝 mosquitto 源碼\r\n\r\n  ```bash\r\n  wget https://mosquitto.org/files/source/mosquitto-2.0.10.tar.gz\r\n  tar xvf mosquitto-2.0.10.tar.gz\r\n  ```\r\n\r\n- 更改 config.mk 設定\r\n\r\n  ```config\r\n  WITH_WEBSOCKETS:=yes\r\n  WITH_CJSON:=no\r\n  ```\r\n\r\n  - `WITH_WEBSOCKETS` 當需要使用 websockets 連線到 mosquitto 時，才將其開啟。\r\n  - `WITH_CJSON` 將此設定開啟會報錯(未知原因)\r\n\r\n- 將 mosquitto 編譯並安裝\r\n\r\n  ```bash\r\n  make\r\n  make install\r\n  ```\r\n\r\n- 建立 mosquitto 使用者並改變目錄權限\r\n\r\n  ```bash\r\n  useradd -r mosquitto\r\n  mkdir /var/log/mosquitto\r\n  chown mosquitto:mosquitto /var/log/mosquitto/\r\n  mkdir /var/lib/mosquitto\r\n  chown mosquitto:mosquitto /var/lib/mosquitto/\r\n  ```\r\n\r\n- 建立文件 /etc/systemd/system/mosquitto.service\r\n\r\n  ```bash\r\n  touch /etc/systemd/system/mosquitto.service\r\n  ```\r\n\r\n  ```service\r\n  [Unit]\r\n  Description=Mosquitto MQTT v3.1/v3.1.1 server\r\n  Wants=network.target\r\n  Documentation=http://mosquitto.org/documentation/\r\n\r\n  [Service]\r\n  Type=simple\r\n  User=mosquitto\r\n  Group=mosquitto\r\n  ExecStart=/usr/local/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf\r\n  Restart=on-failure\r\n  SyslogIdentifier=Mosquitto\r\n\r\n  [Install]\r\n  WantedBy=multi-user.target\r\n  ```\r\n\r\n### 安裝 mosquitto-auth-plug 套件\r\n\r\n- git clone\r\n\r\n```bash\r\ngit clone https://github.com/kmihaylov/mosquitto-auth-plug.git\r\n```\r\n\r\n- 在 mosquitto-auth-plug 的目錄底下編輯 config.mk 的副本\r\n\r\n```bash\r\ncp config.mk.in config.mk\r\nvim config.mk\r\n```\r\n\r\n- 根據實際環境，設定 config.mk\r\n\r\n```mk\r\n# mosquitto 源碼\r\n# MOSQUITTO_SRC = /etc/mosquitto-2.0.10\r\nMOSQUITTO_SRC = <your path>/mosquitto\r\n\r\n# OPENSSLDIR = /usr/lib/ssl\r\nOPENSSLDIR = <your path>\r\n```\r\n\r\n- 可以使用 `whereis openssl` 指令來顯示 OpenSSL 的目錄\r\n\r\n- 編譯此套件\r\n\r\n```bash\r\nmake\r\n```\r\n\r\n- errors\r\n\r\n```bash\r\n/usr/local/include/mosquitto_plugin.h:167:46: error: unknown type name ‘mosquitto_plugin_id_t’; did you mean ‘mosquitto_property’?\r\n```\r\n\r\n修改 `auth-plug.c` 與 `log.c` 檔\r\n\r\n```c\r\n#include <mosquitto_broker.h>\r\n#include <mosquitto_plugin.h>\r\n#include <mosquitto.h>\r\n```\r\n\r\n- 將編譯完成後生成的 `auth-plug.so` 複製至 mosquitto 的目錄下(不是源碼目錄，是安裝後的目錄)\r\n\r\n```bash\r\ncp auth-plug.so /var/lib/mosquitto\r\n```\r\n\r\n- 進入 mosquitto 安裝後的目錄(預設為 etc/mosquitto)，複製 mosquitto.conf.example 並在文件最後加入設定\r\n\r\n```conf\r\ninclude_dir /etc/mosquitto/conf.d\r\n```\r\n\r\n- 在 mosquitto 目錄下建立 conf.d 資料夾，並新增 auth-plug.conf\r\n\r\n```bash\r\nmkdir /etc/mosquitto/conf.d\r\nvim auth-plug.conf\r\n```\r\n\r\n```conf\r\n# auth_plugin /var/lib/mosquitto/auth-plug.so\r\nauth_plugin /<your path>/auth-plug.so\r\nauth_opt_backends mysql\r\nauth_opt_log_quiet false\r\n# auth_opt_host localhost\r\nauth_opt_host <your mysql host>\r\n# auth_opt_port 3306\r\nauth_opt_port <your mysql port>\r\nauth_opt_dbname <your mysql schema>\r\nauth_opt_user <your mysql user>\r\nauth_opt_pass <your mysql password>\r\n\r\nauth_opt_userquery SELECT pw FROM <your_users_table> WHERE username = '%s'\r\nauth_opt_superquery SELECT COUNT(*) FROM <your_users_table> WHERE username = '%s' AND super = 1\r\nauth_opt_aclquery SELECT topic FROM <your_acls_table> WHERE (username = '%s') AND (rw >= %d)\r\n# auth_opt_superusers Sup\r\nauth_opt_superusers S*\r\nauth_opt_ssl_enabled true\r\n```\r\n\r\n- 更改檔案權限\r\n\r\n  ```bash\r\n  chown mosquitto:mosquitto auth-plug.conf\r\n  chmod go-rwx auth-plug.conf\r\n  ```\r\n\r\n### 若 mosquitto 無法正常運行\r\n\r\n使用 `sudo systemctl start mosquitto -l` 啟動 Mosquitto\r\n\r\n使用 `sudo systemctl status mosquitto -l` 查看運行狀態\r\n\r\n若狀態為失敗，運行輸入 `sudo /usr/local/sbin/mosquitto -c /etc/mosquitto/mosquitto.conf` (ExecStart=)，查看詳細的啟動錯誤資訊\r\n\r\n- 缺乏權限：將缺乏權限的目錄或是檔案，其權限歸於 mosquitto\r\n- libmosquitto.so.1:cannot open shard object\r\n  - 運行 `sudo /sbin/ldconfig` 更新庫的連接器緩存\r\n\r\n## 安裝身分驗證套件(mosquitto-go-auth)\r\n\r\n> 僅支援 Linux (Debian, Ubuntu and Mintus) 和 MacOS\r\n>\r\n> [iegomez/mosquitto-go-auth](https://github.com/iegomez/mosquitto-go-auth#build)\r\n>\r\n> [Mosquitto 安装与部署](https://www.cnblogs.com/IC1101/p/14749722.html)\r\n>\r\n> [Uninstalling Go (golang)](https://askubuntu.com/questions/742078/uninstalling-go-golang)\r\n\r\n### 設置 mosquitto (同 mosquitto-auth-plug 套件)\r\n\r\n### 安裝 mosquitto-go-auth\r\n\r\n- 安裝之前，需先在系統上安裝 golang，所需 go 最低版本為 1.13.8。\r\n\r\n```bash\r\ngo version\r\n```\r\n\r\n- 安裝 go (若要更新 golang，需先將舊版本解除安裝 remove golang)\r\n\r\n```bash\r\n# Update the following as per your system configuration\r\nexport GO_VERSION=1.16.4\r\nexport GO_OS=linux\r\nexport GO_ARCH=amd64\r\n\r\nwget https://dl.google.com/go/go${GO_VERSION}.${GO_OS}-${GO_ARCH}.tar.gz -O golang.tar.gz\r\nsudo tar -C /usr/local -xzf golang.tar.gz\r\nexport PATH=$PATH:/usr/local/go/bin\r\nrm golang.tar.gz\r\n\r\n# Prints the Go version\r\ngo version\r\n```\r\n\r\n- 將 mosquitto-go-auth 套件，git clone 下來，並打包\r\n\r\n```bash\r\nmake\r\n```\r\n\r\n- 設定 mosquitto 文件(mosquitto.conf)\r\n\r\n```conf\r\ninclude_dir /etc/mosquitto/conf.d\r\n```\r\n\r\nvim /mosquitto/conf.d/go-auth.conf\r\n\r\n```conf\r\n# 套件編譯完成後的檔案\r\nauth_plugin /etc/mosquitto/conf.d/go-auth.so\r\n\r\n# 後端\r\nauth_opt_backends mysql\r\n\r\n# 密碼編碼方式\r\nauth_opt_hasher bcrypt\r\nauth_opt_hasher_cost 10\r\n\r\n# 設定  mosquitto log (上線後應將 log_level debug 關閉)\r\nauth_opt_log_level debug\r\nauth_opt_log_dest file\r\nauth_opt_log_file /var/log/mosquitto/mosquitto.log\r\n\r\nauth_opt_mysql_protocol tcp\r\n\r\n# 允許使本機密碼\r\nauth_opt_mysql_allow_native_passwords true\r\n\r\n# 連接資料庫的設定\r\nauth_opt_mysql_host localhost\r\nauth_opt_mysql_port 3306\r\nauth_opt_mysql_dbname max_system\r\nauth_opt_mysql_user max_system\r\nauth_opt_mysql_password maxsystem@2021\r\nauth_opt_mysql_connect_tries 5\r\nauth_opt_mysql_userquery SELECT password_hash FROM test_user WHERE username = ? limit 1\r\nauth_opt_mysql_superquery SELECT COUNT(*) FROM test_user WHERE username = ? AND is_admin = 1\r\nauth_opt_mysql_aclquery SELECT topic FROM test_acl WHERE test_user_id = (SELECT id FROM test_user WHERE username = ?) AND (rw >= ?)\r\n```\r\n\r\n### acl 權限設定\r\n\r\n其實一般而言只會使用到權限 2、5、7\r\n\r\n```log\r\n0: no access (NULL)\r\n1: read access (r)  // 不會動\r\n2: write access (w)\r\n3: read and write access (rw)\r\n4: subscribe access (s)\r\n5: read & subscribe access (rs)\r\n6: write & subscribe access (ws)\r\n7: read, write and subscribe access (rws)\r\n```\r\n\r\n## MQTT Client\r\n\r\n> [php-mqtt/client](https://github.com/php-mqtt/client)\r\n>\r\n> [php-mqtt/client-examples](https://github.com/php-mqtt/client-examples)\r\n\r\n### 安裝\r\n\r\n```git\r\ngit clone https://github.com/php-mqtt/client-examples.git\r\n```\r\n\r\n將專案複製到本機，進入專案資料夾，啟動 composer\r\n\r\n```bash\r\ncd client-examples\r\ncomposer install\r\n```\r\n\r\n### 設定 mqtt-client 連線\r\n\r\n進入 share 資料夾，編輯 config.php\r\n\r\n```php\r\n<?php\r\n\r\ndeclare(strict_types=1);\r\n\r\ndefine('MQTT_BROKER_HOST', '127.0.0.1');  // host\r\ndefine('MQTT_BROKER_PORT', 1883);         // port\r\ndefine('MQTT_BROKER_TLS_PORT', 8883);     // tls port\r\n\r\ndefine('TLS_SERVER_CA_FILE', '');\r\ndefine('TLS_CLIENT_CERTIFICATE_FILE', '');\r\ndefine('TLS_CLIENT_CERTIFICATE_KEY_FILE', '');\r\ndefine('TLS_CLIENT_CERTIFICATE_KEY_PASSPHRASE', null);\r\n\r\ndefine('AUTHORIZATION_USERNAME', '');     // mqtt broker username\r\ndefine('AUTHORIZATION_PASSWORD', '');     // mqtt broker password\r\n```\r\n","date":"2022-12-27T05:31:06.650Z","matchingLines":["## 概述\r","## 在 windows 建立 MQTT 測試主機(Eclipse Mosquitto)\r","## 在虛擬主機建立 MQTT Broker (Mosquitto)\r","## Mosquitto conf 設定與啟動\r","## 測試 Broker\r","## 安裝身分驗證套件(mosquitto-auth-plugin)\r","## 安裝身分驗證套件(mosquitto-go-auth)\r","## MQTT Client\r"]},{"name":"phpDoc.md","content":"# phpDoc\r\n\r\n[自動編寫程式](https://github.com/barryvdh/laravel-ide-helper)\r\n\r\n## 通用註解寫法\r\n\r\n### 註解範例（普通程式文件，類別文件，函數文件，變量定義文件）\r\n\r\n```php\r\n/**\r\n * XXXXX的文件\r\n *\r\n * 功能1： xxx\r\n * 功能2： xxx\r\n *\r\n * @file        $https://github.com/changgenglu/note/blob/master/phpDoc.md  $\r\n * @package     core\r\n * @author      Ivan <eatbreakfast2012@gmail.com>\r\n * @version     V1.0.0\r\n * @link        https://github.com/changgenglu/note/blob/master/phpDoc.md\r\n */\r\n```\r\n\r\n- `@file` 檔案位置：\r\n\r\n- `@version` 版本：\r\n\r\n- `@package` 是團隊事先定義好的，在 phpdocumentor 里同一 package 的文件可以給出跟蹤的鏈接。項目開發前需要對其定義。\r\n\r\n- `@link` 行後面接的地址是程式開發文檔的地址\r\n\r\n> 說明：以上自動更新版本及文件名需要設定 SVN，具體請自行搜尋 _'SVN 自動版本號'_\r\n\r\n### 類別註解，使用如下幾個 tag\r\n\r\n```php\r\n/**\r\n * xxxxx類\r\n *\r\n * 功能1：完成xxxx\r\n * 功能2：完成xxxxx\r\n *\r\n * @author      Ivan <eatbreakfast2012@gmail.com>\r\n * @access      public\r\n * @abstract\r\n */\r\npublic class DemoClass {\r\n //code...\r\n}\r\n```\r\n\r\n- `@access` (`public`|`private`) 標記類是私有的還是公用的。\r\n- `@abstract`標記該類是個抽象類\r\n\r\n### 類別屬性宣告註解\r\n\r\n```php\r\npublic class DemoClass {\r\n\r\n   /**\r\n    * 當前頁碼\r\n    *\r\n    * @var integer\r\n    */\r\n    public $currentPageNumber;\r\n\r\n   /**\r\n    * 私有變量使用下劃線開頭\r\n    *\r\n    * @var string\r\n    */\r\n    private $_instance;\r\n}\r\n```\r\n\r\n### 普通函數和類別中的函數註解\r\n\r\n```php\r\n/**\r\n * 獲得頭貼地址\r\n *\r\n * @author Ivan <eatbreakfast2012@gmail.com>\r\n *\r\n * @param string  $imageName  圖片檔案名\r\n * @param integer $size     檔案大小\r\n *\r\n * @return string\r\n */\r\nfunction getAvatarUrl($imageName, $size = 80)\r\n{\r\n    return sprintf(SITE_URL . '/service/images/cropped_%s/'.$imageName, $size);\r\n}\r\n\r\n```\r\n\r\n順序按照 author、param、return 來放，**區塊間空行**。\r\n\r\n### 程式段落註解\r\n\r\n段落註解和邏輯註解使用如下方式\r\n\r\n```php\r\n/**\r\n * 1 如果$_GET['do']等於buy,則購買條碼\r\n */\r\nif($_GET['do'] == 'buy')\r\n{\r\n    // 1.1 驗證用戶提交變量是否合法\r\n    if($_POST['strCodeNum'])\r\n    {\r\n\r\n    }\r\n    // 1.2 驗證用戶提交的碼是否可以購買\r\n    // 1.3 ..................\r\n} // end if\r\n\r\n/**\r\n * 2 如果$_GET['do']等於list,顯示用戶選擇的條碼\r\n */\r\nif($_GET['do'] == 'list')\r\n{\r\n    // 2.1 驗證用戶提交變量是否合法\r\n    if($_POST['strCodeNum'])\r\n    {\r\n\r\n    }\r\n    // 2.2 驗證用戶提交的碼是否可以購買\r\n\r\n    // 2.3 ..................\r\n} // end if\r\n```\r\n\r\n## PHPdoc 規範\r\n\r\n[WIKI 上的 PHPDoc](http://en.wikipedia.org/wiki/Phpdoc)\r\n\r\n| 標記        | 用途                              | 描述                                                                     |\r\n| ----------- | --------------------------------- | ------------------------------------------------------------------------ |\r\n| @abstract   |                                   | 抽象類的變量和方法                                                       |\r\n| @access     | public, private or protected      | 文檔的訪問、使用權限. @access private 表明這個文檔是被保護的。           |\r\n| @author     | Ivan <eatbreakfast2012@gmail.com> | 文檔作者                                                                 |\r\n| @copyright  | 名稱 時間                         | 文檔版權信息                                                             |\r\n| @deprecated | version                           | 文檔中被廢除的方法                                                       |\r\n| @deprec     |                                   | 同 @deprecated                                                           |\r\n| @example    | /path/to/example                  | 文檔的外部保存的示例文件的位置。                                         |\r\n| @exception  |                                   | 文檔中方法拋出的異常，也可參照 @throws.                                  |\r\n| @global     | 類型：$globalvarname              | 文檔中的全局變量及有關的方法和函數                                       |\r\n| @ignore     |                                   | 忽略文檔中指定的關鍵字                                                   |\r\n| @internal   |                                   | 開發團隊內部信息                                                         |\r\n| @link       | URL                               | 類似於 license 但還可以通過 link 找到文檔中的更多個詳細的信息            |\r\n| @name       | 變量別名                          | 為某個變量指定別名                                                       |\r\n| @magic      |                                   | phpdoc.de compatibility                                                  |\r\n| @package    | 封裝包的名稱                      | 一組相關類、函數封裝的包名稱                                             |\r\n| @param      | 如 $username 用戶名               | 變量含義註解                                                             |\r\n| @return     | 如 返回 bool                      | 函數返回結果描述，一般不用在 void（空返回結果的）的函數中                |\r\n| @see        | 如 Class Login()                  | 文件關聯的任何元素（全局變量，包括，頁面，類，函數，定義，方法，變量）。 |\r\n| @since      | version                           | 記錄什麽時候對文檔的哪些部分進行了更改                                   |\r\n| @static     |                                   | 記錄靜態類、方法                                                         |\r\n| @staticvar  |                                   | 在類、函數中使用的靜態變量                                               |\r\n| @subpackage |                                   | 子版本                                                                   |\r\n| @throws     |                                   | 某一方法拋出的異常                                                       |\r\n| @todo       |                                   | 表示文件未完成或者要完善的地方                                           |\r\n| @var        | type                              | 文檔中的變量及其類型                                                     |\r\n| @version    |                                   | 文檔、類、函數的版本信息                                                 |\r\n\r\nPHPDoc 註解實例：\r\n\r\n```php\r\n<?php\r\n /**\r\n  * start page for webaccess\r\n  *\r\n  * PHP version 5\r\n  *\r\n  * @category  PHP\r\n  * @package   PSI_Web\r\n  * @author    Michael Cramer <BigMichi1@users.sourceforge.net>\r\n  * @copyright 2009 phpSysInfo\r\n  * @license   http://opensource.org/licenses/gpl-2.0.php GNU General Public License\r\n  * @version   SVN: $Id: class.Webpage.inc.php 412 2010-12-29 09:45:53Z Jacky672 $\r\n  * @link      http://phpsysinfo.sourceforge.net\r\n  */\r\n  /**\r\n  * generate the dynamic webpage\r\n  *\r\n  * @category  PHP\r\n  * @package   PSI_Web\r\n  * @author    Michael Cramer <BigMichi1@users.sourceforge.net>\r\n  * @copyright 2009 phpSysInfo\r\n  * @license   http://opensource.org/licenses/gpl-2.0.php GNU General Public License\r\n  * @version   Release: 3.0\r\n  * @link      http://phpsysinfo.sourceforge.net\r\n  */\r\n class Webpage extends Output implements PSI_Interface_Output\r\n {\r\n     /**\r\n      * configured language\r\n      *\r\n      * @var String\r\n      */\r\n     private $_language;\r\n\r\n     /**\r\n      * configured template\r\n      *\r\n      * @var String\r\n      */\r\n     private $_template;\r\n\r\n     /**\r\n      * all available templates\r\n      *\r\n      * @var Array\r\n      */\r\n     private $_templates = array();\r\n\r\n     /**\r\n      * all available languages\r\n      *\r\n      * @var Array\r\n      */\r\n     private $_languages = array();\r\n\r\n     /**\r\n      * check for all extensions that are needed, initialize needed vars and read config.php\r\n      */\r\n     public function __construct()\r\n     {\r\n         parent::__construct();\r\n         $this->_getTemplateList();\r\n         $this->_getLanguageList();\r\n     }\r\n\r\n     /**\r\n      * checking config.php setting for template, if not supportet set phpsysinfo.css as default\r\n      * checking config.php setting for language, if not supported set en as default\r\n      *\r\n      * @return void\r\n      */\r\n     private function _checkTemplateLanguage()\r\n     {\r\n         $this->_template = trim(PSI_DEFAULT_TEMPLATE);\r\n         if (!file_exists(APP_ROOT.'/templates/'.$this->_template.\".css\")) {\r\n             $this->_template = 'phpsysinfo';\r\n         }\r\n\r\n         $this->_language = trim(PSI_DEFAULT_LANG);\r\n         if (!file_exists(APP_ROOT.'/language/'.$this->_language.\".xml\")) {\r\n             $this->_language = 'en';\r\n         }\r\n     }\r\n\r\n     /**\r\n      * get all available tamplates and store them in internal array\r\n      *\r\n      * @return void\r\n      */\r\n     private function _getTemplateList()\r\n     {\r\n         $dirlist = CommonFunctions::gdc(APP_ROOT.'/templates/');\r\n         sort($dirlist);\r\n         foreach ($dirlist as $file) {\r\n             $tpl_ext = substr($file, strlen($file) - 4);\r\n             $tpl_name = substr($file, 0, strlen($file) - 4);\r\n             if ($tpl_ext === \".css\") {\r\n                 array_push($this->_templates, $tpl_name);\r\n             }\r\n         }\r\n     }\r\n\r\n     /**\r\n      * get all available translations and store them in internal array\r\n      *\r\n      * @return void\r\n      */\r\n     private function _getLanguageList()\r\n     {\r\n         $dirlist = CommonFunctions::gdc(APP_ROOT.'/language/');\r\n         sort($dirlist);\r\n         foreach ($dirlist as $file) {\r\n             $lang_ext = substr($file, strlen($file) - 4);\r\n             $lang_name = substr($file, 0, strlen($file) - 4);\r\n             if ($lang_ext == \".xml\") {\r\n                 array_push($this->_languages, $lang_name);\r\n             }\r\n         }\r\n     }\r\n\r\n     /**\r\n      * render the page\r\n      *\r\n      * @return void\r\n      */\r\n     public function run()\r\n     {\r\n         $this->_checkTemplateLanguage();\r\n\r\n         $tpl = new Template(\"/templates/html/index_dynamic.html\");\r\n\r\n         $tpl->set(\"template\", $this->_template);\r\n         $tpl->set(\"templates\", $this->_templates);\r\n         $tpl->set(\"language\", $this->_language);\r\n         $tpl->set(\"languages\", $this->_languages);\r\n\r\n         echo $tpl->fetch();\r\n     }\r\n }\r\n```\r\n","date":"2022-12-27T05:20:46.262Z","matchingLines":["## 通用註解寫法\r","## PHPdoc 規範\r"]},{"name":"PHP 物件導向.md","content":"# PHP 物件導向\r\n\r\n- [PHP 物件導向](#php-物件導向)\r\n  - [物件和類別 `Objects` and `Classes`](#物件和類別-objects-and-classes)\r\n  - [建立類別 `Class`](#建立類別-class)\r\n  - [定義類別的屬性](#定義類別的屬性)\r\n  - [定義類別的方法(Methods)](#定義類別的方法methods)\r\n  - [定義類別的常數(const)](#定義類別的常數const)\r\n  - [封裝 Encapsulation](#封裝-encapsulation)\r\n  - [PHP 魔術函數](#php-魔術函數)\r\n    - [`__construct()` 建構式](#__construct-建構式)\r\n    - [`__destruct()` 解構式](#__destruct-解構式)\r\n    - [`unset()`](#unset)\r\n    - [`__toString`](#__tostring)\r\n    - [`__get` `__set` 強制封裝](#__get-__set-強制封裝)\r\n  - [類別繼承](#類別繼承)\r\n    - [覆寫(Override) 繼承的方法和屬性](#覆寫override-繼承的方法和屬性)\r\n    - [`final` 避免被覆寫](#final-避免被覆寫)\r\n    - [範圍解析運算子(scope resolution operator)](#範圍解析運算子scope-resolution-operator)\r\n  - [將屬性和方法加上可視性(Visibility)](#將屬性和方法加上可視性visibility)\r\n    - [`Protected` 受保護的](#protected-受保護的)\r\n    - [`Private` 隱私的](#private-隱私的)\r\n    - [`Static` 靜態的](#static-靜態的)\r\n  - [介面與抽象類別的應用](#介面與抽象類別的應用)\r\n    - [介面(interface)](#介面interface)\r\n    - [抽象類別(Abstract)](#抽象類別abstract)\r\n  - [`trait` 的應用](#trait-的應用)\r\n  - [參考資料](#參考資料)\r\n\r\n## 物件和類別 `Objects` and `Classes`\r\n\r\n把類似或有關聯的工作或屬性，組織到類別`class`裡面。  \r\n這可以讓程式保持遵守 **不重複原則 “don’t repeat yourself” (DRY)**，更容易維護。\r\n\r\n- `class` 類別：可以比喻作一個建築的藍圖。類別是將房子的樣式設計出來。\r\n- `object` 物件：依照藍圖蓋出來的房子。物件是類別的實例。\r\n- `data` 資料：就像是鋼筋、水泥，用來蓋房子的材料。\r\n\r\n`data`(建材)經過`class`(藍圖)，就會被實例化變成`object`(房子)。\r\n\r\n## 建立類別 `Class`\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    // 類別的屬性和方法在大括號裡面宣告\r\n}\r\n\r\n$obj = new MyClass;\r\n\r\nvar_dump($obj);\r\n```\r\n\r\n- `new` 關鍵字在建立類別之後，實例化一個類別，並將它存到一個變數上。\r\n\r\n- `var_dump()` 來印出變數的相關訊息於螢幕上。\r\n\r\n最終會輸出\r\n\r\n```html\r\nobject(MyClass)#1 (0) { }\r\n```\r\n\r\n此為最基礎的物件形式。\r\n\r\n## 定義類別的屬性\r\n\r\n使用屬性(Property)，也稱 **`Class`的變數(Variable)** 來把 `Data` 存入一個 `Class` 裡面。\r\n\r\n```php\r\n<?php\r\n\r\nclass MyClass\r\n{\r\n  public $prop1 = \"I'm a class property!\";\r\n}\r\n\r\n$obj = new MyClass;\r\n```\r\n\r\n- `public` 此為屬性的關鍵字，用來決定屬性的可視性(Visibility)。\r\n\r\n指定要讀取的物件及屬性，並將其顯示在瀏覽器上\r\n\r\n```php\r\necho $obj->prop1; // Output the property\r\n```\r\n\r\n- `->`（對象運算符）: 在 PHP 物件中，用來存取物件的屬性(Property)和方法(Methods)。\r\n- `::`（雙冒號）: 用來訪問靜態屬性。\r\n\r\n最後將會得到\r\n\r\n```html\r\nI'm a class property!\r\n```\r\n\r\n## 定義類別的方法(Methods)\r\n\r\n可以藉由執行這些方法，來更改物件的行為或是狀態。\r\n\r\n建立一個方法來設定與讀取屬性 `$prop1` 的值\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function setProperty($new_value) {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty() {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\n$obj = new MyClass;\r\necho $obj->getProperty(); // 得到原始的屬性值\r\n\r\n$obj->setProperty(\"I'm a new property value!\"); // 設定新的屬性值\r\necho $obj->getProperty(); // 得到新的屬性值\r\n```\r\n\r\n- `$this` : 物件透過 `$this` 關鍵字來參考自己，物件使用 $this 就如同你直接使用物件名稱來指定物件。\r\n- `$this` 寫在 class 內部\r\n- 使用這些含有 `$this` 的方法之前，記得先要實例化這些方法的物件。\r\n\r\n  ```php\r\n  $this->prop1;\r\n  myClass->prop1; // 兩者的意義相同\r\n  ```\r\n\r\n輸出的結果\r\n\r\n```html\r\nI'm a class property! I'm a new property value!\r\n```\r\n\r\n接著再 `new` 一個新的 `class`\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function setProperty($new_value) {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty() {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\n// 將兩個物件實例化\r\n$obj = new MyClass;\r\n$obj2 = new MyClass;\r\n\r\n// 取得兩個物件的屬性變數 $prop1\r\necho $obj->getProperty();\r\necho $obj2->getProperty();\r\n\r\n// 將兩個物件設定新的屬性值\r\n$obj->setProperty(\"I'm a new property value!\");\r\n$obj2->setProperty(\"I belong to the second instance!\");\r\n\r\n// 輸出兩個物件的新屬性值\r\necho $obj->getProperty();\r\necho $obj2->getProperty();\r\n```\r\n\r\n輸出結果\r\n\r\n```html\r\nI'm a class property! I'm a class property! I'm a new property value! I belong\r\nto the second instance!\r\n```\r\n\r\n- 物件導向將 `object` 視為獨立的個體，依照藍圖蓋出來的房子，每一間都是獨立的。\r\n\r\n## 定義類別的常數(const)\r\n\r\n- 可以把類別中始終保持不變的值，定義為常數。\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    const constant = \"value\";\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n\r\n    function showConstant() {\r\n        echo  self::constant . \"<br />\";\r\n    }\r\n}\r\n\r\n// 將物件實例化\r\n$obj = new MyClass;\r\n\r\n// 取得物件的常數\r\necho $obj->showConstant();\r\necho MyClass::constant;\r\n```\r\n\r\n輸出結果\r\n\r\n```html\r\nvalue value\r\n```\r\n\r\n## 封裝 Encapsulation\r\n\r\n每個物件都包含進行操作時需要的所有資訊，物件不必依賴其他物件來完成操作，將方法、欄位、屬性和邏輯包裝在類別內，透過類別的實體來實現，外部物件無法了解物件的內部細節，有種隱藏起來的概念，外部對資料的操作也只能透過已經定義的介面，用一段簡白的話來說，對事只了解他的外在，無需理解內部構造，即為封裝。\r\n\r\n## PHP 魔術函數\r\n\r\n### `__construct()` 建構式\r\n\r\n- `__construct()` : 當一個物件建立的時候會 **首先** 被呼叫。\r\n- `__CLASS__` : 會回傳被呼叫的類別名稱。\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\n// 實例化一個物件\r\n$obj = new MyClass;\r\n\r\n// 取得屬性 $prop1 的值\r\necho $obj->getProperty();\r\n\r\n// 在生命週期的最後加上\r\necho \"End of file.<br />\";\r\n```\r\n\r\n最後輸出\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! I'm a class property! End of file.\r\n```\r\n\r\n### `__destruct()` 解構式\r\n\r\n- `__destruct()` : 可以清除物件，例如：關閉資料庫連線。\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n    {\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\n// 實例化一個新的物件\r\n$obj = new MyClass;\r\n\r\n// 取得屬性 $prop1 的值\r\necho $obj->getProperty();\r\n\r\n// 在生命週期的最後加上\r\necho \"End of file.<br />\";\r\n```\r\n\r\n最後輸出畫面\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! I'm a class property! End of file. The class\r\n\"MyClass\" was destroyed.\r\n```\r\n\r\n- 當物件使用完畢，PHP 會自動釋放記憶體。\r\n\r\n### `unset()`\r\n\r\n- `unset()` : 此方法可以更明確觸發 `__destruct()` 魔術函數。\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\n// 將一個物件實例化\r\n$obj = new MyClass;\r\n\r\n// 取得變數 $prop1\r\necho $obj->getProperty();\r\n\r\n// 清除物件\r\nunset($obj);\r\n\r\n// 生命週期結束後回傳\r\necho \"End of file.<br />\";\r\n```\r\n\r\n結果會輸出\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! I'm a class property! The class \"MyClass\" was\r\ndestroyed. End of file.\r\n```\r\n\r\n### `__toString`\r\n\r\n- `__toString` : 將物件轉換為字串。\r\n\r\n如果將物件當作字串處理的話，會出現無法傳換型態的錯誤。\r\n\r\n```php\r\n// 實例化一個新的物件\r\n$obj = new MyClass;\r\n\r\n// 將物件輸出為字串\r\necho $obj;\r\n```\r\n\r\n輸出結果\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! Catchable fatal error: Object of class\r\nMyClass could not be converted to string\r\n```\r\n\r\n加入 `__toString` 函數，來做轉換處理。\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function __toString()\r\n    {\r\n        echo \"Using the toString method: \";\r\n        return $this->getProperty();\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\n// 實例化一個新的物件\r\n$obj = new MyClass;\r\n\r\n// 回傳物件為字串\r\necho $obj;\r\n\r\n// 清除這個物件\r\nunset($obj);\r\n\r\n// 在生命周期結束後輸出\r\necho \"End of file.<br />\";\r\n```\r\n\r\n當物件試圖轉換成字串時，會觸發 `__toString` 函數，再由 `__toString` 函數呼叫 `getProperty()` 方法。  \r\n輸出結果為\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! Using the toString method: I'm a class\r\nproperty! The class \"MyClass\" was destroyed. End of file.\r\n```\r\n\r\n### `__get` `__set` 強制封裝\r\n\r\n- `__get()` 只會回傳屬性變數的值\r\n- `__set()` 指派一個新的值給屬性變數\r\n\r\n```php\r\nclass className\r\n{\r\n    private $attribute\r\n\r\n    function __get($name)\r\n    {\r\n        return $this->$name;\r\n    }\r\n\r\n    function __set($name, $value)\r\n    {\r\n        $this->$name = $value;\r\n    }\r\n\r\n}\r\n\r\n$a = new className();\r\n//使用public時，不會用到__get(), __set()屬性\r\n\r\n$a->attribute = 5;\r\n//私下呼叫__set()，使用$name設為attribute，$value設為5\r\n\r\n$a->attribute\r\n//私下呼叫__get()，並將參數$name設為attribute\r\n```\r\n\r\n- 優點：藉由單一的存取處，可以自由地修改底層的實作\r\n\r\n## 類別繼承\r\n\r\n- `extend` : 此關鍵字可以讓類別繼承其他類別的**方法**和**屬性**。\r\n- 子類別只能繼承一個父類別。\r\n\r\n建立一個新的 `class` 並繼承 MyClass\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function __toString()\r\n    {\r\n        echo \"Using the toString method: \";\r\n        return $this->getProperty();\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\nclass MyOtherClass extends MyClass\r\n{\r\n    public function newMethod()\r\n    {\r\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\r\n    }\r\n}\r\n\r\n// 實例化一個新的物件\r\n$new_object = new MyOtherClass;\r\n\r\n// 回傳此類別的方法\r\necho $new_object->newMethod();\r\n\r\n// 回傳父層類別的方法\r\necho $new_object->getProperty();\r\n```\r\n\r\n結果輸出\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! From a new method in MyOtherClass. I'm a\r\nclass property! The class \"MyClass\" was destroyed.\r\n```\r\n\r\n### 覆寫(Override) 繼承的方法和屬性\r\n\r\n在新的類別中，重新定義繼承自父層的屬性和方法\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function __toString()\r\n    {\r\n        echo \"Using the toString method: \";\r\n        return $this->getProperty();\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\nclass MyOtherClass extends MyClass\r\n{\r\n    public function __construct()\r\n    {\r\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\r\n    }\r\n\r\n    public function newMethod()\r\n    {\r\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\r\n    }\r\n}\r\n\r\n// 實例化一個新的物件\r\n$new_object = new MyOtherClass;\r\n\r\n// 回傳新類別的方法\r\necho $new_object->newMethod();\r\n\r\n// 回傳父層類別的方法\r\necho $new_object->getProperty();\r\n```\r\n\r\n在新類別中，覆寫 `__construct` 方法的輸出結果\r\n\r\n```html\r\nA new constructor in MyOtherClass. From a new method in MyOtherClass. I'm a\r\nclass property! The class \"MyClass\" was destroyed.\r\n```\r\n\r\n### `final` 避免被覆寫\r\n\r\n- 方法前加入 `final` 避免被覆寫\r\n\r\n```php\r\nclass A\r\n{\r\n    public $attribute = 'default value';\r\n\r\n    final function operation()\r\n    {\r\n        echo 'Something<br />';\r\n        echo 'The value of $attribute is'.$this->attribute.'<br />';\r\n    }\r\n}\r\n //可防止B覆寫operation()\r\n ------------------------------------------------------------\r\n //如何完全防止一個類別被繼承？(完全不能被繼承)\r\nfinal class A\r\n{\r\n\r\n}\r\n```\r\n\r\n### 範圍解析運算子(scope resolution operator)\r\n\r\n當要將繼承自父層類別的方法其功能做擴充，要保留原始的功能，但不用將原有的程式碼重寫一遍。\r\n\r\n- 範圍解析運算子依然會受到可視性的限制。\r\n\r\n新增一個改寫父層類別的函數，並使用 `範圍解析運算子::`，來調用父類別被覆寫的函數\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function __toString()\r\n    {\r\n        echo \"Using the toString method: \";\r\n        return $this->getProperty();\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    public function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\nclass MyOtherClass extends MyClass\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct(); // 調用來自父層的 construct 功能\r\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\r\n    }\r\n\r\n    public function newMethod()\r\n    {\r\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\r\n    }\r\n}\r\n\r\n// 實例化一個新物件\r\n$new_object = new MyOtherClass;\r\n\r\n// 將物件輸出成字串\r\necho $new_object->newMethod();\r\n\r\n// 使用來自父層的方法\r\necho $new_object->getProperty();\r\n```\r\n\r\n結果輸出\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! A new constructor in MyOtherClass. From a new\r\nmethod in MyOtherClass. I'm a class property! The class \"MyClass\" was destroyed.\r\n```\r\n\r\n## 將屬性和方法加上可視性(Visibility)\r\n\r\n- `static` : 不用將類別實例化，即可調用。\r\n- `public` : 方法及屬性可以在類別之外被存取。\r\n- `protected` : 該屬性或方法只能在類別以及子類別的內部存取。\r\n- `private` : 該屬性或方法只能在定義它們的類別內存取。\r\n\r\n### `Protected` 受保護的\r\n\r\n將 MyClass 的 `getProperty()` 方法的可視性宣告為 `protected`，並且嘗試從外面呼叫這個方法\r\n\r\n```php\r\n<?php\r\n\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function __toString()\r\n    {\r\n        echo \"Using the toString method: \";\r\n        return $this->getProperty();\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    protected function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\nclass MyOtherClass extends MyClass\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct();\r\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\r\n    }\r\n\r\n    public function newMethod()\r\n    {\r\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\r\n    }\r\n}\r\n\r\n// 實例化一個新物件\r\n$new_object = new MyOtherClass;\r\n\r\n// 嘗試調用父層的 protected 方法\r\necho $new_object->getProperty();\r\n```\r\n\r\n結果輸出\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! A new constructor in MyOtherClass. Fatal\r\nerror: Call to protected method MyClass::getProperty() from context ''\r\n```\r\n\r\n在子類別 MyOtherClass 中新增一個方法來調用父層的 `protected` `getProperty()` 方法\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function __toString()\r\n    {\r\n        echo \"Using the toString method: \";\r\n        return $this->getProperty();\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    protected function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\nclass MyOtherClass extends MyClass\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct();\r\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\r\n    }\r\n\r\n    public function newMethod()\r\n    {\r\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\r\n    }\r\n\r\n    public function callProtected()\r\n    {\r\n        return $this->getProperty();\r\n    }\r\n}\r\n\r\n// 實例化一個新的物件\r\n$new_object = new MyOtherClass;\r\n\r\n// 用子類別的 public 方法調用父層的 protected 方法\r\necho $new_object->callProtected();\r\n```\r\n\r\n輸出結果\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! A new constructor in MyOtherClass. I'm a\r\nclass property! The class \"MyClass\" was destroyed.\r\n```\r\n\r\n### `Private` 隱私的\r\n\r\n將父層 MyClass 的 `getProperty()` 方法的宣告為 `private`，並且使用 MyOtherClass 的 `callProtected()` 方法來調用 `getProperty()` 方法。\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function __toString()\r\n    {\r\n        echo \"Using the toString method: \";\r\n        return $this->getProperty();\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    private function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n}\r\n\r\nclass MyOtherClass extends MyClass\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct();\r\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\r\n    }\r\n\r\n    public function newMethod()\r\n    {\r\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\r\n    }\r\n\r\n    public function callProtected()\r\n    {\r\n        return $this->getProperty();\r\n    }\r\n}\r\n\r\n// 實例化一個新的物件\r\n$new_object = new MyOtherClass;\r\n\r\n// 調用父層的方法\r\necho $new_object->callProtected();\r\n```\r\n\r\n輸出結果\r\n\r\n```html\r\nThe class \"MyClass\" was initiated! A new constructor in MyOtherClass. Fatal\r\nerror: Call to private method MyClass::getProperty() from context 'MyOtherClass'\r\n```\r\n\r\n### `Static` 靜態的\r\n\r\n在 MyClass 加入一個 `static` 變數與方法： `$count`、`plusOne()`。  \r\n在類別的外面使用 `do…while` 迴圈增加 `$count` 的值。\r\n\r\n```php\r\n<?php\r\nclass MyClass\r\n{\r\n    public $prop1 = \"I'm a class property!\";\r\n\r\n    public static $count = 0;\r\n\r\n    public function __construct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\r\n    }\r\n\r\n    public function __destruct()\r\n    {\r\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\r\n    }\r\n\r\n    public function __toString()\r\n    {\r\n        echo \"Using the toString method: \";\r\n        return $this->getProperty();\r\n    }\r\n\r\n    public function setProperty($new_value)\r\n    {\r\n        $this->prop1 = $new_value;\r\n    }\r\n\r\n    private function getProperty()\r\n    {\r\n        return $this->prop1 . \"<br />\";\r\n    }\r\n\r\n    public static function plusOne()\r\n    {\r\n        return \"The count is \" . ++self::$count . \".<br />\";\r\n    }\r\n}\r\n\r\nclass MyOtherClass extends MyClass\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct();\r\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\r\n    }\r\n\r\n    public function newMethod()\r\n    {\r\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\r\n    }\r\n\r\n    public function callProtected()\r\n    {\r\n        return $this->getProperty();\r\n    }\r\n}\r\n\r\n// 在沒有實例化 MyClass 之下，範圍解析運算子調用 plusOne 方法\r\ndo {\r\n    echo MyClass::plusOne();\r\n} while (\r\n    MyClass::$count < 10\r\n);\r\n```\r\n\r\n- 當使用範圍解析運算子存取 `static` 屬性時，屬性名稱前面加上錢字號 `$`\r\n\r\n輸出結果\r\n\r\n```html\r\nThe count is 1. The count is 2. The count is 3. The count is 4. The count is 5.\r\nThe count is 6. The count is 7. The count is 8. The count is 9. The count is 10.\r\n```\r\n\r\n## 介面與抽象類別的應用\r\n\r\n### 介面(interface)\r\n\r\n- `implements`關鍵字 : 執行介面\r\n- 定義功能名稱，但交由執行的類別去**實作**功能\r\n- 執行介面的類別一定要實作介面的方法。\r\n- 介面可以繼承其他的介面。\r\n- 類別可以同時執行多個介面。\r\n\r\nBark.php\r\n\r\n```php\r\n<?php\r\n  interface Bark\r\n  {\r\n    public function bark();\r\n  }\r\n```\r\n\r\nSwim.php\r\n\r\n```php\r\n<?php\r\n  interface Swim\r\n  {\r\n    public function swim();\r\n  }\r\n```\r\n\r\nHuman.php\r\n\r\n```php\r\n<?php\r\n  include \"Bark.php\";\r\n  include \"Swim.php\";\r\n\r\n  class Human implements Bark, Swim\r\n  {\r\n    public function bark()\r\n    {\r\n      echo \"人類叫聲...是在叫什麼啦！！\";\r\n    }\r\n\r\n    public function swim()\r\n    {\r\n      echo \"人類在游泳...不是在洗澡嗎？\";\r\n    }\r\n  }\r\n```\r\n\r\ndemo.php\r\n\r\n```php\r\n<?php\r\n  include \"Human.php\";\r\n  $man = new Human();\r\n  echo $man->bark();\r\n  echo $man->swim();\r\n```\r\n\r\n介面的使用時機 : 當「多個類別（Class）」之間有共同的方法（function），但方法實做的方式有差異，可以將這些共用「方法」寫成「介面（Interface）」，讓其他的「子類別（Class）」去實做這個介面\r\n\r\n### 抽象類別(Abstract)\r\n\r\n- 父類別若不想實作介面方法，子類別又需要定義介面功能，可以將父類別抽象化，即可不用實作介面方法。\r\n- 子類別繼承抽象父類別之後，必須要實作父類別的介面方法。\r\n\r\ndog.php\r\n\r\n```php\r\n<?php\r\ninclude \"Bark.php\";\r\nabstract class dog implements Bark\r\n{\r\n   // 設定狗的屬性\r\n   public $name;\r\n   public $color;\r\n   public $style;\r\n\r\n   //設定建構子\r\n   public function __construct($name,$color,$style)\r\n   {\r\n     $this->name = $name;\r\n     $this->color = $color;\r\n     $this->style = $style;\r\n   }\r\n\r\n   public function dogRun()\r\n   {\r\n     echo \"狗狗跑步中...\";\r\n   }\r\n\r\n   // 修改狗叫的功能\r\n   public function Bark()\r\n   {\r\n     //這裡保持空白\r\n   }\r\n\r\n   public function __destruct()\r\n   {\r\n     echo \"狗狗回家了...\";\r\n   }\r\n}\r\n```\r\n\r\nPoodle.php\r\n\r\n```php\r\ninclude \"dog.php\";\r\n\r\nclass Poodle extends dog\r\n{\r\n  protected $size;\r\n\r\n  public function __construct($name,$color,$style,$size)\r\n  {\r\n    parent::__construct($name,$color,$style);\r\n    $this->size = $size;\r\n  }\r\n\r\n  // 實作父類別的狗叫 function\r\n  public function Bark()\r\n  {\r\n    echo \"狗叫...但小聲....\";\r\n    //呼叫父類別的 dogBark()\r\n  }\r\n}\r\n```\r\n\r\ndemo2.php\r\n\r\n```php\r\n<?php\r\n  include \"Poodle.php\";\r\n\r\n  $my_dog = new Poodle(\"Windy\",\"白色\",\"貴賓狗\",30);\r\n\r\n  echo $my_dog->Bark();\r\n```\r\n\r\n抽象類別的使用時機 : 當「多個類別（Class）」之間有共同的方法（function）或屬性（attribute）時，可以將這些共用的地方寫成「抽象類別（Abstract Class）」，讓其他的「子類別（Class）」去繼承\r\n\r\n## `trait` 的應用\r\n\r\n簡化 Class 功能複用\r\n\r\n```php\r\nclass Man\r\n{\r\n    public function walk() { // ... }\r\n    public function run() { // ... }\r\n}\r\n\r\nclass Woman\r\n{\r\n    public function walk() { // ... }\r\n    public function run() { // ... }\r\n}\r\n```\r\n\r\n當兩個 `class` 都有類似的內容(property 或 method)，用 `trait` 簡化\r\n\r\n```php\r\ntrait Moveable\r\n{\r\n    public function walk() { // ... }\r\n    public function run() { // ... }\r\n}\r\n\r\nclass Man\r\n{\r\n    use Moveable;\r\n}\r\n\r\nclass Woman\r\n{\r\n    use Moveable;\r\n}\r\n```\r\n\r\n`trait`的屬性無法被使用其的類別覆寫\r\n\r\n```php\r\ntrait CountAge\r\n{\r\n    protected $age;\r\n\r\n    public function getAge(): int { return $this->age; }\r\n    public function setAge(int $age): void { $this->age = $age; }\r\n}\r\n\r\nclass Child\r\n{\r\n    use CountAge;\r\n\r\n    protected $age = 10;\r\n}\r\n```\r\n\r\n因為 CountAge 與 Child 中都存在 `$age` 這個屬性，此時便會產生\r\n\r\n```html\r\nPHP Fatal error: Child and CountAge define the same property ($age) in the\r\ncomposition of Child. However, the definition differs and is considered\r\nincompatible.\r\n```\r\n\r\n在使用這個 `trait` 的 `class` 都可以使用其所定義的方法。`trait` 中定義的方法為共有的。\r\n\r\n```php\r\ntrait CheckAdult\r\n{\r\n    private function getAge(): int\r\n    {\r\n        return $this->age;\r\n    }\r\n\r\n    public function isAdult(): bool\r\n    {\r\n        return $this->getAge() >= 18;\r\n    }\r\n}\r\n\r\nclass Human\r\n{\r\n    use CheckAdult;\r\n\r\n    protected $age = 18;\r\n\r\n    public function canAccessPornHub(): bool\r\n    {\r\n        return $this->isAdult();\r\n    }\r\n\r\n    public function canAccessGayTube(): bool\r\n    {\r\n         public $this->getAge() >= 18;\r\n    }\r\n}\r\n```\r\n\r\n- 只要 `use` CheckAdult，就可以使用 `isAdult()` 與 `getAge()`。\r\n\r\n`trait` 之間不可以具有相同名稱的方法，否則會丟出 Fatal Error。\r\n\r\n```php\r\ntrait USD\r\n{\r\n    public function getBalance() {  }\r\n}\r\n\r\ntrait TWD\r\n{\r\n    public function getBalance() {  }\r\n}\r\n\r\nclass Wallet\r\n{\r\n    use USD;\r\n    use TWD;\r\n}\r\n```\r\n\r\n若將函式設為 private 也同樣會出現衝突。\r\n\r\n```php\r\ntrait USD\r\n{\r\n    private function convert(string $to) { // ... }\r\n    public function getUSDBalance(): int { return $this->convert('USD'); }\r\n}\r\n\r\ntrait TWD\r\n{\r\n    private function convert(string $to) { // ... }\r\n    public function getTWDBalance(): int { return $this->convert('TWD'); }\r\n}\r\n\r\nclass Wallet\r\n{\r\n    use USD;\r\n    use TWD;\r\n}\r\n```\r\n\r\n## 參考資料\r\n\r\n[後端 PHP+Laravel--新手實戰日記](https://ithelp.ithome.com.tw/articles/10216317)\r\n","date":"2022-12-27T05:19:35.350Z","matchingLines":["## 物件和類別 `Objects` and `Classes`\r","## 建立類別 `Class`\r","## 定義類別的屬性\r","## 定義類別的方法(Methods)\r","## 定義類別的常數(const)\r","## 封裝 Encapsulation\r","## PHP 魔術函數\r","## 類別繼承\r","## 將屬性和方法加上可視性(Visibility)\r","## 介面與抽象類別的應用\r","## `trait` 的應用\r","## 參考資料\r"]},{"name":"併發控制.md","content":"# 併發控制\r\n\r\n> 悲觀併發控制(悲觀鎖，Pessimistic Concurrency Control / PCC)\r\n>\r\n> 樂觀併發控制(樂觀鎖，Optimistic Concurrency Control / OCC)\r\n\r\n## 悲觀鎖\r\n\r\n對於 \"資料被外界修改\" 持保守態度，因此在整個資料處理過程中，將資料處於鎖定狀態，進以阻止一個事務以影響其他用戶的方式來修改資料。\r\n\r\n在資料庫中，悲觀鎖的流程為：\r\n\r\n1. 在對任意紀錄進行修改前，先嘗試為該紀錄加上排他鎖(exclusive locking)。\r\n2. 如果加鎖失敗，說明該筆資料正在被修改，那麼當前請求可能要等待或者拋出異常，具體影響方式由開發者根據實際需求決定。\r\n3. 若成功加鎖，那就可以對記錄進行修改，待請求完成後就會解鎖了。\r\n4. 期間若有其他對記錄做修改或加排他鎖的操作，都會等待解鎖後或直接拋出異常。\r\n\r\n### MySQL InnoDB 使用悲觀鎖\r\n\r\n使用悲觀鎖，需先將 mysql 自動提交的屬性關閉，因為 mysql 預設使用 autocommit 模式。\r\n\r\nautocommit 模式：當執行一個更新操作後，mysql 會立刻將結果進行提交，若要關閉 `set autocommit=0`, `set autocommit=false`。\r\n\r\n```sql\r\n-- 開始請求(三選一)\r\nbegin; / begin work; / start transaction;\r\n\r\n-- 查詢出商品訊息\r\nselect status from t_goods where id=1 for update;\r\n\r\n-- 根據商品訊息產生訂單\r\ninsert into t_orders (id, goods_id) values (null, 1);\r\n\r\n-- 修改商品 status 為 2\r\nupdate t_goods set status=2;\r\n\r\n-- 提交請求\r\ncommit; / commit work;\r\n```\r\n\r\n使用 `select...for update` 的方式，通過開啟排他鎖的方式實現悲觀鎖，此時在 t_goods 資料表中，id 為 1 的資料會被鎖定，其他的請求必須待本次請求提交後才能執行。\r\n注意，使用 `select...for update` 會把數據鎖住，須注意鎖的級別，MySQL InnoDB 預設為行級鎖(註 1)。行級鎖是基於所索引的，若一條 sql 語句未使用索引，則 mysql 會使用表級鎖(註 2)將整張資料表鎖住。\r\n\r\n**註 1**：行級鎖(row-level locking)， mysql 中鎖定的最小單位，只針對目前操作的資料該行進行加鎖。行鎖可大幅減低資料庫操作的衝突，缺點為：開銷大、加鎖慢、會出現死鎖。\r\n**註 2**：表級鎖(table-level locking)， mysql 中最大的鎖定單位，會將目前操作的整張表進行加鎖，開銷小、加鎖快、不會出現死鎖，但發出鎖衝突的機率最高。\r\n**註 3**：死鎖(deadlock)，兩個或多個執行緒由於互相等待，而永遠被阻塞的情況。\r\n\r\n### 優點與不足\r\n\r\n悲觀併發控制實際採取 \"先取鎖再訪問\" 的保守策略。在效率方面，處理加鎖的機制會讓資料庫產生額外的負擔，還有增加產生死鎖的機會。也增加了併行性，一個請求若鎖定了某行資料，其他請求則需等待此請求結束才可以處理該行資料\r\n\r\n## 樂觀鎖\r\n\r\n樂觀鎖假設多用戶併發的請求，不會互相影響。請求可以在不產生鎖的情況下，處理各自影響的那部分數據。在提交資料前，每個請求會先檢查在該請求讀取數據後，有沒有其他請求又改了該筆資料。如果其他請求有更新該筆資料，正在提交的請求會進行回滾。\r\n\r\n相較於悲觀鎖而言，樂觀鎖認為數據一般情況下不會產生衝突，鎖鎖在資料進行提交更新的時候，才會最資料是否衝突進行檢查。當發現衝突時，返回錯誤訊息，讓使用者決定如何處理。\r\n大多實現樂觀鎖的方式為記錄資料版本，並不會對資料表進行加鎖。\r\n\r\n實現紀錄資料版本有兩種方式，一為使用版本號，二為使用時間戳。\r\n\r\n### 使用版本號\r\n\r\n可以在資料初始化時指定一個版本號，每次對資料的更新操作都會對版號進行 +1，並判斷目前版號是不是該筆資料的最新版號。\r\n\r\n```sql\r\n-- 查詢出商品訊息\r\nselect (status, status, version) from t_goods where id=#{id};\r\n\r\n-- 根據商品訊息產生訂單\r\n-- 修改商品 status 為 2\r\n\r\nupdate t_goods set status=2, version=version+1\r\nwhere id=#{id} and version=#{version};\r\n```\r\n\r\n### 優點與不足\r\n\r\n樂觀併發控制相信請求之間的資料競爭(data race)的機率小，因此直到提交時才進行鎖定，因此不會產生任何鎖與死鎖問題。但仍然有可能遇到不可預期的結果，例如：兩個請求都讀取資料庫的某一行並加以修改後寫入資料庫，此時就會發生資料衝突。\r\n\r\n## 鎖定形式\r\n\r\n### 共享鎖\r\n\r\n又稱為讀鎖，其他的使用者可以併發讀取資料，但是無法修改和刪除，若一請求對某資料增加共享鎖，則其他請求只能對該資料增加共享鎖，不能加排他鎖。\r\n\r\n### 排他鎖\r\n\r\n又稱寫鎖，獨佔鎖。若一事務對某資料加上排他鎖，則只允許此一事務讀取和修改此資料，其他任何類型的事務都不能在此一資料加上任何類型的鎖，直到此事務釋放資料上的鎖。保證其他事務在上鎖期間不能讀取或修改該筆資料。\r\n","date":"2022-12-13T07:44:50.704Z","matchingLines":["## 悲觀鎖\r","## 樂觀鎖\r","## 鎖定形式\r"]},{"name":"多線程與多進程.md","content":"# 多執行緒與多進程\r\n\r\n> 進程是資源分配的最小單位，執行緒是 CPU 調度的最小單位\r\n\r\n## 基本概念\r\n\r\n### 程式 (程序/Program)\r\n\r\n為完成特地任務，用某種語言編寫成的一組指令的集合。指的是一段靜態的程式碼，靜態的物件。\r\n\r\n### 程序 (進程/Process)\r\n\r\n為執行程式一次的過程，或是正在執行的一個程式。是一個動態的過程：他有自己生成、存在與消亡的過程。\r\n\r\n程式是靜態的，程序是動態的，程序作為資源分配的單位，系統在執行時會為每個程序，分配不同的內存區域。\r\n\r\n### 執行緒 (線程/thread)\r\n\r\n程序可以進一步細分為執行緒，是一個程式內部的一個次程式。\r\n\r\n- 若一個程序同一時間並行執行多個執行緒，就是支援多執行緒。\r\n- 執行緒作為調度和執行的單位，每個執行緒擁有獨立的\\*執行棧(execution stack)和\\*程式計數器(Program Counter)，執行緒切換的開銷小。\r\n- 多個執行緒，共享一個程序中結構：方法區、堆疊。\r\n\r\n- 註：\r\n  - 執行堆疊(執行棧/execution stack) 儲存有關正在執行的子程式其訊息的堆疊，在呼叫任何子程式時，主程式都必須暫存子程式執行完畢後應該返回的地址。因此若被呼叫的子程式還要呼叫其他子程式，其自身返回的地址就必須存入執行堆疊，在其自身執行完畢後再取出。\r\n  - 程式計數器(Program Counter)\r\n    - 紀錄程式執行中的狀態\r\n    - 記錄下一個指令的位元址\r\n    - 紀錄程式執行完畢的指令\r\n    - 紀錄程式執行完成的時間\r\n\r\n## 多執行緒與多進程的選擇與區別\r\n\r\n|                | 多進程                                             | 多執行緒                                                     | 結論       |\r\n| -------------- | -------------------------------------------------- | ------------------------------------------------------------ | ---------- |\r\n| 數據共享、同步 | 數據共享複雜，需要用到 IPC；數據是分開的，同步簡單 | 因為共享進程數據，數據共享簡單，但也因為這個原因導致同步複雜 | 各有優勢   |\r\n| 內存、CPU      | 佔用內存多，切換複雜，CPU 利用率低                 | 佔用內存少，切換簡單，CPU 利用率高                           | 執行緒優勢 |\r\n| 建立銷毀、切換 | 建立與銷毀切換複雜，速度慢                         | 建立與銷毀，切換簡單，速度快                                 | 執行緒優勢 |\r\n| 程式設計、除錯 | 程式設計簡單，除錯簡單                             | 程式設計複雜，除錯複雜                                       | 進程優勢   |\r\n| 可靠性         | 進程間不會互相影響                                 | 一個執行緒掛掉教會導致整個進程掛掉                           | 進程優勢   |\r\n| 分布式         | 適應於多核、多機分布式，擴展到多台機器比較簡單     | 適應於多核分布式                                             | 進程優勢   |\r\n\r\n### 選擇情境\r\n\r\n- 需要頻繁建立與銷毀 => 多執行緒\r\n\r\n  - 常見於 web 伺服器，一個新的連線建立一個執行緒，連線斷了就銷毀執行緒。\r\n\r\n- 需要進行大量計算 => 執行緒\r\n\r\n  - 消耗大量 CPU，切換頻繁，如：圖像處理、算法處理。\r\n\r\n- 強相關的處理 => 執行緒、弱相關的處理 => 進程\r\n\r\n  - 一般 server 的任務，如：`資料收發`、`資料處理`。`資料收發`與`資料處理`為弱相關的任務，而`資料處理`又可分為`資料解碼`、`業務處理`，這兩個任務相較之下關聯性較強。因此`資料收發`與`資料處理`可以分進程設計，`資料解碼`與`業務處理`可以分執行緒設計。\r\n\r\n- 可能要擴展到多機分布的 => 進程、多核分布的 => 執行緒\r\n\r\n## PHP 環境下的多程序與多執行緒\r\n\r\nPHP 為單進程同步模型，一個請求對應一個進程，I/O(input/output)是同步阻塞的，\r\n","date":"2022-10-24T07:41:27.648Z","matchingLines":["## 基本概念\r","## 多執行緒與多進程的選擇與區別\r","## PHP 環境下的多程序與多執行緒\r"]},{"name":"Markdown 學習筆記.md","content":"# Markdown 學習筆記\r\n\r\n## Markdown 程式碼區塊可宣告的程式語言\r\n\r\n| 語言名稱   | Markdown 語言宣告                 | 常見檔名                 |\r\n| ---------- | --------------------------------- | ------------------------ |\r\n| ApacheConf | apacheconf, aconf, apache         | \\*.apacheconf, .htaccess |\r\n| Blade      | blade                             | \\*.blade                 |\r\n| CSS        | css                               | \\*.css                   |\r\n| Git Config | git-config, gitconfig, gitmodules | \\*.gitconfig, .gitconfig |\r\n| HTML       | html, xhtml                       | \\*.html                  |\r\n| HTML+PHP   | html+php                          | \\*.phtml                 |\r\n| HTTP       | http                              | \\*.http                  |\r\n| JSON       | json                              | \\*.json, .arcconfig      |\r\n| JavaScript | javascript, js, node              | \\*.js, Jakefile          |\r\n| Makefile   | makefile, bsdmake, make, mf       | \\*.mak, BSDmakefile      |\r\n| Markdown   | markdown, pandoc                  | \\*.md, contents.lr       |\r\n| Nginx      | nginx                             | \\*.nginxconf, nginx.conf |\r\n| PHP        | php, inc                          | \\*.php, .php             |\r\n| Text       | text, fundamental                 | \\*.txt, COPYING          |\r\n| Vue        | vue                               | \\*.vue                   |\r\n","date":"2022-10-17T05:01:09.977Z","matchingLines":["## Markdown 程式碼區塊可宣告的程式語言\r"]},{"name":"Laravel 表單驗證.md","content":"# Laravel 表單驗證\r\n\r\n## 基礎驗證方法 `validate()`\r\n\r\n```php\r\n$validatedData = $request->validate([\r\n    'title' => ['required', 'unique:posts', 'max:255'],\r\n    'body' => ['required'],\r\n]);\r\n```\r\n\r\n也可以使用 `validateWithBag()` 來請求驗證，並將所有錯誤訊息，儲存在一個命名錯誤訊息包\r\n\r\n```php\r\n$validatedData = $request->validateWithBag('post', [\r\n    'title' => ['required', 'unique:posts', 'max:255'],\r\n    'body' => ['required'],\r\n]);\r\n```\r\n\r\n在驗證規則中，加入 bail，如果某個字串在第一次驗證失敗之後，就立即停止驗證。\r\n\r\n```php\r\n$request->validate([\r\n    'title' => 'bail|required|unique:posts|max:255',\r\n    'body' => 'required',\r\n]);\r\n// 如果title沒通過unique的規則，那麼就不會再 繼續驗證max規則\r\n```\r\n\r\n如果你的 HTTP 請求，包還嵌套參數(比如陣列)，你可以在驗證規則中使用「點」語法，來指定這些參數\r\n\r\n```php\r\n$request->validate([\r\n    'title' => 'required|unique:posts|max:255',\r\n    'author.name' => 'required',\r\n    'author.description' => 'required',\r\n]);\r\n```\r\n\r\n如果你的字段名稱包含點，則可以使用跳脫符號\r\n\r\n```php\r\n$request->validate([\r\n    'title' => 'required|unique:posts|max:255',\r\n    'v1\\.0' => 'required',\r\n]);\r\n```\r\n\r\n## [常用規則](https://learnku.com/docs/laravel/8.x/validation/9374)\r\n","date":"2022-10-03T01:16:56.845Z","matchingLines":["## 基礎驗證方法 `validate()`\r","## [常用規則](https://learnku.com/docs/laravel/8.x/validation/9374)\r"]},{"name":"Laravel HTTP Client.md","content":"# laravel HTTP Client\r\n\r\n> laravel 透過 Guzzle 這個套件，模擬 http client 來發送 request\r\n> 預設情況下，laravel 已經自動包含了這個套件。\r\n> 若尚未安裝，可透過 composer 再安裝一次。\r\n>\r\n> ```bash\r\n> composer require guzzlehttp/guzzle\r\n> ```\r\n\r\n## 建立 request\r\n\r\n建立基礎的 GET request\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Http;\r\n\r\n$response = Http::get('http://example.com');\r\n```\r\n\r\n可以直接將查詢字串(query string)加到 URL 上，或是傳入一組索引鍵/值配對的陣列作為 get 的第二個引數\r\n\r\n```php\r\n$response = Http::get('http://example.com/users', [\r\n    'name' => 'Taylor',\r\n    'page' => 1,\r\n]);\r\n```\r\n\r\nget 方法會回傳 Illuminate\\Http\\Client\\Response 的實體，該實體提供了許多用來取得 Response 資訊的方法：\r\n\r\n```php\r\n$response->body() : string;\r\n$response->json($key = null) : array|mixed;\r\n$response->object() : object;\r\n$response->collect($key = null) : Illuminate\\Support\\Collection;\r\n$response->status() : int;\r\n$response->ok() : bool;\r\n$response->successful() : bool;\r\n$response->redirect(): bool;\r\n$response->failed() : bool;\r\n$response->serverError() : bool;\r\n$response->clientError() : bool;\r\n$response->header($header) : string;\r\n$response->headers() : array;\r\n```\r\n\r\nPOST PUT PATCH 等 HTTP action 傳送額外資料，一般情況下，資料會使用 json 的資料型別來傳遞\r\n\r\n```php\r\nuse Illuminate\\Support\\Facades\\Http;\r\n\r\n$response = Http::post('http://example.com/users', [\r\n    'name' => 'Steve',\r\n    'role' => 'Network Administrator',\r\n]);\r\n```\r\n\r\n若想用 x-www-form-urlencoded 來傳送資料，要在建立 request 前呼叫 asForm() 方法\r\n\r\n```php\r\n$response = Http::asForm()->post('http://example.com/users', [\r\n    'name' => 'Sara',\r\n    'role' => 'Privacy Consultant',\r\n]);\r\n```\r\n\r\n## 錯誤處理\r\n\r\nlaravel HTTP client 不會在 client 端或是 server 端錯誤時拋出異常(status code 400 or 500)。\r\n\r\n此時可以透過 successful, clientError 或是 serverError 方法來判斷是否發生錯誤。\r\n\r\n```php\r\n// 若 status code 在200 ~ 300\r\n$response->successful();\r\n\r\n// 若 status code 大於 400\r\n$response->failed();\r\n\r\n// 若 status code 為400層級的錯誤\r\n$response->clientError();\r\n\r\n// 若 status code 為500層級的錯誤\r\n$response->serverError();\r\n```\r\n","date":"2022-10-03T01:16:56.842Z","matchingLines":["## 建立 request\r","## 錯誤處理\r"]},{"name":"Hyper-v 設定.md","content":"# Hyper-v 設定\r\n\r\n- [參考資料](https://ithelp.ithome.com.tw/articles/10128382)\r\n\r\n## 虛擬交換器\r\n\r\n- 外部網路：讓虛擬機器可以與外部網路連線，簡單說就是與 host 主機共用實體網路卡\r\n- 內部網路：可讓 Host 主機與虛擬機器溝通\r\n- 私人網路：讓虛擬機器彼此可以溝通，與外部網路隔離\r\n","date":"2022-10-03T01:16:56.840Z","matchingLines":["## 虛擬交換器\r"]},{"name":"Bootstrap 學習筆記.md","content":"# Bootstrap 學習筆記\r\n\r\n###### tags: `前端` `Bootstrap`\r\n\r\n## html 引入\r\n\r\n```html\r\n<head>\r\n  <meta charset=\"UTF-8\" />\r\n  <link rel=\"stylesheet\" href=\"../_css/bootstrap.min.css\" />\r\n  <script src=\"../_js/jquery.min.js\"></script>\r\n  <script src=\"../_js/popper.min.js\"></script>\r\n  <script src=\"../_js/bootstrap.min.js\"></script>\r\n  <title>Document</title>\r\n</head>\r\n```\r\n\r\n## 表格\r\n\r\n```html\r\n<div class=\"row\">\r\n  <div class=\"col-6\"></div>\r\n  <div class=\"col-6\"></div>\r\n</div>\r\n```\r\n\r\n## 部分顏色名稱\r\n\r\n- primary 主要的\r\n- secondary 副標\r\n- success 成功\r\n- danger 危險\r\n- warning 警告\r\n- info 訊息\r\n- light 明亮(帶有淺邊框)\r\n- dark 深色\r\n- white 白色\r\n\r\n## 改變字型的外觀\r\n\r\n- font-weight-bold\r\n- font-weight-normal\r\n- font-weight-light\r\n- fon-italic(斜體)\r\n\r\n## 文字位置設定\r\n\r\n- text-left\r\n- text-center\r\n- text-right\r\n\r\n## 輪播牆\r\n\r\n```html\r\n<div id=\"mydemo1\" class=\"carousel slide\" data-ride=\"carousel\">\r\n  <ol class=\"carousel-indicators\">\r\n    <li data-target=\"#mydemo1\" data-slide-to=\"0\" class=\"active\"></li>\r\n    <li data-target=\"#mydemo1\" data-slide-to=\"1\"></li>\r\n    <li data-target=\"#mydemo1\" data-slide-to=\"2\"></li>\r\n  </ol>\r\n  <div class=\"carousel-inner\">\r\n    <div class=\"carousel-item active\">\r\n      <img src=\"https://dummyimage.com/1200x300/00ff5e/ffffff\" alt=\"\" />\r\n    </div>\r\n    <div class=\"carousel-item\">\r\n      <img src=\"https://dummyimage.com/1200x300/ff8400/ffffff\" alt=\"\" />\r\n    </div>\r\n    <div class=\"carousel-item\">\r\n      <img src=\"https://dummyimage.com/1200x300/f057c5/ffffff\" alt=\"\" />\r\n    </div>\r\n  </div>\r\n  <a\r\n    class=\"carousel-control-prev\"\r\n    href=\"#mydemo1\"\r\n    role=\"button\"\r\n    data-slide=\"prev\"\r\n  >\r\n    <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\"></span>\r\n    <span class=\"sr-only\">Previous</span>\r\n  </a>\r\n  <a\r\n    class=\"carousel-control-next\"\r\n    href=\"#mydemo1\"\r\n    role=\"button\"\r\n    data-slide=\"next\"\r\n  >\r\n    <span class=\"carousel-control-next-icon\" aria-hidden=\"true\"></span>\r\n    <span class=\"sr-only\">Next</span>\r\n  </a>\r\n</div>\r\n```\r\n\r\n## drop down\r\n\r\n```html\r\n<li class=\"nav-item dropup\">\r\n  <a class=\"nav-link active \" id=\"navbardrop\" data-toggle=\"dropdown\">\r\n    珈琲體驗\r\n  </a>\r\n  <div class=\"dropdown-menu\">\r\n    <a class=\"dropdown-item\" href=\"#\"> 手沖珈琲 </a>\r\n    <a class=\"dropdown-item\" href=\"#\"> 珈琲特調體驗 </a>\r\n    <a class=\"dropdown-item\" href=\"#\"> 拿鐵拉花 </a>\r\n  </div>\r\n</li>\r\n```\r\n\r\n","date":"2022-10-03T01:16:56.839Z","matchingLines":["## html 引入\r","## 表格\r","## 部分顏色名稱\r","## 改變字型的外觀\r","## 文字位置設定\r","## 輪播牆\r","## drop down\r"]}]