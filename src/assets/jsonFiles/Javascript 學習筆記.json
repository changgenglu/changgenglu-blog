{"name":"Javascript 學習筆記.md","content":"# Javascript 學習筆記\n\n>\n\n> **參考資料：**\n>\n> [重新認識 javascript](https://ithelp.ithome.com.tw/users/20065504/ironman/1259)\n\n## 基本概念\n\n- Javascript 的原始值(基本型別/primitive type)：\n  - null(empty)\n  - undefined(預設/未定義)\n  - string(\"12345\")\n  - number(12345)\n  - boolean(true/false)\n  - symbol(ES6)\n- Javascript 的複合值(物件 => object)：包含一個或多個原始值，像是物件或是物件實字，除了基本型別以外的型別都是物件\n\n- 物件：使用 new 關鍵字建立物件\n\n```javascript\nconst name = new type(arguments);\nconst d = new Date();\n```\n\n- 物件實字\n\n```javascript\nvar obj = {\n  name: \"eason\",\n  action: \"haha\",\n};\n```\n\n- 陣列\n\n```javascript\nvar arr = [1, 2, 3, 4, 5];\narr[8] = 12;\narr = [1, 2, 3, 4, 5, \"\", \"\", \"\", 12];\n```\n\n- 用 new 建構出來的是物件 object\n\n```javascript\n    var a = new String(\"test\");\n    typeof(a) = object\n```\n\n- 只有建構式，則會轉為原始值\n\n```javascript\n    var a = String(\"test\");\n    typeof(a) = string\n```\n\n- 複合值在 javascript 是透過記憶體中的位址來比對\n\n```javascript\nvar a = new String(\"test\");\nvar b = new String(\"test\");\n\nconsole.log(a === b);\n// false\n```\n\n- 將不同型態的物件通通轉為字串\n  \\`${}\\` 在大括號中加入變數\n\n- 宣告原始值：單獨放一個記憶體位址 以 by value 運作\n- 宣告複合值：包含許多原始值，但是只放在一個記憶體位置 以 by reference(參考) 運作\n\n- 更改變數為參考物件(複合值)內的原始值，記憶體位址不變\n- 更改變數為原始值，會更改變數的記憶體位址\n\n- undefined\n  這地方沒有這個東西，所以你無法使用\n- NaN\n  要轉型成數字時傳入參數非數字的時候\n- null\n  這地方會有一個值，但這個值目前還沒準備好的意思，所以先填入 `null`\n\n- this\n  - 物件掛在誰身上就是`this`，`this`只在當下單一層的作用域裡有效果，箭頭函式就不會。\n  - 如果宣告變數，則在宣告當層以及內層為有效範圍。\n  - 單純的呼叫`this`，`this`會變成 Global\n\n.bind //定義 function 內的 this 是什麼\n\n### 宣告與命名\n\n- 命名規則\n  - 開頭字元需要是 ASCII 字元(英文小寫)，或是下底線(\\_)、錢號($)。開頭字元不得使用數字。\n  - 大小寫敏感\n  - 名稱不得使用保留字\n\n**注意** 下底線開頭的命名常為特別用途：如類別中的私有變數、常數或方法。錢符號也通常為特殊用途命名。\n\n變數與方法名稱都用小駝峰式的命名，類別用大駝峰式命名。\n\n在 ES5 之前都只會用 `var` 宣告變數，在 ES6 之後加入 `let` 和 `const`，現在應以新加入的特性進行宣告。\n\n### let, const 特性\n\n- 區塊作用域\n\n  - 變數只存活在 {} 花括號裡面，外面不能調用\n\n  ```javascript\n  {\n    const x = 10;\n  }\n  console.log(x); //Uncaught ReferenceError: x is not defined\n\n  {\n    let y = 20;\n  }\n  console.log(y); //Uncaught ReferenceError: y is not defined\n\n  {\n    var z = 30;\n  }\n  console.log(z); //30\n  ```\n\n- 變量會提升，但若未宣告該變數，會回報錯誤，而非 undefined\n  - var 變數的宣告，初始預設值為 undefined，但 let, const 不會有這個預設，當執行 let 變數宣告語句時，才會初始化且能夠被訪問。\n- 不允許重複宣告\n- 全域變數不會成為 window 的屬性\n\n### 如何分辨使用 let 和 const 的時機？\n\n> 如果變數會變，就使用 let，不變就用 const\n\n更改指的是記憶體地址的改變，而不是值的改變\n\n- 記憶體存放變數的原則：\n  - 基本型別值：\n    - 字串、數值、undefined、null、symbol\n    - 以上不能更改他的值，只能重新賦值，此時會更改記憶體位址\n- 引用值：\n  - 物件、陣列、函式\n  - 可以修改裡面的值，這樣不會更改記憶體位置，但若重新賦予一個新的值，就會更改記憶體位址。\n\n### let 和 const 解決了什麼問題？\n\n用 var 宣告時，容易導致意外汙染全域變數的問題，例如，區域變數覆蓋全域變數\n\n```javascript\nvar food = \"apple\";\nfunction func() {\n  var result = \"I eat \" + food;\n  console.log(result);\n}\nfunc(); //I eat apple\n```\n\n在 func 方法中用到全域變數 food，組合字串及回傳。\n\n但如果程式碼變得複雜時，沒注意到 food 已經在第一行宣告過了\n\n### javascript 參數傳遞方式\n\n> 可能是 Call by sharing\n\n下面的例子，原始型別的 mtString 傳遞給 target 的結果符合 call by value 的行為\n\n但當我們將 myObj 傳遞給 target 時，為何也出現和 call by value 的行為相同的結果？\n\n```javascript\nvar myString = \"hello world\";\nvar myObj = { prop1: 123 };\nfunction setAsLiteralObj(target) {\n  console.log(\"target_1: \");\n  console.log(target);\n  target = {};\n  console.log(\"target_2: \");\n  console.log(target);\n}\nsetAsLiteralObj(myString);\nconsole.log(myString); // 'hello world'\nsetAsLiteralObj(myObj);\nconsole.log(myObj);\n```\n\n```txt\n<!-- setAsLiteralObj(myString) -->\n\"target_1: \"\n\"hello world\"\n\"target_2: \"\n[object Object] { ... }\n<!-- setAsLiteralObj(myString) -->\n\n<!-- console.log(myString); // 'hello world' -->\n\"hello world\"\n<!-- console.log(myString); // 'hello world' -->\n\n<!-- setAsLiteralObj(myObj); -->\n\"target_1: \"\n[object Object] {\n  prop1: 123\n}\n\"target_2: \"\n[object Object] { ... }\n<!-- setAsLiteralObj(myObj); -->\n\n<!-- console.log(myObj); -->\n[object Object] {\n  prop1: 123\n}\n<!-- console.log(myObj); -->\n```\n\n當宣告完 `function setAsLiteralObj()` 後的記憶體位置狀況，`setAsLiteralObj()` 其實是被當成一個變數，指向 `function setAsLiteralObj()` 的內容。\n\n當呼叫 `setAsLiteralObj()`，此時 `myString` 會將記憶體位置指派給 function 中的 `target` 參數，可以理解為在乎叫 function 時，宣告參數：\n\n```javascript\nvar target = myString;\n```\n\n因此記憶體位置會變成 `myString` 與 `target` 都會指向同一個位置。\n\n此時在 function 中，將 `target` 透過字面值賦值 `{}`，所以 `target` 會從原本指向 `hello world` 改成指向我們剛創造出來的 `{}`\n\n當呼叫 function 時傳入的參數為 `object` 時，也是一樣的概念 `setAsLiteralObj(myObj)`，`myObj` 會被指派給 function 的參數 `target`。此時，`target` 與執行 `setAsLiteralObj(myString)` 時的 `target` 不同，下面將以 `target'` 代稱被指配 `myObj` 的新 `target`。\n\n在 `target = {}` 時，`target'` 被賦值 `{}`，因此原來 `target'` 從原本指向 `{prop1: 123}` 改成指向剛剛創造出來的 `{}` 位置。\n\n結果就是 `myString` 和 `myObj` 依然指向原來的記憶體物件，而這些記憶體物件的內容都沒有被改變，改變的只有 `target` 和 `target'` 指向的記憶體位置而已\n\n## 存取資料的方法\n\n- 基本類型：傳值(pass by value)\n- 物件類型：傳址(pass by reference)、pass by sharing\n\n### 基本型別\n\n當一個變數被賦予基本型別的值時，整個值就會存在記憶體中。\n\n當複製基本型別的值到另一個變數時，只會複製他們的值，而該兩變數並不會影響到對方。\n\n這個情況稱作傳值。\n\n```javascript\nvar box1 = 10;\nvar box2 = \"hello\";\n\n//拷貝box1,box2的值\nvar boxA = box1;\nvar boxB = box2;\n\nboxA = 30;\nboxB = \"goodbye\";\n\nconsole.log(box1, box2, boxA, boxB); // 10,\"hello\",30,\"goodbye\"\n```\n\n一開始 boxA 和 boxB 只是各自複製了 box1 和 box2 的值，boxA 和 box1，以及 boxB 和 box2 是沒有關係的，所以當要重新賦值給 boxA. boxB 時，box1, box2 不會受到影響。\n\n### 物件型別\n\n當變數被賦予是物件型別的資料時，記憶體會被存放該物件在記憶體中的位置，並引用該地址來指向該物件。\n\n當複製一個物件到另一個變數時，複製的是該物件的地址，若此物件有被修改，所有引用該物件的變數，值都會被修改\n\n```javascript\nvar user = {\n  name: \"Mary\",\n  age: 30,\n};\n\n//拷貝user物件的地址\nvar userCopy = user;\nuserCopy.age = 20;\n\nconsole.log(user); // {name: 'Mary', age:20}\nconsole.log(userCopy); // {name: 'Mary', age:20}\nconsole.log(user === userCopy); // true\n```\n\n但若將變數重新賦予一個新變數\n\n```javascript\nvar user = {\n  name: \"Mary\",\n  age: 30,\n};\n\nvar userCopy = user;\n\nuserCopy = {\n  name: \"Mary\",\n  age: 20,\n};\n\nconsole.log(user); // {name: Mary\", age: \"30\"}\nconsole.log(userCopy); // {name: Mary\", age: \"20\"}\nconsole.log(user === userCopy); // false\n```\n\n當一個變數被重新賦予一個新的物件，並非修改該物件，因此地址整個變了，並指向另一個新的物件。\n\n### 把基本型別當作參數傳入函式\n\n當我們把基本型別當作參數傳入函式時，函式的參數會複製那些基本型別的值，所以在函式外的變數並不會被影響。\n\n```javascript\nvar box1 = 100;\nvar box2 = 200;\n\nfunction add(a, b) {\n  a = 10;\n  b = 20;\n}\n\nadd(box1, box2);\nconsole.log(box1, box2); //100,200\n```\n\n以上例子中，像之前提及的傳值概念一樣，a 和 b 複製了 box1, box2 的值。即使修改 a 和 b，box1, box2 都不會被修改。\n\n### Function\n\n> 可以將 javascript 的 function 看做是可執行的物件，其有兩大特性：\n>\n> 是 first-class Object\n> 有自己的 Scope\n\n#### First-class Object\n\n對物件型別能做的事情，也能對 function 做\n\n- 將 function 自由指派給變數或屬性\n\n  ```javascript\n  function myFunction() {\n    console.log(\"This is myFunction\");\n  }\n  var a = myFunction,\n    myObj = { fn: myFunction };\n  console.log(a); // f myFunction() { console.log('This is  myFunction'); }\n  console.log(myObj.fn); // f myFunction() { console.log('This is  myFunction'); }\n  a(); // \"This is myFunction\"\n  myObj.fn(); // \"This is myFunction\"\n  ```\n\n  function 可以自由指派給其他參數，當印出 `a`/`myObj.fn` 時，會 log 整個 `myFunction` 的內容。此時變數/屬性的內容是 `myFunction`，因此當加上 `()`，就會執行 function。\n\n- 為 function 加上屬性\n\n  ```javascript\n  function myFunction() {\n    console.log(\"This is myFunction\");\n  }\n  myFunction.prop1 = \"This is prop1\";\n  console.log(myFunction.prop1); // \"This is prop1\"\n  myFunction(); // \"This is myFunction\"\n  ```\n\n- 當作 Expression 使用\n  `function` 可以搭配各種運算元用，甚至也可以放在 if 中判斷\n\n  if 判斷的是 `function` 是否被正式宣告，未加上 `()` 時，`function` 不會被執行\n\n  ```javascript\n  function myFunction() {\n    console.log(\"This is myFunction\");\n  }\n  console.log(!myFunction); // false\n  ```\n\n- 可以在任何地方宣告\n  和物件一樣，可以在任何地方宣告，也可以在 function 中宣告一個 function，甚至在傳入參數時宣告\n\n  ```javascript\n  function myFunction(callback) {\n    console.log(\"This is myFunction\"); // This is myFunction\n    callback(); // This is myCallback\n    function myInnerFunction() {\n      console.log(\"This is myInnerFunction\");\n    }\n    myInnerFunction(); // This is myInnerFunction\n  }\n  myFunction(function myCallback() {\n    console.log(\"This is myCallback\");\n  });\n  ```\n\n#### 宣告 function\n\n宣告的方法主要有三種：\n\n- function declaration\n\n  ```javascript\n  function myFunction() {\n    console.log(\"Function declared with Function declaration\");\n  }\n  ```\n\n- function expression\n  function 可以被傳遞給其他參數儲存。如字面值一般， function 也可以在定義的同時賦予變數。\n\n  ```javascript\n  var myFunction = function NamedFunction() {\n    console.log(\"Function declared with Function expression\");\n  };\n  myFunction(); // \"Function declared with Function expression\"\n  ```\n\n  也因為此宣告方式會將 function 傳遞給一個變數，因此 javascript 允許 function 搭配匿名函式使用：\n\n  ```javascript\n  var myFunction = function () {\n    console.log(\"Function declared with Function expression\");\n  };\n  myFunction(); // \"Function declared with Function expression\"\n  ```\n\n- with function constructor\n  和其他的內建物件型別相同，function 也可以利用 new 來新增物件\n\n  ```javascript\n  var myFunction = new Function(\n    \"parameter1\",\n    \"parameter2\",\n    \"console.log('Function declared with Function Constructor')\"\n  );\n  myFunction(); // Function declared with Function Constructor\n  ```\n\n  若用 function expression 也有相同效果\n\n  ```javascript\n  var myFunction = function (parameter1, parameter2) {\n    console.log(\"Function declared with Function expression\");\n  };\n  myFunction(); // \"Function declared with Function expression\"\n  ```\n\n  因此一般而言會使用 function expression 取代 new 來增加易讀性與效能\n\n#### 呼叫 function\n\n- 一般呼叫\n  在 function 後面加上 `()` 就可以呼叫 function\n\n  ```javascript\n  myFunction();\n  ```\n\n- 使用 function 內建函式呼叫\n  function 中有內建 `call` 和 `apply` 函式可以用來呼叫 function\n  和使用 `()` 來執行 function 的差別在於內建函式具有明確指定 this 的功能。\n\n  ```javascript\n  var myFunction = function (parameter1, parameter2) {\n    console.log(parameter1, parameter2);\n  };\n  myFunction.call(null, \"hello world\", 123); // \"hello world\" 123\n  myFunction.apply(null, [\"hello world\", 123]); // \"hello world\" 123\n  ```\n\n  `call` 和 `apply` 函式的差異在於 apply 的第二個參數為陣列，裡面帶要傳入 `function` 的參數，因此在範例中可以看到 `apply` 的第二個參數為 `['hello world', 123]`，這兩個參數會被攤開為 `parameter1` 和 `parameter2` 後放入 `myFunction` 中執行\n\n- 使用 new 呼叫\n  使用 new 代表 function 當作建構式來使用，會回傳子行別為該 function 的物件\n\n  ```javascript\n  function myFunction() {\n    console.log(\"Function declared with Function expression\");\n  }\n  var a = new myFunction(); // \"Function declared with Function expression\"\n  console.log(a); // myFunction {}\n  ```\n\n#### IIFF 立即函式\n\n> (Immediately Invoked Function Expression) 或稱自我調用函式\n>\n> 是一種在定義後立即執行的函式表達式\n\nIIFE 有兩種特性：\n\n- 當程式執行到 IIFE 的宣告位置時，IIFE 會自動執行\n- 為一種 function expression\n\n```javascript\n// 格式\n(function () {\n  // some codes\n})();\n\n// 實際範例\n(function () {\n  console.log(\"This is IIFE\"); // \"This is IIFE\"\n})();\n```\n\n不需要額外呼叫就會自己執行，重點除了包裹 function 的 `()` 外，還有用來呼叫 function 的 `()`。\n\n若未加上最後面呼叫 function 的 `()`，此 function 便不會自動執行。\n\nIIFE 回傳值\n\n```javascript\nvar myString = (function () {\n  return \"This is IIFE\";\n})();\nconsole.log(myString); // This is IIFE\n```\n\nIIFE 除了會自動執行以外，與一般 function 的特性都是一模一樣的。\n\n使用 IIFE 的原因：\n\n1. 作用域隔離：IIFE 可以創建一個新的作用域，防止變數污染全域作用域。避免變數名稱衝突或保護敏感資訊。\n\n   ```js\n   (function () {\n     //在這個作用域可以用區域變數\n     var localVar = \"這是區域變數\";\n   })();\n\n   // localVar 在這裡為未定義\n   ```\n\n2. 模組化：IIFE 可以用於創建模組，將程式碼組織成可重複使用且相對獨立的片段。這有助於提高程式碼的可讀性與維護性。\n\n   ```js\n   var 模組 = (function () {\n     // 私有變數或函式\n     var privateVar = \"私有變數\";\n\n     // 返回一個公共接口\n     return {\n       getPrivateVar: function () {\n         return privateVar;\n       },\n     };\n   })();\n\n   console.log(模組.getPrivateVar(); // 可以訪問模組的公共接口\n   ```\n\n3. 防止變數提升：IIFE 可以有效防止變數提升(hoisting)，確保函式內部聲明的變數不會污染外部作用域。\n\n   ```js\n   (function () {\n     const localVar = \"這是區域變數\";\n     console.log(localVar); // 正確顯示區域變數的值\n   })();\n\n   console.log(localVar); // 未定義\n   ```\n\n   **ES6 的`const`和`let`，取代立即函式避免汙染全域的優點**\n\n#### Scope 作用域\n\n> Scope: 規範哪些變數在哪些程式碼中可以取用的規則\n>\n> javascript 和大多數的語言都是採用 Lexical Scope(語彙範疇)\n\n- Lexical Scope 語彙範疇\n\n  代表著區塊間的包裹關係，被包裹在內層的區塊可以保護自己的變數不被外層取用；相反的，外層區域的變數還是可以被內層區塊使用\n\n  ```javascript\n  var outer = \"From Outer\";\n  function myFunction() {\n    var inner = \"From Inner\";\n    console.log(outer); // \"From Outer\"\n    console.log(inner); // \"From Inner\"\n  }\n  console.log(outer); // \"From Outer\"\n  console.log(inner); // Uncaught ReferenceError: inner is not defined\n  ```\n\n  在 function 的 `{}` 區塊中宣告一個新的變數 `inner`，此一變數可以在 `myFunction(){}` 的區塊裡被取用，然而當 `myFunction(){}` 區塊外試圖取用 `inner` 時，就會發生 `innerVar is not defined` 的錯誤。\n\n- 參數也屬於內層 scope\n\n  ```javascript\n  var myString = \"hello world\";\n  function setAsLiteralObj(target) {\n    target = {};\n  }\n  setAsLiteralObj(myString);\n  console.log(myString); // 'hello world'\n  console.log(target); // Uncaught ReferenceError: target is not defined\n  ```\n\n  執行 `setAsLiteralObj(myString);` 時，`myString` 會將記憶體位置指派給 `function` 中新的參數 `target`，也就是 `target` 是再執行 `setAsLiteralObj` 時才建立的新參數，新參數 `target` 是屬於 `setAsLiteralObj` 這個 `function` 區塊，因此在外層印 `target` 時，一樣會得到錯誤訊息。\n\n- 巢狀 scope\n\n  ```javascript\n  var outer = \"outer\";\n  function myFunction() {\n    // --- 內層 ---\n    var middle = \"middle\";\n    function myInnerFunction() {\n      // ~~~ 最內層 ~~~\n      var inner = \"inner\";\n      // ~~~ 最內層 ~~~\n    }\n    myInnerFunction();\n    // --- 內層 ---\n  }\n\n  myFunction();\n  ```\n\n## 運算式與運算子\n\n### 嚴謹模式\n\n- 宣告在主程式開頭：Global Scope，所有的程式都會在嚴謹模式下執行。\n- 宣告在函數開頭：Function Scope，只有該函數內的程式會在嚴謹模式下執行。\n\n```javascript\nvar chang = 100; // 將變數chang改成99\nchag = 99; // 拼錯字\nconsole.log(chang); // 100\n\n(\"use strict\");\nvar chang = 100;\nchag = 99; // // ReferenceError: chag is not defined\n```\n\n- 嚴謹模式需要明確的宣告，未明確宣告`this`也會失效，這樣比較不會因為拼錯字而產生污染\n- 在非嚴謹模式下如果沒有用 var 宣告變數，而直接賦值，會直接將此變數作宣告\n- 嚴謹模式下並不會幫你執行，程式完全不跑\n\n### 賦值運算子\n\n- 賦值\n- 賦予左方運算元與右方運算元相同之值。`x = y` 會把`y`的值賦予給`x`。\n\n```javascript\nx = y;\n```\n\n- 加法賦值\n\n```javascript\nx += y;\nx = x + y;\n```\n\n- 減法賦值\n\n```javascript\nx -= y;\nx = x - y;\n```\n\n### 比較運算子\n\n`==`：等於\n\n`!=`：不等於\n\n- 如果運算元相同型別，就使用嚴格比較去檢驗。\n- null 跟 undefined 相同。\n- 運算元一個是數值，一個是字串，會將字串轉數字，再進行比較。\n- 其中一個是 true 或 false 會轉成數字的 1 或 0，再進行比較。\n- 其中一個是物件，另一個是字串或數值，物件會先轉成基型值，再進行比較。\n\n`===`：嚴格等於\n\n`!==`：嚴格不等於\n\n- 先判斷運算元的型別是否相同，若不相同，結果為 false。\n- null 與 undefined 都跟自己相等。\n- true 與 false 都跟自己相等。\n- NaN 不等於任何值，包括自己。\n- 只要是 number 型別的值一樣，他們就相等。\n- 0 跟-0 相等。\n- string 長度跟內容不一樣，包括空白，它們就不相等。\n- 如果參考至同一個物件、陣列、函式，相同的記憶體位置，他們就相等，若無，就算內容的值一樣，它們也不相等，不同的記憶體位置存相同的值。\n\n```javascript\nconsole.log(\"1\" === 1); //false\nconsole.log(null === null); //true\nconsole.log(undefined === undefined); //true\nconsole.log(null === undefined); //false\nconsole.log(NaN === NaN); //false\nconsole.log(NaN !== NaN); //true\nconsole.log(\"ABC\" === \"ABC \"); //false\n```\n\n`>`：大於\n\n`>=`：大於等於\n\n`<`：小於\n\n`<=`：小於等於\n\n注意：`=>`不是運算子，是箭頭函式。\n\n### 算數運算子\n\n- `%` 回傳兩個運算元相除後的餘數。\n\n```javascript\ncount = 12 % 5;\nconsole.log(count); // 回傳 2\n```\n\n- `++` 將運算元增加 1。\n\n```javascript\nx = 3;\nx++;\nconsole.log(x); // 回傳4，設定之後回傳\n\n++x;\nconsole.log(x); // 回傳3，回傳之後再設定\n```\n\n- `--` 將運算元減少 1。\n\n```javascript\nx = 3;\nx--;\nconsole.log(x); // 回傳2，設定之後回傳\n\n--x;\nconsole.log(x); // 回傳3，回傳之後再設定\n```\n\n### 邏輯運算子\n\n- `&&` // `and` 前後全部為 `true` ，才會是 `true`，否則都返回 `false`\n- `||` // `or` 前後只要一個是 `true` 就會返回 `true`，除非全部都是 `false`\n- `!` // `not` 將後面的值做反向，如果是 `true` 就返回 `false`，如果是 `false` 就返回 `true`\n- `!!` // `true`反轉再反轉，返回原本的布林值。\n  大多用在轉換一些可以形成布林值的情況。\n  而經過`!!`運算後，只會很單純出現`true` or `false`，可以單純化減少某些特殊情況出錯的機率。\n  例如：希望\"空字串\"和`null`被視為完全相同時\n\n  ```javascript\n  const a = \"\";\n  const b = null;\n\n  a === b; // false\n  !!a === !!b; // true\n  ```\n\n- 短路邏輯(短路解析)\n  Javascript 裡面只要是 `0`、`\"\"`、`null`、`false`、`undefined`、`NaN` 都會被判定為 `false`\n\n  - 用 || 來設定變數預設值\n    如果 obj 存在的話就維持原樣，如果不存在就給予空物件\n\n    ```javascript\n    if (!obj) {\n      obj = {};\n    }\n\n    //短路邏輯的寫法\n    var obj = obj || {};\n    ```\n\n  - 用 && 來檢查物件與屬性值\n\n    ```javascript\n    var name = o && o.getName();\n    ```\n\n  - 用 || 來簡化程式碼\n\n    ```javascript\n    if (!obj) {\n      call_function();\n    }\n    obj || call_function();\n    ```\n\n  - 用 && 來簡化程式碼\n\n    ```javascript\n    var a = 1;\n    if (a == 1) {\n      alert(\"a=1\");\n    }\n    a == 1 && alert(\"a=1\");\n    ```\n\n  - 用 && 、|| 來簡化程式碼\n\n    ```javascript\n    var a = 3,\n      b;\n    if (a == 3) {\n      b = 1;\n    } else if (a == 5) {\n      b = 2;\n    } else {\n      b = 3;\n    }\n    b = (a == 3 && 1) || (a == 5 && 2) || 3;\n    ```\n\n  - 善用 ! 的轉換\n\n    ```javascript\n    if (obj !== \"null\" && obj !== \"undefined\") {\n      //....\n    }\n    if (!!obj) {\n      //....\n    }\n    ```\n\n### 其餘運算子與展開運算子\n\n- 其餘運算子\n\n  假設要將一個陣列的值相加後取平均\n\n  ```javascript\n  let arr = [1, 2, 3, 4, 5];\n\n  let avg = function (arr) {\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      sum += arr[i];\n    }\n    return sum / arr.length;\n  };\n\n  console.log(avg(arr)); //  3\n  ```\n\n  但若呼叫 function 時，不是傳入陣列，而是傳入多個參數\n\n  最後得到的結果會是 NaN\n\n  ```javascript\n  let avg = function (arr) {\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      sum += arr[i];\n    }\n    return sum / arr.length;\n  };\n\n  console.log(avg(1, 3, 5, 7, 9)); // NaN\n  ```\n\n  運用其餘運算子`...`，將輸入函式中的參數值變成陣列的形式\n\n  ```javascript\n  let avg = function (...arr) {\n    console.log(arr); // [1,3,5,7,9]\n    let sum = 0;\n    for (let i = 0; i < arr.length; i++) {\n      sum += arr[i];\n    }\n    return sum / arr.length;\n  };\n\n  console.log(avg(1, 3, 5, 7, 9)); // 5\n  ```\n\n- 展開運算子 `...`\n\n  關鍵字與其餘運算子相同，但功能與其餘運算子相反，展開運算子可以把陣列中的元素取出。\n\n  假設要用 `Math.max()` 來找出最大值，但傳入的參數為陣列，此時會得到 NaN\n\n  ```javascript\n  let number = [1, 2, 3, 4, 5, 6, 7, 8];\n\n  console.log(Math.max(number)); // NaN\n  ```\n\n  運用展開運算子將陣列展開成許多數值\n\n  ```javascript\n  let number = [1, 2, 3, 4, 5];\n\n  console.log(Math.max(...number)); // 5\n\n  console.log(...number); // 1,2,3,4,5\n  ```\n\n### 三元運算式\n\n```javascript\ncondition ? val1 : val2;\n```\n\n- 如果條件為 true ，此時回傳[數值 / 運算式（1）]\n- 如果條件為 false，此時回傳[數值 / 運算式（2）]\n\n```javascript\nvar status = \"\";\nif (a < 60) {\n  status = \"不及格\";\n} else {\n  status = \"及格\";\n}\n\n// 三元運算式\nvar status = a < 60 ? \"不及格\" : \"及格\";\n```\n\n### if else\n\n```javascript\nif (A) {\n  //  A = True 執行這邊\n} else if (B) {\n  //  A = False and B = True 執行這邊\n} else {\n  //  A = False and B = False 執行這邊\n}\n```\n\n- 判斷式括號裡會強制轉成布林值\n- `null` 跟 `undefined` 和 `NaN` 在 if 判斷時值都會轉換為 `false`\n\n## 流程判斷與迴圈\n\n### switch\n\n```javascript\nswitch (expression) {\n  // expression => 表達式，用來跟每個case做比較\n  case value1:\n    //當 表達式 的值符合 value1\n    //要執行的陳述句\n    break;\n  case value2:\n    //當 表達式 的值符合 value2\n    //要執行的陳述句\n    break;\n  default:\n    //當 表達式 的值都不符合上述條件\n    //要執行的陳述句\n    break;\n}\n```\n\n- 如果忘記放 break，則當下的 case 執行完之後，會直接往下一個 case 執行，直到遇見 break\n\n```javascript\nswitch (表達式) {\n  case x:\n  case y:\n  case z:\n    //如果有多項條件，要執行同一陳述句可以合併撰寫\n    // code block\n    break;\n  case a:\n  case b:\n  case c:\n    // code block\n    break;\n}\n```\n\n### while 迴圈\n\n```javascript\nwhile (condition) {\n  陳述句; // 當 condition 為 true，就重複做\"陳述句\"\n  break; // 遇到 break 就會停止，否則就會繼續執行，直到 condition 為 false\n}\n```\n\n- 完成之後再回去檢查 `condition`\n- 直到 `condition`不成立，才會離開\n\n```javascript\ndo {\n  // 放要重複做的事情，會先執行一次再進入判斷\n} while (condition);\n```\n\n### for 迴圈\n\n```javascript\nfor (var i = 0; i < 10; i++) {\n  // 要被執行的陳述句\n  // for迴圈會產生出從\"i = 0\"開始到\"i < 10\"的長度\n  // 可以當作計數器，每數一次就執行一次陳述句\n}\n\n// for (statement 1; statement 2; statement 3){}\n// Statement 1 執行程式之前做一次\n// Statement 2 執行程式的條件\n// Statement 3 執行程式後每次執行\n\nfor (var i = 0; i < 10; i++) {\n  // 也可以在迴圈裡加入判斷式取\"i\"的值\n  if (i % 2 == 0) {\n    continue; //跳過這次不做\n  }\n  if (i == 7) {\n    break; //跳出整個for迴圈\n  }\n\n  console.log(i); // ans = \"1  3  5\" 7跟9已經跳出迴圈，所以不會被執行出\n}\n```\n\n### for of\n\n```javascript\nvar 物件 = [\"A\", \"B\", \"C\", \"D\"];\nfor (const 變數1 of 物件1) {\n  // 大多使用在陣列，或是其他需要查找物件的內容物\n}\n\nlet 字串 = \"ES6\"; //例如用來查找字串或數列等等\nfor (let 變數2 of 字串) {\n  console.log(變數2); // \"E\", \"S\", \"6\"\n}\n```\n\n### for in\n\n```javascript\nvar 物件2 = {\n  AA: 100,\n  BB: 20,\n};\nfor (變數3 in 物件2) {\n  //會逐一尋找物件裡的屬性\n  //且只顯示有值的資料出來\n  console.log(物件2); //此時出現的是物件裡的字串\n  console.log(物件2[變數3]); //此時出現的是物件裡的數值\n}\n\nvar 物件3 = [10, 20, 30];\n物件3[6] = 999; //這時物件3的陣列[10, 20, 30, nill]\n```\n\n## 函式 function\n\n> function 是物件的一種\n\n### 定義函式\n\n- 函式宣告\n\n  ```javascript\n  function name(params) {\n    // do some things\n  }\n  ```\n\n- 函式運算式\n\n  透過匿名函式將變數賦值\n\n  ```javascript\n  var square = function (params) {\n    return params;\n  };\n  ```\n\n  若在 function 加上名稱時，這個名稱只在\"自己函式的區塊內有效\"\n\n  ```javascript\n  var square = function func(number) {\n    console.log(typeof func); // \"function\"\n    return number * number;\n  };\n\n  console.log(typeof func); // undefined\n  ```\n\n- 透過 new 關鍵字建立函式\n\n```javascript\n// F 要大寫\nvar square = new Function(\"number\", \"return number * number\");\n```\n\n透過關鍵字建立的函式物件，每次執行時都會進行解析字串的動作(如：`'return number * number'`)\n\n### 箭頭函式\n\n```javascript\nfunction test(a) {\n  return a + 1; // 將物件、運算結果傳出到呼叫點\n}\n\nvar test = function (a) {\n  return a + 1;\n};\n\nvar test = (a) => {\n  return a + 1;\n};\n\nvar test = (a) => a + 1; //最終省略了function和return\n\nvar answer = test(5); //呼叫點，test(5)會將刮號內的參數傳到function的刮號(a)中\n```\n\n- 箭頭函式僅用於 function 內只有一條運算式時\n\n### Scope 變數的有效範圍\n\n> 全域變數和區域變數的差異\n\n```javascript\nvar x = 1;\n\nvar someThingHappened = function (y) {\n  var x = 100;\n  return x + y;\n};\n\nconsole.log(someThingHappened(50)); // 150\nconsole.log(x); // 1\n```\n\n切分變數有效範圍的最小單位是 `function`\n\n因此在 function 中透過 var 宣告的變數，其作用範圍僅限於這個函式。\n\n此例中在一開始宣告的變數 x 與在 function 內部宣告的變數 x 為兩個不同變數。\n\n若 function 中沒有宣告新變數，則會一層一層往外尋找，直到全域變數為止\n\n```javascript\nvar x = 1;\n\nvar doSomeThing = function (y) {\n  x = 100;\n  return x + y;\n};\n\nconsole.log(doSomeThing(50)); // 150\nconsole.log(x); // 100\n```\n\n此例中，function 中未宣告新變數 x，因此 javascript 向外層尋找同名的變數，直到最外層的全域變數，並將其賦值。\n\n### Hoisting 提升\n\n#### 變數提升\n\n當 Scope 中的變數有被宣告，即使在宣告之前即調用變數，javascript 會將先告的語法拉到此 scope 的上面\n\n```javascript\nvar x = 1;\n\nvar doSomeThing = function (y) {\n  console.log(x); // undefined\n\n  var x = 100;\n  return x + y;\n};\n\nconsole.log(doSomeThing(50)); // 150\nconsole.log(x); // 1\n```\n\n對編譯器而言此，這段程式碼會是這個樣子\n\n```javascript\nvar x = 1;\n\nvar doSomeThing = function (y) {\n  var x; // 宣告的語法被拉到上面\n  console.log(x); // undefined\n  x = 100;\n  return x + y;\n};\n\nconsole.log(doSomeThing(50)); // 150\nconsole.log(x); // 1\n```\n\n#### 函式提升\n\n透過\"函式宣告\"方式定義的函式可以在宣告前使用\n\n```javascript\nsquare(2); // 4\n\nfunction square(number) {\n  return number * number;\n}\n```\n\n而透過\"函式運算式\"定義的函式則是會出現錯誤\n\n```javascript\nsquare(2); // TypeError: square is not a function\n\nvar square = function (number) {\n  return number * number;\n};\n```\n\n除呼叫時機不同，此兩者在執行時無明顯差異\n\n#### 為何會有 Hoisting 的現象？\n\n> javascript 中的 Compiler(編譯器) 和 Engine (引擎) 執行的順序，造成提升的特性\n\n- 變數宣告屬於 compiler 的工作\n  javascript compiler 會將程式碼解析成有意義的語法結構，轉換成機器可以理解的目的碼。接著 compiler 會建立所有的變數，保留其記憶體空間，並且繫結到所屬的 scope 上面。也就是說，程式開始一行一行執行前，會先將所有變數宣告好。\n\n- 初始化、賦值屬於 engine 的工作\n  在 compiler 好之後，engine 才會開始一行一行的執行程式，也就是初始化、賦值的這個動作也是由 engine 在編譯好之後，等待被執行的程式碼之一。\n\n#### 最佳實踐\n\n1. 宣告變數應集中在燈前 scope 的最上面\n\n### 全域變數\n\n其實在 javascript 中並無所謂\"全域變數\"，所謂全域變數指的是\"全域物件\"(亦稱作\"頂層物件\")的屬性。\n\n以瀏覽器而言，全域物件指的是 `window`，在 node 的環境中則叫做 `global`。\n\n- 全域物件的屬性\n\n  於外層透過 var 宣告一個變數 a，當我們調用 `window.a` 會回傳我們宣告的此一變數\n\n  ```javascript\n  var a = 10;\n  console.log(a); // 10\n  ```\n\n- 變數的作用範圍，最小的的切分單位為 function\n- 即使是寫在函式中，沒有 var 宣告的變數，會變成全域變數\n- 全域變數指的是全域物件(頂層物件)的屬性\n\n> ### 附註\n>\n> 在 javascript ES6 之後有新的宣告方法 let 與 const，分別定義\"變數\"與\"常數\"\n> 和 var 不同的是，他們的作用區域是透過大括號`{}`來切分的\n\n## Promise\n\n當 javascript 在執行時，會將非同步操作留到最後進行處理。\n\n非同步操作如：文件操作、資料庫操作、AJAX 及定時器等等。\n\njavascript 基本實現非同步的方式：\n\n- 回調函示 callback function\n  當需要執行多個非同步操作時，程式碼會不斷的往內嵌套，又被稱做 callback 地獄(callback hell)\n\n  ```js\n  callback(() => {\n    console.log(\"Hello!\");\n    callback(() => {\n      console.log(\"Hello!\");\n      callback(() => {\n        console.log(\"Hello!\");\n        callback(() => {\n          console.log(\"Hello!\");\n        }, 200);\n      }, 200);\n    }, 200);\n  }, 200);\n  ```\n\n### 如何使用 Promise\n\n> 用來表示一個非同步操作的最終完成(或失敗)及其結果值\n\nPromise 為一個構造函示，透過 new 關鍵字建立一個 promise。其會接收一個函示作為參數，此函示又稱為 executor，executor 會立即執行。\n\n```js\nnew Promise((resolve, reject) => {\n  console.log(\"即刻執行\");\n});\n```\n\n而此 executor 會再接受另外兩個函示參數：\n\n- resolve 實現函數：當請求完成，成功時會調用 resolve，並回傳結果。\n- reject 拒絕函數：當請求完成，失敗時會調用。\n\n```js\nfunction requestData(url) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (url === \"example.com\") {\n        resolve(\"hello welcome to example.com\");\n      } else {\n        reject(\"it is not example.com\");\n      }\n    }, 3000);\n  });\n}\n\n// 1. 請求成功\nrequestData(\"example.com\").then((res) => {\n  console.log(res); //hello welcome to example.com\n});\n\n// 2. 請求失敗\nrequestData(\"example.com.com\").catch((e) => console.log(e)); //it is not example.com\n```\n\n### 狀態\n\nPromise 狀態有三種\n\n- pending 初始狀態，已執行 executor，但還在等待中。\n- fulfilled 表示操作完成，執行 resolve 函式。\n- rejected 表示操作失敗，執行 reject 函式。\n\n### then 的使用\n\n1. 多次調用\n   promise 可以用鏈式(chaining)的方式串連多個非同步操作\n\n   ```js\n   function requestData(url) {\n     return new Promise((resolve, reject) => {\n       setTimeout(() => {\n         if (url === \"example.com\") {\n           resolve(\"hello welcome to example.com\");\n         } else {\n           reject(\"it is not example.com\");\n         }\n       }, 3000);\n     });\n   }\n\n   requestData(\"example.com\")\n     .then((res) => {\n       console.log(res);\n       // 印出 executor 執行的結果 => hello welcome to example.com\n       return 1;\n     })\n     .then((res) => {\n       console.log(res); // 印出前面執行結束後回傳的值 => 1\n       return 2;\n     })\n     .then((res) => {\n       console.log(res); // 印出前面執行結束後回傳的值 => 2\n     });\n   ```\n\n2. 傳入兩個參數，一是成功的回調，二是失敗的回調\n\n   ```js\n   function requestData(url) {\n     return new Promise((resolve, reject) => {\n       setTimeout(() => {\n         if (url === \"example.com\") {\n           resolve(\"hello welcome to example\");\n         } else {\n           reject(\"it is not example\");\n         }\n       }, 0);\n     });\n   }\n\n   requestData(\"example.com\").then(\n     (res) => {\n       console.log(res);\n     },\n     (reason) => {\n       console.log(reason); // 錯誤，回傳 => it is not example\n     }\n   );\n   ```\n\n### 錯誤處理\n\nPromise 的錯誤處理，只需要加上 catch 捕捉錯誤，並執行一些錯誤處理代碼。當請求失敗時，catch 方法將捕獲錯誤，並輸出錯誤訊息。\n\n```js\nfetch(\"https://explainthis.com/data\")\n  .then((response) => response.json())\n  .then((data) => {\n    console.log(data);\n  })\n  .catch((error) => {\n    console.error(\"oops!\", error); // 捕獲錯誤，輸出錯誤訊息\n  })\n  .finally(() => {\n    console.log(\"close loader\"); // 操作完成，輸出 => close loader\n  });\n```\n\n### finally\n\n若有加上 `finally`，當 Promise 完成後，無論狀態為 fulfilled 或是 rejected 都會進入 finally 方法。\n\n### async/await 同步操作\n\n首先使用 async 關鍵字將函式標記為非同步函式，也就是指返回值為 Promise 物件的函式。\n\n在非同步函式中，可以調用其他非同步函式，並使用 await 語法，await 會等待 Promise 完成之後返回最終的結果。\n\n```js\nasync function getData() {\n  const res = await fetch(\"https://getsomedata\");\n  const data = await res.json();\n  console.log(data);\n}\n\ngetData();\n```\n\n## document\n\n### `createdElement()` 建立節點\n\n例如在文件中新增一個 `<em>` 標籤\n\n```javascript\nvar str = document.createElement(\"em\"); //新增 em 標籤\nstr.textContent = \"新增文字\";\n```\n\n### `appendChild()` 增加子節點\n\n在 html 中，新增一個 `<div>`\n\n```html\n<div class=\"title\">title</div>\n```\n\n增加子節點\n\n```javascript\ndocument.querySelector(\".title\").appendChild(str);\n```\n\n最終 html 上面顯示：\n\n```html\n<div class=\"title\">\n  title\n  <em class=\"red\">新增文字</em>\n</div>\n```\n\n### `.querySelector` 元素選擇器\n\n用法和 css 一樣，選取 id 元素時用 `#`，選取 class 元素時用 `.`\n\n```javascript\ndocument.querySelector(\".title\");\n```\n\n### `.querySelectorAll` 選取所有指定元素\n\n用法和 `.querySelector()` 一樣，但不同於 `.querySelector()`，`.querySelectorAll()` 可以一次選取所有具有相同元素的內容\n\n### `setAttribute()` 增加標籤屬性\n\n透過 javascript 來增加 HTML 標籤屬性，例如要動態加上一個 a 標籤連結\n\n```html\n<div class=\"titleClass\">\n  <a href=\"#\">Link</a>\n</div>\n<script src=\"js/practice1.js\"></script>\n```\n\n```javascript\nconst el = document.querySelector(\".titleClass\"); //選擇單一元素為 HTML 裡的 class 名稱為 titleClass\nel.setAttribute(\"href\", \"www.facebook.com\"); //前面是屬性，後面是內容\n```\n\n動態新增 id 來操控 HTML\n\n```html\n<div class=\"str\">title</div>\n<script src=\"js/practice1.js\"></script>\n```\n\n```css\n#strId {\n  color: blue;\n  font-size: 18px;\n}\n```\n\n```javascript\nvar elStr = document.querySelector(\".str\"); //選擇單一元素為 HTML 的 class 名稱為 str\nelStr.setAttribute(\"id\", \"strId\"); //因為在 CSS 有動態新增一個 id，所以選擇新增的 id 屬性來控制他的值(會帶回 CSS 的設定內容)\n```\n\n### 移除 HTML 元素\n\n#### 使用 CSS 隱藏元素\n\n```javascript\nvar elem = document.querySelector(\"#some-element\");\nelem.style.display = \"none\";\n```\n\n#### `removeChild()` 從 DOM 中完全移除元素\n\n```javascript\nvar elem = document.querySelector(\"#some-element\");\nelem.parentNode.removeChild(elem);\n```\n\n### `remove()` ES6 新方法\n\n```javascript\nvar elem = document.querySelector(\"#some-element\");\nelem.remove();\n```\n\n### `addEventListener()` 事件監聽\n\n- `element.addEventListener(event, function, useCapture)`\n  - `event` 必須，指定事件名稱\n  - `function` 必須，指定事件觸發時執行的事件處理器(handler)\n  - `useCapture` 可選，指定事件是否在事件冒泡(bubble phase)或事件捕獲(capture phase)流程階段執行。\n    - `true` 捕獲階段執行\n    - `false` 預設，冒泡階段執行\n\n可以針對某事件，綁定多個處理器\n\n```js\nvar btn = document.getElementById(\"btn\");\n\nbtn.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"HI\");\n  },\n  false\n);\n\nbtn.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"HELLO\");\n  },\n  false\n);\n```\n\n### `removeEventListener()` 取消事件監聽\n\n- `element.removeEventListener(event, function, useCapture)`\n  - `event` 必須，指定事件名稱\n  - `function` 必須，指定事件觸發時執行的事件處理器(handler)\n  - `useCapture` 可選，指定事件是否在事件冒泡(bubble phase)或事件捕獲(capture phase)流程階段執行。\n    - `true` 捕獲階段執行\n    - `false` 預設，冒泡階段執行\n\n需注意，由於 `addEventListener()` 可以同時針對某事件綁定多個 `handler`，所以透過 `removeEventListener()`解除事件時，第二個參數的 `handler` 必須和先前在 `addEventListener()` 綁定的 `handler` 為同一個實體。\n\n```js\nvar btn = document.getElementById(\"btn\");\n\nbtn.addEventListener(\n  \"click\",\n  function () {\n    console.log(\"HI\");\n  },\n  false\n);\n\n// 移除事件，但是沒用\nbtn.removeEventListener(\n  \"click\",\n  function () {\n    console.log(\"HI\");\n  },\n  false\n);\n```\n\n## Math\n\n### `Math.round` 四捨五入\n\n```javascript\nMath.round(3.14); // 3\nMath.round(5.49999); // 5\nMath.round(5.5); // 6\nMath.round(\"5.50001\"); // 6\nMath.round(-5.49999); // -5\nMath.round(-5.5); // -5\nMath.round(-5.50001); // -6\n\nlet data = 18.62645;\nMath.round(data * 10) / 10; // 18.6\nMath.round(data * 100) / 100; // 18.63\nMath.round(data * 1000) / 1000; // 18.626\n```\n\n## 物件取值、新增與刪除\n\n### 物件取值\n\n```javascript\nvar family = {\n  name: \"ma's family\",\n  deposit: 1000,\n  members: {\n    mother: \"mom\",\n    father: \"dad\",\n  },\n};\n\nconsole.log(family.name); // ma's family\nconsole.log(family.members.mother); // mom\nconsole.log(family[\"name\"]); // ma's family\n```\n\n用中括號語法，允許以變數的方式取值\n\n```javascript\nvar family = {\n  name: \"ma's family\",\n  deposit: 1000,\n  members: {\n    mother: \"mom\",\n    father: \"dad\",\n  },\n};\nvar a = \"name\";\n\nconsole.log(family.a); // undefine\nconsole.log(family[a]); // ma's family\n```\n\n`.` 語法是直接以字串的方式尋找該物件的屬性，而 family 物件並無 a 屬性。\n但中括號中的語法是將變數 a 的值帶入，相當於 `family['name']`。\n\n另外，在物件中的屬性一律是字串，因此可以允許各種數字或是特殊字元，但在 `.` 語法中，會受到許多限制。\n\n```javascript\nvar family = {\n  name: \"ma's family\",\n  deposit: 1000,\n  members: {\n    mother: \"mom\",\n    father: \"dad\"\n  },\n  1: '1',\n  '$-小名家': '$-小名家 string'\n};\n\nconsole.log(family.1) // 語法錯誤\nconsole.log(family[1]) // 1\n\nconsole.log(family.$-小名家) // 語法錯誤\nconsole.log(family['$-小名家']) // $-小名家 string\n```\n\n執行物件中的方法，也可以用點語法或是中括號\n\n```javascript\nvar family = {\n  name: \"ma's family\",\n  deposit: 1000,\n  members: {\n    mother: \"mom\",\n    father: \"dad\",\n  },\n  callFamily: function () {\n    console.log(\"call 2 ma's family\");\n  },\n};\n\nfamily.callFamily(); // call 2 ma's family\nfamily[\"callFamily\"](); // call 2 ma's family\n```\n\n### 物件轉為陣列\n\n陣列本身舉有許多好用的方法：`forEach`, `map`, `reduce`, `find`...，但物件無法使用這些陣列方法\n\n利用 `Object` 關鍵字，將物件轉為陣列。\n\n- Object.values 可以直接傳入一個物件，並將物件直接轉為陣列的形式，但無法取得 key 值。\n- Object.keys 傳入一個物件，並將其 key 值以陣列方式呈現，僅只取 key 值。\n- Object.entries 傳入物件，並同時回傳 key 值與 values，但產生的新結構，會另外用一層陣列組成。\n\n### 新增物件屬性\n\n```javascript\nvar family = {\n  name: \"ma's family\",\n  deposit: 1000,\n  members: {\n    mother: \"mom\",\n    father: \"dad\",\n  },\n  callFamily: function () {\n    console.log(\"call 2 ma's family\");\n  },\n};\n\nfamily.dog = \"小豬\";\nfamily[\"kitten\"] = \"K Ka貓\";\nfamily[\"$\"] = \"money\";\nconsole.log(family);\n```\n\n### 刪除物件屬性\n\n使用 `delete` 關鍵字\n\n```javascript\nvar family = {\n  name: \"ma's family\",\n  deposit: 1000,\n  members: {\n    mother: \"mom\",\n    father: \"dad\",\n  },\n  callFamily: function () {\n    console.log(\"call 2 ma's family\");\n  },\n};\n\nfamily.dog = \"小豬\";\nfamily[\"kitten\"] = \"K Ka貓\";\nfamily[\"$\"] = \"money\";\n\ndelete family.deposit;\ndelete family[\"$\"];\nconsole.log(family);\n```\n\n## SET 集合物件\n\nSet 物件可儲存任何類型的唯一值，意旨相同的內容不論輸入幾次，都只會有一個，不會重複出現。\n\n若希望陣列的元素不會重複，可以用 set，若希望物件的 key 不會重複，則可以使用 Map\n\n### 基本使用\n\n- add() 新增值到集合中\n\n  ```js\n  let nweSet = new Set();\n  newSet.add(1); // Set [1]\n  newSet.add(5); // Set [1,5]\n  newSet.add(5); // Set [1,5]\n\n  // 新增了兩次 5，但是不會重複出現在 Set 物件中。\n  ```\n\n- delete() 從集合中刪除值\n\n  ```js\n  let newSet = new Set();\n\n  newSet.add(1); // Set [1]\n  newSet.add(5); // Set [1,5]\n  newSet.delete(5); // Set [1]\n  ```\n\n- size() 取得集合中元素的數量\n\n  ```js\n  let newSet = new Set();\n\n  newSet.add(1); // Set [1]\n  newSet.add(5); // Set [1,5]\n  newSet.size(); // 2\n  ```\n\n- has() 檢查集合中視否存在指定值\n\n  ```js\n  let newSet = new Set();\n\n  newSet.add(1); // Set [1]\n  newSet.add(5); // Set [1,5]\n  newSet.has(5); // true\n  newSet.has(12); // false\n  ```\n\n- clear() 清除集合中所有東西\n\n  ```js\n  let newSet = new Set();\n\n  newSet.add(1); // Set [1]\n  newSet.add(5); // Set [1,5]\n  newSet.clear(); // Set []\n  ```\n\n- 加入物件\n\n  ```javascript\n  // new Set Type\n  let classroom = new Set(); //  建立教室這個 set\n  let Aaron = { name: \"Aaron\", country: \"Taiwan\" };\n  let Jack = { name: \"Jack\", country: \"USA\" };\n  let Johnson = { name: \"Johnson\", country: \"Korea\" };\n\n  // 把物件放入 set 中\n  classroom.add(Aaron);\n  classroom.add(Jack);\n  classroom.add(Johnson);\n\n  // 檢驗 set 中是否包含某物件\n  if (classroom.has(Aaron)) console.log(\"Aaron is in the classroom\");\n\n  //  把物件移除 set 中\n  classroom.delete(Jack);\n  console.log(classroom.size); //    看看 set 中有多少元素\n  console.log(classroom);\n  ```\n\n### 陣列與集合間轉換\n\n```javascript\n// 集合轉成陣列\nlet setToArray = [...classroom]; // Array.from(classroom)\n\n// 陣列轉成集合\nlet arrayToSet = new Set(setToArray);\n```\n\n### 過濾陣列中重複的元素\n\n利用 set 中元素不會重複的特性，來過濾掉陣列中重複的元素，留下唯一\n\n```javascript\nvar mySet = new Set();\n\nmySet.add(1); // Set { 1 }\nmySet.add(5); // Set { 1, 5 }\nmySet.add(\"some text\"); // Set { 1, 5, 'some text' }\nvar o = { a: 1, b: 2 };\nmySet.add(o); // Set { 1, 5, 'some text', { a: 1, b: 2 } }\n\n// // o is referencing a different object so this is okay\nmySet.add({ a: 1, b: 2 }); // Set { 1, 5, 'some text', { a: 1, b: 2 }, { a: 1, b: 2 } }\n```\n\n## Map 物件\n\nMap() 為一種資料結構，和方法 array.map() 不同。\n\n用法和 Set 大同小異，但 Map() 重視 key/value 兩者間操作的關係。\n\n- 建立 Map\n\n  ```js\n  let fruitMap = new Map();\n  // 在建立時給予初始值\n  let fruitMap = new Map([\n    [\"a\", \"apple\"],\n    [\"b\", \"banana\"],\n    [\"c\", \"cherry\"],\n  ]);\n  ```\n\n- set() 新增 key/value 到 Map 中\n\n  ```js\n  let fruitMap = new Map();\n  fruitMap.set(\"a\", \"apple\");\n  fruitMap.set(\"b\", \"banana\");\n  fruitMap.set(\"c\", \"cherry\");\n  ```\n\n- get() 取得 key 相對的 value\n\n  ```js\n  let fruitMap = new Map();\n  fruitMap.set(\"a\", \"apple\");\n  fruitMap.get(\"a\"); // apple\n  ```\n\n- delete() 從 Map 中刪除指定 key/value\n\n  ```js\n  let fruitMap = new Map();\n  fruitMap.set(\"a\", \"apple\");\n  fruitMap.set(\"b\", \"banana\");\n  fruitMap.set(\"c\", \"cherry\");\n  fruitMap.delete(\"c\"); // 刪除 key 為 c 的位置\n  ```\n\n- size() 取得 Map 中的數量\n\n  ```js\n  let fruitMap = new Map();\n  fruitMap.set(\"a\", \"apple\");\n  fruitMap.set(\"b\", \"banana\");\n  fruitMap.set(\"c\", \"cherry\");\n  fruitMap.size; // 3\n  ```\n\n- has() 檢查指定 key 是否存在。返回 boolean\n\n  ```js\n  let fruitMap = new Map();\n  fruitMap.set(\"a\", \"apple\");\n  fruitMap.set(\"b\", \"banana\");\n  fruitMap.set(\"c\", \"cherry\");\n  fruitMap.has(\"a\"); // true\n  fruitMap.has(\"f\"); // false\n  ```\n\n- clear() 清空 Map 所有東西\n\n  ```js\n  let fruitMap = new Map();\n  fruitMap.set(\"a\", \"apple\");\n  fruitMap.set(\"b\", \"banana\");\n  fruitMap.set(\"c\", \"cherry\");\n  fruitMap.clear(); // Map(0) {}\n  ```\n\n## JSON 轉換\n\n- json 為一組字串\n- 在使用 {} 建立物件時，屬性名稱的引號可以省略，但在 json 格式中，屬性名稱一定要有引號。\n- 若物件中的值為 function 時，無法透過 json 傳遞。\n\n### `JSON.stringify` 將物件轉為 json 字串\n\n可以將 javascript 任何物件或值轉換為 json 字串。\n\n- JSON.stringify(value, replacer, space)\n\n  - value 必須，任何需要轉換為字串的值\n  - replacer 可選，可以為函式或陣列，可用來替換字串中某些元素。\n\n    - 陣列用法\n\n      ```js\n      const me = {\n        name: \"ivan\",\n        age: 28,\n        gender: \"M\",\n      };\n\n      console.log(Json.stringify(me, [\"name\", \"age\"])); // {\"name\": \"ivan\", \"age\": 28}\n      ```\n\n    - 函式用法\n\n      ```js\n      function myReplacer(key, value) {\n        // 若 value 是字串\n        if (typeof value === \"number\") {\n          return undefined;\n        }\n\n        return value;\n      }\n\n      const me = {\n        name: \"ivan\",\n        age: 28,\n      };\n\n      console.log(JSON.stringify(me, myReplacer)); // {\"name\": \"ivan\"}\n      // 回傳結果已去除元素為數值的資料\n      ```\n\n  - space 可選，在輸出的字串中新增空格提高可讀性，可以為一個字串或數字。\n\n### `JSON.parse` 將 json 字串轉換為物件\n\n和 `JSON.stringify()` 相反，可以接收 JSON 字串並將其轉換為 物件或是值。\n\n- `JSON.parse(reviver)`\n\n  - reviver 過濾解析後的值。\n\n    ```js\n    const me = { name: \"John\", age: 18 };\n\n    console.log(\n      JSON.parse({ name: \"John\", age: 18 }, function (key, value) {\n        if (value == \"John\") {\n          return (value = \"ivan\");\n        }\n        return value;\n      })\n    );\n    // {name: 'ivan', age: 18}\n    ```\n\n## 轉換陣列為字串\n\n### toString()\n\n不僅適用於陣列，還適用於其他資料型別。幾乎任何東西都可以使用 `toString()` 轉換為字串。\n\n```js\nconst arr = [\"Google\", \"is\", \"no\", \"1\", \"search engine\"].toString();\nconsole.log(arr);\n```\n\n```output\n\"Google,is,no,1,search engine\"\n```\n\n### join()\n\n此方法將從陣列中取出每一個元素並一起形成一個字串。\n\n和 `toString()` 不同的是，可以直接傳遞分個符號，作為引數來分隔字串中的元素。\n\n```js\nconst arr_1 = [\"Google\", \"is\", \"no\", \"1\", \"search engine\"].join();\nconst arr_2 = [\"Google\", \"is\", \"no\", \"1\", \"search engine\"].join(\"-\");\nconst arr_3 = [\"Google\", \"is\", \"no\", \"1\", \"search engine\"].join(\"##space##\");\nconsole.log(arr_1);\nconsole.log(arr_2);\nconsole.log(arr_3);\n```\n\n```output\n\"Google,is,no,1,search engine\"\n\"Google-is-no-1-search engine\"\n\"Google##space##is##space##no##space##1##space##search engine\"\n```\n\n### 使用型別轉換\n\njavascript 中有兩種型別強制轉換：隱式強制、顯式強制。\n\n- 隱式強制：當各種運算子(+, -, '', /, 等)應用於不同型別時。\n- 顯式強制：當使用 String(), Number()之類的函式時\n\n```js\nconst srt_1 = [\"This\", \"is\", 11, \"clock\"] + \"\";\nconst str_2 = String([\"This\", \"is\", 11, \"clock\"]);\nconsole.log(str_1);\nconsole.log(str_2);\n```\n\n```output\nThis,is,11,clock\nThis,is,11,clock\n```\n\n`str_1` 是隱式強制轉換的一個例子，在兩種不同型別的值(一個是陣列，另一個是字串)之間使用運算子，此時輸出為一個字串。\n`str_2` 為顯式強制轉換，在 `String()` 函式中，傳遞整個陣列，並將其轉換為字串。\n\n## 轉換字串為數值\n\n### parseInt() 將字串轉換為以十進位表示的整數。\n\n- parseInt(string, radix) 將字串轉換為以十進位表示的整數。接受兩個參數。\n  - string 欲轉換的值，若不為 String，會先使用 ToString()轉換成字串。\n  - radix 代表近位系統\n\nparseInt() 會略前後空白，並根據 radix 解析第一參數，當遇到無法解析的字元，會忽略該字元及其前後的所有字元，並停止解析，回傳目前為止的結果。\n\n若第一個字元就無法解析，則回傳 NaN\n\n```js\nparseInt(\"5A34\", 10); // 5，字元 A 無法被解析為數字，因此停止解析，回傳 5\nparseInt(\"5A34\", 16); // 23092，依照 16 進制解析並計算為 10 進位\nparseInt(\"\"); // NaN\nparseInt(\"16px\", 10); // 16\nparseInt(\" 332\", 10); // 332，空白會被忽略\n```\n\n### parseFloat()\n\n- parseFloat(string) 將字串轉換為以十進位表示的浮點數。僅接受一個參數。\n  - string 欲轉換的值，若第一個參數值不是 String，會先使用 ToString 轉換成字串。\n\n和 parseInt() 相同，會忽略前後空白。當遇到無法解析的字元時，會忽略其後所有字元，並停止解析，回傳目前結果。\n\n和 parseInt() 不同的是，parseFloat() 用以解析浮點數，因此會接受第一個小數點。且僅能分析十進制。\n\n```js\nparseFloat(\"55.44\"); // 55.44\nparseFloat(\"33.44.55\"); // 33.44\n```\n\n### Number()\n\n- Number(value) 在不使用 new 運算子的狀況下，可以用來轉會型別。\n\n規則如下：\n\n1. 若值為 undefined，回傳 NaN\n2. 若值為 null，回傳 0\n3. 若值為 Boolean，true => 1, false => 0\n4. 若值為 Number，直接回傳該值。\n5. 若為 String\n   1. 僅包含數字與浮點數，則忽略前後空白，回傳該值\n   2. 若包含有效的進位系統，如：十六進制的 0x、八進制的 0o、二進制的 0b，則依照進位系統轉換為十進制。\n   3. 空值，回傳 0\n   4. 其他，回傳 NaN\n6. 若值為 Object，使用 valueOf() 得到該值，再根據前述規則進行轉換。\n\n```js\nNumber(undefined); // NaN\nNumber(null); // 0\nNumber(true); // 1\nNumber(false); // 0\nNumber(33); // 33\nNumber(33.66); // 33.66\nNumber(\"0x11\"); // 17\nNumber(\"0b11\"); // 3\nNumber(\"0o11\"); // 9\nNumber(\"\"); // 0\nNumber(\"33\"); //33\nNumber(\"16px\"); // 轉換值中包含無法轉換的內容\n```\n\n## 計時器\n\n瀏覽器內建的計時器\n\n### setTimeout()\n\n來設定一段時間過後，自動執行某個函數(callback)，這個計時器只會執行一次。\n\n```javascript\nconst timeoutId = setTimeout(func, delay[, param1, param2, ...]);\nconst timeoutId = setTimeout(func, delay);\n```\n\n`func` 時間到執行的函數。\n`delay` 等候時間，單位為毫秒。\n`param*` 用來指定要傳入 `func` 的參數\n`setTimeout()` 執行後會返回一個數字，表示這個計時器的 id\n\n```javascript\nconst timeoutId = setTimeout(myAlert, 5000);\n\nfunction myAlert() {\n  alert(\"五秒鐘到了\");\n}\n```\n\n若取消計時器，可以使用 `clearTimeout(timeoutId)`;\n\n### setInterval()\n\n用來設定每過一段時間，就會自動執行某個函數(callback)，這個計時器會重複執行。\n\n```javascript\nconst intervalId = setInterval(func, delay[, param1, param2, ...]);\nconst intervalId = setInterval(func, delay);\n```\n\n```javascript\nconst intervalId = setInterval(function () {\n  alert(\"十秒鐘又到了\");\n}, 10000);\n```\n\n若取消計時器，可以使用 `clearInterval(intervalId)`;\n\n## 屬性描述器\n\n當對於屬性除了指定 key/value 以外有更進一步的要求時，例如設定屬性為 read-only 甚至是 constant 時，就可以使用屬性描述器。\n\n屬性的特徵：\n\n- 資料描述器\n  - writable\n  - configurable\n  - enumerable\n  - value\n- 存取器描述器\n  - get\n  - set\n\n這些特徵都是可以透過屬性描述器去設定的 `Object.defineProperty` 和 `Object.definedProperties`\n\n### 使用字面值宣告屬性的特徵\n\n- writable, configurable, enumerable 都會是 true\n- value 代表屬性的值\n- get, set 則是沒有設定\n\n### 取得屬性特徵\n\n若想要瞭解一個屬性的特徵時，可以使用 `Object.getOwnPropertyDescriptor(object, 'propertyName')` 這個內建函式\n\n```javascript\nvar obj = { prop1: \"prop1\", prop2: \"prop2\" };\nObject.getOwnPropertyDescriptor(obj, \"prop1\", \"prop2\");\n// {\n//    value: \"prop1\",\n//    writable: true,\n//    enumerable: true,\n//    configurable: true\n// }\n```\n\n使用字面值創建的屬性，其 `writable`, `enumerable`, `configurable` 都會是 `true`，而 `value` 就會是此屬性的值 `prop1`\n\n對於一次察看多個屬性的特徵，可以使用 `Object.getOwnPropertyDescriptors(object, 'propertyName1', 'propertyName2', ...)`\n\n```javascript\nvar obj = { prop1: \"prop1\", prop2: \"prop2\" };\nObject.getOwnPropertyDescriptors(obj, \"prop1\", \"prop2\");\n// {\n//   prop1: { value: \"prop1\", writable: true, enumerable: true, configurable: true },\n//   prop2: { value: \"prop2\", writable: true, enumerable: true, configurable: true }\n// }\n```\n\n### Object.defineProperty 設定單一個屬性描述器\n\n```javascript\nObject.defineProperty(object, \"propertyName\", descriptor);\n// descriptor 是一個 object，descriptor 裡面的屬性可以是剛剛提到的屬性特徵\n```\n\n在 `obj` 中按需求設定 ‵prop` 這個屬性\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, \"prop\", {\n  writable: false,\n  configurable: true,\n  enumerable: true,\n  value: \"This is prop\",\n});\nconsole.log(obj.prop); // \"This is prop\"\n```\n\n### Object.defineProperties 一次設定多個屬性\n\n```javascript\nObject.definedProperties(object, properties);\n\n// properties 也是一個 object，其結構如下：\n// {\n//   'propertyName1': descriptor1,\n//   'propertyName2': descriptor1,\n//    ...\n//   'propertyNamen': descriptorn\n// }\n```\n\n```javascript\nvar obj = {};\nObject.defineProperties(obj, {\n  prop1: {\n    writable: false,\n    configurable: true,\n    enumerable: true,\n    value: \"This is prop1\",\n  },\n  prop2: {\n    writable: false,\n    configurable: true,\n    enumerable: true,\n    value: \"This is prop2\",\n  },\n});\nconsole.log(obj.prop1); // \"This is prop1\"\nconsole.log(obj.prop2); // \"This is prop2\"\n```\n\n### 資料描述器\n\n> 參考資料：\n>\n> [JavaScript - 屬性描述器](https://ithelp.ithome.com.tw/articles/10197826)\n\n#### writable 屬性是否可以改值\n\n可以將屬性設定為 `read-only`\n\n當使用屬性的字面值( `obj.prop` 與 `obj[prop]`)定義屬性時，屬性的 writable 為 true，也就代表可以寫入。\n\n相較之下，當 writable 為 false 就代表此屬性為 read-only\n\n在非嚴格模式下，還是可以對 read-only 的屬性進行寫值，但會沒有效果。\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, \"prop1\", {\n  value: \"This is prop1\",\n  configurable: true,\n  enumerable: true,\n  writable: false, // 將 writable 設為 false\n});\nconsole.log(obj.prop1); // 'This is prop1'\nobj.prop1 = \"This is prop2\";\nconsole.log(obj.prop1); // 'This is prop1'\n```\n\n#### Configurable 是否可編輯該屬性\n\n屬性描述器在一般狀況下，可以利用屬性描述器重新設定，若沒有重新設定，會保留原有的特徵。\n\n```javascript\nvar obj = {};\nobj.prop1 = \"This is prop1\";\n\nObject.defineProperty(obj, \"prop1\", {\n  value: \"This is prop1\",\n  configurable: true,\n  enumerable: true,\n  writable: false,\n});\nconsole.log(obj.prop1); // \"This is prop1\"\nobj.prop1 = \"This is prop2\";\nconsole.log(obj.prop1); // \"This is prop1\"\n```\n\n上面將 `writable` 設為 `false`，因此無法對 `obj.prop1` 賦值。\n\n下面實作禁止屬性被重新設定：\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, \"prop1\", {\n  value: \"This is prop1\",\n  configurable: false,\n  enumerable: true,\n  writable: true,\n});\nconsole.log(obj.prop1); // \"This is prop1\"\n\nObject.defineProperty(obj, \"prop1\", {\n  value: \"This is prop1\",\n  configurable: true,\n  enumerable: true,\n  writable: false,\n}); // Uncaught TypeError: Cannot redefine property: prop1\n\ndelete obj.prop1; // false 禁止屬性被刪除\nconsole.log(obj.prop1); // \"This is prop1\"\n```\n\n當 `obj.prop1` 已經被設定為 `configurable: false` 時，又試著重新設定屬性描述器一次時，javascript 會報錯。\n\n即是在非嚴格模式下，都不允許重新設定 `configurable: false` 的屬性描述。\n\n但有一個特例：在 `configurable: false`，`writable` 特徵還是可以從 `true` 改為 `false`\n\n#### Enumerable 屬性是否會在物件的屬性列舉時被顯示\n\n在 `for...in` 的屬性列舉動作中，只有可列舉的屬性會被迭代\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, \"prop1\", {\n  value: \"This is prop1\",\n  configurable: true,\n  enumerable: false,\n  writable: true,\n});\nobj.prop2 = \"This is prop2\";\n\nconsole.log(\"prop1\" in obj); // true\nconsole.log(\"prop2\" in obj); // true\nfor (var prop in obj) {\n  console.log(\"prop: \", prop); // \"prop: This is prop2\"\n}\n```\n\n雖然 `prop1` 和 `prop2` 都存在於物件中(利用 `in` 檢查)，但因為 `obj.prop1` 被設定為 `enumerable: false` 因此在 `for...in` 列舉的動作中，並不會被迭代到。\n\n相較之下，普通屬性的 `obj.prop2` 可以被列舉。\n\n- `obj.propertyIsEnumerable` 檢查屬性是否可列舉且為物件自有的\n\n```javascript\nvar obj = { prop1: \"prop1\" };\nObject.defineProperty(obj, \"prop2\", {\n  value: \"prop2\",\n  enumerable: false,\n  writable: true,\n  configurable: true,\n});\nobj.propertyIsEnumerable(\"prop1\"); // true\nobj.propertyIsEnumerable(\"prop2\"); // false\n```\n\n使用 Object.keys 會將所有可列舉的屬性列成一個陣列\n\n```javascript\nvar obj = { prop1: \"prop1\" };\nObject.defineProperty(obj, \"prop2\", {\n  value: \"prop2\",\n  enumerable: false,\n  writable: true,\n  configurable: true,\n});\nObject.keys(obj); // [\"prop1\"]\n```\n\n#### value 屬性的值\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, \"prop1\", {\n  value: \"This is prop1\",\n  writable: true,\n  configurable: true,\n  enumerable: true,\n});\nconsole.log(obj.prop1); // \"This is prop1\"\n```\n\n上面程式碼，等同於下面\n\n```javascript\nvar obj = {};\nobj.prop1 = \"This is prop1\";\nconsole.log(obj.prop1); // \"This is prop1\"\n```\n\n#### 屬性描述器屬於淺層設定\n\n淺層設定：只有目標物件的`自有屬性`才會擁有這個特徵，若屬性又指向了另一個物件，則另一個物件內的屬性，即不為自有屬性，亦不會擁有這個特徵。\n\n```javascript\nvar obj = {};\nvar innerObj = { innerProp: \"This is innerProp\" };\n\nObject.defineProperty(obj, \"prop1\", {\n  value: innerObj,\n  writable: false,\n  configuration: true,\n  enumerable: true,\n});\n\nobj.prop1 = {};\nconsole.log(obj.prop1); // { innerProp: \"This is innerProp\" }\n\nobj.prop1.innerProp = \"innerProp changed!\";\nconsole.log(obj.prop1); // { innerProp: \"innerProp changed!\" }\n```\n\n將 `obj.prop1` 設為 `writable: false`，並賦值為 `innerObj`，接著試圖將`{}` 寫入 `obj.prop1`。此時寫入的動作並沒有成功，`obj.prop1` 還是指向 `innerObj`\n\n但若賦值的是 `innerObj` 的屬性 `innerProp` 的話，是可以寫入的，因為只有 `obj` 自身的屬性 `prop1` 被指定為 `writable: false`，而 `prop1` 指向的 `innerObj` 內部屬性則不受 `prop1` 的特徵管轄，因此複寫 `innerProp` 是可行的\n\n### 存取器描述器\n\n`get` 和 `set` 分別為取值器與設值器，可以將他想像成是函式。\n當有設定這兩個特徵時，他們會覆蓋 javascript 原有的取值與設值行為 `[[GET]]` 和 `[[set]]`\n\n#### 宣告方式\n\n- 使用物件字面值時直接定義\n\n  ```javascript\n  var obj = {\n    get propName() {\n      // ... do something\n      return \"some value\";\n    },\n    set propName(val) {\n      // ... do something\n    },\n  };\n  ```\n\n- 利用屬性描述器定義\n\n  ```javascript\n  Object.defineProperty(obj, \"prop1\", {\n    // ...\n    get: function () {\n      // ... do something\n      return \"some value\";\n    },\n    set: function (val) {\n      // ... do something\n    },\n  });\n  ```\n\n以上的宣告方式是一樣的\n\n#### Getter\n\n需要回傳一個值來當作取值結果\n\n```javascript\nvar obj = {\n  get prop1() {\n    return \"This is prop1\";\n  },\n};\nconsole.log(obj.prop1); // 'This is prop1'\n\nobj.prop1 = \"Change value!\";\nconsole.log(obj.prop1); // 'This is prop1'\n```\n\n無論怎麼修改 prop1 的值，最後回傳的都是取值器回傳的 \"This is prop1\"\n\n### setter\n\n在拿到值之後，去做指定的動作\n\n```javascript\nvar obj = {\n  set prop1(val) {\n    console.log(\"prop1 set: \", val);\n  },\n};\nobj.prop1 = \"This is prop1\"; // \"prop1 set:  This is prop1\"\n\nconsole.log(obj.prop1); // undefined\n```\n\n將 \"this is prop1\" 傳入 prop1 中，此時會印出 set 要求的 log，當要取出 obj.prop1 的值時，因為我們並沒有設置 get，因此出現 undefined\n\n### 資料處理器與存取器處理器\n\n- 資料描述器：代表屬性是有值，會有以下兩個特徵\n  - value\n  - writable\n- 存取器描述器：屬性的值是由取值器與設值器所決定，會有以下兩個特徵：\n  - get\n  - set\n\n需要注意的是，資料描述器與存取器描述器不相容。\n\n若今天物件中的屬性已經設定了 get 和 set，也就代表已經定義取值和設值的行為，此時再額外進行屬性值(value)與唯獨(writable)的設定，產生行為衝突\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, \"prop1\", {\n  get: function () {\n    return \"This is prop1\";\n  },\n  value: \"test\",\n  writable: true,\n}); // Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #<Object>\n```\n\n### 取值器與設值器的應用\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, \"prop1\", {\n  set: function (val) {\n    this._prop1_ = val * 2;\n  },\n  get: function () {\n    return this._prop1_;\n  },\n  configurable: true,\n  enumerable: true,\n});\n\nobj.prop1 = 100;\nconsole.log(obj.prop1); // 200\n```\n\n上面我們宣告了一個變數 obj 並加入一個屬性 prop1，並為這個屬性同時加入 get 和 set，這兩個函式的共通點：都對 obj.prop1 進行存取。\n\n## 解構賦值\n\n> 參考資料：\n>\n> [解構賦值 · 從 ES6 開始的 JavaScript 學習生活](https://eyesofkids.gitbooks.io/javascript-start-from-es6/content/part4/destructuring.html)\n\n用於提取(extract)陣列或物件中的資料，\n\n### 從陣列解構賦值\n\n```js\n//基本用法\nconst [a, b] = [1, 2]; //a=1, b=2\n\n//先宣告後指定值，要用let才行\nlet a, b;\n[a, b] = [1, 2];\n\n// 略過某些值\nconst [a, , b] = [1, 2, 3]; // a=1, b=3\n\n// 其餘運算\nconst [a, ...b] = [1, 2, 3]; //a=1, b=[2,3]\n\n// 失敗保護\nconst [, , , a, b] = [1, 2, 3]; // a=undefined, b=undefined\n\n// 交換值\nlet a = 1,\n  b = 2;\n[b, a] = [a, b]; //a=2, b=1\n\n// 多維複雜陣列\nconst [a, [b, [c, d]]] = [1, [2, [[[3, 4], 5], 6]]]; // a=1, b=2, c=[ [ 3, 4 ], 5 ], d=6\n\n// 字串\nconst str = \"hello\";\nconst [a, b, c, d, e] = str; // a=h, b=e, c=l, d=l, e=o\n```\n\n### 從物件解構賦值\n\n```js\n// 基本用法\nconst { user: x } = { user: 5 }; // x=5\n\n// 失敗保護(Fail-safe)\nconst { user: x } = { user2: 5 }; //x=undefined\n\n// 賦予新的變數名稱\nconst { prop: x, prop2: y } = { prop: 5, prop2: 10 }; // x=5, y=10\n\n// 屬性賦值語法\nconst { prop: prop, prop2: prop2 } = { prop: 5, prop2: 10 }; //prop = 5, prop2=10\n\n// 相當於上一行的簡短語法(Short-hand syntax)\nconst { prop, prop2 } = { prop: 5, prop2: 10 }; //prop = 5, prop2=10\n\n// ES7+的物件屬性其餘運算符\nconst { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 }; //a=1, b=2, rest={c:3, d:4}\n```\n\n### 非物件或非陣列解構賦值\n\n### 解構賦值時給予預設值\n\n### 搭配函式的傳入參數使用\n\n## Linked list 鏈結串列\n\n> 參考資料：\n>\n> [JavaScript 學演算法（五）- 鏈結串列 Linked list](https://chupai.github.io/posts/200427_ds_linkedlist/)\n>\n> [Linked list Javascript 實作及 Leet code 題目解析](https://medium.com/@nchuuu/linked-list-es6-javascript%E5%AF%A6%E4%BD%9C%E5%8F%8Aleet-code%E9%A1%8C%E7%9B%AE%E8%A7%A3%E6%9E%90-4afcd9a67b3d)\n\n中國稱鏈表。和陣列一樣都是線性資料結構，但和陣列不同為，他為鏈式儲存結構，也就是記憶體位置儲存為不連續性。\n\n### 定義\n\n鏈結串列是由一連串節點 `node` 組成，節點之間是透過指標來連接。所以儲存上不需要連續的空間。\n每個節點包括：\n\n1. 資料元素\n2. 指標\n   指標(又稱鏈結、引用)，通常為一或兩個，用來指向上/下個的位置。若沒有上/下節點，則為空。若指標斷裂，資料就遺失。\n\n鏈結串列就像是火車車廂一樣，一節拉一節。\n\n相較於陣列，鏈結串列的元素不是連續放置的，插入或是移除元素時，不需要移動其他元素，只需要修改上/下個指標的指向。\n\n因為鏈結串列沒有索引，所要存取特定值，需要從頭開始找起，因此相較於陣列，資料存取為費時。\n\n### 類型\n\n鏈結串列有多種類型：\n\n- 單向鏈結串列(singly linked list)：\n  - 又稱單鏈結串列、線性鏈結串列、普通鏈結串列，為最基本的鏈結串列，其特點是連結串列的鏈結方向是單向的，對鏈結串列的存取要通過頭部開始，依序向下讀取。\n- 雙向鏈結串列(doubly linked list)：\n  - 又稱為雙鏈結串列。他和單向鏈結串列最大的區別在於，每個節點中都有兩個指標，分別指向上一個和下一個節點。所以從雙向鏈結串列中的任意一個節點開始，都可以很方便的存取他的上一個和下一個節點。\n- 迴圈鏈結串列(circularly linked list)：\n  - 又稱環狀鏈結串列、循環鏈結串列，他和一般的鏈結串列操作基本一致，但串列頭尾的指標會連接在一起，行成一個環。\n\n### 優缺點比較\n\n- 陣列\n  - 優點\n    - 可利用 index 隨機存取只需要 O(1) 的時間\n    - 可靠度高，不會因為鏈結斷裂而遺失資料。\n  - 缺點\n    - 在開頭或在中間插入、刪除元素，需花費 O(n) 的時間移動元素。\n    - 連續的記憶體空間，可能有用不到的空間，進而造成浪費。\n    - 若陣列已滿，會需要花費 O(n) 的時間搬動資料到新的陣列中。\n- 鏈結串列\n  - 優點\n    - 資料在記憶體中非連續。\n    - 插入、刪除元素只需修改上/下個指標的指向。\n  - 缺點\n    - 只能順序存取，需花費 O(n) 的時間。\n    - 鏈結斷裂就會遺失資料。\n\n## 額外補充\n\n### 函式註解模版\n\n```js\n/**\n * functionName 函式功能說明。\n *\n * @param  {型態}  傳入變數名稱 - 變數說明。\n * @return {型態}  回傳說明。\n */\n\nfunction functionName(傳入變數名稱) {\n  // do something...\n  return 回傳;\n}\n```\n\n範例\n\n```js\n/**\n * HelloWord 打招呼訊息傳送是否成功。\n *\n * @param  {String}  greeting - 打招呼的訊息。\n * @return {Boolean} 傳送是否成功。\n */\n\nfunction HelloWord(greeting) {\n  // do something...\n  return true;\n}\n```\n\n### random 公式\n\n```javascript\nfunction getRandom(start, end) {\n  return Math.floor(Math.random() * (end - start + 1)) + start;\n}\nvar r = getRandom(0, 255);\nvar g = getRandom(0, 255);\nvar b = getRandom(0, 255);\n```\n\ndebounce、throttle、flatten、cloneDeep\n","tocContent":"- [Javascript 學習筆記](#javascript-學習筆記)\n  - [基本概念](#基本概念)\n    - [宣告與命名](#宣告與命名)\n    - [let, const 特性](#let-const-特性)\n    - [如何分辨使用 let 和 const 的時機？](#如何分辨使用-let-和-const-的時機)\n    - [let 和 const 解決了什麼問題？](#let-和-const-解決了什麼問題)\n    - [javascript 參數傳遞方式](#javascript-參數傳遞方式)\n  - [存取資料的方法](#存取資料的方法)\n    - [基本型別](#基本型別)\n    - [物件型別](#物件型別)\n    - [把基本型別當作參數傳入函式](#把基本型別當作參數傳入函式)\n    - [Function](#function)\n      - [First-class Object](#first-class-object)\n      - [宣告 function](#宣告-function)\n      - [呼叫 function](#呼叫-function)\n      - [IIFF 立即函式](#iiff-立即函式)\n      - [Scope 作用域](#scope-作用域)\n  - [運算式與運算子](#運算式與運算子)\n    - [嚴謹模式](#嚴謹模式)\n    - [賦值運算子](#賦值運算子)\n    - [比較運算子](#比較運算子)\n    - [算數運算子](#算數運算子)\n    - [邏輯運算子](#邏輯運算子)\n    - [其餘運算子與展開運算子](#其餘運算子與展開運算子)\n    - [三元運算式](#三元運算式)\n    - [if else](#if-else)\n  - [流程判斷與迴圈](#流程判斷與迴圈)\n    - [switch](#switch)\n    - [while 迴圈](#while-迴圈)\n    - [for 迴圈](#for-迴圈)\n    - [for of](#for-of)\n    - [for in](#for-in)\n  - [函式 function](#函式-function)\n    - [定義函式](#定義函式)\n    - [箭頭函式](#箭頭函式)\n    - [Scope 變數的有效範圍](#scope-變數的有效範圍)\n    - [Hoisting 提升](#hoisting-提升)\n      - [變數提升](#變數提升)\n      - [函式提升](#函式提升)\n      - [為何會有 Hoisting 的現象？](#為何會有-hoisting-的現象)\n      - [最佳實踐](#最佳實踐)\n    - [全域變數](#全域變數)\n  - [Promise](#promise)\n    - [如何使用 Promise](#如何使用-promise)\n    - [狀態](#狀態)\n    - [then 的使用](#then-的使用)\n    - [錯誤處理](#錯誤處理)\n    - [finally](#finally)\n    - [async/await 同步操作](#asyncawait-同步操作)\n  - [document](#document)\n    - [`createdElement()` 建立節點](#createdelement-建立節點)\n    - [`appendChild()` 增加子節點](#appendchild-增加子節點)\n    - [`.querySelector` 元素選擇器](#queryselector-元素選擇器)\n    - [`.querySelectorAll` 選取所有指定元素](#queryselectorall-選取所有指定元素)\n    - [`setAttribute()` 增加標籤屬性](#setattribute-增加標籤屬性)\n    - [移除 HTML 元素](#移除-html-元素)\n      - [使用 CSS 隱藏元素](#使用-css-隱藏元素)\n      - [`removeChild()` 從 DOM 中完全移除元素](#removechild-從-dom-中完全移除元素)\n    - [`remove()` ES6 新方法](#remove-es6-新方法)\n    - [`addEventListener()` 事件監聽](#addeventlistener-事件監聽)\n    - [`removeEventListener()` 取消事件監聽](#removeeventlistener-取消事件監聽)\n  - [Math](#math)\n    - [`Math.round` 四捨五入](#mathround-四捨五入)\n  - [物件取值、新增與刪除](#物件取值新增與刪除)\n    - [物件取值](#物件取值)\n    - [物件轉為陣列](#物件轉為陣列)\n    - [新增物件屬性](#新增物件屬性)\n    - [刪除物件屬性](#刪除物件屬性)\n  - [SET 集合物件](#set-集合物件)\n    - [基本使用](#基本使用)\n    - [陣列與集合間轉換](#陣列與集合間轉換)\n    - [過濾陣列中重複的元素](#過濾陣列中重複的元素)\n  - [Map 物件](#map-物件)\n  - [JSON 轉換](#json-轉換)\n    - [`JSON.stringify` 將物件轉為 json 字串](#jsonstringify-將物件轉為-json-字串)\n    - [`JSON.parse` 將 json 字串轉換為物件](#jsonparse-將-json-字串轉換為物件)\n  - [轉換陣列為字串](#轉換陣列為字串)\n    - [toString()](#tostring)\n    - [join()](#join)\n    - [使用型別轉換](#使用型別轉換)\n  - [轉換字串為數值](#轉換字串為數值)\n    - [parseInt() 將字串轉換為以十進位表示的整數。](#parseint-將字串轉換為以十進位表示的整數)\n    - [parseFloat()](#parsefloat)\n    - [Number()](#number)\n  - [計時器](#計時器)\n    - [setTimeout()](#settimeout)\n    - [setInterval()](#setinterval)\n  - [屬性描述器](#屬性描述器)\n    - [使用字面值宣告屬性的特徵](#使用字面值宣告屬性的特徵)\n    - [取得屬性特徵](#取得屬性特徵)\n    - [Object.defineProperty 設定單一個屬性描述器](#objectdefineproperty-設定單一個屬性描述器)\n    - [Object.defineProperties 一次設定多個屬性](#objectdefineproperties-一次設定多個屬性)\n    - [資料描述器](#資料描述器)\n      - [writable 屬性是否可以改值](#writable-屬性是否可以改值)\n      - [Configurable 是否可編輯該屬性](#configurable-是否可編輯該屬性)\n      - [Enumerable 屬性是否會在物件的屬性列舉時被顯示](#enumerable-屬性是否會在物件的屬性列舉時被顯示)\n      - [value 屬性的值](#value-屬性的值)\n      - [屬性描述器屬於淺層設定](#屬性描述器屬於淺層設定)\n    - [存取器描述器](#存取器描述器)\n      - [宣告方式](#宣告方式)\n      - [Getter](#getter)\n    - [setter](#setter)\n    - [資料處理器與存取器處理器](#資料處理器與存取器處理器)\n    - [取值器與設值器的應用](#取值器與設值器的應用)\n  - [解構賦值](#解構賦值)\n    - [從陣列解構賦值](#從陣列解構賦值)\n    - [從物件解構賦值](#從物件解構賦值)\n    - [非物件或非陣列解構賦值](#非物件或非陣列解構賦值)\n    - [解構賦值時給予預設值](#解構賦值時給予預設值)\n    - [搭配函式的傳入參數使用](#搭配函式的傳入參數使用)\n  - [Linked list 鏈結串列](#linked-list-鏈結串列)\n    - [定義](#定義)\n    - [類型](#類型)\n    - [優缺點比較](#優缺點比較)\n  - [額外補充](#額外補充)\n    - [函式註解模版](#函式註解模版)\n    - [random 公式](#random-公式)"}