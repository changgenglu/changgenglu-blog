{"name":"VueX 學習筆記.md","content":"# Vuex 學習筆記\n\n>\n\n> 參考資料：\n>\n> [Vuex 是什麼? 怎麼用?](https://medium.com/itsems-frontend/vue-vuex5-sumup-c170d4bd6c42)\n>\n> 實作：\n>\n> [github-repo](https://github.com/changgenglu/vuex-note)\n>\n> [github-pages](https://changgenglu.github.io/vuex-note/)\n\n## 什麼是 Vuex\n\n一個專門為 vue 專案開發的資料管理套件，可以為網站做全域的資料管理。\n\n在專案結構下面可能會有多個組件，組件中又會有組件，組件的溝通，通常會會透過 emit 和 prop，而為了處理大型專案的兄弟組件間的溝通，Vuex 就這樣誕生了。\n\nVuex 有一點像是全域的 components，大家可以拿他資料，呼叫他出來用。\n\nstate 就像是 data，action + Mutation 就像是 methods，getters 就像 computed\n\n在 Vuex 中，儲存的狀態為 State，Component 使用 Dispatch 呼叫 Actions，讓 Actions 發出 commit 觸發 Mutations 去修改 State 的資料。整個 Vuex 的方法也稱為 store。\n\n## 帶入參數及呼叫方法\n\n### State\n\n- 定義：/store.js\n\n  ```javascript\n  import Vue from \"vue\";\n  import Vuex from \"vuex\";\n  Vue.use(Vuex);\n\n  const store = new Vuex.Store({\n    state: {\n      isLoading: false,\n    },\n  });\n  export default store;\n  ```\n\n- 使用：/app.vue\n\n  ```html\n  <template>\n    <div id=\"app\">\n      <p>isLoading: {{ ifLoading }}</p>\n    </div>\n  </template>\n\n  <script>\n    export default {\n      name: \"app\",\n      computed: {\n        // 注意: 這邊的ifLoading跟store的state的isLoading名字不同，是可以自定義的喔\n        ifLoading() {\n          return this.$store.state.isLoading;\n        },\n      },\n    };\n  </script>\n  ```\n\n### mapState\n\n- 定義：/store.js\n\n  ```javascript\n  import Vue from \"vue\";\n  import Vuex from \"vuex\";\n  Vue.use(Vuex);\n\n  const store = new Vuex.Store({\n    state: {\n      myName: \"Emma\",\n      isLoading: false,\n    },\n  });\n\n  export default store;\n  ```\n\n- 使用：/app.vue\n\n  ```html\n  <template>\n    <div id=\"app\">\n      <p>My Name is {{ myName }}</p>\n      <p>isLoading: {{ isLoading }}</p>\n    </div>\n  </template>\n\n  <script>\n    import { mapState } from \"vuex\";\n    export default {\n      name: \"app\",\n      computed: {\n        // 陣列寫法\n        ...mapState([\"isLoading\", \"myName\"])\n        // 物件寫法\n        ...mapState({\n          isLoading: state => state.isLoading,\n          myName:  state => state.myName,\n        })\n      }\n    };\n  </script>\n  ```\n\n### Getters\n\n- 可帶參數：state, getters\n- 定義：/store.js\n\n  ```javascript\n  import Vue from \"vue\";\n  import Vuex from \"vuex\";\n  Vue.use(Vuex);\n\n  const store = new Vuex.Store({\n    state: {\n      myName: \"Emma\",\n    },\n    getters: {\n      // 只有一個參數的箭頭函式寫法\n      newName: (state) => {\n        return state.myName + \" lin\";\n      },\n    },\n  });\n\n  export default store;\n  ```\n\n- 使用：/app.vue\n\n  ```html\n  <template>\n    <div id=\"app\">\n      <p>My New Name is {{ newName }}</p>\n    </div>\n  </template>\n\n  <script>\n    export default {\n      name: \"app\",\n      computed: {\n        newName() {\n          return this.$store.getters.newName;\n        },\n      },\n    };\n  </script>\n  ```\n\n加上參數 getters 表示可以呼叫別的 getters 來用\n\n- 定義：/store.js\n\n  ```javascript\n  import Vue from \"vue\";\n  import Vuex from \"vuex\";\n  Vue.use(Vuex);\n\n  const store = new Vuex.Store({\n    state: {\n      myName: \"Emma\",\n    },\n    getters: {\n      newName: (state) => {\n        return state.myName + \" lin\";\n      },\n      // 這邊呼叫下面那個getters\n      anotherName: (state, getters) => {\n        return getters.nickName;\n      },\n      nickName: (state) => {\n        return state.myName + \" Watson\";\n      },\n    },\n  });\n\n  export default store;\n  ```\n\n- 使用：/app.vue\n\n  ```html\n  <template>\n    <div id=\"app\">\n      <p>My New Name is {{ newName }}</p>\n      <p>or you can call me {{ anotherName }}</p>\n    </div>\n  </template>\n\n  <script>\n    export default {\n      name: \"app\",\n      computed: {\n        newName() {\n          return this.$store.getters.newName;\n        },\n        anotherName() {\n          return this.$store.getters.anotherName;\n        },\n      },\n    };\n  </script>\n  ```\n\n### mapGetters\n\n定義和上面的 store.js 相同，差異在 components 呼叫的時候\n\n- 使用：\n\n  ```javascript\n  <script>\n    import { mapGetters } from \"vuex\";\n    export default {\n      name: \"app\",\n      computed: {\n        // 陣列寫法\n        ...mapGetters([\"newName\", \"anotherName\"])\n        // 物件寫法\n        ...mapGetters({\n          newName: \"newName\",\n          anotherName: \"anotherName\"\n        })\n      }\n    };\n  </script>\n  ```\n\n### mutations\n\n可帶參數：state, payload\n\n- 使用：/app.vue\n\n  ```javascript\n  methods: {\n    reverse() {\n      this.$store.commit(\"Loaded\");\n    },\n  }\n  ```\n\n- with payload:\n  通常 payload 可以用物件表示，就能更具描述性，但是要記得在 mutations 運算時，帶入的參數 payload 要加上參數物件的 key\n\n  - /app.vue\n\n    ```javascript\n    store.commit(\"addCounts\", {\n      amount: 10,\n    });\n    ```\n\n  - /store.js\n\n    ```javascript\n    mutations: {\n      addCounts (state, payload) {\n        state.count += payload.amount\n      }\n    }\n    ```\n\n  - 所以帶上 payload 的呼叫可以這樣使用：\n\n    ```javascript\n    this.$store.commit(\"addTimes\", 10);\n    // 或\n    this.$store.commit({\n      type: \"addTimes\",\n      count: 2,\n    });\n    ```\n\n    物件 type 是必要的，其他可以隨意\n\n### mapMutations\n\n```javascript\n<script>\n  import { mapMutations } from \"vuex\";\n  export default {\n    name: \"app\",\n    computed: {\n      // 陣列寫法\n      ...mapMutations([\"Loaded\", \"addTimes\"])\n      // 物件寫法\n      ...mapMutations({\n        // add是component自定義的事件名稱，addTimes是mutations在store的名稱\n        add: 'addTimes'\n      })\n    }\n  };\n</script>\n```\n\n使用 mapMutations，就要把 payload 直接帶入 template：\n\n```html\n<button @click=\"addTimes(2)\">addTimes</button>\n```\n\n**注意**：mutations 一定只能同步執行，action 才能執行非同步\n\n### actions\n\n- 可帶參數：\n  - context: {commit, dispatch, state, getters, rootState, rootGetters}, payload\n\n上面描述 mutations 只能同步執行，action 執行非同步，意旨 axios 要在 Actions 裡面做，不可以在 mutations 裡面做。\n\n- 定義：/app.vue\n\n  ```javascript\n  ClickedActions({ commit }, payload) {\n  commit('addTimes', payload)\n  }\n  ```\n\n- 使用：/app.vue\n\n  ```javascript\n  methods: {\n    add() {\n      this.$store.dispatch(\"ClickedActions\",2);\n    }\n  }\n  ```\n\n## 專案結構\n\n1. App 層級的狀態要在 state 集中管理\n   > app 層級的意思是指：不會因為跨組件改變的狀態，如：登入資訊、購物車清單...等。\n   >\n   > 會因為跨組件改變的狀態，如：下拉式選單的開關狀態、商品列表...等。\n2. 唯一改變 state 的方式只有 mutations，而且是同步執行\n3. actions 才可以非同步執行\n\n```txt\n|--index.js\n|--main.js\n|--api\n|  |--...             // 後端 api\n|--components         // 頁面\n|  |--App.vue\n|  |--...\n|--store\n   |--index.js        // 註冊 modules 並 export store\n   |--actions.js      // 跨組件的 action\n   |--mutations.js    // 跨組件的 mutations\n   |--modules\n      |--cart.js      // 購物車 model\n      |--products.js  // 商品 model\n```\n","tocContent":"- [Vuex 學習筆記](#vuex-學習筆記)\n  - [什麼是 Vuex](#什麼是-vuex)\n  - [帶入參數及呼叫方法](#帶入參數及呼叫方法)\n    - [State](#state)\n    - [mapState](#mapstate)\n    - [Getters](#getters)\n    - [mapGetters](#mapgetters)\n    - [mutations](#mutations)\n    - [mapMutations](#mapmutations)\n    - [actions](#actions)\n  - [專案結構](#專案結構)"}