{"name":"Javascript 事件.md","content":"# Javascript 事件\n\n> 參考資料：\n>\n> [重新認識 JavaScript: Day 14 事件機制的原理](https://ithelp.ithome.com.tw/articles/10191970)\n\n## 事件流程\n\n假設有兩個元素：outer, inner\n\n```html\n<div id='outer'>\n  <div id='inner'></div>\n</div>\n```\n\n此時當點擊 inner 的時候，也代表同時點擊 outer，甚至實際上我們也點擊到整個網頁。\n\n事件流程(Event Flow)指的就是`網頁元素接收事件的順序`。\n\n- 事件流程可以分為兩種機制：\n  - 事件冒泡(Event Bubbling)\n  - 事件捕獲(Event Capturing)\n\n\n### 事件冒泡\n\n事件冒泡的意思是：從啟動事件的元素節點開始，逐層向上傳遞，直到整個網頁的根節點，也就是 `document`。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>TITLE</title>\n</head>\n<body>\n\n  <div>CLICK</div>\n\n</body>\n</html>\n```\n\n如上面程式碼，假設點擊了 click 元素，那在`事件冒泡`的機制下，觸發事件的順序會是：\n\n1. `<div>CLICK</div>`\n2. `<body>`\n3. `<html>`\n4. `document`\n\n向這樣 click 事件逐層向上依序被觸發，就是事件冒泡。\n\n### 事件捕獲\n\n事件捕獲和事件冒泡的機制正好相反\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>TITLE</title>\n</head>\n<body>\n\n  <div>CLICK</div>\n\n</body>\n</html>\n\n```\n\n今點擊 click 後，事件捕獲的機制會是：\n\n1. `document`\n2. `<html>`\n3. `<body>`\n4. `<div>CLICK</div>`\n\n### 機制執行邏輯\n\n當事件被觸發時，兩種事件傳遞的機制都會執行。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>title</title>\n</head>\n<body>\n    <table>\n        <tbody>\n            <tr>\n                <td>a</td>\n                <td>b</td>\n            </tr>\n            <tr>\n                <td>c</td>\n                <td>d</td>\n            </tr>\n        </tbody>\n    </table>\n</body>\n</html>\n```\n\n假設現在的事件為點擊 `<td>c</td>`，當事件發生時，會先執行`事件捕獲(capture phase)`：\n\n1. `document`\n2. `<html>`\n3. `<body>`\n4. `<table>`\n5. `<tbody>`\n6. `<tr>`\n7. `<td>` (實際被點擊的元素)\n\n由上而下依序觸發他們的 click 事件。\n\n藉著再繼續執行`事件冒泡(bubble phase)`，反方向由 `<td>` 一路向上傳至 `document` 結束整個事件流程。\n\n若要檢驗事件流程，可以透過`addEventListener()` 方法來綁定 click 事件：\n\n```html\n<div>\n  <div id=\"parent\">\n    父元素\n    <div id=\"child\">子元素</div>\n  </div>\n</div>\n```\n\n```js\n// 父元素\nvar parent = document.getElementById('parent');\n// 子元素\nvar child = document.getElementById('child');\n\n// 透過 addEventListener 指定事件的綁定\n// 第三個參數 true / false 分別代表捕獲/ 冒泡 機制\n\nparent.addEventListener('click', function () {\n  console.log('Parent Capturing');\n}, true);\n\nparent.addEventListener('click', function () {\n  console.log('Parent Bubbling');\n}, false);\n\n\nchild.addEventListener('click', function () {\n  console.log('Child Capturing');\n}, true);\n\nchild.addEventListener('click', function () {\n  console.log('Child Bubbling');\n}, false);\n\n```\n\n當點擊 `子元素`時，透過`console.log()`可以觀察到事件觸發的順序。\n\n```text\n\"Parent Capturing\"\n\"Child Capturing\"\n\"Child Bubbling\"\n\"Parent Bubbling\"\n```\n\n若點擊`父元素`，則出現\n\n```text\n\"Parent Capturing\"\n\"Parent Bubbling\"\n```\n\n當點擊子元素時，父層的`捕獲` 會先被觸發。然後到子層內部的 `捕獲`接著`冒泡`事件，最後才又回到父層的`冒泡`結束。\n\n那子層的`捕獲`或`冒泡`的順序要依程式碼的順序而定。\n\n若是`捕獲`在`冒泡`前面：\n\n```js\nchild.addEventListener('click', function () {\n  console.log('Child Capturing');\n}, true);\n\nchild.addEventListener('click', function () {\n  console.log('Child Bubbling');\n}, false);\n```\n\n則會得到\n\n```text\n\"Child Capturing\"\n\"Child Bubbling\"\n```\n\n若是將兩段程式碼順序相反，結果如下：\n\n```js\nchild.addEventListener('click', function () {\n  console.log('Child Bubbling');\n}, false);\n\nchild.addEventListener('click', function () {\n  console.log('Child Capturing');\n}, true);\n```\n\n```text\n\"Child Bubbling\"\n\"Child Capturing\"\n```\n\n## 註冊事件的綁定\n\n除了 `addEventListener()`方法，綁定事件的方式還有其他方法。\n\n### on-event 處理器 (HTML 屬性)\n\n對 html 標籤而言，只要支援某個`事件`的觸發，就可以透過 `on + 事件名`的屬性來註冊事件：\n\n```html\n<button id=\"btn\" onclick=\"console.log('HI');\">Click</button>\n```\n\n如同上面範例，透過 `onclick`事件，就可以在 `<button>`標籤上面註冊 `click`事件，也就是當使用者按下 `<button>`標籤時，就會執行 `conaole.log('HI');`的程式碼。\n\n但基於程式碼的使用性與維護性考量，現在不建議用此方法來綁定事件。\n\n### on-event 處理器(非 HTML 屬性)\n\n像是 `window`或`document`此類沒有實體元素的情況，一樣可以用 DOM API 提供的`on-event 處理器(on-event handler)`來處理事件\n\n```js\nwindow.onload = function(){\n  document.write(\"Hello world!\");\n};\n```\n\n上面程式碼會在 `window`觸發 `load` 事件時，執行相對應功能。\n\n另外，若是實體元素也可透過 DOM API 取得 DOM 物件後，在透過 on-event 處理器來處理事件。\n\n```html\n<button id='btn'>\n  Click\n</button>\n```\n\nㄊ\n\n```js\nconst btn = document.getElementById('btn');\n\nbtn.onclick = function(){\n  console.log('HI')\n};\n```\n\n若想解除事件，則重新指定`on-event hendler`為`null`\n\n### 事件監聽`EventTarget.addEventListener()`\n\n `.addEventListener()`有三個參數，分別為`事件名稱`、`事件處理器`、`執行機制`。\n\n- 事件名稱：HTML DOM 事件，為字串\n- 事件處理器：事件觸發時執行的 function\n- 執行機制(boolean)：決定事件以捕獲或是冒泡機制執行。\n\n用此方法來註冊事件的好處是可以重複指定多個`處理器(handler)`給同一個標籤的同一個事件。\n\n```js\nvar btn = document.getElementById('btn');\n\nbtn.addEventListener('click', function(){\n  console.log('HI');\n}, false);\n\nbtn.addEventListener('click', function(){\n  console.log('HELLO');\n}, false);\n```\n\n點擊觸發事件：\n\n```text\n\"HI\"\n\"HELLO\"\n```\n\n若是要解除事件的註冊，則是透過 `removeEventListener()`來取消。\n\n## HTML DOM 事件\n\n> 參考資料：\n>\n> [HTML DOM 事件](https://www.runoob.com/jsref/dom-obj-event.html)\n\nHTML DOM 事件允許 javascript 在 html 檔案中註冊不同事件處理程序。\n\n事件通常和函式結合使用，函式不會在事件發生前被執行(如使用者點擊按鈕)。\n\n### DOM Event事件名稱整理\n\n|     屬性     | 描述                          |\n| :----------: | ----------------------------- |\n|     blur     | 物件失去焦點時                |\n|    change    | 物件內容改變時                |\n|    click     | 滑鼠點擊物件時                |\n|   dblclick   | 滑鼠連點二下物件時            |\n|    error     | 當圖片或文件下載產生錯誤時    |\n|    focus     | 當物件被點擊或取得焦點時      |\n|   keydown    | 按下鍵盤按鍵時                |\n|   keypress   | 按下並放開鍵盤按鍵後          |\n|    keyup     | 按下並放開鍵盤按鍵時          |\n|     load     | 網頁或圖片完成下載時          |\n|  mousedown   | 按下滑鼠按鍵時                |\n|  mousemove   | 介於over跟out間的滑鼠移動行為 |\n|   mouseout   | 滑鼠離開某物件四周時          |\n|  mouseover   | 鼠離開某物件四周時            |\n|   mouseup    | 放開滑鼠按鍵時                |\n|    resize    | 當視窗或框架大小被改變時      |\n|    scroll    | 當捲軸被拉動時                |\n|    select    | 當文字被選取時                |\n|    submit    | 當按下送出按紐時              |\n| beforeunload | 當使用者關閉(或離開)網頁之前  |\n|    unload    | 當使用者關閉(或離開)網頁之後  |","tocContent":""}