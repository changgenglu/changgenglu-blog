{"name":"SOLID 物件導向原則.md","content":"# SOLID 物件導向原則\r\n\r\n> 參考資料\r\n>\r\n> [物件導向設計原則 SOLID](https://clouding.city/php/solid/)\r\n\r\n## SPR 單一職責原則\r\n\r\n> Single Responsibility Principle\r\n\r\n### 定義\r\n\r\n應該且僅有一個原因引起類別的變更，讓類別只有一個職責。\r\n\r\n### 秘訣\r\n\r\n- 關注點分離\r\n- 不應該因為貪圖方便塞在一起\r\n- 若切分太細，會有類別太多的問題\r\n\r\n### 提醒\r\n\r\n- 設計階段就可以避開類別職責太大的問題\r\n- 在維護階段需小心別又讓類別職責變多\r\n\r\nBad\r\n\r\n```php\r\nclass UserSettings\r\n{\r\n    private $user;\r\n\r\n    public function __construct(User $user)\r\n    {\r\n        $this->user = $user;\r\n    }\r\n\r\n    public function changSettings(array $settings): void\r\n    {\r\n        if ($this->verifyCredentials()) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private function verifyCredentials(): bool\r\n    {\r\n        //\r\n    }\r\n}\r\n```\r\n\r\nGood\r\n\r\n```php\r\nclass UserAuth\r\n{\r\n    private $user;\r\n\r\n    public function __construct(User $user)\r\n    {\r\n        $this->user = $user;\r\n    }\r\n\r\n    public function verifyCredentials(): bool\r\n    {\r\n        //\r\n    }\r\n}\r\n\r\nclass UserSetters\r\n{\r\n    private $user;\r\n\r\n    private $auth;\r\n\r\n    public function __construct(User $user)\r\n    {\r\n        $this->user = $user;\r\n        $this->auth = new UserAuth($user);\r\n    }\r\n\r\n    public function ChangSettings(array $settings): void\r\n    {\r\n        if ($this->auth->verifyCredentials()) {\r\n            //\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Open Closed Principle 開放封閉原則\r\n\r\n### 定義\r\n\r\n軟體中的對象(類別、函數)，對於擴展是開放的，對於修改是封閉的。\r\n\r\n### 秘訣\r\n\r\n- 只考慮抽象層級的介面互動\r\n- 把變化委託給其他類別處理\r\n- 只異動 metadata 或 config\r\n\r\n### 提醒\r\n\r\n- 不是所有程式都遵守 OCP\r\n- 可能一開始無法預想到要擴充，但可以透過重構完成\r\n- 不要過度用繼承的方式來進行擴充\r\n\r\nBad\r\n\r\n```php\r\nabstract class Adapter\r\n{\r\n    protected $name;\r\n\r\n    public function getName(): string\r\n    {\r\n        return $this->name;\r\n    }\r\n}\r\n\r\nclass AjaxAdapter extends Adapter\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct();\r\n\r\n        $this->name = 'ajaxAdapter';\r\n    }\r\n}\r\n\r\nclass NodeAdapter extends Adapter\r\n{\r\n    public function __construct()\r\n    {\r\n        parent::__construct();\r\n\r\n        $this->name = 'nodeAdapter';\r\n    }\r\n}\r\n\r\nclass HttpRequester\r\n{\r\n    private $adapter;\r\n\r\n    public function __construct(Adapter $adapter)\r\n    {\r\n        $this->adapter = $adapter;\r\n    }\r\n\r\n    public function fetch(string $url): promise\r\n    {\r\n        $adapterName = $this->adapter->getName();\r\n\r\n        if ($adapterName === 'ajaxAdapter') {\r\n            return $this->makeAjaxCall($url);\r\n        } elseif ($adapterName === 'httpNodeAdapter') {\r\n            return $this->makeHttpCall($url);\r\n        }\r\n    }\r\n\r\n    private function makeAjaxCall(string $url): promise\r\n    {\r\n        // request and return promise\r\n    }\r\n\r\n    private function makeHttpCall(string $url): promise\r\n    {\r\n        // request and return promise\r\n    }\r\n}\r\n```\r\n\r\nGood\r\n\r\n```php\r\ninterface Adapter\r\n{\r\n    public function request(string $url): promise;\r\n}\r\n\r\nclass AjaxAdapter implements Adapter\r\n{\r\n    public function request(string $url): promise\r\n    {\r\n        // request and return promise\r\n    }\r\n}\r\n\r\nclass NodeAdapter implements Adapter\r\n{\r\n    public function request(string $url): promise\r\n    {\r\n        // request and return promise\r\n    }\r\n}\r\n\r\nclass HttpRequester\r\n{\r\n    private $adapter;\r\n\r\n    public function __construct(Adapter $adapter)\r\n    {\r\n        $this->adapter = $adapter;\r\n    }\r\n\r\n    public function fetch(string $url): promise\r\n    {\r\n        return $this->adapter->request($url);\r\n    }\r\n}\r\n```\r\n\r\n## Liskov Substitution Principle 里氏替換原則\r\n\r\n### 定義\r\n","tocContent":""}