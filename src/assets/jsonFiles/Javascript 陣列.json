{"name":"Javascript 陣列.md","content":"# JavaScript 陣列\n\n> 參考資料：\n>\n> [JavaScript Array 陣列操作方法大全 ( 含 ES6 )](https://www.oxxostudio.tw/articles/201908/js-array.html)\n\n>\n\n## 改變原始陣列\n\n### push() 加入陣列最後一個位置\n\n將值加入陣列的最後一個位置，push() 會回傳新的陣列長度。\n\n```javascript\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8];\nconsole.log(arr.push(9, 10)); // 10\nconsole.log(arr); // [1, 2, 3, 4, 5, 6, 7, 8, ,9, 10]\n```\n\n### pop() 取出陣列的最後一個元素\n\n```javascript\nlet arr = [1, 2, 3, 4, 5, 6];\nlet new_arr = arr.pop();\nconsole.log(arr); // [1,2,3,4,5]\nconsole.log(new_arr); // 6\n```\n\n### shift() 取出並移除陣列的第一個元素\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\nlet new_arr = arr.shift();\nconsole.log(arr); // [2, 3, 4, 5]\nconsole.log(new_arr); // 1\n```\n\n### unshift() 將元素添加到第一個位置\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\narr.unshift(100, 200, 300);\nconsole.log(arr); // [100, 200, 300, 1, 2, 3, 4, 5]\n```\n\n### reverse() 反轉陣列\n\n```javascript\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();\nconsole.log(arr); // [5, 4, 3, 2, 1]\n```\n\n### splice(start, delete_count, item) 新增或移除陣列中指定位置的元素\n\n可以移除或新增陣列的元素，包含三個參數\n\n- start 要編輯的序列號碼\n- delete_count 要移除的長度(選填，若不填，則將第一個號碼位置面的所有元素清除，若為 0 則不刪除元素)\n- item 要添加的內容(選填)\n\n```javascript\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8];\narr.splice(5, 1);\nconsole.log(arr); // [1, 2, 3, 4, 5, 7, 8] (6 被移除了)\n```\n\n設定第三個參數就能添加或取代元素\n\n```javascript\nlet arr = [1, 2, 3, 4, 5, 6, 7, 8];\narr.splice(5, 1, 100);\nconsole.log(arr); // [1, 2, 3, 4, 5, 100, 7, 8]; (6 被移除，100 被加到第五的位置)\n```\n\nsplice 方法會回傳被刪除的元素，若無刪除元素，則回傳空陣列\n\n### sort() 針對陣列的元素進行排列\n\n- 未帶入參數:\n\n  預設排序為依照陣列內元素的 code UTF-16 的順序排序。\n\n  ```js\n  const arr_1 = [\n    null,\n    2,\n    8,\n    undefined,\n    NaN,\n    200,\n    \"Hi\",\n    \"apple\",\n    \"\",\n    \"#\",\n    \"!\",\n    \"2\",\n  ];\n\n  arr_1.sort();\n\n  console.log(arr_1);\n  // [ '', '!', '#', '2', 2, 200, 8, 'Hi', NaN, 'apple', null, undefined ]\n  ```\n\n  `sort()` 會將所有元素轉成字串後，以第一個字元為對象進行排序。符號會先被篩選出來，接著是數字，接著是字母。\n\n- 傳入匿名函數\n\n  `sort()` 會依匿名函式的參數與回傳的值當作排序依據\n\n  - 當回傳值為負數時，前面的數放在前面\n  - 當回傳值為正數時，後面的數在前面\n  - 當回傳值為零時，保持不動\n\n  ```js\n  // 沒有給參數的預設排序\n  const arr = [5, 9, 1, 3, 2, 6];\n  arr.sort(); // [1, 2, 3, 5, 6, 9]\n\n  // 以匿名函式回參數做「升序」排序\n  arr.sort(function (a, b) {\n    return a - b; // a - b > 0\n  });\n  // [1, 2, 3, 5, 6, 9]\n\n  // 如果要反過來做「降序」排序\n  arr.sort(function (a, b) {\n    return b - a;\n  });\n  // [9, 6, 5, 3, 2, 1]\n  ```\n\n  為什麼參數相減就能判斷排序？\n\n  ```js\n  const arr = [5, 9, 1, 3, 2, 6];\n  // 升序\n  arr.sort(function (a, b) {\n    if (a > b) {\n      return 1; // 正數時，後面的數放在前面\n    } else {\n      return -1; // 負數時，前面的數放在前面\n    }\n  });\n\n  // 降序\n  arr.sort(function (a, b) {\n    if (a < b) {\n      return 1; // 正數時，後面的數放在前面\n    } else {\n      return -1; // 負數時，前面的數放在前面\n    }\n  });\n\n  // 升序 另一種寫法，就會精簡到像最上面那樣！\n  arr.sort(function (a, b) {\n    if (a > b) {\n      // a > b  等於 a - b > 0\n      return a - b;\n    } else {\n      return a - b;\n    }\n  });\n  ```\n\n### copyWithin()\n\n### fill()　置換陣列中的值\n\n會將陣列中所有元素，置換為指定的值。\n\n- fill(value, start, end)\n  - value 必填，欲替換的值\n  - start 可選，起使位置(包含該位置)\n  - end 可選，停止位置(不包含此位置)\n\n> 使用 fill() 會改變原本的陣列內容\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\na.fill(\"a\");\nconsole.log(a); // ['a','a','a','a','a','a','a','a']\n\nlet b = [1, 2, 3, 4, 5, 6, 7, 8];\nb.fill(\"b\", 3, 5);\nconsole.log(b); // [1,2,3,'b','b',6,7,8]\n```\n\n## 回傳陣列元素資訊或索引值\n\n### length() 取得陣列長度\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nconsole.log(a.length); // 8\n```\n\n### indexOf()\n\n### lastIndexOf()\n\n### find() 回傳第一個符合判斷條件的元素\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nconsole.log(a.find((e) => e > 3)); // 4\nconsole.log(a.find((e) => e < 0)); // undefined\n```\n\n### findIndex()\n\n### filter() 回傳條件為 true 的元素組成的陣列\n\n會將陣列中每一個元素，帶入指定的函式做判斷，若元素符合判斷條件會傳出成唯一個新的陣列元素。\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nconsole.log(a.filter((e) => e > 3)); // [4, 5, 6, 7, 8]\nconsole.log(a.filter((e) => e % 2 == 0)); // [2, 4, 6, 8]\n```\n\n## 針對每個元素進行處理\n\n### forEach()\n\n將陣列中每個元素套用到指定函式裡面進行運算。\n\n函式有三個參數：\n\n1. 表示每個元素的值(必填)\n2. 該元素的索引值(選填)\n3. 表示原本的陣列(選填)\n\n```javascript\nlet a = [1, 2, 3, 4, 5];\nlet b = 0;\na.forEach((item) => {\n  b = b + item;\n});\nconsole.log(b); // 15 => (1 + 2 + 3 + 3 + 4 + 5)\n```\n\n## 產生新的陣列或值\n\n### join()\n\n### concat()\n\n### slice() 擷取陣列，回傳指定範圍元素的新陣列\n\n- slice(startIndex, endIndex)\n  - startIndex 必須，起始位置的 index，包含此位置。\n  - endIndex 可選，擷取結束位置的索引，不包含此位置。預設為擷取至陣列末端。\n\n```js\nlet arr = [1, 2, 3, 4, 5];\n\n// 擷取位置 1 到位置 3 (不包含)的元素\nlet answer = arr.slice(1, 3);\n\nconsole.log(answer); // [2,3]\nconsole.log(arr); // [1,2,3,4,5] (原陣列未被修改)\n```\n\n若傳入負數索引為引數，則表示從陣列末尾開始計算。\n\n```js\nlet arr = [1, 2, 3, 4, 5];\n\n// 擷取倒數第二元素到陣列末端\nlet answer = arr.slice(-2);\n\nconsole.log(answer); // [4,5]\n```\n\n### map() 處理陣列中每一個元素，最後回傳一個新的陣列\n\n裡面有一個函式(必填)和一個回傳函式裡面的 this 參數(選填)，函式中包含三個參數：\n\n1. 每個元素的值(必填)\n2. 當前元素的 index 值(選填)\n3. 當前的陣列(選填)\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nlet b = a.map((e) => {\n  return e + 10;\n});\nconsole.log(b); // [11, 12, 13, 14, 15, 16, 17, 18]\n```\n\n套用第二和第三個參數的變化\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nlet b = a.map((e, i, arr) => {\n  return `${e}${i}${arr.find((e) => e % 5 == 1)}`; // 組合成「元素 + 索引值 + 除以五餘數為 1 的元素」\n});\nconsole.log(b); // ['101', '211', '321', '431', '541', '651', '761', '871']\n```\n\n若要使用回傳函式裡 this 的函數，則「不能使用」箭頭函式，因為箭頭函式的 this 指向，和函式的 this 指向不同，所以要用一般的函式處理。\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nlet b = a.map(function (e) {\n  return e + this; // 此處的 this 為 10\n}, 10);\nconsole.log(b); // [11, 12, 13, 14, 15, 16, 17, 18]\n```\n\n### reduce() 計算陣列中每個元素，並將結果與下個元素做計算\n\n可以將陣列中的每一個元素做計算，每次計算的結果，會再與下個元素做計算到結束為止。\n\n包含一個函式，函式內有四個參數：\n\n1. 計算的值(必填)\n2. 取得的元素(必填)\n3. 該元素的 index 值(選填)\n4. 原本的陣列 (選填)\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nlet b = a.reduce(function (total, e) {\n  return total + e;\n});\nconsole.log(b); // 36 => (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 = 36)\n```\n\n### reduceRight() 計算方式為從右到左\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nlet b = a.reduce(function (total, e) {\n  return total - e;\n});\nconsole.log(b); // -34 (1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 = -34)\nlet c = a.reduceRight(function (total, e) {\n  return total - e;\n});\nconsole.log(c); // -20 (8 - 7 - 6 - 5 - 4 - 3 - 2 - 1 = -20)\n```\n\n### flat() 將多維陣列扁平化\n\n可以將一個多維陣列的深度轉換為一維(扁平化)，他有一個選填的參數，代表要轉換的深度，其預設為 1，如果深度很多層，可以用`infinity`來全部展開成一維陣列。\n\n```javascript\nlet a = [1, 2, [3], [4, [5, [6]]]];\nlet b = a.flat();\nlet c = a.flat(2);\nlet d = a.flat(Infinity);\nconsole.log(b); // [1, 2, 3, 4, [5, [6]]]\nconsole.log(c); // [1, 2, 3, 4, 5, [6]]\nconsole.log(d); // [1, 2, 3, 4, 5, 6]\n```\n\n### flatMap() map + flat()\n\n在運算後直接將陣列扁平化\n\n```javascript\nlet a = [1, 2, [3], [4, 5]];\nlet b = a.flatMap((e) => e + 1);\nlet c = a.map((e) => e + 1).flat();\nconsole.log(b); // [2, 3, \"31\", \"4,51\"] ( 可以看到 b 和 c 得到的結果相同 )\nconsole.log(c); // [2, 3, \"31\", \"4,51\"]\n```\n\n### Array.from()\n\n### Array.of() 將數值、字串等內容，轉換為陣列\n\n```javascript\nlet a = Array.Of(1, \"a\", 2, \"b\", 3);\nconsole.log(a); // [1, \"a\", 2, \"b\", 3]\n```\n\n### toString() 將陣列轉換為字串\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nlet b = a.toString();\nconsole.log(b); // 1,2,3,4,5,6,7,8\n```\n\n## 判斷\n\n### every() 全部符合判斷條件回傳 true\n\n只要有任何一個元素不符合判斷條件，就會回傳 false，全部符合就會回傳 true。\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6];\nconsole.log(a.every((e) => e > 3)); // false (1, 2 小於 3，3　等於 3)\nconsole.log(a.every((e) => e > 0)); // true\n```\n\n### some() 其中任一符合回傳 true\n\n會將陣列中每一個元素帶入指定的函式中做判斷，只要有任一個元素符合判斷標準，就會回傳 true，若完全不符合，回傳 false\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nconsole.log(a.some((e) => e > 3)); // true (因為 4, 5, 6 大於 3)\nconsole.log(a.some((e) => e > 6)); // false (因為全部都小於或等於 6)\n```\n\n### include() 陣列中使否包含指定值\n\n會判斷陣列中是否包含指定值，包含回傳 true，否則回傳 false。\n\n有兩個參數：\n\n1. 表示要判斷的值(必填)\n2. 陣列的開始位置(選填)\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nconsole.log(a.includes(2)); // true\nconsole.log(a.includes(2, 2)); // false (從陣列中第二個位置開始搜尋，沒有 2)\n```\n\n### Array.inArray()\n\n## 其他\n\n### keys()\n\n### valueOf() 回傳陣列的原始值\n\n```javascript\nlet a = [1, 2, 3, 4, 5, 6, 7, 8];\nlet b = a.valueOf();\nconsole.log(a); // [1, 2, 3, 4, 5, 6, 7, 8]\nlet c = a.valueOf();\na.shift();\nconsole.log(a); // [2, 3, 4, 5, 6, 7, 8]\nconsole.log(b); // [2, 3, 4, 5, 6, 7, 8] ( 因為 a 的原始值更動了，所以 b 也變了 )\nconsole.log(c); // [2, 3, 4, 5, 6, 7, 8]\n```\n","tocContent":"- [JavaScript 陣列](#javascript-陣列)\n  - [改變原始陣列](#改變原始陣列)\n    - [push() 加入陣列最後一個位置](#push-加入陣列最後一個位置)\n    - [pop() 取出陣列的最後一個元素](#pop-取出陣列的最後一個元素)\n    - [shift() 取出並移除陣列的第一個元素](#shift-取出並移除陣列的第一個元素)\n    - [unshift() 將元素添加到第一個位置](#unshift-將元素添加到第一個位置)\n    - [reverse() 反轉陣列](#reverse-反轉陣列)\n    - [splice(start, delete\\_count, item) 新增或移除陣列中指定位置的元素](#splicestart-delete_count-item-新增或移除陣列中指定位置的元素)\n    - [sort() 針對陣列的元素進行排列](#sort-針對陣列的元素進行排列)\n    - [copyWithin()](#copywithin)\n    - [fill()　置換陣列中的值](#fill置換陣列中的值)\n  - [回傳陣列元素資訊或索引值](#回傳陣列元素資訊或索引值)\n    - [length() 取得陣列長度](#length-取得陣列長度)\n    - [indexOf()](#indexof)\n    - [lastIndexOf()](#lastindexof)\n    - [find() 回傳第一個符合判斷條件的元素](#find-回傳第一個符合判斷條件的元素)\n    - [findIndex()](#findindex)\n    - [filter() 回傳條件為 true 的元素組成的陣列](#filter-回傳條件為-true-的元素組成的陣列)\n  - [針對每個元素進行處理](#針對每個元素進行處理)\n    - [forEach()](#foreach)\n  - [產生新的陣列或值](#產生新的陣列或值)\n    - [join()](#join)\n    - [concat()](#concat)\n    - [slice() 擷取陣列，回傳指定範圍元素的新陣列](#slice-擷取陣列回傳指定範圍元素的新陣列)\n    - [map() 處理陣列中每一個元素，最後回傳一個新的陣列](#map-處理陣列中每一個元素最後回傳一個新的陣列)\n    - [reduce() 計算陣列中每個元素，並將結果與下個元素做計算](#reduce-計算陣列中每個元素並將結果與下個元素做計算)\n    - [reduceRight() 計算方式為從右到左](#reduceright-計算方式為從右到左)\n    - [flat() 將多維陣列扁平化](#flat-將多維陣列扁平化)\n    - [flatMap() map + flat()](#flatmap-map--flat)\n    - [Array.from()](#arrayfrom)\n    - [Array.of() 將數值、字串等內容，轉換為陣列](#arrayof-將數值字串等內容轉換為陣列)\n    - [toString() 將陣列轉換為字串](#tostring-將陣列轉換為字串)\n  - [判斷](#判斷)\n    - [every() 全部符合判斷條件回傳 true](#every-全部符合判斷條件回傳-true)\n    - [some() 其中任一符合回傳 true](#some-其中任一符合回傳-true)\n    - [include() 陣列中使否包含指定值](#include-陣列中使否包含指定值)\n    - [Array.inArray()](#arrayinarray)\n  - [其他](#其他)\n    - [keys()](#keys)\n    - [valueOf() 回傳陣列的原始值](#valueof-回傳陣列的原始值)"}