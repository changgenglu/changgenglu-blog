{"name":"MySQL學習筆記.md","content":"# MySQL 學習筆記\r\n\r\n>\r\n\r\n## 環境設定\r\n\r\n### 設定時區\r\n\r\n- `show variables like '%time_zone%'` 查看當前時區\r\n  - 會返回兩行紀錄，第一行為 system_time_zone(系統時區)，第二行為 time_zone(資料庫時區)\r\n- `set time_zone='+8:00'` 設置當前請求的時區\r\n  - 不須重新連接 mysql\r\n  - 僅當前的請求有效，若關閉則回復原始值。\r\n- `set global time_zone='+8:00` 設定全域時區\r\n  - 全域請求有效，但必須重新連接 mysql 才會生效(exit 後重新 mysql -uroot -p 進行連接)。\r\n  - 不須重啟 mysql，重啟後回復原始值\r\n- 修改 mysql 設定文件\r\n  - 在 my.ini 中添加\r\n  - 須重啟 mysql\r\n\r\n```ini\r\n[mysqld]\r\ndefault-time-zone=+00:00\r\ncharacter-set-server=utf8mb4\r\n```\r\n\r\n### MariaDB 設定命名時區\r\n\r\n命名時區是指使用時區的名字，而不是標準時間的小時差。例如 `Asia/Taipei` 就是命名時區，而不是 +08:00。\r\n在 MariaDB 中域設有時區表，但預設為空，需要填充這些表後才能使用。\r\n\r\n#### 從 zoneinfo 匯入時區\r\n\r\n若系統環境為類 Unix 系統(Mac OS, Linux, FreeBSD, Sun Solaris)，zoneinfo 文件已經包含在系統中。\r\n輸入指令將時區表加入 MariaDB 中的 MySQL 資料庫中\r\n\r\n```bash\r\nmysql_tzinfo_to_sql /usr/share/zoneinfo | mariadb -u root -p mysql\r\n&\r\nmysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root -p mysql\r\n```\r\n\r\n#### 從 mysql 提供的指令碼匯入\r\n\r\n由於 windows 沒有 zoneinfo 資料庫，所以必須透過 sql 指令碼匯入時區表\r\n\r\n- 下載 sql 指令碼並解壓縮：[https://downloads.mysql.com/general/timezone_2022g_posix_sql.zip](https://downloads.mysql.com/general/timezone_2022g_posix_sql.zip)\r\n- 登入 mariaDB\r\n\r\n```bash\r\n.\\mysql.exe -u root -p\r\n# 輸入 root 使用者密碼\r\n```\r\n\r\n- 連接 MySQL 資料庫\r\n\r\n```bash\r\nUSE mysql\r\n```\r\n\r\n- 從 SQL 指令碼匯入資料\r\n\r\n```bash\r\nSOURCE C:\\Users\\Adam\\Downloads\\timezone_posix.sql\r\n```\r\n\r\n- 檢查是否正確匯入\r\n\r\n```bash\r\nSELECT * FROM mysql.time_zone_name;\r\n```\r\n\r\n```output\r\n+----------------------------------+--------------+\r\n| Name                             | Time_zone_id |\r\n+----------------------------------+--------------+\r\n| Africa/Abidjan                   |            1 |\r\n| Africa/Accra                     |            2 |\r\n| Africa/Addis_Ababa               |            3 |\r\n| Africa/Algiers                   |            4 |\r\n| Africa/Asmara                    |            5 |\r\n| Africa/Asmera                    |            6 |\r\n| Africa/Bamako                    |            7 |\r\n| Africa/Bangui                    |            8 |\r\n| Africa/Banjul                    |            9 |\r\n| Africa/Bissau                    |           10 |\r\n...\r\n...\r\n| Zulu                             |          597 |\r\n+----------------------------------+--------------+\r\n597 rows in set (0.000 sec)\r\n```\r\n\r\n## 資料表語法\r\n\r\n- 建立資料表\r\n\r\n  ```sql\r\n  CREATE TABLE 資料表名稱 (\r\n    欄位名稱  資料型態,\r\n    ...\r\n  )\r\n  ```\r\n\r\n- 增加資料表欄位\r\n\r\n  ```sql\r\n  ALTER TABLE 資料表 ADD 欄位名稱 資料型態;\r\n  ```\r\n\r\n- 增加資料表內容\r\n\r\n  ```sql\r\n  INSERT INTO 資料表 (欄位1, 欄位2, 欄位3, ...)\r\n  VALUES (值1,  值2,  值3, ...);\r\n  ```\r\n\r\n- 更新資料欄位\r\n\r\n  ```sql\r\n  UPDATE 資料表 SET 欄位1 = '資料1', 欄位2 = '資料2' WHERE 條件;\r\n  ```\r\n\r\n- 刪除資料欄位\r\n\r\n  ```sql\r\n  delete from 資料表 where 欄位 = ;\r\n  truncate table 資料表;\r\n  drop table 資料表\r\n\r\n  -- 刪除外鍵欄位\r\n  ALTER TABLE 資料表 DROP FOREIGN KEY FK_欄位 ; -- 先刪除外鍵名稱\r\n  ALTER TABLE 資料表 DROP `欄位`;               --  才能刪除欄位\r\n  ```\r\n\r\n- 選擇欄位\r\n\r\n  ```sql\r\n      SELECT 別名.欄位,\r\n      DISTINCT 別名.欄位          -- 欄位資料不重複\r\n      CONCAT(別名.欄位, 別名.欄位) -- 欄位合併\r\n      FROM 資料表 as 別名         -- 別名\r\n\r\n      join 資料表B on 資料表別名.欄位 = 資料表B別名.欄位\r\n\r\n      WHERE 別名.欄位 = \"內容\" AND 別名.欄位 = 內容  -- ...而且...\r\n      WHERE (別名.欄位 = \"內容\" OR 別名.欄位 = 內容) -- (..或者..)\r\n                                                  -- OR的前後要加上括弧，將條件限制住\r\n      WHERE 別名.欄位 LIKE \"%內容%\"                 -- 內容部分有符合者\r\n      WHERE 別名.欄位 BETWEEN 起始 and 結束         -- 連續不間段的區間\r\n      WHERE 別名.欄位 in (內容, 內容)               -- 挑選同一型態指定內容\r\n\r\n      GROUP BY                -- 相同的東西記錄在一起\r\n      HAVING                  -- 接在 GROUP BY 之後設定條件\r\n      UNION\r\n      ORDER BY 別名.欄位       -- 排序(預設由小到大)\r\n      ORDER BY 別名.欄位 DESC  -- 排序由大到小\r\n      LIMIT 起始位置, 資料筆數; -- 選擇資料中要顯示的項目\r\n  ```\r\n\r\n- 使用者定義變數\r\n\r\n  ```sql\r\n  SELECT @x; --> x值為NULL\r\n\r\n  SET @x = 1;\r\n  SELECT @x, ProductID  FROM Products;\r\n  ```\r\n\r\n- 子查詢:查詢裡面有查詢\r\n\r\n  ```sql\r\n  --> 檢查資料表302中的 ProductID，不存在於資料表301 的 ProductID\r\n  SELECT * FROM lab302\r\n  WHERE ProductID NOT in (SELECT ProductID FROM lab301)\r\n  ```\r\n\r\n- inner join | left join | right join | cross join\r\n\r\n  ```sql\r\n  -- 結合兩個表中某欄位具有相同資料，一起列出查詢結果\r\n  inner join\r\n  -- 列出左/右邊的表，另一邊的表列出有相同的部分，不足的欄位印出NULL\r\n  left join | right join\r\n  -- 將所有可能的組合通通列出來(交叉查詢)\r\n  cross join\r\n  ```\r\n\r\n## 資料型態\r\n\r\n- 字串類型\r\n\r\n  - `char()` 與 `varchar()` 的空間大小是以後面參數來表示欄位的大小，不同的地方在於`varchar()` 是以動態的方式儲存。\r\n\r\n    ```sql\r\n    char(10) = \"hello     \" -- 10 bytes  包含了五個空格\r\n    varchar(10) = \"hello\"   -- 5 bytes\r\n    ```\r\n\r\n  - `char()` 固定大小浪費空間，但是所需的計算時間少。\r\n  - `varchar()` 不固定長度，但是每一次抓取都要運算，花費 CPU 運算時間\r\n\r\n- 數值類型\r\n\r\n  |    type     | storage(bytes) |          signed          |    unsigned    |\r\n  | :---------: | :------------: | :----------------------: | :------------: |\r\n  |  `TINYINT`  |       1        |        -128 ~ 127        |    0 ~ 225     |\r\n  | `SMALLINT`  |       2        |      -32768 ~ 32767      |   0 ~ 65535    |\r\n  | `MEDIUMINT` |       3        |    -8388608 ~ 8388607    |  0 ~ 16777215  |\r\n  |    `int`    |       4        | -2147483648 ~ 2147483647 | 0 ~ 4294967295 |\r\n  |  `BIGINT`   |       8        |  $-2^{63}$ ~ $2^{63}-1$  | 0 ~ $2^{64}-1$ |\r\n\r\n- `DECIMAL(x, y)` : x = 數值長度(包含小數點)，y = 小數點後的位數(不足補零)\r\n\r\n- 時間類型\r\n\r\n  - `YEAR` : YYYY\r\n  - `TIME` : HH:MM:SS\r\n  - `DATE` : YYYY-MM-DD\r\n  - `DATETIM`E : YYYY-MM-DD HH:MM:SS\r\n\r\n- 鍵名\r\n\r\n  - `primary key` 主索引鍵(主鍵)\r\n  - `foreign key` 外部索引鍵(外來鍵)\r\n  - `UNIQUE` 唯一 不能有重複的資料\r\n  - `_INCREMENT` 流水號\r\n  - `DEFAULT =` 預設值\r\n  - `CHECK ()` 資料寫入前的檢查(預設標準)\r\n\r\n- functions | method | 方法 | 函式 | 副程式 | 函數\r\n\r\n  - `count()` : 計算數量\r\n  - `MAX()` : 找最大的那一個\r\n  - `AVG()` : 平均值\r\n  - `ABS()` : 取絕對值\r\n  - `ROUND()` : 小數點四捨五入\r\n\r\n  ***\r\n\r\n  - 取得現在時間\r\n    - `CURRENT_DATE()`\r\n    - `SYSDATE()`\r\n    - `NOW()`\r\n\r\n  ***\r\n\r\n  - `Year()` : 年\r\n\r\n  - `Month()` : 月\r\n\r\n  - `DAY()` : 日\r\n\r\n  - `LENGTH()` : 資料的大小 bytes\r\n\r\n  - `CHAR_LENGTH(`) : 字串的長度\r\n\r\n  ***\r\n\r\n  - `POWER(數值, N次方)` : 計算次方\r\n\r\n  - `SUBSTRING(欄位, 起始位置, 擷取長度)` : 擷取字串\r\n\r\n  - `INSTR(欄位, '指定的文字')` : 找出指定位置的位置，回傳數值\r\n\r\n  - `LEFT(欄位, 擷取長度)` : 從左邊開始擷取到指定長度\r\n\r\n  - `REPLACE(目標欄位, '目標字串', '要取代上字串')` :取代指定字元\r\n\r\n  - `RPAD(內容, 內容的長度, '取代的字')` : 內容不足或是超過的部分會被取代\r\n\r\n  - `REPEAT('要重複的字', 重複次數)` :重複輸入\r\n\r\n  ***\r\n\r\n  - 將字串轉換型態\r\n    - `CONVERT('字串', 型態)`\r\n    - `CAST('字串' AS 型態)`\r\n\r\n  ***\r\n\r\n  - `DATE_FORMAT(日期, \"%Y\")` :日期格式，取得日期中的項目\r\n\r\n  ***\r\n\r\n  - `IF(判斷條件, \"條件為T\", \"條件為F\")` :條件判斷為 true 返回 1，否則返回 2\r\n\r\n  - `ELT(數值、清單, '值1', '值2'......'值n')` :透過數值清單傳回指定之索引的項目\r\n\r\n  - `IFNULL(x, y)` : 如果 x 有值回傳 x，如果 x 為 NULL 回傳 y\r\n\r\n  - `ISNULL(x)` : 如果 x 為 NULL，ISNULL(x)會回傳 1，否則回傳 0\r\n\r\n  - `NULLIF(x, y)` : 如果 x = y 回傳 NULL，否則回傳 x\r\n\r\n  ***\r\n\r\n  - 類似 if else\r\n\r\n    ```sql\r\n    CASE\r\n      when condition(條件為true) then \"返回結果\"\r\n      --如果條件為false就繼續下一行判斷\r\n      when condition(條件為true) then \"返回結果\"\r\n      else \"返回結果\" -- 如果上述條件都不符，就返回此結果\r\n    end\r\n    ```\r\n\r\n  - 不等於：\r\n\r\n    - `<>`\r\n    - `!=`\r\n    - `NOT`\r\n\r\n  - 比較：\r\n    - `>=`\r\n    - `<=`\r\n\r\n## 資料庫設計原則\r\n\r\n> 參考資料：\r\n>\r\n> [詳記一次 MySQL 千萬級大表最佳化過程！](https://www.ipshop.xyz/14954.html)\r\n\r\n### 資料庫設計和表建立時就要考慮效能\r\n\r\n表設計時要注意的東西\r\n\r\n1. 資料表欄位避免出現 null，null 值不容易查詢最佳化，且佔用額外的索引空間。推薦使用數字 0 代替 null。\r\n2. 盡量使用 INT 而非 BIGINT，如果非負，則加上 UNSIGNED (這樣做數值會擴大一倍)，若使用 TINYINT、SMALLINT、MEDIUM_INT 更好。\r\n3. 使用列舉或整數代替字串型別。\r\n4. 資料表不要有太多欄位，在 20 個以內。\r\n5. 用整型來存 ip\r\n\r\n索引\r\n\r\n1. 索引並不是越多越好。要根據查詢有針對性的建立，考慮在 WHERE 和 ORDER BY 命令上涉及的列建立索引，可根據 EXPLAIN 來檢視是否用了索引還是全表掃描。\r\n2. 避免在 WHERE 子句中對欄位進行 NULL 值的判斷。否則將導致引擎放棄使用 index 而使用全表掃描。\r\n3. 值分布很稀少的欄位不適合建立索引。例如「性別」這種只有兩三個值的欄位。\r\n4. 字元欄位只建字首索引。\r\n5. 字元欄位最好不要作為主鍵。\r\n6. 不用外來見，用程式保證約束。\r\n7. 盡量不使用 UNIQUE，由程式保證約束。\r\n8. 使用多列索引時，主意順序和查詢條件保持一致，同時刪除不必要的單列索引。\r\n\r\n#### 選擇適合的資料型別\r\n\r\n1. 使用可存下面資料的最小資料型別：整型 < date, time < char, varchar < blob。\r\n2. 使用簡單的資料型別，整型比字元處理開銷更小，因為字串的比較複雜。如：INT 型別儲存時間型別，BIGINT 型別轉 ip 函示。\r\n3. 使用合理的欄位屬性長度，固定程度的表會更快。使用 enum、char 而不是 varchar。\r\n4. 盡可能使用 NOT NULL 定義欄位。\r\n5. 盡量使用 text，非用不可時，最好分表。\r\n\r\n#### 選擇適合的索引列\r\n\r\n1. 查詢頻繁的列，在 where, group by, order by, on 從句中出現的列。\r\n2. where 條件中，>=, between, in 以及 like 字串加萬用字元 (%) 出現的列。\r\n3. 長度小的列，索引欄位越小越好，因為資料庫的儲存單位是頁，一頁中能存下的資料越多越好。\r\n4. 離散度越大(不同的值多)的列，放在聯合索引前面。檢視離散度，透過統計不同的列直來實現，count 越大，離散度越高。\r\n\r\n### SQL 的編寫需要注意最佳化\r\n\r\n1. 使用 limit 對查詢結果的紀錄進行限定。\r\n2. 避免 select \\*，將要查詢的欄位列出來。\r\n3. 是用連線(join) 來代替子查詢。\r\n4. 拆分大的 delete 或 insert 陳述句。\r\n5. 可透過開啟慢查詢日誌來找出較慢的 SQL。\r\n6. 不進行列運算：SELECT id WHERE age + 1 = 10，任何對列的操作都將導致表掃描。他包括資料庫教程函式、計算運算式等等，查詢時要盡可能將操作移至等號右邊。\r\n7. SQL 陳述句盡可能簡單：一條 SQL 只能在一個 CPU 運算。大陳述句拆成小陳述句，減少鎖時間。一條大 SQL 可以堵死整個庫。\r\n8. OR 改成 IN：OR 的效率是 n 級別，IN 的效率是 log(n)級別，in 個數建議是控制在 200 以內。\r\n9. 不用函式和觸發器，在應用程式實現。\r\n10. 避免 %xxx 式的查詢。\r\n11. 少用 join\r\n12. 使用同型別進行比較，比如用 '123' 和 '123' 比，123 和 123 進行比較。\r\n13. 盡量避免在 WHERE 子句中使用 != 或 <> 運算子，引擎會放棄使用索引而進行全表掃描。\r\n14. 對於連續數值，使用 BETWEEN 不用 in：SELECT id FROM t WHERE num BETWEEN 1 AND 5\r\n15. 串列資了不要拿全表，要使用 LIMIT 來分頁，每頁數量也不要太大。\r\n\r\n#### 引擎選擇\r\n\r\n- MyISAM(MySQL 5.1 及之前版本的預設引擎)\r\n  - 不支援行鎖，讀取時對需要讀到的所有表加鎖，寫入時則對表加排他鎖。\r\n  - 不支援事務\r\n  - 不支援外來鍵\r\n  - 不支援崩潰後的安全恢復\r\n  - 在表有讀取查詢時，支援往表裡插入新紀錄。\r\n  - 支援 BLOB 和 TEXT 的前 500 個字元索引，支援全文索引。\r\n  - 支援延遲更新索引，極大提升寫入效能。\r\n  - 對於不會進行修的表，支援壓縮表，極大減少磁碟空間佔用。\r\n- InnoDB(MySQL 5.5 後成為預設索引)\r\n  - 支援行鎖，採用 MVCC 來支援高併發\r\n  - 支援事務\r\n  - 支援外來鍵\r\n  - 支援崩潰後的安全恢復\r\n  - 不支援全文索引\r\n\r\n> MyISAM 適合 SELECT 密集型的表，而 InnoDB 適合 INSERT 和 UPDATE 密集型的表。\r\n>\r\n> MyISAM 速度很快，佔用儲存空間也小，但若程式要求事務則 InnoDB 是必須的。\r\n\r\n#### 分割槽\r\n\r\n分割槽的過程是將一個表或索引分解為多個更小、更可管理的部分。對於開發者而言，分割槽後資料表的使用方式和未分割的資料表是一樣的，只不過在物理儲存上，原本該表只有一個數據檔案，現在變成了多個，每個分割槽都是獨立的物件，可以獨自處理，有可以作為一個更大物件的一部分進行處理。\r\n\r\n## DB 命名原則\r\n\r\n- 命名只能使用英文字母、數字、下劃線，以英文字母開頭\r\n- 避免用 MySQL 的保留字如：backup、call、group 等\r\n- 所有資料庫物件使用小寫字母\r\n\r\n### 資料庫命名\r\n\r\n- 不超過 30 個字元\r\n\r\n### 資料表命名\r\n\r\n- 一律使用複數名詞\r\n- 不超過 30 個字元\r\n- 多對多關係中的中間表命名，為兩個表名稱，中間以`_`區隔，以單數命名 例如：`admins`和`members`，中間表命名為`admin_member`\r\n\r\n### 欄位命名\r\n\r\n- 各表之間相同意義的欄位必須同名\r\n- 多單詞以`_`\r\n- 外鍵約束欄位，以關聯的父層資料表名加上父層資料表欄位名來命名，中間以`_`區隔  \r\n  例:父層資料表名`admins`，父層資料表欄位名`id`，關聯欄位名`admin_id`\r\n\r\n### 索引命名\r\n\r\n#### 外鍵索引\r\n\r\n- 資料表名稱\\_關聯欄位名稱\\_foreign\r\n\r\n## Function\r\n\r\n### CONVERT_TZ(dt,from_tz,to_tz) 轉換時區\r\n\r\n- dt 日期/時間\r\n- from_tz 原始時區\r\n- to_tz 目標時區\r\n\r\n```sql\r\nSELECT CONVERT_TZ('2020-12-01 01:00:00','+00:00','+08:00') AS Result;\r\n```\r\n\r\n```output\r\n+---------------------+\r\n| Result              |\r\n+---------------------+\r\n| 2020-12-01 09:00:00 |\r\n+---------------------+\r\n```\r\n\r\n### Event 事件\r\n\r\n用於定期執行某些資料庫任務\r\n\r\n- 用途：\r\n  - 自動化維護\r\n  - 刪除過期數據\r\n  - 複製存檔、生成報告\r\n\r\n#### 範例\r\n\r\n- devices 資料表需要定時刪除已被標記 delete_at 的裝置\r\n\r\n```sql\r\nCREATE EVENT delete_old_devices\r\nON SCHEDULE\r\n-- 每半年檢查一次，並刪除超過半年以上的資料\r\nEVERY 6 MONTH\r\nDO\r\n  DELETE FROM devices WHERE deleted_at < DATE_SUB(NOW(), INTERVAL 6 MONTH);\r\n```\r\n\r\n#### 基本使用\r\n\r\n- 查詢、刪除\r\n\r\n```sql\r\nSHOW EVENTS; -- 查詢\r\n\r\nDROP EVENT IF EXISTS <event_name>; --刪除，IF EXISTS可以避免報錯\r\n```\r\n\r\n- 啟用事件排程\r\n\r\n```sql\r\nSET GLOBAL event_scheduler = ON;\r\n```\r\n\r\n- 查看目前正在執行的程序\r\n\r\n```sql\r\nSHOW PROCESSLIST;\r\n```\r\n\r\n## 使用情境\r\n\r\n### 外鍵 onDelete 約束情況\r\n\r\n- 沒有加入`onDelete`  \r\n  如果在關聯中的限制屬性，沒有加入`onDelete`，此時刪除外鍵約束的父層資料表中的欄位，會出現#1451 error\r\n\r\n  ```cmd\r\n  #1451 - Cannot delete or update a parent row: a foreign key constraint fails (`test0505`.`posts`, CONSTRAINT `posts_user_id_foreign` FOREIGN KEY (`user_id`)     REFERENCES `users` (`id`))\r\n  ```\r\n\r\n- onDelete('set null')\r\n  刪除父層資料表的欄位時，同時會將關聯的子資料表中的欄位設為`null`。\r\n- onDelete('cascade')\r\n  刪除父層資料表的欄位時，同時會將關聯的子資料表中的欄位刪除。\r\n\r\n### ERROR: #1215 - Cannot add foreign key constraint\r\n\r\n- 可能原因:\r\n  1. 添加外鍵約束時，目標欄位須和引用欄位具有相同的數據類型，int signed with int signed 或 int unsigned with int unsigned\r\n  2. 在 not null 的欄位加上 on delete/update set null 的外鍵約束，須將該欄位設為 DEFAULT NULL\r\n\r\n### 刪除重複的資料\r\n\r\n#### 使用 `DISTINCT` 去除重複值\r\n\r\n需求：查找 `02:81:85:34:ED:DC` 表中的數據，將表中 `i`, `p`, `ep`, `eq`, `pf`, `created_at` 這六個欄位均重複的資料刪除，並重新整理 id\r\n\r\n先建立一個表，接者使用 `SELECT DISTINCT` 去除重複的值，並把去除重複值的資料，存入新資料表中\r\n\r\n```sql\r\nCREATE TABLE `02:81:85:34:ED:DC_copy` (\r\n  `id` int(10) UNSIGNED NOT NULL,\r\n  `i` json DEFAULT NULL,\r\n  `p` json DEFAULT NULL,\r\n  `ep` json DEFAULT NULL,\r\n  `eq` json DEFAULT NULL,\r\n  `pf` json DEFAULT NULL,\r\n  `created_at` datetime DEFAULT NULL\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\r\n\r\nINSERT INTO `02:81:85:34:ED:DC_copy` (`i`, `p`, `ep`, `eq`, `pf`, `created_at`)\r\nSELECT DISTINCT `i`, `p`, `ep`, `eq`, `pf`, `created_at` FROM `02:81:85:34:ED:DC`;\r\n```\r\n\r\n最後刪掉原表，並將複製的表改名\r\n\r\n```sql\r\ndrop tables `02:81:85:34:ED:DC`;\r\nalter table `02:81:85:34:ED:DC_copy` rename to `02:81:85:34:ED:DC`;\r\n```\r\n\r\n### 匯入 txt 檔\r\n\r\n建立資料表\r\n\r\n```sql\r\ncreate table `city_raw_data` (\r\n    `geonameid` int(10) NOT NULL,\r\n    `name` varchar(200) DEFAULT NULL,\r\n    `latitude` decimal(11, 8) DEFAULT NULL,\r\n    `longitude` decimal(11, 8) DEFAULT NULL,\r\n    `country code` varchar(10) DEFAULT NULL,\r\n    `timezone` varchar(40) DEFAULT NULL,\r\n    `modification date` date DEFAULT NULL\r\n) ENGINE = InnoDB DEFAULT CHARSET = utf8;\r\n```\r\n\r\n本地 txt 檔匯入\r\n在 txt 檔中，每一個欄位用 tab 鍵進行分隔\r\n\r\n```sql\r\nLOAD DATA INFILE \"C:/Users/RD/Desktop/ES.txt\" INTO TABLE `city_raw_data` (\r\n`geonameid`,`name`,`asciiname`,`alternatenames`,`latitude`,`longitude`,`feature class`,`feature code`,`country code`,`cc2`,`admin1 code`,`admin2 code``admin3 code`,`admin4 code`,`population`,`elevation`,`dem`,`timezone`,`modification date`\r\n)\r\n```\r\n\r\n或用指定的符號進行分隔，如：`|`\r\n\r\n```sql\r\nLOAD DATA INFILE \"C:/Users/RD/Desktop/ES.txt\" INTO TABLE `city_raw_data` FIELDS TERMINATED BY '|' (\r\n    `geonameid`,\r\n    `name`,\r\n    `latitude`,\r\n    `longitude`,\r\n    `country code`,\r\n    `timezone`,\r\n    `modification date`\r\n);\r\n```\r\n\r\n### 複合主鍵與聯合主鍵，索引與聯合(複合)索引\r\n\r\n#### 複合主鍵與聯合主鍵\r\n\r\n- **複合主鍵**：表的主鍵含有一個以上的欄位組成，不使用無業務含意的自增 id 作為主鍵\r\n\r\n```sql\r\ncreate table test\r\n(\r\n  'name' varchar(19) NOT NULL\r\n  'id' number\r\n  'value' varchar(10)\r\n  primary key ('name', 'id')\r\n)\r\n```\r\n\r\n`name` 和 `id` 欄位組合起來就是 test 表的複合主鍵，他的出現是因為 `name` 欄位可能會出現重複，所以要加上 `id` 欄位，如此可以保證紀錄的唯一性。\r\n\r\n一般而言，主見的欄位資料長度和字串字數越少越好。\r\n\r\n當表中只有一個主鍵時，他是唯一的索引；當表中有多個主鍵時，稱為複合主鍵，複合主鍵聯合保證唯一索引。\r\n\r\n某者個主鍵欄位值出現重複是沒問題的，只要不是有多筆資料的所有主鍵值完全一樣，就不算重複。\r\n\r\n- **聯合主鍵**：多個主鍵聯合形成一個主鍵組合。\r\n\r\n聯合主鍵的意義：用兩個字串(或多字串)來確定一條紀錄。這兩個字串都不唯一，可以分別重複。\r\n\r\n如：主鍵 A 和主鍵 B 組成聯合主鍵\r\n\r\n主鍵 A 跟主鍵 B 的資料可以完全相同，聯合就在於主鍵 A 和主鍵 B 形成的聯合主鍵是唯一的。\r\n下面的例子：主鍵 A 的數據是 1，主鍵 B 的數據也是 1，聯合主鍵其實是 11，11 是唯一值，不允許再出現 11 這個值。(即為多對多關係)\r\n\r\n| 主鍵 A | 主鍵 B |\r\n| :----: | :----: |\r\n|   1    |   1    |\r\n|   2    |   2    |\r\n|   3    |   3    |\r\n\r\n主鍵 A 與主鍵 B 的聯合主鍵值最多為：11, 12, 13, 21, 22, 23, 31, 32, 33\r\n\r\n#### 索引、聯合(複合)索引\r\n\r\n- **索引**：加快查詢速度的有效手段。\r\n\r\n  系統讀寫資料時，會自動選擇合適的索引作為存取路徑。\r\n\r\n  建立索引\r\n\r\n  ```sql\r\n  -- 建立索引\r\n  create [unique][cluster]index<索引名>\r\n\r\n  -- 刪除索引\r\n  drop index <索引名>\r\n  ```\r\n\r\n  建立資料表時同時建立索引\r\n\r\n  ```sql\r\n  CREATE TABLE your_table_name (\r\n    column1 datatype,\r\n    column2 datatype,\r\n    -- 其他列定義\r\n    INDEX index_name (column_name)  -- 在這裡添加索引\r\n  );\r\n  ```\r\n\r\n  當建立 `your_table_name` 時，同時定義了一個名為 `index_name` 的索引，並指定了要建立索引的列 `column_name`。\r\n  可以依照需求在資料表定義中添加多個索引。\r\n\r\n  - `INDEX` 關鍵字用於定義一個普通索引。如果要創建唯一鍵索引，您可以使用 UNIQUE INDEX。\r\n  - `index_name` 是您為索引指定的名稱，用於在以後引用索引。\r\n  - `column_name` 是您要為其建立索引的列名。\r\n\r\n  添加索引\r\n\r\n  ```sql\r\n  ALTER TABLE your_table_name\r\n  ADD INDEX index_name (column_name);\r\n  ```\r\n\r\n  - `your_table_name` 是您要向其添加索引的資料表名稱。\r\n  - `index_name` 是您為新索引指定的名稱。\r\n  - `column_name` 是您要為其建立索引的列名。\r\n\r\n  ```sql\r\n  ALTER TABLE users\r\n  ADD INDEX idx_users_email (email);\r\n  ```\r\n\r\n  索引是各種關係資料庫中，最常見的一種邏輯單元，是關係資料庫系統很重要的組成部分，對於提高檢索資料速度有很顯著的效果。\r\n  索引的原理是利用根據索引值得到行指針，然後快速定位到資料庫紀錄。\r\n\r\n  索引的使用：\r\n\r\n  1. 主鍵(預設自帶索引)和外鍵(以及一些可以跟其他表觀聯的字段)\r\n  2. where 子句中基常出現的字段。\r\n  3. 索引應該建立在小字段上，大數據字段(bit, image, test, blob)等，不適用\r\n\r\n- **聯合(複合)索引**\r\n\r\n```sql\r\n-- 建立聯合索引\r\ncreate index <索引名> on 表名(欄位1, 欄位2, ...);\r\n\r\n-- 例如：有聯合索引 (a, b, c, d)\r\nselect * from test where a=1 and b=2; -- a 和 b 索引都起作用\r\n```\r\n\r\n索引生效原則：按照聯合索引的順序，由前往後依次使用生效，如果中間某個索引沒有使用，那麼斷點前面的索引部份起作用，斷點後面的索引沒有起作用。\r\n\r\n例如\r\n\r\n```sql\r\nwhere a=1 and b=2 and d=4;\r\n```\r\n\r\n則只有 a 和 b 索引起作用，中間 c 斷了，則 d 索引不起作用。\r\n\r\nmysql 會一值向右尋找直到遇到範圍查詢(>, <, between, like)時停止。\r\n\r\n如：\r\n\r\n```sql\r\nwhere a = 1 and b = 2 and c > 3 and d = 4 ;\r\n```\r\n\r\n若建立 (a, b, c, d)順序的索引，則索引範圍不會到 b ，因為 c 出現 \">\"。\r\n如果建立(a, b, d, c)的順序，則\r\n\r\n```sql\r\nwhere a = 1 and b = 2 and c > 3 and d = 4\r\n```\r\n\r\n其中 abcd 都可以用到索引，並且 abd 的順序可以任意調整。\r\n\r\n```sql\r\nselect * from test where b=2 and d=4 and a=1and c>3;\r\n```\r\n\r\n以上 sql 語句中，a, b, c, d 都用到了索引\r\n\r\n**注意**\r\n\r\n1. 只要列中包含有 null 值，都將不會被包含在索引中，複合索引中只要有一列含有 null 值，那此列的複合索引就是無效的，因此在資料庫設計時盡量不要讓欄位的預設值為 null\r\n2. 使用 like 關鍵字須注意：`like \"%aaa%\"` 不會命中索引，`like \"aaa%\"` 才會命中索引。\r\n3. NOT IN 和操作都會變成全表掃描，not in 可以用 not exist 代替。\r\n","tocContent":"- [MySQL 學習筆記](#mysql-學習筆記)\r\n  - [環境設定](#環境設定)\r\n    - [設定時區](#設定時區)\r\n    - [MariaDB 設定命名時區](#mariadb-設定命名時區)\r\n      - [從 zoneinfo 匯入時區](#從-zoneinfo-匯入時區)\r\n      - [從 mysql 提供的指令碼匯入](#從-mysql-提供的指令碼匯入)\r\n  - [資料表語法](#資料表語法)\r\n  - [資料型態](#資料型態)\r\n  - [資料庫設計原則](#資料庫設計原則)\r\n    - [資料庫設計和表建立時就要考慮效能](#資料庫設計和表建立時就要考慮效能)\r\n      - [選擇適合的資料型別](#選擇適合的資料型別)\r\n      - [選擇適合的索引列](#選擇適合的索引列)\r\n    - [SQL 的編寫需要注意最佳化](#sql-的編寫需要注意最佳化)\r\n      - [引擎選擇](#引擎選擇)\r\n      - [分割槽](#分割槽)\r\n  - [DB 命名原則](#db-命名原則)\r\n    - [資料庫命名](#資料庫命名)\r\n    - [資料表命名](#資料表命名)\r\n    - [欄位命名](#欄位命名)\r\n    - [索引命名](#索引命名)\r\n      - [外鍵索引](#外鍵索引)\r\n  - [Function](#function)\r\n    - [CONVERT\\_TZ(dt,from\\_tz,to\\_tz) 轉換時區](#convert_tzdtfrom_tzto_tz-轉換時區)\r\n    - [Event 事件](#event-事件)\r\n      - [範例](#範例)\r\n      - [基本使用](#基本使用)\r\n  - [使用情境](#使用情境)\r\n    - [外鍵 onDelete 約束情況](#外鍵-ondelete-約束情況)\r\n    - [ERROR: #1215 - Cannot add foreign key constraint](#error-1215---cannot-add-foreign-key-constraint)\r\n    - [刪除重複的資料](#刪除重複的資料)\r\n      - [使用 `DISTINCT` 去除重複值](#使用-distinct-去除重複值)\r\n    - [匯入 txt 檔](#匯入-txt-檔)\r\n    - [複合主鍵與聯合主鍵，索引與聯合(複合)索引](#複合主鍵與聯合主鍵索引與聯合複合索引)\r\n      - [複合主鍵與聯合主鍵](#複合主鍵與聯合主鍵)\r\n      - [索引、聯合(複合)索引](#索引聯合複合索引)"}