{"name":"Laravel 事件.md","content":"# Laravel 事件\r\n\r\n> Event 類別一般儲存在 app/Event 目錄下\r\n> Listener 類別則存在 app/Listeners 目錄下\r\n\r\n## 註冊 Event 與 Listener\r\n\r\n首先在 laravel 專案中的 App\\Providers\\EventServiceProvider 註冊事件和監聽者\r\n\r\n- `$listen` 屬性是一個陣列，包含所有 `Event`(key) 和其 `listener`(value)\r\n- 可以使用 `php artisan event:list` 來列出所有註冊的 `Event` 和 `listener`\r\n\r\n```php\r\nnamespace App\\Providers;\r\n\r\nuse App\\Events\\OrderShipped;\r\nuse App\\Listeners\\SendShipmentNotification;\r\n\r\n/**\r\n * The event listener mappings for the application.\r\n *\r\n * @var array\r\n */\r\nprotected $listen = [\r\n    OrderShipped::class => [\r\n        SendShipmentNotification::class,\r\n    ],\r\n];\r\n```\r\n\r\n### 產生 Event Listener\r\n\r\n在 EventServiceProvider 中註冊後，使用 artisan 指令，即可產生 EventServiceProvider 中已註冊但尚未生成的 Event 和 Listener\r\n\r\n```bash\r\nphp artisan event:generate\r\n```\r\n\r\n或者也可以分別建立 Event 和 Listener\r\n\r\n```bash\r\nphp artisan make:event PodcastProcessed\r\n\r\nphp artisan make:listener SendPodcastNotification --event=PodcastProcessed\r\n```\r\n\r\n此時會產生兩個文件，分別為：\r\napp\\Events\\OrderShipped.php\r\napp\\Listeners\\SendShipmentNotification.php\r\n\r\n### 手動註冊\r\n\r\n除了在 EventServiceProvider 的 class 中宣告 $listen 屬性外，也可以在 class 中的 boot() 方法手動註冊基於 class 或是匿名函數的 Listener\r\n\r\n```php\r\nuse App\\Events\\PodcastProcessed;\r\nuse App\\Listeners\\SendPodcastNotification;\r\nuse Illuminate\\Support\\Facades\\Event;\r\n\r\n/**\r\n * Register any other events for your application.\r\n *\r\n * @return void\r\n */\r\npublic function boot()\r\n{\r\n    Event::listen(\r\n        PodcastProcessed::class,\r\n        [SendPodcastNotification::class, 'handle']\r\n    );\r\n\r\n    Event::listen(function (PodcastProcessed $event) {\r\n        //\r\n    });\r\n}\r\n```\r\n\r\n#### 一個 Listener 處理多個 Event\r\n\r\n使用 `*` 作為萬用字元參數來註冊 Listener，實現一個監聽者對應多個事件\r\n\r\n```php\r\nEvent::listen('event.*', function ($eventName, array $data) {\r\n    //\r\n});\r\n```\r\n\r\n- 此監聽者接收事件名作為第一個參數，並將整個事件數據，作為第二個參數\r\n\r\n### Event Discovery 事件發現\r\n\r\n啟用事件發現時，laravel 會搜尋專案的 `app/Listener` 目錄自動尋找並註冊事件與監聽器。  \r\n此外，列在 `EventServiceProvider` 中有被正確定義的事件也會被註冊。\r\n\r\n在預設中，事件發現預設是關閉，可以在 `EventServiceProvider` 上複寫 `shouldDiscoverEvents()` 方法來啟用\r\n\r\n```php\r\n/**\r\n * Determine if events and listeners should be automatically discovered.\r\n *\r\n * @return bool\r\n */\r\npublic function shouldDiscoverEvents()\r\n{\r\n    return true;\r\n}\r\n```\r\n\r\n## 定義 Event\r\n\r\nEvent class 基本上就是一個資料容器，用來保存與該事件相關的資訊。\r\n\r\n假設有一個事件會接收 Eloquent ORM 的物件，`App\\Events\\OrderShipped`\r\n\r\n在 class 中加入 $order 屬性，並在建構子中加入 $this->order = $order\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Events;\r\n\r\nuse App\\Models\\Order;\r\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\r\nuse Illuminate\\Foundation\\Events\\Dispatchable;\r\nuse Illuminate\\Queue\\SerializesModels;\r\n\r\nclass OrderShipped\r\n{\r\n    use Dispatchable, InteractsWithSockets, SerializesModels;\r\n\r\n    /**\r\n     * The order instance.\r\n     *\r\n     * @var \\App\\Models\\Order\r\n     */\r\n    public $order;\r\n\r\n    /**\r\n     * Create a new event instance.\r\n     *\r\n     * @param  \\App\\Models\\Order  $order\r\n     * @return void\r\n     */\r\n    public function __construct(Order $order)\r\n    {\r\n        $this->order = $order;\r\n    }\r\n}\r\n```\r\n\r\n- 在 Event class 中不包含邏輯，只作為已付款訂單 `App\\Models\\Order` 實體的容器\r\n\r\n## 定義 Listener\r\n\r\n事件監聽器會在 handle() 中接收 Event 實體，當使用 artisan 指定建立監聽器時，會自動載入相對應的 Event class，並在 handle() 做 Event 的型別提示\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Listeners;\r\n\r\nuse App\\Events\\OrderShipped;\r\n\r\nclass SendShipmentNotification\r\n{\r\n    /**\r\n     * Create the event listener.\r\n     *\r\n     * @return void\r\n     */\r\n    public function __construct()\r\n    {\r\n        //\r\n    }\r\n\r\n    /**\r\n     * Handle the event.\r\n     *\r\n     * @param  \\App\\Events\\OrderShipped  $event\r\n     * @return void\r\n     */\r\n    public function handle(OrderShipped $event)\r\n    {\r\n        // Access the order using $event->order...\r\n        // ex: dd($event->order);\r\n    }\r\n}\r\n```\r\n\r\n### 停止事件的傳播\r\n\r\n若要停止將某個事件傳播到另一個監聽器上，只要在監聽器的 handle 方法是回傳 false 即可\r\n\r\n## 觸發事件\r\n\r\n將 order 物件傳入 controller，listener 的 handle 方法中可以拿到 event 中的 order 變數，後續就可以觸發事件的邏輯\r\n\r\n```php\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Models\\Order;\r\nuse App\\Events\\OrderShipped;\r\nuse App\\Http\\Controllers\\Controller;\r\n\r\nclass OrderController extends Controller\r\n{\r\n    public function ship() {\r\n        $orderId = 1;\r\n        $order = Order::findOrFail($orderId);\r\n\r\n        // 訂單出貨的邏輯\r\n        // 觸發 event\r\n        event(new OrderShipped($order));\r\n\r\n        return response()->json([\r\n            'status' => 'success',\r\n            'message' => ''\r\n        ]);\r\n    }\r\n}\r\n```\r\n\r\n## 分派 Event\r\n\r\n呼叫事件上的靜態方法 `dispatch` ，此方法由 `Illuminate\\Foundation\\Events\\Dispatchable` 提供\r\n\r\n任何傳入此方法的值，會被傳給 Event 的 Constructor\r\n\r\n```PHP\r\n<?php\r\n\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Events\\OrderShipped;\r\nuse App\\Http\\Controllers\\Controller;\r\nuse App\\Models\\Order;\r\nuse Illuminate\\Http\\Request;\r\n\r\nclass OrderShipmentController extends Controller\r\n{\r\n    /**\r\n     * Ship the given order.\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @return \\Illuminate\\Http\\Response\r\n     */\r\n    public function store(Request $request)\r\n    {\r\n        $order = Order::findOrFail($request->order_id);\r\n\r\n        // Order shipment logic...\r\n\r\n        OrderShipped::dispatch($order);\r\n    }\r\n}\r\n```\r\n\r\n## 實作範例\r\n\r\n> [最簡單易懂的 laravel 事件，這個功能非常的有用](https://segmentfault.com/a/1190000010730545)\r\n\r\n### 情境\r\n\r\n在用戶註冊時，發送幫助電子郵件給用戶\r\n\r\n以下為原始的註冊方法\r\n\r\n```php\r\nnamespace  App\\Htt\\Controllers;\r\n\r\nuse  Illuminate\\Http\\Request;\r\n\r\nclass  UserController  extends  Controller\r\n {\r\n     public  function  register ( Request $request )\r\n     {\r\n        //獲取參數\r\n        //驗證參數\r\n        //寫入資料庫\r\n        //return 註冊信息\r\n    }\r\n}\r\n```\r\n\r\n現在有一個需求，註冊成功之後，向用戶的電子信箱發送一個廣告\r\n\r\n```php\r\nnamespace  App\\Htt\\Controllers;\r\n\r\nuse  Illuminate\\Http\\Request;\r\n\r\nclass  UserController  extends  Controller\r\n {\r\n     public  function  register ( Request $request )\r\n     {\r\n        //獲取參數\r\n        //驗證參數\r\n        //寫入資料庫\r\n\r\n        //發送廣告電子郵件\r\n        //return 註冊信息\r\n\r\n    }\r\n}\r\n```\r\n\r\n此時再增加一個發送簡訊的需求\r\n\r\n```php\r\nnamespace  App\\Htt\\Controllers;\r\n\r\nuse  Illuminate\\Http\\Request;\r\n\r\nclass  UserController  extends  Controller\r\n {\r\n     public  function  register ( Request $request )\r\n     {\r\n        //獲取參數\r\n        //驗證參數\r\n        //寫入資料庫\r\n\r\n        //發送廣告電子郵件\r\n        //發送簡訊\r\n        //return 註冊信息\r\n    }\r\n}\r\n```\r\n\r\n接著又有新的需求：發送 IM 消息，雖然將許多的功能寫在一個 function 中很直觀，但當多人協作時，會產生各種不便。\r\n\r\n### 事件功能\r\n\r\nlaravel 事件功能實際上更傾向於一種管理手段 + 實現的體現。\r\n\r\n我們可以透過 laravel 事件功能，宏觀的看到所有的事件，而不需每次都要打開 controller 的方法才能知道註冊之後發生什麼事\r\n\r\n我們要在註冊之後作一系列事情，首先在註冊完之後調用一個事件，然後這個事件在做各式各樣的事。\r\n\r\n```php\r\nnamespace  App\\Htt\\Controllers;\r\n\r\nuse  Illuminate\\Http\\Request;\r\n //我們先引入一個事件類，名字自定義的，之後再一步一步創建\r\nuse  App\\Events\\Register;\r\n\r\nclass  UserController  extends  Controller\r\n {\r\n     public  function  register ( Request $request )\r\n     {\r\n        // 獲取參數\r\n        // 驗證參數\r\n        // 寫入資料庫\r\n        // 觸發事件，以後所有需要註冊後要做的事情，都不需要再這裡加代碼了，我們只需要管理事件就好了\r\n        // event 方法是 laravel 自帶方法, $uid是外部參數，看你需要做什麼，傳什麼參數了。註冊之後肯定有 $uid 的嘛\r\n        event ( new  Register ( $uid ));\r\n        // return 註冊信息\r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\n找到 app\\Providers\\EventServiceProvider.php 文件，並加入關係\r\n\r\n```php\r\nnamespace  App\\Providers;\r\n\r\nuse  Laravel\\Lumen\\Providers\\EventServiceProvider  as  ServiceProvider;\r\n\r\nclass  EventServiceProvider  extends  ServiceProvider\r\n {\r\n     /**\r\n     * The event listener mappings for the application.\r\n     *\r\n     * @var array\r\n     */\r\n    protected  $listen = [\r\n        // 用戶註冊後的事件\r\n        'App\\Events\\Register' => [\r\n            // 發送廣告電子郵件\r\n            'App\\Listeners\\SendAdMail',\r\n            // 發送簡訊\r\n            'App\\Listeners\\SendSms',\r\n            // 發送幫助信息\r\n            'App\\Listeners\\SendHelpInformation',\r\n        ],\r\n    ];\r\n}\r\n```\r\n\r\n這是註冊事件的入口，相當於一個總目錄，這樣就可以跟註冊的程式碼，未來增加功能時，便不須再查看註冊方法的程式碼\r\n\r\n註冊完成後會觸發 App\\Events\\Register 類別，然後這個類會被 App\\Listeners\\SendAdMail, App\\Listeners\\SendSms, App\\Listeners\\SendHelpInformation 監聽到\r\n\r\n此時進入 App\\Events 目錄，建立 Register 這個 class\r\n\r\n```php\r\nnamespace  App\\Events;\r\n\r\nclass  Register\r\n {\r\n\r\n    public  $uid;\r\n\r\n    /**\r\n     * 創建一個新的事件實例.\r\n     *\r\n     * @param   Order $order\r\n     * @return void\r\n     */\r\n    public  function  __construct ( $uid )\r\n     {\r\n         $this ->uid = $uid;\r\n    }\r\n}\r\n```\r\n\r\n接著在 app\\Listeners 目錄底下建立各種事件監聽 class\r\n\r\n```php\r\nnamespace  App\\Listeners;\r\n\r\nuse  App\\Event\\Register;\r\nuse  App\\Models\\User;\r\nuse  Illuminate\\Contracts\\Queue\\ShouldQueue;\r\n\r\nclass  SendHelpInformation  implements  ShouldQueue\r\n {\r\n\r\n\r\n    public  function  __construct ()\r\n    {\r\n        //\r\n    }\r\n\r\n\r\n    public  function  handle ( Register $event )\r\n    {\r\n        $uid = $event ->uid;\r\n\r\n        $user = User :: find ( $uid );\r\n\r\n        //......各種實現\r\n    }\r\n}\r\n```\r\n","tocContent":""}