{"name":"Laravel 事件.md","content":"# Laravel 事件\n\n> Event 類別一般儲存在 app/Event 目錄下\n> Listener 類別則存在 app/Listeners 目錄下\n\n## 註冊 Event 與 Listener\n\n首先在 laravel 專案中的 App\\Providers\\EventServiceProvider 註冊事件和監聽者\n\n- `$listen` 屬性是一個陣列，包含所有 `Event`(key) 和其 `listener`(value)\n- 可以使用 `php artisan event:list` 來列出所有註冊的 `Event` 和 `listener`\n\n```php\nnamespace App\\Providers;\n\nuse App\\Events\\OrderShipped;\nuse App\\Listeners\\SendShipmentNotification;\n\n/**\n * The event listener mappings for the application.\n *\n * @var array\n */\nprotected $listen = [\n    OrderShipped::class => [\n        SendShipmentNotification::class,\n    ],\n];\n```\n\n### 產生 Event Listener\n\n在 EventServiceProvider 中註冊後，使用 artisan 指令，即可產生 EventServiceProvider 中已註冊但尚未生成的 Event 和 Listener\n\n```bash\nphp artisan event:generate\n```\n\n或者也可以分別建立 Event 和 Listener\n\n```bash\nphp artisan make:event PodcastProcessed\n\nphp artisan make:listener SendPodcastNotification --event=PodcastProcessed\n```\n\n此時會產生兩個文件，分別為：\napp\\Events\\OrderShipped.php\napp\\Listeners\\SendShipmentNotification.php\n\n### 手動註冊\n\n除了在 EventServiceProvider 的 class 中宣告 $listen 屬性外，也可以在 class 中的 boot() 方法手動註冊基於 class 或是匿名函數的 Listener\n\n```php\nuse App\\Events\\PodcastProcessed;\nuse App\\Listeners\\SendPodcastNotification;\nuse Illuminate\\Support\\Facades\\Event;\n\n/**\n * Register any other events for your application.\n *\n * @return void\n */\npublic function boot()\n{\n    Event::listen(\n        PodcastProcessed::class,\n        [SendPodcastNotification::class, 'handle']\n    );\n\n    Event::listen(function (PodcastProcessed $event) {\n        //\n    });\n}\n```\n\n#### 一個 Listener 處理多個 Event\n\n使用 `*` 作為萬用字元參數來註冊 Listener，實現一個監聽者對應多個事件\n\n```php\nEvent::listen('event.*', function ($eventName, array $data) {\n    //\n});\n```\n\n- 此監聽者接收事件名作為第一個參數，並將整個事件數據，作為第二個參數\n\n### Event Discovery 事件發現\n\n啟用事件發現時，laravel 會搜尋專案的 `app/Listener` 目錄自動尋找並註冊事件與監聽器。  \n此外，列在 `EventServiceProvider` 中有被正確定義的事件也會被註冊。\n\n在預設中，事件發現預設是關閉，可以在 `EventServiceProvider` 上複寫 `shouldDiscoverEvents()` 方法來啟用\n\n```php\n/**\n * Determine if events and listeners should be automatically discovered.\n *\n * @return bool\n */\npublic function shouldDiscoverEvents()\n{\n    return true;\n}\n```\n\n## 定義 Event\n\nEvent class 基本上就是一個資料容器，用來保存與該事件相關的資訊。\n\n假設有一個事件會接收 Eloquent ORM 的物件，`App\\Events\\OrderShipped`\n\n在 class 中加入 $order 屬性，並在建構子中加入 $this->order = $order\n\n```php\n<?php\n\nnamespace App\\Events;\n\nuse App\\Models\\Order;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass OrderShipped\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n\n    /**\n     * The order instance.\n     *\n     * @var \\App\\Models\\Order\n     */\n    public $order;\n\n    /**\n     * Create a new event instance.\n     *\n     * @param  \\App\\Models\\Order  $order\n     * @return void\n     */\n    public function __construct(Order $order)\n    {\n        $this->order = $order;\n    }\n}\n```\n\n- 在 Event class 中不包含邏輯，只作為已付款訂單 `App\\Models\\Order` 實體的容器\n\n## 定義 Listener\n\n事件監聽器會在 handle() 中接收 Event 實體，當使用 artisan 指定建立監聽器時，會自動載入相對應的 Event class，並在 handle() 做 Event 的型別提示\n\n```php\n<?php\n\nnamespace App\\Listeners;\n\nuse App\\Events\\OrderShipped;\n\nclass SendShipmentNotification\n{\n    /**\n     * Create the event listener.\n     *\n     * @return void\n     */\n    public function __construct()\n    {\n        //\n    }\n\n    /**\n     * Handle the event.\n     *\n     * @param  \\App\\Events\\OrderShipped  $event\n     * @return void\n     */\n    public function handle(OrderShipped $event)\n    {\n        // Access the order using $event->order...\n        // ex: dd($event->order);\n    }\n}\n```\n\n### 停止事件的傳播\n\n若要停止將某個事件傳播到另一個監聽器上，只要在監聽器的 handle 方法是回傳 false 即可\n\n## 觸發事件\n\n將 order 物件傳入 controller，listener 的 handle 方法中可以拿到 event 中的 order 變數，後續就可以觸發事件的邏輯\n\n```php\nnamespace App\\Http\\Controllers;\n\nuse App\\Models\\Order;\nuse App\\Events\\OrderShipped;\nuse App\\Http\\Controllers\\Controller;\n\nclass OrderController extends Controller\n{\n    public function ship() {\n        $orderId = 1;\n        $order = Order::findOrFail($orderId);\n\n        // 訂單出貨的邏輯\n        // 觸發 event\n        event(new OrderShipped($order));\n\n        return response()->json([\n            'status' => 'success',\n            'message' => ''\n        ]);\n    }\n}\n```\n\n## 分派 Event\n\n呼叫事件上的靜態方法 `dispatch` ，此方法由 `Illuminate\\Foundation\\Events\\Dispatchable` 提供\n\n任何傳入此方法的值，會被傳給 Event 的 Constructor\n\n```PHP\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Events\\OrderShipped;\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\Order;\nuse Illuminate\\Http\\Request;\n\nclass OrderShipmentController extends Controller\n{\n    /**\n     * Ship the given order.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function store(Request $request)\n    {\n        $order = Order::findOrFail($request->order_id);\n\n        // Order shipment logic...\n\n        OrderShipped::dispatch($order);\n    }\n}\n```\n\n## 實作範例\n\n> [最簡單易懂的 laravel 事件，這個功能非常的有用](https://segmentfault.com/a/1190000010730545)\n\n### 情境\n\n在用戶註冊時，發送幫助電子郵件給用戶\n\n以下為原始的註冊方法\n\n```php\nnamespace  App\\Htt\\Controllers;\n\nuse  Illuminate\\Http\\Request;\n\nclass  UserController  extends  Controller\n {\n     public  function  register ( Request $request )\n     {\n        //獲取參數\n        //驗證參數\n        //寫入資料庫\n        //return 註冊信息\n    }\n}\n```\n\n現在有一個需求，註冊成功之後，向用戶的電子信箱發送一個廣告\n\n```php\nnamespace  App\\Htt\\Controllers;\n\nuse  Illuminate\\Http\\Request;\n\nclass  UserController  extends  Controller\n {\n     public  function  register ( Request $request )\n     {\n        //獲取參數\n        //驗證參數\n        //寫入資料庫\n\n        //發送廣告電子郵件\n        //return 註冊信息\n\n    }\n}\n```\n\n此時再增加一個發送簡訊的需求\n\n```php\nnamespace  App\\Htt\\Controllers;\n\nuse  Illuminate\\Http\\Request;\n\nclass  UserController  extends  Controller\n {\n     public  function  register ( Request $request )\n     {\n        //獲取參數\n        //驗證參數\n        //寫入資料庫\n\n        //發送廣告電子郵件\n        //發送簡訊\n        //return 註冊信息\n    }\n}\n```\n\n接著又有新的需求：發送 IM 消息，雖然將許多的功能寫在一個 function 中很直觀，但當多人協作時，會產生各種不便。\n\n### 事件功能\n\nlaravel 事件功能實際上更傾向於一種管理手段 + 實現的體現。\n\n我們可以透過 laravel 事件功能，宏觀的看到所有的事件，而不需每次都要打開 controller 的方法才能知道註冊之後發生什麼事\n\n我們要在註冊之後作一系列事情，首先在註冊完之後調用一個事件，然後這個事件在做各式各樣的事。\n\n```php\nnamespace  App\\Htt\\Controllers;\n\nuse  Illuminate\\Http\\Request;\n //我們先引入一個事件類，名字自定義的，之後再一步一步創建\nuse  App\\Events\\Register;\n\nclass  UserController  extends  Controller\n {\n     public  function  register ( Request $request )\n     {\n        // 獲取參數\n        // 驗證參數\n        // 寫入資料庫\n        // 觸發事件，以後所有需要註冊後要做的事情，都不需要再這裡加代碼了，我們只需要管理事件就好了\n        // event 方法是 laravel 自帶方法, $uid是外部參數，看你需要做什麼，傳什麼參數了。註冊之後肯定有 $uid 的嘛\n        event ( new  Register ( $uid ));\n        // return 註冊信息\n\n\n    }\n}\n```\n\n找到 app\\Providers\\EventServiceProvider.php 文件，並加入關係\n\n```php\nnamespace  App\\Providers;\n\nuse  Laravel\\Lumen\\Providers\\EventServiceProvider  as  ServiceProvider;\n\nclass  EventServiceProvider  extends  ServiceProvider\n {\n     /**\n     * The event listener mappings for the application.\n     *\n     * @var array\n     */\n    protected  $listen = [\n        // 用戶註冊後的事件\n        'App\\Events\\Register' => [\n            // 發送廣告電子郵件\n            'App\\Listeners\\SendAdMail',\n            // 發送簡訊\n            'App\\Listeners\\SendSms',\n            // 發送幫助信息\n            'App\\Listeners\\SendHelpInformation',\n        ],\n    ];\n}\n```\n\n這是註冊事件的入口，相當於一個總目錄，這樣就可以跟註冊的程式碼，未來增加功能時，便不須再查看註冊方法的程式碼\n\n註冊完成後會觸發 App\\Events\\Register 類別，然後這個類會被 App\\Listeners\\SendAdMail, App\\Listeners\\SendSms, App\\Listeners\\SendHelpInformation 監聽到\n\n此時進入 App\\Events 目錄，建立 Register 這個 class\n\n```php\nnamespace  App\\Events;\n\nclass  Register\n {\n\n    public  $uid;\n\n    /**\n     * 創建一個新的事件實例.\n     *\n     * @param   Order $order\n     * @return void\n     */\n    public  function  __construct ( $uid )\n     {\n         $this ->uid = $uid;\n    }\n}\n```\n\n接著在 app\\Listeners 目錄底下建立各種事件監聽 class\n\n```php\nnamespace  App\\Listeners;\n\nuse  App\\Event\\Register;\nuse  App\\Models\\User;\nuse  Illuminate\\Contracts\\Queue\\ShouldQueue;\n\nclass  SendHelpInformation  implements  ShouldQueue\n {\n\n\n    public  function  __construct ()\n    {\n        //\n    }\n\n\n    public  function  handle ( Register $event )\n    {\n        $uid = $event ->uid;\n\n        $user = User :: find ( $uid );\n\n        //......各種實現\n    }\n}\n```\n","tocContent":""}