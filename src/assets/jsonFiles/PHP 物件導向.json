{"name":"PHP 物件導向.md","content":"# PHP 物件導向\n\n>\n\n## 物件和類別 `Objects` and `Classes`\n\n把類似或有關聯的工作或屬性，組織到類別`class`裡面。\n這可以讓程式保持遵守 **不重複原則 “don’t repeat yourself” (DRY)**，更容易維護。\n\n- `class` 類別：可以比喻作一個建築的藍圖。類別是將房子的樣式設計出來。\n- `object` 物件：依照藍圖蓋出來的房子。物件是類別的實例。\n- `data` 資料：就像是鋼筋、水泥，用來蓋房子的材料。\n\n`data`(建材)經過`class`(藍圖)，就會被實例化變成`object`(房子)。\n\n## 建立類別 `Class`\n\n```php\n<?php\nclass MyClass\n{\n    // 類別的屬性和方法在大括號裡面宣告\n}\n\n$obj = new MyClass;\n\nvar_dump($obj);\n```\n\n- `new` 關鍵字在建立類別之後，實例化一個類別，並將它存到一個變數上。\n\n- `var_dump()` 來印出變數的相關訊息於螢幕上。\n\n最終會輸出\n\n```html\nobject(MyClass)#1 (0) { }\n```\n\n此為最基礎的物件形式。\n\n## 定義類別的屬性\n\n使用屬性(Property)，也稱 **`Class`的變數(Variable)** 來把 `Data` 存入一個 `Class` 裡面。\n\n```php\n<?php\n\nclass MyClass\n{\n  public $prop1 = \"I'm a class property!\";\n}\n\n$obj = new MyClass;\n```\n\n- `public` 此為屬性的關鍵字，用來決定屬性的可視性(Visibility)。\n\n指定要讀取的物件及屬性，並將其顯示在瀏覽器上\n\n```php\necho $obj->prop1; // Output the property\n```\n\n- `->`（對象運算符）: 在 PHP 物件中，用來存取物件的屬性(Property)和方法(Methods)。\n- `::`（雙冒號）: 用來訪問靜態屬性。\n\n最後將會得到\n\n```html\nI'm a class property!\n```\n\n## 定義類別的方法 Methods\n\n可以藉由執行這些方法，來更改物件的行為或是狀態。\n\n建立一個方法來設定與讀取屬性 `$prop1` 的值\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function setProperty($new_value) {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty() {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\n$obj = new MyClass;\necho $obj->getProperty(); // 得到原始的屬性值\n\n$obj->setProperty(\"I'm a new property value!\"); // 設定新的屬性值\necho $obj->getProperty(); // 得到新的屬性值\n```\n\n- `$this` : 物件透過 `$this` 關鍵字來參考自己，物件使用 $this 就如同你直接使用物件名稱來指定物件。\n- `$this` 寫在 class 內部\n- 使用這些含有 `$this` 的方法之前，記得先要實例化這些方法的物件。\n\n  ```php\n  $this->prop1;\n  myClass->prop1; // 兩者的意義相同\n  ```\n\n輸出的結果\n\n```html\nI'm a class property! I'm a new property value!\n```\n\n接著再 `new` 一個新的 `class`\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function setProperty($new_value) {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty() {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\n// 將兩個物件實例化\n$obj = new MyClass;\n$obj2 = new MyClass;\n\n// 取得兩個物件的屬性變數 $prop1\necho $obj->getProperty();\necho $obj2->getProperty();\n\n// 將兩個物件設定新的屬性值\n$obj->setProperty(\"I'm a new property value!\");\n$obj2->setProperty(\"I belong to the second instance!\");\n\n// 輸出兩個物件的新屬性值\necho $obj->getProperty();\necho $obj2->getProperty();\n```\n\n輸出結果\n\n```html\nI'm a class property! I'm a class property! I'm a new property value! I belong\nto the second instance!\n```\n\n- 物件導向將 `object` 視為獨立的個體，依照藍圖蓋出來的房子，每一間都是獨立的。\n\n## 定義類別的常數 const\n\n- 可以把類別中始終保持不變的值，定義為常數。\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    const constant = \"value\";\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n\n    function showConstant() {\n        echo  self::constant . \"<br />\";\n    }\n}\n\n// 將物件實例化\n$obj = new MyClass;\n\n// 取得物件的常數\necho $obj->showConstant();\necho MyClass::constant;\n```\n\n輸出結果\n\n```html\nvalue value\n```\n\n## 封裝 Encapsulation\n\n每個物件都包含進行操作時需要的所有資訊，物件不必依賴其他物件來完成操作，將方法、欄位、屬性和邏輯包裝在類別內，透過類別的實體來實現，外部物件無法了解物件的內部細節，有種隱藏起來的概念，外部對資料的操作也只能透過已經定義的介面，用一段簡白的話來說，對事只了解他的外在，無需理解內部構造，即為封裝。\n\n## PHP 魔術函數\n\n### `__construct` 建構式\n\n- `__construct()` : 當一個物件建立的時候會 **首先** 被呼叫。\n- `__CLASS__` : 會回傳被呼叫的類別名稱。\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\n// 實例化一個物件\n$obj = new MyClass;\n\n// 取得屬性 $prop1 的值\necho $obj->getProperty();\n\n// 在生命週期的最後加上\necho \"End of file.<br />\";\n```\n\n最後輸出\n\n```html\nThe class \"MyClass\" was initiated! I'm a class property! End of file.\n```\n\n### `__destruct` 解構式\n\n- `__destruct()` : 可以清除物件，例如：關閉資料庫連線。\n\n```php\n<?php\nclass MyClass\n    {\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function __destruct()\n    {\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\n// 實例化一個新的物件\n$obj = new MyClass;\n\n// 取得屬性 $prop1 的值\necho $obj->getProperty();\n\n// 在生命週期的最後加上\necho \"End of file.<br />\";\n```\n\n最後輸出畫面\n\n```html\nThe class \"MyClass\" was initiated! I'm a class property! End of file. The class\n\"MyClass\" was destroyed.\n```\n\n- 當物件使用完畢，PHP 會自動釋放記憶體。\n\n### `unset`\n\n- `unset()` : 此方法可以更明確觸發 `__destruct()` 魔術函數。\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function __destruct()\n    {\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\n// 將一個物件實例化\n$obj = new MyClass;\n\n// 取得變數 $prop1\necho $obj->getProperty();\n\n// 清除物件\nunset($obj);\n\n// 生命週期結束後回傳\necho \"End of file.<br />\";\n```\n\n結果會輸出\n\n```html\nThe class \"MyClass\" was initiated! I'm a class property! The class \"MyClass\" was\ndestroyed. End of file.\n```\n\n### `__toString`\n\n- `__toString` : 將物件轉換為字串。\n\n如果將物件當作字串處理的話，會出現無法傳換型態的錯誤。\n\n```php\n// 實例化一個新的物件\n$obj = new MyClass;\n\n// 將物件輸出為字串\necho $obj;\n```\n\n輸出結果\n\n```html\nThe class \"MyClass\" was initiated! Catchable fatal error: Object of class\nMyClass could not be converted to string\n```\n\n加入 `__toString` 函數，來做轉換處理。\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function __destruct()\n    {\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\n    }\n\n    public function __toString()\n    {\n        echo \"Using the toString method: \";\n        return $this->getProperty();\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\n// 實例化一個新的物件\n$obj = new MyClass;\n\n// 回傳物件為字串\necho $obj;\n\n// 清除這個物件\nunset($obj);\n\n// 在生命周期結束後輸出\necho \"End of file.<br />\";\n```\n\n當物件試圖轉換成字串時，會觸發 `__toString` 函數，再由 `__toString` 函數呼叫 `getProperty()` 方法。\n輸出結果為\n\n```html\nThe class \"MyClass\" was initiated! Using the toString method: I'm a class\nproperty! The class \"MyClass\" was destroyed. End of file.\n```\n\n### `__get` `__set` 強制封裝\n\n- `__get()` 只會回傳屬性變數的值\n- `__set()` 指派一個新的值給屬性變數\n\n```php\nclass className\n{\n    private $attribute\n\n    function __get($name)\n    {\n        return $this->$name;\n    }\n\n    function __set($name, $value)\n    {\n        $this->$name = $value;\n    }\n\n}\n\n$a = new className();\n//使用public時，不會用到__get(), __set()屬性\n\n$a->attribute = 5;\n//私下呼叫__set()，使用$name設為attribute，$value設為5\n\n$a->attribute\n//私下呼叫__get()，並將參數$name設為attribute\n```\n\n- 優點：藉由單一的存取處，可以自由地修改底層的實作\n\n## 類別繼承\n\n- `extend` : 此關鍵字可以讓類別繼承其他類別的**方法**和**屬性**。\n- 子類別只能繼承一個父類別。\n\n建立一個新的 `class` 並繼承 MyClass\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function __destruct()\n    {\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\n    }\n\n    public function __toString()\n    {\n        echo \"Using the toString method: \";\n        return $this->getProperty();\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\nclass MyOtherClass extends MyClass\n{\n    public function newMethod()\n    {\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\n    }\n}\n\n// 實例化一個新的物件\n$new_object = new MyOtherClass;\n\n// 回傳此類別的方法\necho $new_object->newMethod();\n\n// 回傳父層類別的方法\necho $new_object->getProperty();\n```\n\n結果輸出\n\n```html\nThe class \"MyClass\" was initiated! From a new method in MyOtherClass. I'm a\nclass property! The class \"MyClass\" was destroyed.\n```\n\n### 覆寫 Override 繼承的方法和屬性\n\n在新的類別中，重新定義繼承自父層的屬性和方法\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function __destruct()\n    {\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\n    }\n\n    public function __toString()\n    {\n        echo \"Using the toString method: \";\n        return $this->getProperty();\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\nclass MyOtherClass extends MyClass\n{\n    public function __construct()\n    {\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\n    }\n\n    public function newMethod()\n    {\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\n    }\n}\n\n// 實例化一個新的物件\n$new_object = new MyOtherClass;\n\n// 回傳新類別的方法\necho $new_object->newMethod();\n\n// 回傳父層類別的方法\necho $new_object->getProperty();\n```\n\n在新類別中，覆寫 `__construct` 方法的輸出結果\n\n```html\nA new constructor in MyOtherClass. From a new method in MyOtherClass. I'm a\nclass property! The class \"MyClass\" was destroyed.\n```\n\n### `final` 避免被覆寫\n\n- 方法前加入 `final` 避免被覆寫\n\n```php\nclass A\n{\n    public $attribute = 'default value';\n\n    final function operation()\n    {\n        echo 'Something<br />';\n        echo 'The value of $attribute is'.$this->attribute.'<br />';\n    }\n}\n //可防止B覆寫operation()\n ------------------------------------------------------------\n //如何完全防止一個類別被繼承？(完全不能被繼承)\nfinal class A\n{\n\n}\n```\n\n### 範圍解析運算子 scope resolution operator\n\n當要將繼承自父層類別的方法其功能做擴充，要保留原始的功能，但不用將原有的程式碼重寫一遍。\n\n- 範圍解析運算子依然會受到可視性的限制。\n\n新增一個改寫父層類別的函數，並使用 `範圍解析運算子::`，來調用父類別被覆寫的函數\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function __destruct()\n    {\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\n    }\n\n    public function __toString()\n    {\n        echo \"Using the toString method: \";\n        return $this->getProperty();\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    public function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\nclass MyOtherClass extends MyClass\n{\n    public function __construct()\n    {\n        parent::__construct(); // 調用來自父層的 construct 功能\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\n    }\n\n    public function newMethod()\n    {\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\n    }\n}\n\n// 實例化一個新物件\n$new_object = new MyOtherClass;\n\n// 將物件輸出成字串\necho $new_object->newMethod();\n\n// 使用來自父層的方法\necho $new_object->getProperty();\n```\n\n結果輸出\n\n```html\nThe class \"MyClass\" was initiated! A new constructor in MyOtherClass. From a new\nmethod in MyOtherClass. I'm a class property! The class \"MyClass\" was destroyed.\n```\n\n## 將屬性和方法加上可視性 Visibility\n\n- `public` : 方法及屬性可以在類別之外被存取。\n- `protected` : 該屬性或方法只能在類別以及子類別的內部存取。\n- `private` : 該屬性或方法只能在定義它們的類別內存取。\n\n### `Protected` 受保護的\n\n將 MyClass 的 `getProperty()` 方法的可視性宣告為 `protected`，並且嘗試從外面呼叫這個方法\n\n```php\n<?php\n\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function __destruct()\n    {\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\n    }\n\n    public function __toString()\n    {\n        echo \"Using the toString method: \";\n        return $this->getProperty();\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    protected function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\nclass MyOtherClass extends MyClass\n{\n    public function __construct()\n    {\n        parent::__construct();\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\n    }\n\n    public function newMethod()\n    {\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\n    }\n}\n\n// 實例化一個新物件\n$new_object = new MyOtherClass;\n\n// 嘗試調用父層的 protected 方法\necho $new_object->getProperty();\n```\n\n結果輸出\n\n```html\nThe class \"MyClass\" was initiated! A new constructor in MyOtherClass. Fatal\nerror: Call to protected method MyClass::getProperty() from context ''\n```\n\n在子類別 MyOtherClass 中新增一個方法來調用父層的 `protected` `getProperty()` 方法\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function __destruct()\n    {\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\n    }\n\n    public function __toString()\n    {\n        echo \"Using the toString method: \";\n        return $this->getProperty();\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    protected function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\nclass MyOtherClass extends MyClass\n{\n    public function __construct()\n    {\n        parent::__construct();\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\n    }\n\n    public function newMethod()\n    {\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\n    }\n\n    public function callProtected()\n    {\n        return $this->getProperty();\n    }\n}\n\n// 實例化一個新的物件\n$new_object = new MyOtherClass;\n\n// 用子類別的 public 方法調用父層的 protected 方法\necho $new_object->callProtected();\n```\n\n輸出結果\n\n```html\nThe class \"MyClass\" was initiated! A new constructor in MyOtherClass. I'm a\nclass property! The class \"MyClass\" was destroyed.\n```\n\n### `Private` 隱私的\n\n將父層 MyClass 的 `getProperty()` 方法的宣告為 `private`，並且使用 MyOtherClass 的 `callProtected()` 方法來調用 `getProperty()` 方法。\n\n```php\n<?php\nclass MyClass\n{\n    public $prop1 = \"I'm a class property!\";\n\n    public function __construct()\n    {\n        echo 'The class \"', __CLASS__, '\" was initiated!<br />';\n    }\n\n    public function __destruct()\n    {\n        echo 'The class \"', __CLASS__, '\" was destroyed.<br />';\n    }\n\n    public function __toString()\n    {\n        echo \"Using the toString method: \";\n        return $this->getProperty();\n    }\n\n    public function setProperty($new_value)\n    {\n        $this->prop1 = $new_value;\n    }\n\n    private function getProperty()\n    {\n        return $this->prop1 . \"<br />\";\n    }\n}\n\nclass MyOtherClass extends MyClass\n{\n    public function __construct()\n    {\n        parent::__construct();\n        echo \"A new constructor in \" . __CLASS__ . \".<br />\";\n    }\n\n    public function newMethod()\n    {\n        echo \"From a new method in \" . __CLASS__ . \".<br />\";\n    }\n\n    public function callProtected()\n    {\n        return $this->getProperty();\n    }\n}\n\n// 實例化一個新的物件\n$new_object = new MyOtherClass;\n\n// 調用父層的方法\necho $new_object->callProtected();\n```\n\n輸出結果\n\n```html\nThe class \"MyClass\" was initiated! A new constructor in MyOtherClass. Fatal\nerror: Call to private method MyClass::getProperty() from context 'MyOtherClass'\n```\n\n## 介面與抽象類別的應用\n\n### interface 介面\n\n- `implements`關鍵字 : 執行介面\n- 定義功能名稱，但交由執行的類別去**實作**功能\n- 執行介面的類別一定要實作介面的方法。\n- 介面可以繼承其他的介面。\n- 類別可以同時執行多個介面。\n\n用於解決以下問題：\n\n1. 定義共同行為：介面定義一組方法，但不實作這些方法。他允許不同的類別實作相同介面，確保這些類別具有相同的方法。\n2. 實現多型：透過介面，可以實現多型，讓不同的物件以相同的方式被處理。\n3. 降低耦合：介面提供一種抽象層，使得依賴於介面的程式碼，不需要知道具體實作的細節。\n4. 強制契約：介面做為一種契約，確保實作該介面的類別必須提供特定的方法。\n\nBark.php\n\n```php\n<?php\ninterface Bark\n{\n  public function bark();\n}\n```\n\nSwim.php\n\n```php\n<?php\ninterface Swim\n{\n  public function swim();\n}\n```\n\nHuman.php\n\n```php\n<?php\ninclude \"Bark.php\";\ninclude \"Swim.php\";\nclass Human implements Bark, Swim\n{\n  public function bark()\n  {\n    echo \"人類叫聲...是在叫什麼啦！！\";\n  }\n\n  public function swim()\n  {\n    echo \"人類在游泳...不是在洗澡嗎？\";\n  }\n}\n```\n\ndemo.php\n\n```php\n<?php\ninclude \"Human.php\";\n$man = new Human();\necho $man->bark();\necho $man->swim();\n```\n\n介面的使用時機 : 當「多個類別（Class）」之間有共同的方法（function），但方法實做的方式有差異，可以將這些共用「方法」寫成「介面（Interface）」，讓其他的「子類別（Class）」去實做這個介面\n\n### Abstract 抽象類別\n\n- 父類別若不想實作介面方法，子類別又需要定義介面功能，可以將父類別抽象化，即可不用實作介面方法。\n- 子類別繼承抽象父類別之後，必須要實作父類別的介面方法。\n\ndog.php\n\n```php\n<?php\ninclude \"Bark.php\";\nabstract class dog implements Bark\n{\n   // 設定狗的屬性\n   public $name;\n   public $color;\n   public $style;\n\n   //設定建構子\n   public function __construct($name,$color,$style)\n   {\n     $this->name = $name;\n     $this->color = $color;\n     $this->style = $style;\n   }\n\n   public function dogRun()\n   {\n     echo \"狗狗跑步中...\";\n   }\n\n   // 修改狗叫的功能\n   public function Bark()\n   {\n     //這裡保持空白\n   }\n\n   public function __destruct()\n   {\n     echo \"狗狗回家了...\";\n   }\n}\n```\n\nPoodle.php\n\n```php\ninclude \"dog.php\";\n\nclass Poodle extends dog\n{\n  protected $size;\n\n  public function __construct($name,$color,$style,$size)\n  {\n    parent::__construct($name,$color,$style);\n    $this->size = $size;\n  }\n\n  // 實作父類別的狗叫 function\n  public function Bark()\n  {\n    echo \"狗叫...但小聲....\";\n    //呼叫父類別的 dogBark()\n  }\n}\n```\n\ndemo2.php\n\n```php\n<?php\n  include \"Poodle.php\";\n\n  $my_dog = new Poodle(\"Windy\",\"白色\",\"貴賓狗\",30);\n\n  echo $my_dog->Bark();\n```\n\n抽象類別的使用時機 : 當「多個類別（Class）」之間有共同的方法（function）或屬性（attribute）時，可以將這些共用的地方寫成「抽象類別（Abstract Class）」，讓其他的「子類別（Class）」去繼承\n\n## `trait` 的應用\n\n簡化 Class 功能複用\n\n```php\nclass Man\n{\n    public function walk() {\n       // ...\n    }\n    public function run() {\n       // ...\n    }\n}\n\nclass Woman\n{\n    public function walk() {\n      // ...\n    }\n    public function run() {\n       // ...\n    }\n}\n```\n\n當兩個 `class` 都有類似的內容(property 或 method)，用 `trait` 簡化\n\n```php\ntrait Moveable\n{\n    public function walk() {\n       // ...\n    }\n    public function run() {\n       // ...\n    }\n}\n\nclass Man\n{\n    use Moveable;\n}\n\nclass Woman\n{\n    use Moveable;\n}\n```\n\n`trait`的屬性無法被使用其的類別覆寫\n\n```php\ntrait CountAge\n{\n    protected $age;\n\n    public function getAge(): int { return $this->age; }\n    public function setAge(int $age): void { $this->age = $age; }\n}\n\nclass Child\n{\n    use CountAge;\n\n    protected $age = 10;\n}\n```\n\n因為 CountAge 與 Child 中都存在 `$age` 這個屬性，此時便會產生\n\n```html\nPHP Fatal error: Child and CountAge define the same property ($age) in the\ncomposition of Child. However, the definition differs and is considered\nincompatible.\n```\n\n在使用這個 `trait` 的 `class` 都可以使用其所定義的方法。`trait` 中定義的方法為共有的。\n\n```php\ntrait CheckAdult\n{\n    private function getAge(): int\n    {\n        return $this->age;\n    }\n\n    public function isAdult(): bool\n    {\n        return $this->getAge() >= 18;\n    }\n}\n\nclass Human\n{\n    use CheckAdult;\n\n    protected $age = 18;\n\n    public function canAccessPornHub(): bool\n    {\n        return $this->isAdult();\n    }\n\n    public function canAccessGayTube(): bool\n    {\n         public $this->getAge() >= 18;\n    }\n}\n```\n\n- 只要 `use` CheckAdult，就可以使用 `isAdult()` 與 `getAge()`。\n\n`trait` 之間不可以具有相同名稱的方法，否則會丟出 Fatal Error。\n\n```php\ntrait USD\n{\n    public function getBalance() {  }\n}\n\ntrait TWD\n{\n    public function getBalance() {  }\n}\n\nclass Wallet\n{\n    use USD;\n    use TWD;\n}\n```\n\n若將函式設為 private 也同樣會出現衝突。\n\n```php\ntrait USD\n{\n    private function convert(string $to) {\n       // ...\n       }\n    public function getUSDBalance(): int { return $this->convert('USD'); }\n}\n\ntrait TWD\n{\n    private function convert(string $to) {\n       // ...\n       }\n    public function getTWDBalance(): int { return $this->convert('TWD'); }\n}\n\nclass Wallet\n{\n    use USD;\n    use TWD;\n}\n```\n\n## `Static` 靜態關鍵字\n\n### 概念與定義\n\n用於宣告靜態變數與方法。所謂「靜態」表示這些變數和方法屬於類別本身，而不是類別的任何特定實例。因此無論創建多少類別的實例，靜態變數和方法只會有一個。\n\n### 目的和好處\n\n- 程式碼重用：用於 static 方法和變數是類別及別的，因此不需要創建類別實例就可以使用。有助於減少程式碼的重複。\n- 記憶體效率：靜態變數在所有實例間共享，因此他們同時也節省記憶體使用。尤其在需要多個實例共享資料狀或狀態時非常有用。\n\n1. 靜態屬性：\n   1. 靜態屬性是屬於 class 本身，而不是某個特定的物件實例。\n   2. 可以使用 `self::` 關鍵字來存取靜態屬性。\n   3. 靜態屬性在 class 的所有實例中共享。也就是說，若一個實例改變靜態屬性的值，其他實例也會受到影響。\n2. 靜態方法\n   1. 靜態方法可以在不建立實例的情況下被呼叫。\n   2. 使用 self:: 關鍵字來呼叫靜態方法。\n   3. 靜態方法中不能使用 $this，因為他們不屬於任何特定的物件實例。\n3. 靜態繼承\n   1. 在繼承的 class 中，靜態屬性和方法可以被子類別繼承。\n   2. 使用 `parent::` 關鍵字可以在子類別中呼叫父層的靜態方法。\n\n### 範例\n\n1. 計數器：\n   靜態屬性可以用來計算某個類別被實例化的次數。\n\n   ```php\n   class Counter {\n       public static $count = 0;\n\n       public function __construct() {\n           self::$count++;\n       }\n\n       public static function getCount() {\n           return self::$count;\n       }\n   }\n\n   $a = new Counter();\n   $b = new Counter();\n   echo Counter::getCount(); // 輸出: 2\n   ```\n\n2. 單例模式：\n   單例模式確保一個類別只有一個實例，並提供一個全局的訪問點。\n\n   ```php\n   class Singleton {\n       private static $instance = null;\n\n       private function __construct() {\n           // 私有構造函數防止外部實例化\n       }\n\n       public static function getInstance() {\n           if (self::$instance === null) {\n               self::$instance = new Singleton();\n           }\n           return self::$instance;\n       }\n   }\n\n   $singleton1 = Singleton::getInstance();\n   $singleton2 = Singleton::getInstance();\n   var_dump($singleton1 === $singleton2); // 輸出: bool(true)\n   ```\n\n3. 工具類別：\n   靜態方法可以用來實現不需要狀態的工具函數。\n\n   ```php\n   class Utility {\n       public static function formatDate($timestamp) {\n           return date('Y-m-d H:i:s', $timestamp);\n       }\n   }\n\n   echo Utility::formatDate(time()); // 輸出: 當前時間的格式化日期\n   ```\n\n4. 配置管理：\n   使用靜態屬性來存儲和管理應用程序的配置。\n\n   ```php\n   class Config {\n       private static $settings = [];\n\n       public static function set($key, $value) {\n           self::$settings[$key] = $value;\n       }\n\n       public static function get($key) {\n           return isset(self::$settings[$key]) ? self::$settings[$key] : null;\n       }\n   }\n\n   Config::set('database_host', 'localhost');\n   echo Config::get('database_host'); // 輸出: localhost\n   ```\n\n## 參考資料\n\n[後端 PHP+Laravel--新手實戰日記](https://ithelp.ithome.com.tw/articles/10216317)\n","tocContent":"- [PHP 物件導向](#php-物件導向)\n  - [物件和類別 `Objects` and `Classes`](#物件和類別-objects-and-classes)\n  - [建立類別 `Class`](#建立類別-class)\n  - [定義類別的屬性](#定義類別的屬性)\n  - [定義類別的方法 Methods](#定義類別的方法-methods)\n  - [定義類別的常數 const](#定義類別的常數-const)\n  - [封裝 Encapsulation](#封裝-encapsulation)\n  - [PHP 魔術函數](#php-魔術函數)\n    - [`__construct` 建構式](#__construct-建構式)\n    - [`__destruct` 解構式](#__destruct-解構式)\n    - [`unset`](#unset)\n    - [`__toString`](#__tostring)\n    - [`__get` `__set` 強制封裝](#__get-__set-強制封裝)\n  - [類別繼承](#類別繼承)\n    - [覆寫 Override 繼承的方法和屬性](#覆寫-override-繼承的方法和屬性)\n    - [`final` 避免被覆寫](#final-避免被覆寫)\n    - [範圍解析運算子 scope resolution operator](#範圍解析運算子-scope-resolution-operator)\n  - [將屬性和方法加上可視性 Visibility](#將屬性和方法加上可視性-visibility)\n    - [`Protected` 受保護的](#protected-受保護的)\n    - [`Private` 隱私的](#private-隱私的)\n  - [介面與抽象類別的應用](#介面與抽象類別的應用)\n    - [interface 介面](#interface-介面)\n    - [Abstract 抽象類別](#abstract-抽象類別)\n  - [`trait` 的應用](#trait-的應用)\n  - [`Static` 靜態關鍵字](#static-靜態關鍵字)\n    - [概念與定義](#概念與定義)\n    - [目的和好處](#目的和好處)\n    - [範例](#範例)\n  - [參考資料](#參考資料)"}