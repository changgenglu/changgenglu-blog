{"name":"Vue 學習筆記.md","content":"# Vue 學習筆記\n\n>\n\n## Vue 實體的生命週期\n\n- `beforeCreate`: 當 Vue 實例初始化時便立即調用，此時尚未創建實例，因此所有 Vue 實體中的設定(如：data)都還未配置。\n- `created`: 完成創建實例，此時 Vue 實體中的配置除了 \\$el 外，其餘已全部配置，而 \\$el 要在掛載模板後才會配置。\n- `beforeMount`: 在 Vue 實體中被掛載到目標元素之前調用，此時的 \\$el 依然未被 Vue 實體中的定義渲染的初始設定模板。\n- `mounted`: Vue 實體上的設置已經安裝上模板，此時 \\$el 是已經藉由實體中的定義渲染成真正的頁面。\n- `beforeUpdate`: Vue 實體中的 data 產生變化後，或是執行 vm.$forceUpdate() 時調用，此時頁面尚未被重新渲染成變過的畫面。\n- `update`: 在重新渲染頁面後調用，此時的頁面已經被重新渲染成改變後的畫面。\n- `beforeDestroy`: 在此實體被銷毀前調用，此時實體依然擁有完整的功能。\n- `destroyed`: 於此實體被銷毀後調用，此時實體中的任何定義(data, methods...)都已被解除綁定，在此做任何操作都會失效。\n\n## Vue 屬性\n\n### watch 監聽器\n\n當資料變化時調用函數，函數會有兩個傳入參數：改變前的值、改變後的後的值，可以使用這個函數做跟此資料變化有的處理。\n\n監聽器在 vue.js 中有兩種使用方式：\n\n- `$watch` 實體上的函數，使用此函數註冊監聽器。\n- `watch` 實體上的屬性，此屬性設置的物件在實體建立時會調用 `$watch` 註冊監聽器。\n\n`$watch` 是註冊監聽器的函數，而 watch 是為了開發者方便在實體上設置監聽器而提供的，其實 watch 本身也是使用 $watch 註冊監聽器。\n\n#### $watch\n\n```javascript\nunwatched = vm.$watch(expOrFn, callback, [options]);\n```\n\n`$watch` 的回傳值是註銷監聽器的函數，執行此函數可使監聽器失效。\n\n- `exOrFn` 設定要監聽的目標，可以使用 javascript 表達式或是一個回傳監聽目標值的函數\n- `callback` 當數值改變時，要叫用的函數，此函數會有兩個傳入參數：callback(newVal, oldVal)\n  - `newVal` 改變後的資料值\n  - `oldVal` 改變前的資料值\n- `[options]` 非必要參數，監聽器的設定\n  - `deep` 監聽物件時，物件下層屬性變化也會觸發監聽器\n  - `immediate` 在實體初始畫設置監聽器的時候馬上叫用 callback 函數\n\n```html\n<div id=\"app\">\n  <button @click=\"a++\">+</button>\n  <button @click=\"a--\">--</button>\n  <div>a: {{a}}</div>\n  <div>changed: {{newA}}</div>\n  <div>before change: {{oldA}}</div>\n</div>\n```\n\n```javascript\nvar vm = new Vue({\n  ...\n  data: {\n    a: 1,\n    newA: 0,\n    oldA: 0\n  }\n});\n\nvm.$watch('a', function(newA, oldA) {\n  this.newA = newA;\n  this.oldA = oldA;\n});\n```\n\n#### watch\n\n```javascript\nwatch: (\n  key: value,\n  ...\n)\n```\n\n- 以 watch 為 key 值，下面定義的屬性都是欲監聽的資料來源。\n- key 監聽目標名稱，可以使用 javascript 表達式\n- value callback 函數的設定，共有 string, function, object 及 array 可以設定。\n  - string callback 函數名稱\n  - function callback 函數\n  - object 設定監聽物件，設定方法如下\n    - handler callback 函數\n    - deep 布林值，是否監聽物件下層屬性\n    - immediate 布林值 使否在實體初始化時立即調用 callback\n  - array 當有多個監聽器時，使用陣列帶入多個 callback 函數\n\n### computed 計算\n\n和 watch 一樣，都是用來監聽數據的方式，但使用場景不同。\n\ncomputed 是一個計算屬性，他根據依賴的資料，動態計算出一個新的值，並且會自動存入快取。當依賴的資料發生變化時，computed 會自動重新計算。這樣可以有效避免重複計算和提高性能。\n\ncomputed 通常用計算衍生的資料，例如從一個列表中過濾出符合條件的資料，或根據資料的狀態產生顯示內容等等。在模板中，可以像普通的資料屬性一樣使用 computed\n\n```javascript\nexport default {\n  data() {\n    return {\n      count: 0,\n    };\n  },\n  computed: {\n    doubleCount() {\n      return this.count * 2;\n    },\n  },\n};\n```\n\n`doubleCount` 為一個計算屬性，他依賴於 count 屬性。當 count 屬性發生變化時，doubleCount 會自動重新計算。在模板中，可以像下面這樣使用：\n\n```html\n<p>count: {{ count }}</p>\n<p>double count: {{ doubleCount }}</p>\n```\n\n#### computed 和 watch 的差別\n\ncomputed 最大特點是必須回傳一個值，並且將其存入快取，當方法中的依賴改變時，才會重新執行和求值。\n\n但 watch 和 methods 不會強制要求回傳一個值，他們只需要執行動作，不一定要回傳值。\n\nwatch 會偵測單一個值，當她有變化時就執行。methods 只要呼叫，就會執行。\n\n- computed 的特點\n\n  - 當元件被建立時(created 生命週期)，computed 方法會被建立和執行一次。之後如果依賴沒有更新，就不會重新執行和求值，僅回傳快取的值。\n  - computed 只能被該 computed 修改，不能被其他方法修改。例如：this.some_computed_function = 123 就會報錯。\n  - computed 的方法必須回傳一個值。\n  - computed 方法無法傳入參數\n  - computed 依賴更新才會重新執行\n\n    > vue 官方文件\n    >\n    > 计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。\n\n    響應式依賴：在一個 computed 方法中，他所用到在 data 建立的資料，當資料產生變化，此方法就會重新執行和求值。\n\n    ```javascript\n    computed:{\n        total(){\n            return this.price * this.quantity * this.discount\n        }\n    }\n    ```\n\n    total 的依賴就是 this.price, this.quantity, this.discount。只要其中一樣產生變化，就會重新執行 total()，並回傳新的值。\n\n    當 computed 內所有的依賴都沒有發生變化，此 computed 函示就會一直回傳之前儲存起來的值。\n\n    ```javascript\n    <div id=\"app\">\n      <button @click=\"num = 1\">按我改num</button>\n      <p> 用add方法把以下的值由0變1：</p>\n      <p> {{ add }} </p>\n    </div>\n    ```\n\n    ```javascript\n    // 當num變成1之後，changeOne()就不會再觸發，而「我有被觸發了！」這句也不會印出來\n\n    import { createApp } from \"https://cdnjs.cloudflare.com/ajax/libs/vue/3.0.9/vue.esm-browser.js\";\n    createApp({\n      data() {\n        return { num: 0 };\n      },\n      computed: {\n        add() {\n          console.log(\"我有被觸發了！\");\n          return this.num;\n        },\n      },\n    }).mount(\"#app\");\n    ```\n\n    當元件剛建立時(created)時，會打印一次，然後第一次按下按鈕時，會在打印一次，並且 num 會變成 1。\n    但第二次之後按下按鈕，就不會再觸發 add() 方法，因為每次按下按鈕，都會將 num 賦值為 1，和之前快取儲存的值相同。\n\n## eventHub 事件中心(vue 2)\n\n在無關聯的組件之間，互相傳遞 data\n\n在需要取得 data 的組件上設置一個監聽器，每次要傳遞 data 時，那個組件就會廣播這個事件並調用這些監聽器。\n\neventHub 最主要的功能就是**監聽**和**廣播**\n\n若 vue 搭配其他框架時，在 library 新增一個 eventHub.js\n\n```javascript\nimport Vue from \"vue\";\nconst eventHub = new Vue();\nexport default eventHub;\n```\n\n若只有單純 vue 框架，則在頂層組件的 `data` 裡初始化 eventHub，並使用 `provide` 對外傳遞這個 eventHub\n\n```javascript\nimport Vue from \"vue\";\n\nexport default {\n  name: \"App\",\n  components: {\n    GrandParent,\n  },\n  data() {\n    return {\n      eventHub: new Vue(),\n    };\n  },\n  provide() {\n    return {\n      eventHub: this.eventHub,\n    };\n  },\n  methods: {\n    setRandomValue() {\n      this.eventHub.$emit(\"update:msg\", Math.random() * 100);\n    },\n  },\n};\n```\n\n在要傳遞 data 的組件裡加入廣播\n\n```javascript\nimport eventHub from \"../library/eventHub\";\nexport default {\n  data() {\n    return {\n      name: \"\",\n    };\n  },\n  methods: {\n    getCategories: function () {\n      let id = \"\";\n      axios\n        .get(base_url + \"/api/category/\")\n        .then((response) => {\n          this.name = response.data.name;\n          eventHub.$emit(\"categoryupdate\", this.name);\n        })\n        .catch(function (error) {\n          console.log(error);\n        });\n    },\n  },\n  created() {\n    this.getCategories();\n  },\n};\n```\n\n接著在需要監聽的組件裡注入這個依賴，並在添加事件監聽。\n\n```javascript\nimport eventHub from \"../library/eventHub\";\nexport default {\n  data() {\n    return {\n      categories: [],\n    };\n  },\n  mounted() {\n    eventHub.$on(\"categoryupdate\", this.categoryupdate);\n  },\n  methods: {\n    categoryupdate(input) {\n      this.categories.push(input);\n    },\n  },\n};\n```\n\n## directive 指令\n\n### 屬性綁定\n\n透過 `v-bind`，進行數據綁定 HTML class\n\n傳遞對象給 v-bind:class，用以動態切換 class\n\n```html\n<div v-bind:class=\"{ active: isActive }\"></div>\n```\n\n此時 `active` 這個 class 是否存在，將取決於 property `isActive` 的 truthiness(註 1)。\n\n可以在對象中傳入更多屬性，來動態切換多個 class。此外 v-bind:class 也可以與普通的 class attribute 共存\n\n```html\n<div\n  class=\"static\"\n  v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\n```\n\ndata:\n\n```javascript\ndata: {\n  isActive: true,\n  hasError: false\n}\n```\n\n渲染結果\n\n```html\n<div class=\"static active\"></div>\n```\n\n當 isActive 或 hasError 變化時，class 的屬性會同步更新。\n\n例如：若 hasError 值為 true，class 屬性將變為 \"static active text-danger\"。\n\n綁定的數據對象，不一定要定義在模板裡\n\n```html\n<div v-bind:class=\"classObject\"></div>\n```\n\n```javascript\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n```\n\n此渲染的結果和上面一樣。\n\n也可以在此綁定 computed 屬性。\n\n```html\n<div v-bind:class=\"classObject\"></div>\n```\n\n```javascript\ndata: {\n  isActive: true,\n  error: null\n},\ncomputed: {\n  classObject: function () {\n    return {\n      active: this.isActive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal'\n    }\n  }\n}\n```\n\n### 表單綁定 `v-model`\n\n> 當使用 v-model 指令時，表單元素會自動忽略原有的 value, checked 和 selected 屬性，實際的值將以 data 內的狀態為主\n\n#### input\n\n在 input 文字框加入 v-model=\"message\" 屬性之後，此文字框便會自動被綁定 input 事件\n\n```html\n<div id=\"app\">\n  <input type=\"text\" v-model=\"message\" />\n  <p>Message is {{ message }}</p>\n</div>\n\n<script>\n  const vm = Vue.createApp({\n    data() {\n      return {\n        message: \"Hello\",\n      };\n    },\n  });\n</script>\n```\n\n#### textarea 文字方塊\n\n使用方式與 input 完全一樣\n\n```html\n<p><span>Multiline message is:</span>{{ message }}</p>\n\n<textarea v-model=\"message\"></textarea>\n```\n\n#### radio\n\n```html\n<div id=\"app\">\n  <div>\n    <input type=\"radio\" id=\"one\" value=\"1\" v-model=\"picked\" />\n    <label for=\"one\">One</label>\n  </div>\n  <div>\n    <input type=\"radio\" id=\"two\" value=\"2\" v-model=\"picked\" />\n    <label for=\"two\">Two</label>\n  </div>\n\n  <span>Picked: {{ picked }}</span>\n</div>\n\n<script>\n  const vm = Vue.createApp({\n    data() {\n      return {\n        picked: 1,\n      };\n    },\n  }).mount(\"#app\");\n</script>\n```\n\n因為 data 裡的 picked 預設為 1，所以執行時畫面上 `<input type=\"radio\" id=\"one\" value=\"1\">` 會預設為已選擇\n\n#### checkbox\n\n可以當作多選的選項，而當他只有一個的時候，又可以將它做 boolean 的選項\n\n複選時，用法跟前面 radio 完全一樣，因為是複選的關係，其差別在 data 內的狀態必須為陣列\n\n```html\n<div id=\"app\">\n  <input type=\"checkbox\" id=\"jack\" value=\"jack\" v-model=\"checkedNames\" />\n  <label for=\"jack\">jack</label>\n  <input type=\"checkbox\" id=\"john\" value=\"john\" v-model=\"checkedNames\" />\n  <label for=\"john\">john</label>\n  <input type=\"checkbox\" id=\"mike\" value=\"mike\" v-model=\"checkedNames\" />\n  <label for=\"mike\">mike</label>\n  <input type=\"checkbox\" id=\"mary\" value=\"mary\" v-model=\"checkedNames\" />\n  <label for=\"mary\">mary</label>\n  <br />\n  <p>Checked names: {{ checkedNames }}</p>\n</div>\n\n<script>\n  const vm = Vue.createApp({\n    data() {\n      return {\n        checkedNames: [],\n      };\n    },\n  }).mount(\"#app\");\n</script>\n```\n\n- 如果要控制表單的全選或全部取消，只要控制 data 內的 checkedNames 陣列內容即可\n\n當 checkbox 為單選時\n\n```html\n<div id=\"app\">\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"isChecked\" />\n  <label for=\"jack\">Status: {{ isChecked }}</label>\n</div>\n\n<script>\n  const vm = Vue.createApp({\n    data() {\n      return {\n        isChecked: true,\n      };\n    },\n  }).mount(\"#app\");\n</script>\n```\n\n此時， data 內的選項，會變成 true 或 false，當值為 true 時，對應的 checkbox 會被勾起。\n\n#### select 下拉式選單\n\n```html\n<div id=\"app\">\n  <select v-model=\"selected\">\n    <option disabled value=\"\">請選擇</option>\n    <option>台北市</option>\n    <option>新北市</option>\n    <option>基隆市</option>\n  </select>\n\n  <p>Selected: {{ selected || '未選擇' }}</p>\n</div>\n\n<script>\n  const vm = Vue.createApp({\n    data() {\n      return {\n        selected: \"\",\n      };\n    },\n  }).mount(\"#app\");\n</script>\n```\n\nv-model 標籤須使用在 `<select>` 標籤，不能用在 `<option>` 標籤中\n\n### v-model 修飾子\n\n#### .lazy\n\n```html\n<input v-model.lazy=\"message\" />\n```\n\n在 v-model 屬性後面加上.lazy，此輸入框就會從原本的 input 事件，變成監聽 change 事件\n\n也就是，原本 input 事件會在輸入值時做實時的更新，而監聽 change 事件，則是當使用者離開輸入框焦點時才會更新。\n\n### 模板綁定\n\n#### v-text\n\n```html\n<div id=\"app\">\n  <div v-text=\"text\"></div>\n</div>\n\n<script>\n  const vm = Vue.createApp({\n    data() {\n      return {\n        text: \"hello\",\n      };\n    },\n  }).mount(\"#app\");\n</script>\n```\n\n當透過 v-text 指令來進行綁定，此時畫面渲染出來的結果會與下面相同\n\n```html\n<div>{{ text }}</div>\n```\n\n但若在 v-text 綁定的標籤內加入文字，以 v-text 指令渲染出來的結果會無視標籤內的內容\n\n```html\n<!-- 只會出現 Hello -->\n<div v-text=\"text\">World!</div>\n\n<!-- 出現 Hello world! -->\n<div>{{ text }} world!</div>\n```\n\n#### v-html\n\n和 v-text 類似，但當 data 的內容為 HTML 的語法時，v-html 會將其渲染為 html 語法\n\n```html\n<button v-for=\"(item, index) in data.links\">{{ item.label }}</button>\n<!--  輸出結果 -->\n&laquo; Previous\n```\n\n```html\n<button v-for=\"(item, index) in data.links\" v-html=\"item.label\"></button>\n<!--  輸出結果 -->\n<< Previous\n```\n\n#### v-once\n\n只渲染指定的節點一次，往後就不再更新\n\n#### v-pre\n\n加入 v-pre 後，就不會解析模板內容。\n\n### 樣式綁定\n\n## 條件渲染\n\n### v-if\n\n其屬性為 truthy，當其返回 true 時會被渲染。\n\n```html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n\n可以添加 `v-else`\n\n```html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>It's not true.</h1>\n```\n\n還可以添加 `v-else-if`\n\n此三元素需緊跟彼此，否則將不會被識別\n\n### v-show\n\n和 `v-if` 用法類似，不同的是 `v-show` 的元素始終會被渲染並保留在 DOM 中，`v-show` 只是單純的切換元素的 CSS property display。\n\n`v-if` 是真正的條件渲染，他會確保在切換過程中條件內的事件監聽器和子組件適當的被銷毀和重建。\n\n同時 `v-if` 也是惰性的，若在初始渲染時條件為 false，則不執行，直至條件第一次轉為 true 時，才會開始渲染。\n\n相較之下，`v-show` 就比較單純，無論初始條件，元素總是會被渲染，`v-show` 做的只是基於 CSS 進行切換。\n\n## 迴圈渲染\n\nv-for 可以用陣列進行渲染成一個列表。其語法為 item in items，items 為源陣列，而 item 則為被迭代的陣列元素別名。\n\n```html\n<ul id=\"example-1\">\n  <li v-for=\"item in items\" :key=\"item.message\">{{ item.message }}</li>\n</ul>\n```\n\n```javascript\nvar example1 = new Vue({\n  el: \"#example-1\",\n  data: {\n    items: [{ message: \"Foo\" }, { message: \"Bar\" }],\n  },\n});\n```\n\n輸出\n\n```txt\nFoo\nBar\n```\n\n在 v-for 中可以訪問所有父作用域的 property。v-for 還可加入可選的第二參數作為當前的 key 值。\n\n```html\n<ul id=\"example-2\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n```\n\n```javascript\nvar example2 = new Vue({\n  el: \"#example-2\",\n  data: {\n    parentMessage: \"Parent\",\n    items: [{ message: \"Foo\" }, { message: \"Bar\" }],\n  },\n});\n```\n\n```txt\nparent-0-Foo\nparent-1-Bar\n```\n\n用 v-for 來迭代一個對象的 property\n\n```html\n<ul id=\"v-for-object\" class=\"demo\">\n  <li v-for=\"value in object\">{{ value }}</li>\n</ul>\n```\n\n```javascript\nnew Vue({\n  el: \"#v-for-object\",\n  data: {\n    object: {\n      title: \"How to do lists in Vue\",\n      author: \"Jane Doe\",\n      publishedAt: \"2016-04-10\",\n    },\n  },\n});\n```\n\n```txt\nHow to do lists in Vue\nJane Doe\n2016-04-10\n```\n\n可以傳入第二個參數作為 property 的名稱(key 值)\n\n```html\n<div v-for=\"(value, name) in object\">{{ name }}: {{ value }}</div>\n```\n\n```txt\ntitle: How to do lists in Vue\nauthor: Jane Doe\npublishedAt: 2016-04-10\n```\n\n還可以傳入第三個參數作為索引值\n\n```html\n<div v-for=\"(value, name, index) in object\">\n  {{ index }}. {{ name }}: {{ value }}\n</div>\n```\n\n```txt\n0. title: How to do lists in Vue\n1. author: Jane Doe\n2. **publishedAt**: 2016-04-10\n```\n\n## 事件監聽器\n\n> 靜態事件監聽\n>\n> - 元素上使用 v-on 監聽原生事件\n> - 父組件設定 v-on 設定所需要監聽的事件，子組件用 $emit 觸發事件\n> - 在 Vue 實體上設定生命週期鉤子，監聽各個鉤子事件。\n\n當要在執行時去動態增減事件的監聽，這時就要用到 $on, $once, and $off 這些 js 函式來做設定。\n\n## props\n\n### 命名與使用\n\n可以使用 PascalCase 或是 camelCase 的命名方法，但在 html 中必須使用 kebab-case 且應該小寫(html 大小寫不敏感)\n\n像是 PostTitle 、 CartItem 、 TodoItem 等，在 HTML 中使用時就會變成 post-title 、 cart-item 、 todo-item。\n\n```vue\n<div id=\"vm\">\n<!--post-title 跟 post-content 都是props -->\n  <blog-post post-title=\"Blog1\" post-content=\"I\\'m content1\"></blog-post>\n</div>\n\n<script>\nVue.component(\"blog-post\", {\n  props: [\"PostTitle\", \"postContent\"],\n  template: `<div>\n    <h3>{{ PostTitle }}</h3>\n    <div>{{ postContent }}</div>\n  </div>`,\n});\n</script>\n```\n\n### 傳遞 props 值的方法\n\n#### 傳遞字串\n\n```vue\n<blog-post\n  post-title=\"Blog1\"\n  post-content=\"I\\'m content1\"\n  post-complete=\"true\"\n  post-total-num=\"500\"\n  post=\"{title:'Blog1'}\"\n>\n</blog-post>\n```\n\n只要是直接傳遞(靜態傳遞)都是字串，所以 prop 接收的值 log1、I\\'m content1、true、500、{...} 等等都是字串。\n\n#### 傳遞數字、布林值、陣列、物件\n\n利用 vue 的 v-bind 傳遞字串以外的值。\n\n```vue\n<blog-post\n  post-title=\"動態傳遞\"\n  post-content=\"I\\'m content1\"\n  v-bind:post-complete=\"true\"\n  v-bind:post-total-num=\"500\"\n  v-bind:post=\"{ title: '動態傳遞' }\"\n></blog-post>\n```\n\n也可以透過給予變數來獲得數字、布林值、陣列或物件等型別\n\n```vue\n<blog-post\n  :post-title=\"postTitle\"\n  :post-content=\"postContent\"\n  :post-complete=\"postComplete\"\n  :post-total-num=\"postTotalNum\"\n  :post=\"post\"\n></blog-post>\n\n<script>\nconst vm = new Vue({\n  el: \"#vm\",\n  data: {\n    postTitle: \"動態傳遞\",\n    postContent: \"I'm content\",\n    postComplete: true,\n    postTotalNum: 500,\n    post: { title: \"動態傳遞\" },\n  },\n});\n</script>\n```\n\n### 單向數據流\n\nprop 是為了接收從富組件傳遞過來的資料，而這些資料是單向綁定的，已就是說父模組資料的更新，會影響子模組裡的 prop，但子模組裡 prop 值改變並不會影響父模組。\n\n```vue\n<prop-change :counter=\"counter\"></prop-change>\n<br />\n<span>外 {{counter}}</span>\n<button type=\"button\" @click=\"changeOuterCounter\">改變外面數字</button>\n\n<script>\nVue.component(\"prop-change\", {\n  props: [\"counter\"],\n  template: `<div>\n    <span>component內的  {{counter}}</span>\n    <button type=\"button\" @click=\"changeInnerCounter\">改變component數字</button>\n  </div>`,\n  methods: {\n    changeInnerCounter() {\n      this.counter += 2;\n    },\n  },\n});\n\nconst vm = new Vue({\n  el: \"#vm\",\n  data: {\n    counter: 1,\n  },\n  methods: {\n    changeOuterCounter() {\n      this.counter += 1;\n    },\n  },\n});\n</script>\n```\n\n以上測試可以得知：\n\n- 外面(父層)的資料 counter 改變會影響子模組 prop 的 counter 的值。\n- 子模組 prop 的 counter 值改變僅影響內部 counter 值\n- 不論子模組的 prop 的 counter 值是否有變動，只要父模組資料 counter 改變時，子模組 prop 的 counter 值一定會連動。\n\n### 改變子模組內的 prop 值\n\n- 在 data 內創建一個值\n  賦予 data 跟 prop 初始值相同的值，且之後也是針對該 data 內的值操作，並且不會再受到該 prop 的影響了\n\n  ```javascript\n  Vue.component(\"one-way-data\", {\n    props: [\"counter\"],\n    template: `<div>\n      <span>component內的  {{newCounter}}</span>\n      <button type=\"button\" @click=\"changeNewCounter\">改變component數字</button>\n    </div>`,\n    data() {\n      return {\n        newCounter: this.counter,\n      };\n    },\n    methods: {\n      changeNewCounter() {\n        this.newCounter += 10;\n      },\n    },\n  });\n  ```\n\n### 物件型別的 prop 傳遞\n\n- 父層透過標籤傳遞參數\n\n```javascript\n<ExLogLineComponent :channel-names=\"channel_names\" :region-id=\"region.id\" :bx-mac=\"region.bx_mac\"></ExLogLineComponent>\n```\n\n- 子層 prop 接收參數後，透過 watch 將參數存入 data.return\n\n```javascript\nprops: ['channelNames', 'regionId', 'bxMac'],\n    data() {\n        return {\n            channel_names: [],\n            region_id: '',\n            mac: ''\n        }\n    },\n    watch: {\n        channelNames(names) {\n            this.channel_names = names;\n        },\n        regionId(id) {\n            this.region_id = id;\n        },\n        bxMac(mac) {\n            this.mac = mac;\n        }\n    },\n```\n\n### 子組件接收來自父組件的 props\n\n#### 在模板中\n\n```vue\n<template>\n  <div>{{ parentData }}</div>\n</template>\n\n<script>\nexport default {\n  props: [\"parentData\"],\n};\n</script>\n```\n\n#### 在 data 中\n\n```vue\n<script>\nexport default {\n  props: [\"parentData\"],\n  data() {\n    return {\n      parent_data: this.parentData,\n    };\n  },\n};\n</script>\n```\n\n#### 在 methods 中\n\n```vue\n<script>\nexport default {\n  props: [\"parentData\"],\n  methods: {\n    printParentData: function () {\n      console.log(this.$props.parentData);\n    },\n  },\n};\n</script>\n```\n\n#### 在 mounted 中\n\n```vue\n<script>\nexport default {\n  props: [\"parentData\"],\n  mounted() {\n    console.log(this.message);\n  },\n};\n</script>\n```\n\n#### 在 computed 中\n\n```vue\n<template>\n  <div>\n    <p>{{ parentDataLength }}</p>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: [\"parentData\"],\n  computed: {\n    parentDataLength() {\n      return this.parentData.length;\n    },\n  },\n};\n</script>\n```\n\n## emit 子組件向父組件傳遞參數\n\n```vue\n<!-- 子組件 HelloWorld.vue -->\n<template>\n  <div></div>\n</template>\n\n<script>\nexport default {\n  methods: {\n    open() {\n      console.log(\"已呼叫\");\n      // 呼叫父組件方法\n      this.$emit(\"refresh-data\");\n    },\n  },\n};\n</script>\n```\n\n```vue\n<!-- 父組件 -->\n<template>\n  <div id=\"app\">\n    <!-- 子組件傳遞的方法 refresh-data -->\n    <HelloWorld ref=\"hello\" @refresh-data=\"getData\" />\n    <button @click=\"getHello\">取得 HelloWorld 組件中的值</button>\n  </div>\n</template>\n\n<script>\nimport HelloWorld from \"./components/HelloWorld.vue\";\n\nexport default {\n  components: {\n    HelloWorld,\n  },\n  data() {\n    return {};\n  },\n  methods: {\n    getHello() {\n      this.$refs.hello.open();\n    },\n    getData() {\n      console.log(\"111111111\");\n    },\n  },\n};\n</script>\n```\n\n最後輸出時，`已呼叫`為子組件輸出，`111111111111`為父組件輸出\n\n## ref 取得 Dom 元素\n\n> `refs` 是 vue 提供的一個 api，可以讓我們在 vue 中取得 Dom 元素\n\n`ref` 被用來給元素或子組件註冊引用訊息，引用訊息將會註冊在父組件的`$refs` 物件上，如果在普通的 dom 元素上使用，那麼指向的就會是普通的 dom 元素；如果用在子組件上，引用就會指向該子組件的實例。\n\nref 的特性就是為元素或子組件賦予一個 id 引用，通過 `this.$ref.refName` 來訪問元素或是子組件的實例。\n\n- 一共有三種用法：\n  - ref 加在普通元素上，用 `this.ref.name` 獲取到的是 dom 元素\n  - ref 加在子組件上，用 `this.ref.name` 方式，獲得的是組件實例，可以使用組件的所有方法。\n  - 如何利用 v-for 和 ref 獲取一組陣列或是 dom 節點\n\n### 基本用法：取得 dom 元素\n\n```html\n<p ref=\"p\">Hello</p>\n<children ref=\"children\"></children>\n```\n\n```javascript\nthis.$ref.p;\nthis.$ref.children;\n```\n\n### 獲取子組件中的 data 和調用子組件的方法\n\n```vue\n<!-- 子組件 -->\n<template>\n  <div>{{ msg }}</div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      msg: \"我是子組件\";\n    }\n  },\n  methods: {\n    changeMsg() {\n      this.mag = \"變身\";\n    }\n  }\n}\n</script>\n```\n\n```vue\n<!-- 父組件 -->\n<template>\n  <div @click=\"parentMethod\">\n    <children ref=\"children\"></children>\n  </div>\n</template>\n\n<script>\nimport children from \"components/children.vue\";\n\nexport default {\n  components: {\n    children,\n  },\n  data() {\n    return {};\n  },\n  methods: {\n    parentMethod() {\n      this.$ref.children; // 返回一個物件\n      this.$ref.children.changMsg(); // 呼叫 children 的 changeMsg 方法\n    },\n  },\n};\n</script>\n```\n\n### this.$refs 介紹\n\n`this.$refs` 為一個物件，持有當前組件中註冊過`ref`特性的所有`dom`元素和子組件實例。\n\n注意：`$refs` 只有在組件完成渲染後才會填充，在初始渲染時無法取得，並且他是非響應式的，因此不能用他模版中做數據綁定。\n\n當 ref 和 v-for 一起用時，你得到的 ref 將會是一個包含了對應的數據源的這些子組件的陣列。\n\n```vue\n<template>\n  <ul>\n    <li v-for=\"item in people\" ref=\"refContent\">{{ item }}</li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  data: {\n    return {\n      people:['one', 'two', 'three', 'four', 'five']\n    }\n  },\n  created() {\n    this.$nextTick(() => {\n      console.log(this.$refs.refContent);\n    })\n  },\n  mounted() {\n    console.log(this.$refs.refContent);\n  }\n};\n</script>\n```\n\n## Mixin 共用方法\n\n> 參考資料：\n>\n> [彻底搞懂 Vue 中的 Mixin 混入（保姆级教程）](https://juejin.cn/post/7076340796361801759)\n\n將組件的共用邏輯或設定抽出，當組件需要使用時，直接將抽出的部分混入到組件內部。\n\n```js\n// src/mixin/index.js\nexport const index = {\n  data() {\n    return {\n      msg: \"msg from mixin\",\n    };\n  },\n  computed: {},\n  created() {\n    console.log(\"created in mixin\");\n  },\n  mounted() {\n    console.log(\"mounted in mixin\");\n  },\n  methods: {\n    clickMe() {\n      console.log(\"click in mixin\");\n    },\n  },\n};\n```\n\n當 mixin 定義好之後，依據不同的業務場景，可以分為兩種：局部混入和全局混入。顧名思義，局部混入和元件的載入有點類似，就是當需要使用到 mixin 的程式碼時，在元件中引入。而全局混入則將 mixin 於 app.js 中引入，此時專案中任何元件都可以使用 mixin。\n\n### 局部混入\n\n在 component 中引入 mixin：\n\n```vue\n// src/App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <button @click=\"clickMe\">button</button>\n  </div>\n</template>\n\n<script>\nimport { mixins } from \"./mixin/index\";\nexport default {\n  name: \"App\",\n  mixins: [mixins],\n  created() {\n    console.log(\"component call mixin data: \", this.msg);\n  },\n  mounted() {\n    console.log(\"mounted in component\");\n  },\n};\n</script>\n```\n\n輸出：\n\n```text\ncreated in mixin\ncomponent call mixin data: msg from mixin\nmounted in mixin\nmounted in component\nclick in mixin\n```\n\n- mixin 的生命週期函數會和元件的生命週期一起合併執行\n- 元件可以使用 mixin 中的 data 資料\n- 元件中可以直接呼叫 mixin 中的方法\n- 生命週期的執行順序為：先執行 mixin 再執行 component\n\n若多個元件都有引入 mixin，當期中一個元件修改了 mixin 的資料，會影響其他元件嗎？\n\n```vue\n// src/component/demo.vue\n<template>\n  <button @click=\"demoShowMsg\">demo button</button>\n</template>\n<script>\nimport { mixins } from \"../mixin/index\";\nexport default {\n  mixins: [mixins],\n  methods: {\n    demoShowMsg() {\n      console.log(\"msg in demo: \", this.msg);\n    },\n  },\n};\n</script>\n```\n\n在 App.vue 中引入\n\n```vue\n// src/App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <button @click=\"clickMe\">button</button>\n    <button @click=\"changeMsg\">edit mixin data</button>\n    <demo></demo>\n  </div>\n</template>\n\n<script>\nimport { mixins } from \"./mixin/index\";\nimport demo from \"./components/demo.vue\";\nexport default {\n  name: \"App\",\n  mixins: [mixins],\n  components: { demo },\n  created() {\n    console.log(\"component call mixin data: \", this.msg);\n  },\n  mounted() {\n    console.log(\"mounted in component\");\n  },\n  methods: {\n    changeMsg() {\n      this.msg = \"new message\";\n      console.log(\"new msg:\", this.msg);\n    },\n  },\n};\n</script>\n```\n\n輸出：\n\n```text\ncreated in mixin\ncomponent call mixin data: msg from mixin\ncreated in mixin\nmounted in mixin\nmounted in mixin\nmounted in component\nnew msg in App: new message\nmsg in demo: msg from mixin\n```\n\n由上面程式碼可以得知，當 App.vue 中修改 msg 後，demo 元件並沒有受到任何變化。\n\n### 全域混入\n\n將 mixin 在 main.js 中註冊後，便可以在任何元件中直接使用。\n\n```js\n// main.js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\nimport { mixins } from \"./mixin/index\";\nVue.mixin(mixins);\n\nVue.config.productionTip = false;\n\nnew Vue({\n  render: (h) => h(App),\n}).$mount(\"#app\");\n```\n\n此時若將前面的 App.vue 中引入 mixin 的部分註解掉，會發現效果和局部混入沒有任何差別。\n\n```vue\n// src/App.vue\n<template>\n  <div id=\"app\">\n    <img alt=\"Vue logo\" src=\"./assets/logo.png\" />\n    <button @click=\"clickMe\">button</button>\n    <button @click=\"changeMsg\">edit mixin data</button>\n    <demo></demo>\n  </div>\n</template>\n\n<script>\n// import { mixins } from \"./mixin/index\";\nimport demo from \"./components/demo.vue\";\nexport default {\n  name: \"App\",\n  // mixins: [mixins],\n  components: { demo },\n  created() {\n    console.log(\"component call mixin data: \", this.msg);\n  },\n  mounted() {\n    console.log(\"mounted in component\");\n  },\n  methods: {\n    changeMsg() {\n      this.msg = \"new message\";\n      console.log(\"new msg:\", this.msg);\n    },\n  },\n};\n</script>\n```\n\n雖然這樣做很方便，但是一般而言不推薦。\n\nvue 官方：\n\n> 請謹慎使用全域混入，因為他會影響每個獨立建立的 Vue 實例（包括第三方元件）。大多數情況下，只應應用於自訂選項，推薦將其作為插件發布，以避免重複應用程式混入。\n\n### vuex 和 mixin 的區別\n\n- vuex: 用來做狀態管理，裡面定義的變數在不同元件中均可以使用和修改。而在任一元件中修改此變數的值後，其他元件中此變數的值也會隨之修改。\n- mixin: 可以定義共用的變數，在每個組件之中使用。引入組件後，每個變數都是獨立的，值的修改在組件中不會互相影響。\n\n## 備註\n\n### Truthy(真值) 與 Falsy(假值)\n\n- `Truthy`：真值，只要是假值(false, 0, -0, 0n, \"\", null, undefined, NaN)以外的任何值皆為 true\n- `Falsy`：假值\n\n### 判斷當前環境是否為開發環境\n\n```javascript\nif (process.env.NODE_ENV !== \"production\") {\n  this.is_dev = true;\n} else {\n  this.is_dev = false;\n}\n```\n\n### 取得 base_url\n\n- 在 html 加入 meta 標籤\n\n  ```html\n  <head>\n    <meta name=\"base-url\" content=\"{{ url('/') }}\" />\n  </head>\n  ```\n\n- 此時就可以透過 meta 標籤取得 base_url\n\n  ```javascript\n  window.base_url = document.head.querySelector('meta[name=\"base-url\"]');\n  ```\n","tocContent":"- [Vue 學習筆記](#vue-學習筆記)\n  - [Vue 實體的生命週期](#vue-實體的生命週期)\n  - [Vue 屬性](#vue-屬性)\n    - [watch 監聽器](#watch-監聽器)\n      - [$watch](#watch)\n      - [watch](#watch-1)\n    - [computed 計算](#computed-計算)\n      - [computed 和 watch 的差別](#computed-和-watch-的差別)\n  - [eventHub 事件中心(vue 2)](#eventhub-事件中心vue-2)\n  - [directive 指令](#directive-指令)\n    - [屬性綁定](#屬性綁定)\n    - [表單綁定 `v-model`](#表單綁定-v-model)\n      - [input](#input)\n      - [textarea 文字方塊](#textarea-文字方塊)\n      - [radio](#radio)\n      - [checkbox](#checkbox)\n      - [select 下拉式選單](#select-下拉式選單)\n    - [v-model 修飾子](#v-model-修飾子)\n      - [.lazy](#lazy)\n    - [模板綁定](#模板綁定)\n      - [v-text](#v-text)\n      - [v-html](#v-html)\n      - [v-once](#v-once)\n      - [v-pre](#v-pre)\n    - [樣式綁定](#樣式綁定)\n  - [條件渲染](#條件渲染)\n    - [v-if](#v-if)\n    - [v-show](#v-show)\n  - [迴圈渲染](#迴圈渲染)\n  - [事件監聽器](#事件監聽器)\n  - [props](#props)\n    - [命名與使用](#命名與使用)\n    - [傳遞 props 值的方法](#傳遞-props-值的方法)\n      - [傳遞字串](#傳遞字串)\n      - [傳遞數字、布林值、陣列、物件](#傳遞數字布林值陣列物件)\n    - [單向數據流](#單向數據流)\n    - [改變子模組內的 prop 值](#改變子模組內的-prop-值)\n    - [物件型別的 prop 傳遞](#物件型別的-prop-傳遞)\n    - [子組件接收來自父組件的 props](#子組件接收來自父組件的-props)\n      - [在模板中](#在模板中)\n      - [在 data 中](#在-data-中)\n      - [在 methods 中](#在-methods-中)\n      - [在 mounted 中](#在-mounted-中)\n      - [在 computed 中](#在-computed-中)\n  - [emit 子組件向父組件傳遞參數](#emit-子組件向父組件傳遞參數)\n  - [ref 取得 Dom 元素](#ref-取得-dom-元素)\n    - [基本用法：取得 dom 元素](#基本用法取得-dom-元素)\n    - [獲取子組件中的 data 和調用子組件的方法](#獲取子組件中的-data-和調用子組件的方法)\n    - [this.$refs 介紹](#thisrefs-介紹)\n  - [Mixin 共用方法](#mixin-共用方法)\n    - [局部混入](#局部混入)\n    - [全域混入](#全域混入)\n    - [vuex 和 mixin 的區別](#vuex-和-mixin-的區別)\n  - [備註](#備註)\n    - [Truthy(真值) 與 Falsy(假值)](#truthy真值-與-falsy假值)\n    - [判斷當前環境是否為開發環境](#判斷當前環境是否為開發環境)\n    - [取得 base\\_url](#取得-base_url)"}