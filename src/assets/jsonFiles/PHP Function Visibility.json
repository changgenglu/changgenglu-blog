{"name":"PHP Function Visibility.md","content":"# PHP 方法可見度（Visibility）指南\n\n## 目錄\n- [概述](#概述)\n- [三種可見度等級](#三種可見度等級)\n- [基礎範例](#基礎範例)\n- [實際應用情境](#實際應用情境)\n- [繼承中的可見度](#繼承中的可見度)\n- [介面與可見度](#介面與可見度)\n- [最佳實踐](#最佳實踐)\n- [常見問題](#常見問題)\n\n---\n\n## 概述\n\n### 可見度（Visibility）的概念\n可見度決定了類別成員（屬性和方法）的可訪問性。PHP 提供三種可見度等級：\n- **public**: 公開的，任何地方都可以訪問\n- **protected**: 保護的，只有類別內部及其子類別可以訪問\n- **private**: 私有的，只有類別內部可以訪問\n\n### 為什麼需要可見度？\n- **封裝**：隱藏內部實作細節，只暴露必要的介面\n- **安全性**：防止外部程式碼直接修改內部狀態\n- **維護性**：明確哪些方法應該被外部調用，哪些是內部實作\n- **測試**：容易區分公共 API 和內部實作\n\n---\n\n## 三種可見度等級\n\n### 1. public（公開方法）\n\n#### 定義\n- 任何地方都可以訪問\n- 類別外部可以呼叫\n- 子類別可以覆寫\n\n#### 情境\n- **對外介面**：提供給外部使用的方法\n- **API 方法**：需要在 Controller 或 Route 中呼叫\n- **被測試的方法**：單元測試需要訪問的方法\n- **介面實作**：介面要求的方法必須是 public\n\n#### 範例\n```php\nclass UserService\n{\n    /**\n     * 取得使用者資料\n     * 這是公開方法，Controller 或 Route 可以呼叫\n     */\n    public function getUser(int $userId): User\n    {\n        // 邏輯實作\n        return new User();\n    }\n\n    /**\n     * 建立使用者\n     * 外部可以呼叫此方法\n     */\n    public function createUser(string $email, string $password): User\n    {\n        // 建立邏輯\n        return new User();\n    }\n}\n\n// 使用範例\n$service = new UserService();\n$user = $service->getUser(123);  // ✅ 可以呼叫\n```\n\n---\n\n### 2. protected（保護方法）\n\n#### 定義\n- 只有類別**內部**可以訪問\n- **子類別**可以訪問和覆寫\n- **外部**無法訪問\n\n#### 情境\n- **內部輔助方法**：被公開方法呼叫的內部方法\n- **繼承架構**：父類別希望子類別能使用，但不對外公開\n- **模板方法模式**：定義骨架，讓子類別實作特定步驟\n- **共通邏輯**：多個子類別共用的邏輯\n\n#### 範例\n```php\nclass PaymentProcessor\n{\n    /**\n     * 公開方法：處理付款\n     */\n    public function processPayment(float $amount): bool\n    {\n        // 驗證金額\n        if (!$this->validateAmount($amount)) {\n            return false;\n        }\n\n        // 扣款\n        if (!$this->deductFunds($amount)) {\n            return false;\n        }\n\n        // 記錄日誌\n        $this->logTransaction($amount);\n\n        return true;\n    }\n\n    /**\n     * 保護方法：驗證金額\n     * 子類別可以使用此方法，但外部無法呼叫\n     */\n    protected function validateAmount(float $amount): bool\n    {\n        return $amount > 0 && $amount <= 1000000;\n    }\n\n    /**\n     * 保護方法：扣款\n     * 子類別可以覆寫此方法實作不同的扣款邏輯\n     */\n    protected function deductFunds(float $amount): bool\n    {\n        // 預設實作\n        return true;\n    }\n\n    /**\n     * 保護方法：記錄交易\n     */\n    protected function logTransaction(float $amount): void\n    {\n        // 記錄邏輯\n    }\n}\n\nclass CreditCardProcessor extends PaymentProcessor\n{\n    /**\n     * 子類別可以覆寫保護方法\n     */\n    protected function deductFunds(float $amount): bool\n    {\n        // 信用卡扣款邏輯\n        return true;\n    }\n\n    /**\n     * 子類別可以使用父類別的保護方法\n     */\n    public function processCard(float $amount): bool\n    {\n        if (!$this->validateAmount($amount)) {  // ✅ 可以使用父類別的保護方法\n            return false;\n        }\n        return $this->processPayment($amount);\n    }\n}\n\n// 使用範例\n$processor = new PaymentProcessor();\n$processor->processPayment(1000);  // ✅ 可以呼叫公開方法\n\n$processor->validateAmount(1000);  // ❌ 錯誤！無法訪問保護方法\n\n$cardProcessor = new CreditCardProcessor();\n$cardProcessor->processCard(1000);  // ✅ 子類別公開方法可以呼叫\n```\n\n---\n\n### 3. private（私有方法）\n\n#### 定義\n- **只有類別內部**可以訪問\n- **子類別無法訪問**\n- **外部無法訪問**\n\n#### 情境\n- **內部實作細節**：類別內部使用的輔助方法\n- **不應該被外部呼叫**：僅供類別內部使用\n- **不期望被子類別覆寫**：固定實作，不想被改變\n- **工具方法**：轉換、格式化等純內部使用的工具\n\n#### 範例\n```php\nclass EmailSender\n{\n    /**\n     * 公開方法：發送郵件\n     */\n    public function send(string $to, string $subject, string $body): bool\n    {\n        // 驗證郵件地址\n        if (!$this->isValidEmail($to)) {\n            return false;\n        }\n\n        // 格式化內容\n        $formattedBody = $this->formatBody($body);\n\n        // 發送\n        return $this->performSend($to, $subject, $formattedBody);\n    }\n\n    /**\n     * 私有方法：驗證郵件地址\n     * 只有此類別內部可以使用，外部和子類別都無法呼叫\n     */\n    private function isValidEmail(string $email): bool\n    {\n        return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;\n    }\n\n    /**\n     * 私有方法：格式化郵件內容\n     */\n    private function formatBody(string $body): string\n    {\n        return strip_tags($body);\n    }\n\n    /**\n     * 私有方法：實際執行發送\n     */\n    private function performSend(string $to, string $subject, string $body): bool\n    {\n        // 實際發送邏輯\n        return true;\n    }\n}\n\nclass EmailSenderWithTemplate extends EmailSender\n{\n    /**\n     * 子類別無法訪問父類別的私有方法\n     */\n    public function sendTemplate(string $to, string $templateName): bool\n    {\n        // $this->isValidEmail($to);  // ❌ 錯誤！無法訪問父類別私有方法\n\n        // 必須自己實作驗證邏輯\n        if (!filter_var($to, FILTER_VALIDATE_EMAIL)) {\n            return false;\n        }\n\n        $body = $this->loadTemplate($templateName);\n        return $this->send($to, 'Template Email', $body);\n    }\n\n    private function loadTemplate(string $name): string\n    {\n        return \"Template content for {$name}\";\n    }\n}\n\n// 使用範例\n$sender = new EmailSender();\n$sender->send('user@example.com', 'Hello', 'Body');  // ✅ 可以呼叫公開方法\n\n$sender->isValidEmail('test@test.com');  // ❌ 錯誤！無法訪問私有方法\n\n$templateSender = new EmailSenderWithTemplate();\n$templateSender->sendTemplate('user@example.com', 'welcome');  // ✅ 可以呼叫\n```\n\n---\n\n## 基礎範例\n\n### 完整範例：購物車類別\n\n```php\nclass ShoppingCart\n{\n    private array $items = [];\n    private float $taxRate = 0.05;\n\n    /**\n     * 公開方法：新增商品\n     */\n    public function addItem(string $productName, float $price, int $quantity = 1): void\n    {\n        $this->validateItem($productName, $price, $quantity);\n        $this->items[] = [\n            'name' => $productName,\n            'price' => $price,\n            'quantity' => $quantity,\n        ];\n    }\n\n    /**\n     * 公開方法：取得總額\n     */\n    public function getTotal(): float\n    {\n        $subtotal = $this->calculateSubtotal();\n        $tax = $this->calculateTax($subtotal);\n\n        return $subtotal + $tax;\n    }\n\n    /**\n     * 公開方法：清空購物車\n     */\n    public function clear(): void\n    {\n        $this->items = [];\n    }\n\n    /**\n     * 保護方法：計算小計\n     * 子類別可能需要覆寫此方法（例如：VIP 折扣）\n     */\n    protected function calculateSubtotal(): float\n    {\n        $subtotal = 0;\n        foreach ($this->items as $item) {\n            $subtotal += $item['price'] * $item['quantity'];\n        }\n        return $subtotal;\n    }\n\n    /**\n     * 保護方法：計算稅金\n     * 子類別可以覆寫（例如：免稅商品）\n     */\n    protected function calculateTax(float $amount): float\n    {\n        return $amount * $this->taxRate;\n    }\n\n    /**\n     * 私有方法：驗證商品資料\n     * 內部實作細節，不希望被外部或子類別修改\n     */\n    private function validateItem(string $name, float $price, int $quantity): void\n    {\n        if (empty($name)) {\n            throw new \\InvalidArgumentException('商品名稱不能為空');\n        }\n        if ($price < 0) {\n            throw new \\InvalidArgumentException('價格不能為負數');\n        }\n        if ($quantity <= 0) {\n            throw new \\InvalidArgumentException('數量必須大於 0');\n        }\n    }\n}\n\nclass VIPShoppingCart extends ShoppingCart\n{\n    private float $discountRate = 0.1;\n\n    /**\n     * 覆寫保護方法，提供 VIP 折扣\n     */\n    protected function calculateSubtotal(): float\n    {\n        $subtotal = parent::calculateSubtotal();\n        return $subtotal * (1 - $this->discountRate);\n    }\n}\n\n// 使用範例\n$cart = new ShoppingCart();\n$cart->addItem('蘋果', 10.0, 3);\n$cart->addItem('香蕉', 5.0, 2);\necho $cart->getTotal();  // ✅ 結果：40.75（33 + 1.65 稅金）\n\n$cart->calculateSubtotal();  // ❌ 錯誤！無法訪問保護方法\n$cart->validateItem('test', 10, 1);  // ❌ 錯誤！無法訪問私有方法\n\n$vipCart = new VIPShoppingCart();\n$vipCart->addItem('蘋果', 10.0, 3);\necho $vipCart->getTotal();  // ✅ VIP 折扣後的總額\n```\n\n---\n\n## 實際應用情境\n\n### 情境 1：Service 類別\n\n```php\nclass UserService\n{\n    /**\n     * 公開方法：供 Controller 呼叫\n     */\n    public function updateUser(int $userId, array $data): User\n    {\n        // 驗證資料\n        $this->validateUserData($data);\n\n        // 取得使用者\n        $user = $this->findUserById($userId);\n\n        // 更新使用者\n        return $this->performUpdate($user, $data);\n    }\n\n    /**\n     * 保護方法：驗證使用者資料\n     * Service 的其他方法可能需要呼叫\n     */\n    protected function validateUserData(array $data): void\n    {\n        // 驗證邏輯\n    }\n\n    /**\n     * 保護方法：查找使用者\n     * 子類別可以覆寫（例如：使用快取）\n     */\n    protected function findUserById(int $userId): User\n    {\n        return User::find($userId);\n    }\n\n    /**\n     * 私有方法：執行更新\n     * 內部實作細節，不需要被外部或子類別了解\n     */\n    private function performUpdate(User $user, array $data): User\n    {\n        // 更新邏輯\n        $user->fill($data);\n        $user->save();\n\n        return $user;\n    }\n}\n```\n\n### 情境 2：Repository 類別\n\n```php\nclass UserRepository\n{\n    private \\Illuminate\\Database\\Connection $connection;\n\n    public function __construct(\\Illuminate\\Database\\Connection $connection)\n    {\n        $this->connection = $connection;\n    }\n\n    /**\n     * 公開方法：取得使用者\n     */\n    public function find(int $id): ?User\n    {\n        $data = $this->connection->table('users')\n            ->where('id', $id)\n            ->first();\n\n        return $data ? $this->mapToUser($data) : null;\n    }\n\n    /**\n     * 保護方法：將資料庫資料對應到 User 物件\n     * 子類別可能需要覆寫（例如：不同的對應邏輯）\n     */\n    protected function mapToUser(object $data): User\n    {\n        return new User($data);\n    }\n\n    /**\n     * 私有方法：建立基礎查詢\n     * 內部實作細節\n     */\n    private function buildBaseQuery(): \\Illuminate\\Database\\Query\\Builder\n    {\n        return $this->connection->table('users');\n    }\n}\n```\n\n### 情境 3：Controller 類別\n\n```php\nclass ApiController\n{\n    private ApiService $service;\n    private LoggerInterface $logger;\n\n    public function __construct(ApiService $service, LoggerInterface $logger)\n    {\n        $this->service = $service;\n        $this->logger = $logger;\n    }\n\n    /**\n     * 公開方法：處理 API 請求\n     */\n    public function handle(Request $request): Response\n    {\n        try {\n            $data = $this->parseRequest($request);\n            $result = $this->service->process($data);\n\n            return $this->buildSuccessResponse($result);\n        } catch (\\Exception $e) {\n            $this->logError($e);\n            return $this->buildErrorResponse($e);\n        }\n    }\n\n    /**\n     * 保護方法：解析請求\n     * Controller 的其他方法可能需要\n     */\n    protected function parseRequest(Request $request): array\n    {\n        return $request->all();\n    }\n\n    /**\n     * 保護方法：建立成功回應\n     */\n    protected function buildSuccessResponse($data): Response\n    {\n        return response()->json(['success' => true, 'data' => $data]);\n    }\n\n    /**\n     * 保護方法：建立錯誤回應\n     */\n    protected function buildErrorResponse(\\Exception $e): Response\n    {\n        return response()->json(['success' => false, 'error' => $e->getMessage()], 500);\n    }\n\n    /**\n     * 私有方法：記錄錯誤\n     * 內部實作細節\n     */\n    private function logError(\\Exception $e): void\n    {\n        $this->logger->error($e->getMessage(), [\n            'exception' => $e,\n            'trace' => $e->getTraceAsString(),\n        ]);\n    }\n}\n```\n\n---\n\n## 繼承中的可見度\n\n### 可見度規則\n\n```php\nclass Parent\n{\n    public function publicMethod() { }\n    protected function protectedMethod() { }\n    private function privateMethod() { }\n}\n\nclass Child extends Parent\n{\n    public function callParentMethods(): void\n    {\n        $this->publicMethod();       // ✅ 可以\n        $this->protectedMethod();    // ✅ 可以\n        // $this->privateMethod();   // ❌ 錯誤！無法訪問\n    }\n\n    // 可以覆寫父類別的公開或保護方法\n    public function publicMethod() { }\n    protected function protectedMethod() { }\n\n    // 但不能\"覆寫\"私有方法（實質上是新方法）\n    // 因為私有方法在子類別中不可見\n    private function privateMethod() { }  // 這是新方法，不是覆寫\n}\n\nclass External\n{\n    public function callMethods(Parent $parent): void\n    {\n        $parent->publicMethod();       // ✅ 可以\n        // $parent->protectedMethod(); // ❌ 錯誤！外部無法訪問\n        // $parent->privateMethod();   // ❌ 錯誤！外部無法訪問\n    }\n}\n```\n\n---\n\n## 介面與可見度\n\n### 介面方法必須是 public\n\n```php\ninterface IUserRepository\n{\n    /**\n     * 介面方法隱含是 public\n     * 不能聲明可見度（會報錯）\n     */\n    public function find(int $id): ?User;\n\n    // ❌ 錯誤！介面不能有 protected 或 private 方法\n    // protected function internalMethod();\n}\n\nclass UserRepository implements IUserRepository\n{\n    /**\n     * 實作介面方法必須是 public\n     */\n    public function find(int $id): ?User\n    {\n        return User::find($id);\n    }\n\n    /**\n     * 實作類別可以有 protected 和 private 方法\n     */\n    protected function helperMethod(): void\n    {\n        // 內部方法\n    }\n\n    private function internalMethod(): void\n    {\n        // 私有方法\n    }\n}\n```\n\n---\n\n## 最佳實踐\n\n### 1. 預設使用 private，需要時再開放\n\n```php\nclass OrderService\n{\n    // ✅ 正確：預設使用 private\n    private function validateOrder(Order $order): bool\n    {\n        // 預設為私有，只有內部需要時再改成 protected\n    }\n\n    // ❌ 避免：一開始就用 public\n    // public function validateOrder(Order $order): bool\n    // {\n    //     // 如果不需要外部呼叫，就不應該用 public\n    // }\n}\n```\n\n### 2. 公開方法應該簡潔\n\n```php\nclass PaymentService\n{\n    /**\n     * ✅ 公開方法：簡潔明瞭\n     */\n    public function processPayment(float $amount): bool\n    {\n        // 驗證\n        if (!$this->validateAmount($amount)) {\n            return false;\n        }\n\n        // 扣款\n        if (!$this->deductFunds($amount)) {\n            return false;\n        }\n\n        // 記錄\n        $this->logTransaction($amount);\n\n        return true;\n    }\n\n    /**\n     * ✅ 複雜邏輯拆分成保護方法\n     */\n    protected function validateAmount(float $amount): bool\n    {\n        // 複雜的驗證邏輯\n    }\n\n    protected function deductFunds(float $amount): bool\n    {\n        // 複雜的扣款邏輯\n    }\n\n    /**\n     * ✅ 內部實作細節用私有方法\n     */\n    private function logTransaction(float $amount): void\n    {\n        // 記錄邏輯\n    }\n}\n```\n\n### 3. 使用可見度實現封裝\n\n```php\nclass BankAccount\n{\n    private float $balance = 0;\n\n    /**\n     * ✅ 公開方法：存款\n     */\n    public function deposit(float $amount): void\n    {\n        $this->validateAmount($amount);\n        $this->balance += $amount;\n        $this->logTransaction('deposit', $amount);\n    }\n\n    /**\n     * ✅ 公開方法：提款\n     */\n    public function withdraw(float $amount): bool\n    {\n        if (!$this->hasSufficientFunds($amount)) {\n            return false;\n        }\n\n        $this->validateAmount($amount);\n        $this->balance -= $amount;\n        $this->logTransaction('withdraw', $amount);\n\n        return true;\n    }\n\n    /**\n     * ✅ 公開方法：查詢餘額\n     */\n    public function getBalance(): float\n    {\n        return $this->balance;\n    }\n\n    /**\n     * ✅ 私有方法：驗證金額\n     */\n    private function validateAmount(float $amount): void\n    {\n        if ($amount <= 0) {\n            throw new \\InvalidArgumentException('金額必須大於 0');\n        }\n    }\n\n    /**\n     * ✅ 私有方法：檢查餘額是否足夠\n     */\n    private function hasSufficientFunds(float $amount): bool\n    {\n        return $this->balance >= $amount;\n    }\n\n    /**\n     * ✅ 私有方法：記錄交易\n     */\n    private function logTransaction(string $type, float $amount): void\n    {\n        // 記錄邏輯\n    }\n\n    // ❌ 避免：直接公開 balance 屬性\n    // public $balance;  // 這樣就無法控制存取行為\n}\n```\n\n---\n\n## 常見問題\n\n### 問題 1: 什麼時候用 protected，什麼時候用 private？\n\n**原則**：\n- **private**: 確定只有當前類別使用，不期望被子類別使用或覆寫\n- **protected**: 子類別可能需要使用或覆寫的方法\n\n```php\nclass BaseProcessor\n{\n    /**\n     * ✅ private: 確信子類別不需要\n     */\n    private function hashPassword(string $password): string\n    {\n        return password_hash($password, PASSWORD_DEFAULT);\n    }\n\n    /**\n     * ✅ protected: 子類別可能需要不同的驗證邏輯\n     */\n    protected function validateInput(array $data): bool\n    {\n        // 基礎驗證\n    }\n}\n\nclass AdminProcessor extends BaseProcessor\n{\n    /**\n     * 子類別可以覆寫 protected 方法\n     */\n    protected function validateInput(array $data): bool\n    {\n        // 額外的管理員驗證\n        if (!parent::validateInput($data)) {\n            return false;\n        }\n        // 更多驗證...\n        return true;\n    }\n}\n```\n\n### 問題 2: 測試時如何處理不同可見度的方法？\n\n```php\nclass PaymentService\n{\n    public function processPayment(float $amount): bool\n    {\n        if (!$this->validateAmount($amount)) {\n            return false;\n        }\n        // ...\n    }\n\n    protected function validateAmount(float $amount): bool\n    {\n        return $amount > 0;\n    }\n}\n\n// 測試類別\nclass PaymentServiceTest extends TestCase\n{\n    public function test_process_payment(): void\n    {\n        $service = new PaymentService();\n\n        // ✅ 測試公開方法\n        $result = $service->processPayment(100);\n        $this->assertTrue($result);\n\n        // ❌ 無法直接測試保護或私有方法\n        // $service->validateAmount(100);  // 錯誤！\n    }\n}\n\n// 解決方案：使用 Reflection\nuse ReflectionMethod;\n\nclass PaymentServiceTest extends TestCase\n{\n    public function test_validate_amount(): void\n    {\n        $service = new PaymentService();\n\n        // 使用反射訪問保護方法\n        $method = new ReflectionMethod($service, 'validateAmount');\n        $method->setAccessible(true);\n\n        $result = $method->invoke($service, 100);\n        $this->assertTrue($result);\n    }\n}\n```\n\n### 問題 3: 需要改變可見度時怎麼辦？\n\n```php\n// 情境：一開始設計為 private，後來發現子類別需要\n\n// ❌ 原始設計\nclass BaseService\n{\n    private function validateData(array $data): bool\n    {\n        // ...\n    }\n}\n\n// ✅ 改為 protected\nclass BaseService\n{\n    protected function validateData(array $data): bool\n    {\n        // ...\n    }\n}\n\nclass ExtendedService extends BaseService\n{\n    // 現在可以使用父類別的保護方法\n    public function process(array $data): bool\n    {\n        if (!$this->validateData($data)) {  // ✅ 可以呼叫\n            return false;\n        }\n        // ...\n    }\n}\n```\n\n---\n\n## 總結\n\n### 快速參考\n\n| 可見度 | 類別內部 | 子類別 | 外部 | 使用情境 |\n|--------|---------|--------|------|---------|\n| **public** | ✅ | ✅ | ✅ | 公開 API、對外介面 |\n| **protected** | ✅ | ✅ | ❌ | 內部方法、可被子類別覆寫 |\n| **private** | ✅ | ❌ | ❌ | 內部實作細節 |\n\n### 設計原則\n\n1. **最小可見度原則**：預設使用 private，需要時再開放\n2. **YAGNI 原則**：不要過度設計，只有真正需要時才使用 protected\n3. **封裝優先**：隱藏內部實作，只暴露必要的介面\n4. **測試友好**：確保 public 方法足夠測試類別行為\n\n### 實務建議\n\n- **Laravel Controller**: 所有方法用 public\n- **Service 類別**: 對外 API 用 public，內部邏輯用 protected/private\n- **Repository 類別**: 查詢方法用 public，輔助方法用 protected\n- **Helper 類別**: 根據用途選擇，通常都是 public 或 private\n\n---\n\n## 版本資訊\n\n- **建立日期**: 2024-12-19\n- **適用專案**: Stars Laravel 專案\n- **適用版本**: PHP 8.x, Laravel 9.x\n- **維護者**: Stars Team\n","tocContent":""}