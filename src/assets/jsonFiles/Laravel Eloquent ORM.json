{"name":"Laravel Eloquent ORM.md","content":"# Laravel Eloquent ORM\r\n\r\n>\r\n\r\n## models\r\n\r\n### 建立 Model\r\n\r\n```php\r\nphp artisan make:model New\r\n```\r\n\r\n建立 Model 同時建立與其相關的 class\r\n\r\n```php\r\n// migration\r\nphp artisan make:model New -m\r\n\r\n// factory\r\nphp artisan make:model New -f\r\n\r\n// seed\r\nphp artisan make:model New -s\r\n\r\n// controller\r\nphp artisan make:model New -c\r\n\r\n// 同時建立多個class\r\nphp artisan make:model New -mfsc\r\n\r\n```\r\n\r\n### 基本屬性\r\n\r\n```php\r\nclass UserInfo extends Model\r\n{\r\n    protected $table = 'user_data';  // 資料表名稱\r\n\r\n    protected $primaryKey = 'id';   // 主鍵\r\n\r\n    public $timestamps = false;\r\n\r\n    protected $fillable = [\r\n        'userId',\r\n        'userName',\r\n        'account',\r\n        'password',\r\n        'email'\r\n    ];\r\n\r\n    protected $casts = [\r\n        'is_admin' => 'boolean',\r\n    ];\r\n}\r\n```\r\n\r\n- public $timestamps = false // 關閉時間戳記，預設為開啟\r\n- 批量賦值：調用 create() update() 時，可以大量新增、修改的欄位。若沒有添加這個屬性，新增修改的動作將無法實現。\r\n\r\n  - $fillable 設定可以大量新增的欄位（白名單）\r\n\r\n    ```php\r\n    protected $fillable = ['userId','userName','account','pw','email'];\r\n    ```\r\n\r\n  - $guarded 設定需要被保護的欄位（黑名單）\r\n\r\n    ```php\r\n    protected $guarded = [‘uuid’, ‘pw’];\r\n    ```\r\n\r\n- 屬性類型轉換：`$casts` 可以將屬性轉換為指定的類型，支援的類型有\r\n  - `integer`\r\n  - `real`\r\n  - `float`\r\n  - `double`\r\n  - `decimal:<digits>` 需定義小數位的個數，如 `decimal:2`\r\n  - `string`\r\n  - `boolean`\r\n  - `object`\r\n  - `array`\r\n  - `collection`\r\n  - `date`\r\n  - `datetime`\r\n  - `timestamps`\r\n\r\n## 關聯\r\n\r\n### 多型態關聯\r\n\r\n> [參考資料](https://laravelacademy.org/post/9725)\r\n>\r\n> 多型態關聯可以讓一張表同時關連到兩張以上的資料表\r\n>\r\n> 優點:\r\n> 可以合一管理資類類似的資料結構與處理邏輯\r\n> 缺點:\r\n> 耦合提高，變動邏輯時容易影響到某一方的操作\r\n\r\n假設我們有 user 跟 post 兩種資料，而他們各自有所屬的 image 資料表\r\n\r\n| users |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n| user_images |\r\n| :---------: |\r\n|     id      |\r\n|   user_id   |\r\n|     url     |\r\n\r\n| posts |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n| post_images |\r\n| :---------: |\r\n|     id      |\r\n|   post_id   |\r\n|     url     |\r\n\r\n如果 image 的資料結構和處理邏輯相似，就可以使用多型態關聯，將表單合成一張\r\n\r\n| users |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n| posts |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n|     images      |\r\n| :-------------: |\r\n|       id        |\r\n| imaginable_type |\r\n|  imaginable_id  |\r\n|       url       |\r\n\r\n- imaginable_id : 關聯的主鍵值\r\n- imaginable_type : 指定這筆資料是關聯 users 資料表還是 posts 資料表，欄內儲存的是類別名稱，型態為字串，如：'App\\Models\\User' 'App\\Models\\Post'\r\n\r\n#### 多形一對一關聯\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Image extends Model\r\n{\r\n    public function imaginable()\r\n    {\r\n        return $this->morphTo();\r\n    }\r\n}\r\n\r\nclass Post extends Model\r\n{\r\n\r\n    public function image()\r\n    {\r\n        return $this->morphOne(Image::class, 'imaginable');\r\n    }\r\n}\r\n\r\nclass User extends Model\r\n{\r\n\r\n    public function image()\r\n    {\r\n        return $this->morphOne(Image::class, 'imaginable');\r\n    }\r\n}\r\n```\r\n\r\n- `morphOne`: hasOne 的多型態版本\r\n\r\n  和 hasOne 相比，標類別後面多了一個 name 參數 imaginable，Eloquent 會根據這個 name 預設目標表單上的查詢欄位，以 imaginable 為例的話就是查詢 imaginable_type 跟 imaginable_id\r\n\r\n  - 自訂目標的查詢欄位名稱\r\n\r\n    ```php\r\n    // morphOne(目標表單名稱，多形名稱，目標的型別欄位名稱，目標的外鍵欄位名稱，自己的關聯鍵)\r\n     $this->morphOne(Image::class, 'imaginable','imaginable_type',  'imaginable_id','id');\r\n    ```\r\n\r\n- `morphTo`: belongsTo 的多型態版本\r\n\r\n  ```php\r\n  // 使用時要注意函式的名稱\r\n  public function imaginable()\r\n  {\r\n      return $this->morphTo();\r\n  }\r\n  ```\r\n\r\n  如果沒有帶入參數的話預設會用函式的名稱產出預設名稱，像這裡的函式名稱是 imaginable ，那查詢時就會以型別欄位 imaginable_type 查對應的資料表，以及鍵值欄位 imaginable_id 查資料。\r\n\r\n  - 自訂預設名稱\r\n\r\n    ```php\r\n    $this->morphTo('imaginable');\r\n    ```\r\n\r\n  - 自訂查詢欄位的名稱\r\n\r\n    ```php\r\n    // morphOne(多形名稱，型別欄位名稱，外鍵欄位名稱)\r\n    $this->morphTo('imaginable'，'imaginable_type','imaginable_id');\r\n    ```\r\n\r\n#### 多型一對多關聯\r\n\r\n和一對一的關聯差不多，差別在 morphOne 改成 morphMany，查詢得到的資料不是一筆而是一組\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Image extends Model\r\n{\r\n    public function imaginable()\r\n    {\r\n        return $this->morphTo();\r\n    }\r\n}\r\n\r\nclass Post extends Model\r\n{\r\n\r\n    public function image()\r\n    {\r\n        return $this->morphMany(Image::class, 'imaginable');\r\n    }\r\n}\r\n\r\nclass User extends Model\r\n{\r\n\r\n    public function image()\r\n    {\r\n        return $this->morphMany(Image::class, 'imaginable');\r\n    }\r\n}\r\n```\r\n\r\n#### 多型多對多關聯\r\n\r\n> 和普通多對多關聯相比，中介表為多型態\r\n\r\n影片和文章有相同的 tag，一篇文章和影片同時會有多個 tag，一個 tag 也會同時關連到多個影片或文章\r\n| videos |\r\n| :----: |\r\n| id |\r\n| name |\r\n\r\n| posts |\r\n| :---: |\r\n|  id   |\r\n| name  |\r\n\r\n|   taggable    |\r\n| :-----------: |\r\n|      id       |\r\n|    tag_id     |\r\n| taggable_type |\r\n|  taggable_id  |\r\n\r\n| tags |\r\n| :--: |\r\n|  id  |\r\n| name |\r\n\r\n多型的一方，會用 morphToMany 方法\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Video extends Model\r\n{\r\n    /**\r\n     * Get all of the tags for the post.\r\n     */\r\n    public function tags()\r\n    {\r\n        return $this->morphToMany(Tag::class, 'taggable');\r\n    }\r\n}\r\n\r\nclass Post extends Model\r\n{\r\n    /**\r\n     * Get all of the tags for the post.\r\n     */\r\n    public function tags()\r\n    {\r\n        return $this->morphToMany(Tag::class, 'taggable');\r\n    }\r\n}\r\n```\r\n\r\n反向關聯會使用 morphedByMany 方法\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Tag extends Model\r\n{\r\n    /**\r\n     * Get all of the posts that are assigned this tag.\r\n     */\r\n    public function posts()\r\n    {\r\n        return $this->morphedByMany(Post::class, 'taggable');\r\n    }\r\n\r\n    /**\r\n     * Get all of the videos that are assigned this tag.\r\n     */\r\n    public function videos()\r\n    {\r\n        return $this->morphedByMany(Video::class, 'taggable');\r\n    }\r\n}\r\n```\r\n\r\n- `morphToMany`: belongsToMany 的多型態版\r\n- `morphedByMany`: 多對多的反向多型關聯\r\n\r\n  需要帶多型的名稱參數才能查詢資料\r\n\r\n  ```php\r\n  // morphOne(目標表單名稱，多形名稱)\r\n   $this->morphToMany(Tag::class, 'taggable');\r\n  ```\r\n\r\n  - 自訂名稱\r\n\r\n    ```php\r\n    public function morphedByMany(\r\n      $related,                 // 目標表單名稱\r\n      $name,                    // 多型名稱\r\n      $table = null,            // 中介表單名稱\r\n      $foreignPivotKey = null,  // 中介表單上參照自己的外鍵\r\n      $relatedPivotKey = null,  // 中介表單上參照目標的外鍵\r\n      $parentKey = null,        // 目標的關聯鍵\r\n      $relatedKey = null        // 自己的關聯鍵\r\n    )\r\n\r\n    $this->morphToMany(\r\n      Tag::class, 'taggable','taggable','taggable_id','tag_id','id','id'\r\n    );\r\n    ```\r\n\r\n#### 自訂多型型別\r\n\r\n預設 laravel 會使用類別的完整名稱來儲存 model type。\r\n\r\n可以透過自訂多型型別，使用簡單的字串作為 model type，將這些值從專案的內部結構中解耦出來。\r\n\r\n如此一來，即使修改 model 名稱，資料庫中的多型 type 欄位也會繼續有效。\r\n\r\n- 例如：  \r\n  Commit Model 可以隸屬於 Post Model 或 Video Model。因此，comments 資料表中的 commentable_type 欄位分別會記載 App\\Models\\Post 或 App\\Models\\Video。\r\n\r\n  此時可以在 `App\\Providers\\AppServiceProvider` 中的 `boot` 方法，呼叫`enforceMorphMap`方法。將 post 及 video 等簡單字串作為 model type。\r\n\r\n```php\r\nuse Illuminate\\Database\\Eloquent\\Relations\\Relation;\r\n\r\nRelation::enforceMorphMap([\r\n    'post' => 'App\\Models\\Post',\r\n    'video' => 'App\\Models\\Video',\r\n]);\r\n```\r\n\r\n## Laravel ORM 將資料存至資料庫\r\n\r\n### save\r\n\r\n將表格第一筆資料的名字，改成小華\r\n\r\n```php\r\nUser::find(1)->save(['name' => '小華']);\r\n```\r\n\r\n也可以一次編輯多個欄位\r\n\r\n```php\r\nUser::find(1)->save([\r\n  'name'=>'小華',\r\n  'email'=>'flower@gmail.com'\r\n  'sex'=>'male'\r\n]);\r\n```\r\n\r\n### 修改多對多中間表\r\n\r\n- articles\r\n\r\n| id  | article_name |\r\n| :-: | :----------: |\r\n|  1  |   article1   |\r\n|  2  |   article2   |\r\n|  3  |   article3   |\r\n|  4  |   article5   |\r\n\r\n- tags\r\n\r\n| id  | tag_name |\r\n| :-: | :------: |\r\n|  1  |   tech   |\r\n|  2  |  music   |\r\n|  3  |   art    |\r\n|  4  |   food   |\r\n\r\n- article_tag\r\n\r\n| article_id | tag_id |\r\n| :--------: | :----: |\r\n|     1      |   2    |\r\n|     1      |   3    |\r\n|     1      |   4    |\r\n|     3      |   4    |\r\n\r\n建立和控制多對多關係的方法\r\n\r\n- 建立:\r\n\r\n  - `attach()`\r\n\r\n    ```php\r\n    // id=3 的文章原有的標籤[4]\r\n    Article::find(3)->tags()->attach([1,2]);\r\n    // id=3 的文章加入標籤[1, 2]\r\n    // id=3 的文章的標籤有[1, 2, 4]\r\n    ```\r\n\r\n  - `save()`\r\n\r\n    ```php\r\n    Article::find(3)->tags()->saveMany([\r\n        Tag::find(1),\r\n    Tag::find(2)\r\n    ]);\r\n    // save輸入的類型須為model\r\n    // 多個時要用saveMany\r\n    ```\r\n\r\n    |   方法   | 單個 id | 多個 id | 單個 model |   多個 model    |\r\n    | :------: | :-----: | :-----: | :--------: | :-------------: |\r\n    | attach() |    V    |    V    |     V      |                 |\r\n    |  sync()  |    V    |    V    |     V      |                 |\r\n    |  save()  |         |         |     V      | 要用 saveMany() |\r\n\r\n- 刪去: `detach()`\r\n\r\n  ```php\r\n  $article = Article::find(1);\r\n\r\n  // 從文章上移除指定tag\r\n  $article->tags()->detach($tag_id);\r\n\r\n  // 移除文章所有tag\r\n  $article->tags()->detach();\r\n  ```\r\n\r\n- 同步\r\n\r\n  - `sync`\r\n\r\n    ```php\r\n    // 更新有傳入值的該筆資料，其他資料會被刪除\r\n    $user->roles()->sync([1, 2, 3]);\r\n\r\n    // 透過id傳入額外的值到中間表\r\n    $user->roles()->sync([1 => ['expires' => true], 2, 3]);\r\n    ```\r\n\r\n  - `syncWithoutDetaching`\r\n\r\n    ```php\r\n    // 更新有傳入值的該筆資料，並保留原有的資料\r\n    $user->roles()->syncWithoutDetaching([1, 2, 3]);\r\n    ```\r\n\r\n  - `updateExistingPivot`\r\n\r\n    ```php\r\n    // 更新一筆已存在的資料，接受中間表的外鍵和要更新的值進行更新\r\n    $user = App\\Models\\User::find(1);\r\n\r\n    $user->roles()->updateExistingPivot($roleId, $attributes);\r\n    ```\r\n\r\n- 切換: `toggle()`\r\n\r\n  ```php\r\n  $article->tags()->toggle([1, 2 ,3]);\r\n  // 用來切換傳入id的附加狀態，如果傳入的id目前已經被附加，他將會被卸除。\r\n  // 若已經被卸除，將會被附加\r\n  ```\r\n\r\n## ORM N+1\r\n\r\n> 紀錄 ORM 對資料庫的查詢語法\r\n>\r\n> ```php\r\n> // 開始紀錄\r\n> DB::enableQueryLog();\r\n>\r\n> // 結束並印出\r\n> dd(DB::getQueryLog());\r\n> ```\r\n\r\n### 什麼是 N+1\r\n\r\n資料表中有關聯關係，以論壇文章為例。\r\n\r\n- 一名使用者，可以發布多篇文章。\r\n- 一篇文章只屬於一名使用者。\r\n\r\n使用者與文章的關係為一對多。當我們要取得多名使用者，並同時取得這些使用者過去發布的所有文章時：\r\n\r\n```php\r\nuse App\\Models\\User;\r\nuse Illuminate\\Support\\Facades\\Route;\r\n\r\nRoute::get('lazy-loading', function () {\r\n  // 開啟 Query Log\r\n  DB::enableQueryLog();\r\n\r\n  // 取得所有使用者\r\n  $users = User::get();\r\n\r\n  // 使用迴圈取得每一位使用者所發布的文章\r\n  foreach ($users as $user) {\r\n      $posts = $user->posts;\r\n      dump($posts->toArray());\r\n  }\r\n\r\n  // dump 對資料庫的查詢語法\r\n  dump(DB::getQueryLog());\r\n});\r\n```\r\n\r\n這時就會產生 n+1 的問題。\r\n\r\n第一筆查詢是取得所有用戶。\r\n\r\n```php\r\n// 取得所有使用者\r\n$users = User::get();\r\n```\r\n\r\n接下來每一筆是取得各用戶發布的文章。\r\n\r\n```php\r\n// 使用迴圈取得每一位使用者所發布的文章\r\nforeach ($users as $user) {\r\n  $posts = $user->posts;\r\n}\r\n```\r\n\r\n### 解決 N+1 的問題\r\n\r\n可以使用 laravel 所提供的預加載功能 `with()`\r\n\r\n```php\r\nRoute::get('lazy-loading', function () {\r\n  // 開啟 Query Log\r\n  DB::enableQueryLog();\r\n\r\n  // 取得所有使用者，並預先加載 Post 的資料\r\n  // 這裡的 'posts' 對應到 User Model 中的 posts()\r\n  $users = User::with('posts')->get();\r\n\r\n  // 使用迴圈取得每一位使用者所發布的文章\r\n  foreach ($users as $user) {\r\n      $posts = $user->posts;\r\n      dump($posts->toArray());\r\n  }\r\n\r\n  // dump 對資料庫的查詢語法\r\n  dump(DB::getQueryLog());\r\n});\r\n```\r\n\r\n這時僅執行了兩個查詢\r\n\r\n```sql\r\nselect * from users\r\n\r\nselect * from posts where id in (1, 2, 3, 4, 5, ...)\r\n```\r\n\r\n可以指定不需要某些資料\r\n\r\n```php\r\n$users = User::without('posts')->get();\r\n```\r\n\r\n或是只需要其他資料\r\n\r\n```php\r\n$users = User::withOnly('loginRecords')->get();\r\n```\r\n\r\n也可以加載多個關聯\r\n\r\n```php\r\n$users = User::with(['posts', 'commit'])->get();\r\n```\r\n\r\n## 序列化\r\n\r\n> 建構 JSON API 時，針對 model 及其取得關連的值，將其轉化為 array 或是 JSON\r\n\r\n### 將 collection 序列化\r\n\r\n#### array\r\n\r\n- `toArray()` 所有的屬性和關聯(包括關聯的關聯)，當將轉化為陣列。\r\n\r\n  ```php\r\n  $user = App\\Models\\User::with('roles')->first();\r\n\r\n  return $user->toArray();\r\n\r\n  // 將整個 model collection 序列化\r\n  $users = App\\Models\\User::all();\r\n\r\n  return $users->toArray();\r\n  ```\r\n\r\n- `attributesToArray()` 僅將 model 的屬性轉換為陣列\r\n\r\n  ```php\r\n  $user = App\\Models\\User::first();\r\n\r\n  return $user->attributesToArray();\r\n  ```\r\n\r\n#### JSON\r\n\r\n- `toJson` 所有的屬性和關聯(包括關聯的關聯)，當將轉化為 JSON。\r\n\r\n  ```php\r\n  $user = App\\Models\\User::find(1);\r\n\r\n  return $user->toJson();\r\n\r\n  // 指定PHP支援的JSON編碼選項\r\n  return $user->toJson(JSON_PRETTY_PRINT);\r\n  ```\r\n\r\n- 將 model 或 collection 轉為字串時，會自動調用`toJson()`，因此可以應用在 route 或 controller 中直接返回。\r\n\r\n  ```php\r\n  Route::get('users', function () {\r\n      return App\\Models\\User::all();\r\n  });\r\n\r\n  $user = App\\Models\\User::find(1);\r\n\r\n  return (string) $user;\r\n  ```\r\n\r\n- 關聯屬性：當 model 被轉化為 JSON 的時候，他加載的關聯關係也將自動轉化為 JSON 對象被包含進來，同時透過小駝峰定義的關聯方式，關聯的 JSON 屬性將會是蛇底式命名。\r\n\r\n### 隱藏 JSON 屬性\r\n\r\n> 有時需要將 model array 或 JSON 中某些屬性進行隱藏，如：密碼。\r\n\r\n- `$hidden`\r\n\r\n  ```php\r\n  namespace App\\Models;\r\n\r\n  use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n  class User extends Model\r\n  {\r\n      /**\r\n       * 数组中的属性会被隐藏\r\n       *\r\n       * @var array\r\n       */\r\n      protected $hidden = ['password'];\r\n  }\r\n  ```\r\n\r\n- `$visible` 定義一個 model array 和 JSON 可見的白名單。經過定義後，序列化此 model 不會出現白名單以外的屬性。\r\n\r\n  ```php\r\n  namespace App\\Models;\r\n\r\n  use Illuminate\\Database\\Eloquent\\Model;\r\n\r\n  class User extends Model\r\n  {\r\n      /**\r\n       * 数组中的属性会被展示\r\n       *\r\n       * @var array\r\n       */\r\n      protected $visible = ['first_name', 'last_name'];\r\n  }\r\n  ```\r\n\r\n#### 臨時修改屬性可見度\r\n\r\n- `makeVisible`\r\n\r\n  ```php\r\n  return $user->makeVisitable('attribute')->toArray();\r\n  ```\r\n\r\n- `makeHidden`\r\n\r\n  ```php\r\n  return $user->makeHidden('attribute')->toArray();\r\n  ```\r\n\r\n### 追加 JSON 值\r\n\r\n> 在 array 或是 JSON 中添加一些不存在於資料庫的欄位。\r\n\r\n定義 `getAttribute`\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass User extends Model\r\n{\r\n    /**\r\n     * Get the administrator flag for the user.\r\n     *\r\n     * @return bool\r\n     */\r\n    public function getIsAdminAttribute()\r\n    {\r\n        return $this->attributes['admin'] === 'yes';\r\n    }\r\n}\r\n```\r\n\r\n然後在 model 中宣告屬性 `appends`。\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass User extends Model\r\n{\r\n    /**\r\n     * The accessors to append to the model's array form.\r\n     *\r\n     * @var array\r\n     */\r\n    protected $appends = ['is_admin'];\r\n}\r\n```\r\n\r\n- **Notice:** 在`getAttribute`中使用駝峰命名，但在宣告屬性時，通常以蛇底式命名。\r\n\r\n宣告 `append` 追加屬性後，其將會被包含在 model array 和 JSON 中。追加屬性也會遵循 model 宣告的`visible`及`hidden`屬性。\r\n\r\n#### 臨時追加屬性\r\n\r\n可以在單一 model 實例，使用`append`方法蘭追加屬性。或者使用`setAppends`方法來重寫追加屬性的陣列。\r\n\r\n```php\r\nreturn $user->append('is_admin')->toArray();\r\n\r\n// 重寫整個追加屬性的陣列\r\nreturn $user->setAppends(['is_admin'])->toArray();\r\n```\r\n\r\n### 日期序列化\r\n\r\n- `serializeDate` 此方法可自訂預設的日期序列化格式\r\n\r\n```php\r\n/**\r\n * 為array / JSON 序列化準備一個日期\r\n *\r\n * @param  \\DateTimeInterface  $date\r\n * @return string\r\n */\r\nprotected function serializeDate(DateTimeInterface $date)\r\n{\r\n    return $date->format('Y-m-d');\r\n}\r\n```\r\n\r\n#### 自訂任意屬性的日期格式\r\n\r\n可以在 Eloquent 宣告屬性轉換，單獨為資料庫中為日期屬性的欄位定義其格式\r\n\r\n```php\r\nprotected $casts = [\r\n    'birthday' => 'date:Y-m-d',\r\n    'joined_at' => 'datetime:Y-m-d H:00',\r\n];\r\n```\r\n\r\n## 刪除\r\n\r\n### 普通刪除\r\n\r\n```php\r\n$contact = Contact::find(5);\r\n$contact->delete();\r\n```\r\n\r\n透過 id 刪除\r\n\r\n```php\r\nContact::destroy(1);\r\n// or\r\nContact::destroy([1, 5, 7]);\r\n```\r\n\r\n刪除查詢結果\r\n\r\n```php\r\nContact::where('updated_at', '<', now()->subYear())->delete();\r\n```\r\n\r\n### 軟刪除\r\n\r\n> 透過在資料表中增加一個 delete_at 的欄位，來標記要刪除的資料，而不是直接將資料刪除。\r\n>\r\n> 優點：刪除的資料可以被復原、可以記錄資料刪除的時間點。\r\n>\r\n> 缺點：中間表無法使用軟刪除、需要定時清理軟刪除的資料，以免資料庫日益肥大。\r\n\r\n#### 啟用軟刪除\r\n\r\n將 `Illuminate\\Database\\Eloquent\\SoftDeletes` Trait 加到 Model 上\r\n\r\n```php\r\n<?php\r\n\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\r\n\r\nclass Flight extends Model\r\n{\r\n    use SoftDeletes;\r\n}\r\n```\r\n\r\n利用 migration 將 delete_at 欄位加入資料表\r\n\r\n```php\r\nuse Illuminate\\Database\\Schema\\Blueprint;\r\nuse Illuminate\\Support\\Facades\\Schema;\r\n\r\npublic function up() {\r\n    Schema::table('flights', function (Blueprint $table) {\r\n        $table->softDeletes();\r\n    });\r\n}\r\n\r\npublic function down() {\r\n    Schema::table('flights', function (Blueprint $table) {\r\n        $table->dropSoftDeletes();\r\n    });\r\n}\r\n```\r\n\r\n當在 model 上呼叫 delete 方法時，會自動更新 delete_at 欄位，並設為當前時間。\r\n\r\n#### 軟刪除應用\r\n\r\n- 判斷是否已被軟刪除\r\n\r\n  ```php\r\n  if ($flight->trashed()) {\r\n      //\r\n  }\r\n  ```\r\n\r\n- 恢復軟刪除\r\n\r\n  ```php\r\n  $flight->restore();\r\n\r\n  // 恢復多個\r\n  Flight::withTrashed()\r\n      ->where('airline_id', 1)\r\n      ->restore();\r\n  ```\r\n\r\n  - 永久刪除 model\r\n\r\n  ```php\r\n  $flight->forceDelete();\r\n  ```\r\n\r\n- 查詢軟刪除的 model\r\n\r\n  - 包含軟刪除的 model\r\n\r\n    ```php\r\n    use App\\Models\\Flight;\r\n\r\n    $flights = Flight::withTrashed()\r\n                    ->where('account_id', 1)\r\n                    ->get();\r\n    ```\r\n\r\n  - 只取得被刪除的 model\r\n\r\n    ```php\r\n    $flights = Flight::onlyTrashed()\r\n                    ->where('airline_id', 1)\r\n                    ->get();\r\n    ```\r\n\r\n#### 實現中間表的軟刪除\r\n\r\n> 一般不建議對 pivot 進行軟刪除。\r\n\r\n在 pivot 表，添加一個 bool 欄位，ex: is_deleted。\r\n\r\n- `updateExistingPivot()` 此方法可以修改這欄位\r\n- `wherePivot('is_deleted', true)` 可以篩選數據\r\n\r\n```php\r\nBook::find(1)->buyers()->wherePivot('is_deleted', true)->get()\r\n\r\nBook::find(1)->buyers()->updateExistingPivot(11, ['is_deleted' => false])\r\n```\r\n\r\n或者在關聯中，定義兩者的關係\r\n\r\n```PHP\r\nfunction buyers() {\r\n    return $this->belongToMany('App\\User')->wherePivot('is_deleted', false);\r\n}\r\n\r\nfunction buyersWithDeleted() {\r\n    return $this->belongToMany('App\\User');\r\n}\r\n```\r\n\r\n#### 清除舊的軟刪除資料\r\n\r\n[參考資料](https://github.com/tighten/quicksand)\r\n","tocContent":"- [Laravel Eloquent ORM](#laravel-eloquent-orm)\r\n  - [models](#models)\r\n    - [建立 Model](#建立-model)\r\n    - [基本屬性](#基本屬性)\r\n  - [關聯](#關聯)\r\n    - [多型態關聯](#多型態關聯)\r\n      - [多形一對一關聯](#多形一對一關聯)\r\n      - [多型一對多關聯](#多型一對多關聯)\r\n      - [多型多對多關聯](#多型多對多關聯)\r\n      - [自訂多型型別](#自訂多型型別)\r\n  - [Laravel ORM 將資料存至資料庫](#laravel-orm-將資料存至資料庫)\r\n    - [save](#save)\r\n    - [修改多對多中間表](#修改多對多中間表)\r\n  - [ORM N+1](#orm-n1)\r\n    - [什麼是 N+1](#什麼是-n1)\r\n    - [解決 N+1 的問題](#解決-n1-的問題)\r\n  - [序列化](#序列化)\r\n    - [將 collection 序列化](#將-collection-序列化)\r\n      - [array](#array)\r\n      - [JSON](#json)\r\n    - [隱藏 JSON 屬性](#隱藏-json-屬性)\r\n      - [臨時修改屬性可見度](#臨時修改屬性可見度)\r\n    - [追加 JSON 值](#追加-json-值)\r\n      - [臨時追加屬性](#臨時追加屬性)\r\n    - [日期序列化](#日期序列化)\r\n      - [自訂任意屬性的日期格式](#自訂任意屬性的日期格式)\r\n  - [刪除](#刪除)\r\n    - [普通刪除](#普通刪除)\r\n    - [軟刪除](#軟刪除)\r\n      - [啟用軟刪除](#啟用軟刪除)\r\n      - [軟刪除應用](#軟刪除應用)\r\n      - [實現中間表的軟刪除](#實現中間表的軟刪除)\r\n      - [清除舊的軟刪除資料](#清除舊的軟刪除資料)"}