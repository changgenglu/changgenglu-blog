{"name":"Laravel Eloquent ORM.md","content":"# Laravel Eloquent ORM\n\n>\n\n## models\n\n### 建立 Model\n\n```php\nphp artisan make:model New\n```\n\n建立 Model 同時建立與其相關的 class\n\n```php\n// migration\nphp artisan make:model New -m\n\n// factory\nphp artisan make:model New -f\n\n// seed\nphp artisan make:model New -s\n\n// controller\nphp artisan make:model New -c\n\n// 同時建立多個class\nphp artisan make:model New -mfsc\n\n```\n\n### 基本屬性\n\n```php\nclass UserInfo extends Model\n{\n    protected $table = 'user_data';  // 資料表名稱\n\n    protected $primaryKey = 'id';   // 主鍵\n\n    public $timestamps = false;\n\n    protected $fillable = [\n        'userId',\n        'userName',\n        'account',\n        'password',\n        'email'\n    ];\n\n    protected $casts = [\n        'is_admin' => 'boolean',\n    ];\n}\n```\n\n- public $timestamps = false // 關閉時間戳記，預設為開啟\n- 批量賦值：調用 create() update() 時，可以大量新增、修改的欄位。若沒有添加這個屬性，新增修改的動作將無法實現。\n\n  - $fillable 設定可以大量新增的欄位（白名單）\n\n    ```php\n    protected $fillable = ['userId','userName','account','pw','email'];\n    ```\n\n  - $guarded 設定需要被保護的欄位（黑名單）\n\n    ```php\n    protected $guarded = [‘uuid’, ‘pw’];\n    ```\n\n- 屬性類型轉換：`$casts` 可以將屬性轉換為指定的類型，支援的類型有\n  - `integer`\n  - `real`\n  - `float`\n  - `double`\n  - `decimal:<digits>` 需定義小數位的個數，如 `decimal:2`\n  - `string`\n  - `boolean`\n  - `object`\n  - `array`\n  - `collection`\n  - `date`\n  - `datetime`\n  - `timestamps`\n\n## 關聯\n\n### 多型態關聯\n\n> [參考資料](https://laravelacademy.org/post/9725)\n>\n> 多型態關聯可以讓一張表同時關連到兩張以上的資料表\n>\n> 優點:\n> 可以合一管理資類類似的資料結構與處理邏輯\n> 缺點:\n> 耦合提高，變動邏輯時容易影響到某一方的操作\n\n假設我們有 user 跟 post 兩種資料，而他們各自有所屬的 image 資料表\n\n| users |\n| :---: |\n|  id   |\n| name  |\n\n| user_images |\n| :---------: |\n|     id      |\n|   user_id   |\n|     url     |\n\n| posts |\n| :---: |\n|  id   |\n| name  |\n\n| post_images |\n| :---------: |\n|     id      |\n|   post_id   |\n|     url     |\n\n如果 image 的資料結構和處理邏輯相似，就可以使用多型態關聯，將表單合成一張\n\n| users |\n| :---: |\n|  id   |\n| name  |\n\n| posts |\n| :---: |\n|  id   |\n| name  |\n\n|     images      |\n| :-------------: |\n|       id        |\n| imaginable_type |\n|  imaginable_id  |\n|       url       |\n\n- imaginable_id : 關聯的主鍵值\n- imaginable_type : 指定這筆資料是關聯 users 資料表還是 posts 資料表，欄內儲存的是類別名稱，型態為字串，如：'App\\Models\\User' 'App\\Models\\Post'\n\n#### 多形一對一關聯\n\n```php\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Image extends Model\n{\n    public function imaginable()\n    {\n        return $this->morphTo();\n    }\n}\n\nclass Post extends Model\n{\n\n    public function image()\n    {\n        return $this->morphOne(Image::class, 'imaginable');\n    }\n}\n\nclass User extends Model\n{\n\n    public function image()\n    {\n        return $this->morphOne(Image::class, 'imaginable');\n    }\n}\n```\n\n- `morphOne`: hasOne 的多型態版本\n\n  和 hasOne 相比，標類別後面多了一個 name 參數 imaginable，Eloquent 會根據這個 name 預設目標表單上的查詢欄位，以 imaginable 為例的話就是查詢 imaginable_type 跟 imaginable_id\n\n  - 自訂目標的查詢欄位名稱\n\n    ```php\n    // morphOne(目標表單名稱，多形名稱，目標的型別欄位名稱，目標的外鍵欄位名稱，自己的關聯鍵)\n     $this->morphOne(Image::class, 'imaginable','imaginable_type',  'imaginable_id','id');\n    ```\n\n- `morphTo`: belongsTo 的多型態版本\n\n  ```php\n  // 使用時要注意函式的名稱\n  public function imaginable()\n  {\n      return $this->morphTo();\n  }\n  ```\n\n  如果沒有帶入參數的話預設會用函式的名稱產出預設名稱，像這裡的函式名稱是 imaginable ，那查詢時就會以型別欄位 imaginable_type 查對應的資料表，以及鍵值欄位 imaginable_id 查資料。\n\n  - 自訂預設名稱\n\n    ```php\n    $this->morphTo('imaginable');\n    ```\n\n  - 自訂查詢欄位的名稱\n\n    ```php\n    // morphOne(多形名稱，型別欄位名稱，外鍵欄位名稱)\n    $this->morphTo('imaginable'，'imaginable_type','imaginable_id');\n    ```\n\n#### 多型一對多關聯\n\n和一對一的關聯差不多，差別在 morphOne 改成 morphMany，查詢得到的資料不是一筆而是一組\n\n```php\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Image extends Model\n{\n    public function imaginable()\n    {\n        return $this->morphTo();\n    }\n}\n\nclass Post extends Model\n{\n\n    public function image()\n    {\n        return $this->morphMany(Image::class, 'imaginable');\n    }\n}\n\nclass User extends Model\n{\n\n    public function image()\n    {\n        return $this->morphMany(Image::class, 'imaginable');\n    }\n}\n```\n\n#### 多型多對多關聯\n\n> 和普通多對多關聯相比，中介表為多型態\n\n影片和文章有相同的 tag，一篇文章和影片同時會有多個 tag，一個 tag 也會同時關連到多個影片或文章\n| videos |\n| :----: |\n| id |\n| name |\n\n| posts |\n| :---: |\n|  id   |\n| name  |\n\n|   taggable    |\n| :-----------: |\n|      id       |\n|    tag_id     |\n| taggable_type |\n|  taggable_id  |\n\n| tags |\n| :--: |\n|  id  |\n| name |\n\n多型的一方，會用 morphToMany 方法\n\n```php\n<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Video extends Model\n{\n    /**\n     * Get all of the tags for the post.\n     */\n    public function tags()\n    {\n        return $this->morphToMany(Tag::class, 'taggable');\n    }\n}\n\nclass Post extends Model\n{\n    /**\n     * Get all of the tags for the post.\n     */\n    public function tags()\n    {\n        return $this->morphToMany(Tag::class, 'taggable');\n    }\n}\n```\n\n反向關聯會使用 morphedByMany 方法\n\n```php\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Tag extends Model\n{\n    /**\n     * Get all of the posts that are assigned this tag.\n     */\n    public function posts()\n    {\n        return $this->morphedByMany(Post::class, 'taggable');\n    }\n\n    /**\n     * Get all of the videos that are assigned this tag.\n     */\n    public function videos()\n    {\n        return $this->morphedByMany(Video::class, 'taggable');\n    }\n}\n```\n\n- `morphToMany`: belongsToMany 的多型態版\n- `morphedByMany`: 多對多的反向多型關聯\n\n  需要帶多型的名稱參數才能查詢資料\n\n  ```php\n  // morphOne(目標表單名稱，多形名稱)\n   $this->morphToMany(Tag::class, 'taggable');\n  ```\n\n  - 自訂名稱\n\n    ```php\n    public function morphedByMany(\n      $related,                 // 目標表單名稱\n      $name,                    // 多型名稱\n      $table = null,            // 中介表單名稱\n      $foreignPivotKey = null,  // 中介表單上參照自己的外鍵\n      $relatedPivotKey = null,  // 中介表單上參照目標的外鍵\n      $parentKey = null,        // 目標的關聯鍵\n      $relatedKey = null        // 自己的關聯鍵\n    )\n\n    $this->morphToMany(\n      Tag::class, 'taggable','taggable','taggable_id','tag_id','id','id'\n    );\n    ```\n\n#### 自訂多型型別\n\n預設 laravel 會使用類別的完整名稱來儲存 model type。\n\n可以透過自訂多型型別，使用簡單的字串作為 model type，將這些值從專案的內部結構中解耦出來。\n\n如此一來，即使修改 model 名稱，資料庫中的多型 type 欄位也會繼續有效。\n\n- 例如：  \n  Commit Model 可以隸屬於 Post Model 或 Video Model。因此，comments 資料表中的 commentable_type 欄位分別會記載 App\\Models\\Post 或 App\\Models\\Video。\n\n  此時可以在 `App\\Providers\\AppServiceProvider` 中的 `boot` 方法，呼叫`enforceMorphMap`方法。將 post 及 video 等簡單字串作為 model type。\n\n```php\nuse Illuminate\\Database\\Eloquent\\Relations\\Relation;\n\nRelation::enforceMorphMap([\n    'post' => 'App\\Models\\Post',\n    'video' => 'App\\Models\\Video',\n]);\n```\n\n## Laravel ORM 將資料存至資料庫\n\n### save\n\n將表格第一筆資料的名字，改成小華\n\n```php\nUser::find(1)->save(['name' => '小華']);\n```\n\n也可以一次編輯多個欄位\n\n```php\nUser::find(1)->save([\n  'name'=>'小華',\n  'email'=>'flower@gmail.com'\n  'sex'=>'male'\n]);\n```\n\n### 修改多對多中間表\n\n- articles\n\n| id  | article_name |\n| :-: | :----------: |\n|  1  |   article1   |\n|  2  |   article2   |\n|  3  |   article3   |\n|  4  |   article5   |\n\n- tags\n\n| id  | tag_name |\n| :-: | :------: |\n|  1  |   tech   |\n|  2  |  music   |\n|  3  |   art    |\n|  4  |   food   |\n\n- article_tag\n\n| article_id | tag_id |\n| :--------: | :----: |\n|     1      |   2    |\n|     1      |   3    |\n|     1      |   4    |\n|     3      |   4    |\n\n建立和控制多對多關係的方法\n\n- 建立:\n\n  - `attach()`\n\n    ```php\n    // id=3 的文章原有的標籤[4]\n    Article::find(3)->tags()->attach([1,2]);\n    // id=3 的文章加入標籤[1, 2]\n    // id=3 的文章的標籤有[1, 2, 4]\n    ```\n\n  - `save()`\n\n    ```php\n    Article::find(3)->tags()->saveMany([\n        Tag::find(1),\n    Tag::find(2)\n    ]);\n    // save輸入的類型須為model\n    // 多個時要用saveMany\n    ```\n\n    |   方法   | 單個 id | 多個 id | 單個 model |   多個 model    |\n    | :------: | :-----: | :-----: | :--------: | :-------------: |\n    | attach() |    V    |    V    |     V      |                 |\n    |  sync()  |    V    |    V    |     V      |                 |\n    |  save()  |         |         |     V      | 要用 saveMany() |\n\n- 刪去: `detach()`\n\n  ```php\n  $article = Article::find(1);\n\n  // 從文章上移除指定tag\n  $article->tags()->detach($tag_id);\n\n  // 移除文章所有tag\n  $article->tags()->detach();\n  ```\n\n- 同步\n\n  - `sync`\n\n    ```php\n    // 更新有傳入值的該筆資料，其他資料會被刪除\n    $user->roles()->sync([1, 2, 3]);\n\n    // 透過id傳入額外的值到中間表\n    $user->roles()->sync([1 => ['expires' => true], 2, 3]);\n    ```\n\n  - `syncWithoutDetaching`\n\n    ```php\n    // 更新有傳入值的該筆資料，並保留原有的資料\n    $user->roles()->syncWithoutDetaching([1, 2, 3]);\n    ```\n\n  - `updateExistingPivot`\n\n    ```php\n    // 更新一筆已存在的資料，接受中間表的外鍵和要更新的值進行更新\n    $user = App\\Models\\User::find(1);\n\n    $user->roles()->updateExistingPivot($roleId, $attributes);\n    ```\n\n- 切換: `toggle()`\n\n  ```php\n  $article->tags()->toggle([1, 2 ,3]);\n  // 用來切換傳入id的附加狀態，如果傳入的id目前已經被附加，他將會被卸除。\n  // 若已經被卸除，將會被附加\n  ```\n\n## ORM N+1\n\n> 紀錄 ORM 對資料庫的查詢語法\n>\n> ```php\n> // 開始紀錄\n> DB::enableQueryLog();\n>\n> // 結束並印出\n> dd(DB::getQueryLog());\n> ```\n\n### 什麼是 N+1\n\n資料表中有關聯關係，以論壇文章為例。\n\n- 一名使用者，可以發布多篇文章。\n- 一篇文章只屬於一名使用者。\n\n使用者與文章的關係為一對多。當我們要取得多名使用者，並同時取得這些使用者過去發布的所有文章時：\n\n```php\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('lazy-loading', function () {\n  // 開啟 Query Log\n  DB::enableQueryLog();\n\n  // 取得所有使用者\n  $users = User::get();\n\n  // 使用迴圈取得每一位使用者所發布的文章\n  foreach ($users as $user) {\n      $posts = $user->posts;\n      dump($posts->toArray());\n  }\n\n  // dump 對資料庫的查詢語法\n  dump(DB::getQueryLog());\n});\n```\n\n這時就會產生 n+1 的問題。\n\n第一筆查詢是取得所有用戶。\n\n```php\n// 取得所有使用者\n$users = User::get();\n```\n\n接下來每一筆是取得各用戶發布的文章。\n\n```php\n// 使用迴圈取得每一位使用者所發布的文章\nforeach ($users as $user) {\n  $posts = $user->posts;\n}\n```\n\n### 解決 N+1 的問題\n\n可以使用 laravel 所提供的預加載功能 `with()`\n\n```php\nRoute::get('lazy-loading', function () {\n  // 開啟 Query Log\n  DB::enableQueryLog();\n\n  // 取得所有使用者，並預先加載 Post 的資料\n  // 這裡的 'posts' 對應到 User Model 中的 posts()\n  $users = User::with('posts')->get();\n\n  // 使用迴圈取得每一位使用者所發布的文章\n  foreach ($users as $user) {\n      $posts = $user->posts;\n      dump($posts->toArray());\n  }\n\n  // dump 對資料庫的查詢語法\n  dump(DB::getQueryLog());\n});\n```\n\n這時僅執行了兩個查詢\n\n```sql\nselect * from users\n\nselect * from posts where id in (1, 2, 3, 4, 5, ...)\n```\n\n可以指定不需要某些資料\n\n```php\n$users = User::without('posts')->get();\n```\n\n或是只需要其他資料\n\n```php\n$users = User::withOnly('loginRecords')->get();\n```\n\n也可以加載多個關聯\n\n```php\n$users = User::with(['posts', 'commit'])->get();\n```\n\n## 序列化\n\n> 建構 JSON API 時，針對 model 及其取得關連的值，將其轉化為 array 或是 JSON\n\n### 將 collection 序列化\n\n#### array\n\n- `toArray()` 所有的屬性和關聯(包括關聯的關聯)，當將轉化為陣列。\n\n  ```php\n  $user = App\\Models\\User::with('roles')->first();\n\n  return $user->toArray();\n\n  // 將整個 model collection 序列化\n  $users = App\\Models\\User::all();\n\n  return $users->toArray();\n  ```\n\n- `attributesToArray()` 僅將 model 的屬性轉換為陣列\n\n  ```php\n  $user = App\\Models\\User::first();\n\n  return $user->attributesToArray();\n  ```\n\n#### JSON\n\n- `toJson` 所有的屬性和關聯(包括關聯的關聯)，當將轉化為 JSON。\n\n  ```php\n  $user = App\\Models\\User::find(1);\n\n  return $user->toJson();\n\n  // 指定PHP支援的JSON編碼選項\n  return $user->toJson(JSON_PRETTY_PRINT);\n  ```\n\n- 將 model 或 collection 轉為字串時，會自動調用`toJson()`，因此可以應用在 route 或 controller 中直接返回。\n\n  ```php\n  Route::get('users', function () {\n      return App\\Models\\User::all();\n  });\n\n  $user = App\\Models\\User::find(1);\n\n  return (string) $user;\n  ```\n\n- 關聯屬性：當 model 被轉化為 JSON 的時候，他加載的關聯關係也將自動轉化為 JSON 對象被包含進來，同時透過小駝峰定義的關聯方式，關聯的 JSON 屬性將會是蛇底式命名。\n\n### 隱藏 JSON 屬性\n\n> 有時需要將 model array 或 JSON 中某些屬性進行隱藏，如：密碼。\n\n- `$hidden`\n\n  ```php\n  namespace App\\Models;\n\n  use Illuminate\\Database\\Eloquent\\Model;\n\n  class User extends Model\n  {\n      /**\n       * 数组中的属性会被隐藏\n       *\n       * @var array\n       */\n      protected $hidden = ['password'];\n  }\n  ```\n\n- `$visible` 定義一個 model array 和 JSON 可見的白名單。經過定義後，序列化此 model 不會出現白名單以外的屬性。\n\n  ```php\n  namespace App\\Models;\n\n  use Illuminate\\Database\\Eloquent\\Model;\n\n  class User extends Model\n  {\n      /**\n       * 数组中的属性会被展示\n       *\n       * @var array\n       */\n      protected $visible = ['first_name', 'last_name'];\n  }\n  ```\n\n#### 臨時修改屬性可見度\n\n- `makeVisible`\n\n  ```php\n  return $user->makeVisitable('attribute')->toArray();\n  ```\n\n- `makeHidden`\n\n  ```php\n  return $user->makeHidden('attribute')->toArray();\n  ```\n\n### 追加 JSON 值\n\n> 在 array 或是 JSON 中添加一些不存在於資料庫的欄位。\n\n定義 `getAttribute`\n\n```php\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * Get the administrator flag for the user.\n     *\n     * @return bool\n     */\n    public function getIsAdminAttribute()\n    {\n        return $this->attributes['admin'] === 'yes';\n    }\n}\n```\n\n然後在 model 中宣告屬性 `appends`。\n\n```php\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    /**\n     * The accessors to append to the model's array form.\n     *\n     * @var array\n     */\n    protected $appends = ['is_admin'];\n}\n```\n\n- **Notice:** 在`getAttribute`中使用駝峰命名，但在宣告屬性時，通常以蛇底式命名。\n\n宣告 `append` 追加屬性後，其將會被包含在 model array 和 JSON 中。追加屬性也會遵循 model 宣告的`visible`及`hidden`屬性。\n\n#### 臨時追加屬性\n\n可以在單一 model 實例，使用`append`方法蘭追加屬性。或者使用`setAppends`方法來重寫追加屬性的陣列。\n\n```php\nreturn $user->append('is_admin')->toArray();\n\n// 重寫整個追加屬性的陣列\nreturn $user->setAppends(['is_admin'])->toArray();\n```\n\n### 日期序列化\n\n- `serializeDate` 此方法可自訂預設的日期序列化格式\n\n```php\n/**\n * 為array / JSON 序列化準備一個日期\n *\n * @param  \\DateTimeInterface  $date\n * @return string\n */\nprotected function serializeDate(DateTimeInterface $date)\n{\n    return $date->format('Y-m-d');\n}\n```\n\n#### 自訂任意屬性的日期格式\n\n可以在 Eloquent 宣告屬性轉換，單獨為資料庫中為日期屬性的欄位定義其格式\n\n```php\nprotected $casts = [\n    'birthday' => 'date:Y-m-d',\n    'joined_at' => 'datetime:Y-m-d H:00',\n];\n```\n\n## 刪除\n\n### 普通刪除\n\n```php\n$contact = Contact::find(5);\n$contact->delete();\n```\n\n透過 id 刪除\n\n```php\nContact::destroy(1);\n// or\nContact::destroy([1, 5, 7]);\n```\n\n刪除查詢結果\n\n```php\nContact::where('updated_at', '<', now()->subYear())->delete();\n```\n\n### 軟刪除\n\n> 透過在資料表中增加一個 delete_at 的欄位，來標記要刪除的資料，而不是直接將資料刪除。\n>\n> 優點：刪除的資料可以被復原、可以記錄資料刪除的時間點。\n>\n> 缺點：中間表無法使用軟刪除、需要定時清理軟刪除的資料，以免資料庫日益肥大。\n\n#### 啟用軟刪除\n\n將 `Illuminate\\Database\\Eloquent\\SoftDeletes` Trait 加到 Model 上\n\n```php\n<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\n\nclass Flight extends Model\n{\n    use SoftDeletes;\n}\n```\n\n利用 migration 將 delete_at 欄位加入資料表\n\n```php\nuse Illuminate\\Database\\Schema\\Blueprint;\nuse Illuminate\\Support\\Facades\\Schema;\n\npublic function up() {\n    Schema::table('flights', function (Blueprint $table) {\n        $table->softDeletes();\n    });\n}\n\npublic function down() {\n    Schema::table('flights', function (Blueprint $table) {\n        $table->dropSoftDeletes();\n    });\n}\n```\n\n當在 model 上呼叫 delete 方法時，會自動更新 delete_at 欄位，並設為當前時間。\n\n#### 軟刪除應用\n\n- 判斷是否已被軟刪除\n\n  ```php\n  if ($flight->trashed()) {\n      //\n  }\n  ```\n\n- 恢復軟刪除\n\n  ```php\n  $flight->restore();\n\n  // 恢復多個\n  Flight::withTrashed()\n      ->where('airline_id', 1)\n      ->restore();\n  ```\n\n  - 永久刪除 model\n\n  ```php\n  $flight->forceDelete();\n  ```\n\n- 查詢軟刪除的 model\n\n  - 包含軟刪除的 model\n\n    ```php\n    use App\\Models\\Flight;\n\n    $flights = Flight::withTrashed()\n                    ->where('account_id', 1)\n                    ->get();\n    ```\n\n  - 只取得被刪除的 model\n\n    ```php\n    $flights = Flight::onlyTrashed()\n                    ->where('airline_id', 1)\n                    ->get();\n    ```\n\n#### 實現中間表的軟刪除\n\n> 一般不建議對 pivot 進行軟刪除。\n\n在 pivot 表，添加一個 bool 欄位，ex: is_deleted。\n\n- `updateExistingPivot()` 此方法可以修改這欄位\n- `wherePivot('is_deleted', true)` 可以篩選數據\n\n```php\nBook::find(1)->buyers()->wherePivot('is_deleted', true)->get()\n\nBook::find(1)->buyers()->updateExistingPivot(11, ['is_deleted' => false])\n```\n\n或者在關聯中，定義兩者的關係\n\n```PHP\nfunction buyers() {\n    return $this->belongToMany('App\\User')->wherePivot('is_deleted', false);\n}\n\nfunction buyersWithDeleted() {\n    return $this->belongToMany('App\\User');\n}\n```\n\n#### 清除舊的軟刪除資料\n\n[參考資料](https://github.com/tighten/quicksand)\n","tocContent":"- [Laravel Eloquent ORM](#laravel-eloquent-orm)\n  - [models](#models)\n    - [建立 Model](#建立-model)\n    - [基本屬性](#基本屬性)\n  - [關聯](#關聯)\n    - [多型態關聯](#多型態關聯)\n      - [多形一對一關聯](#多形一對一關聯)\n      - [多型一對多關聯](#多型一對多關聯)\n      - [多型多對多關聯](#多型多對多關聯)\n      - [自訂多型型別](#自訂多型型別)\n  - [Laravel ORM 將資料存至資料庫](#laravel-orm-將資料存至資料庫)\n    - [save](#save)\n    - [修改多對多中間表](#修改多對多中間表)\n  - [ORM N+1](#orm-n1)\n    - [什麼是 N+1](#什麼是-n1)\n    - [解決 N+1 的問題](#解決-n1-的問題)\n  - [序列化](#序列化)\n    - [將 collection 序列化](#將-collection-序列化)\n      - [array](#array)\n      - [JSON](#json)\n    - [隱藏 JSON 屬性](#隱藏-json-屬性)\n      - [臨時修改屬性可見度](#臨時修改屬性可見度)\n    - [追加 JSON 值](#追加-json-值)\n      - [臨時追加屬性](#臨時追加屬性)\n    - [日期序列化](#日期序列化)\n      - [自訂任意屬性的日期格式](#自訂任意屬性的日期格式)\n  - [刪除](#刪除)\n    - [普通刪除](#普通刪除)\n    - [軟刪除](#軟刪除)\n      - [啟用軟刪除](#啟用軟刪除)\n      - [軟刪除應用](#軟刪除應用)\n      - [實現中間表的軟刪除](#實現中間表的軟刪除)\n      - [清除舊的軟刪除資料](#清除舊的軟刪除資料)"}