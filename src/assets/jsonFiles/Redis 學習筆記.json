{"name":"Redis 學習筆記.md","content":"# Redis 學習筆記\n\n>\n\n## redis-cil\n\n```shell\n# redis-cli -h <host> -p <port>\nredis-cli -h 127.0.0.1 -p 6379\n```\n\n### scan keys tool\n\nfind_redis_keys.sh\n\nchmod +x find_redis_keys.sh\n\n- 開頭檢查 redis-cli，若未安裝會嘗試用 apk add redis 安裝\n- 支援 -h 參數顯示 常見 pattern 速查表\n- 使用者輸入 Redis host、port、db、pattern\n- 顯示找到的 key 與總數\n- 刪除選項：\n  - y → 刪除全部\n  - n → 不刪除\n  - 輸入指定 key → 只刪該 key\n\n```bash\n#!/bin/bash\n\n# 檢查 redis-cli 是否存在\nif ! command -v redis-cli >/dev/null 2>&1; then\n  echo \"redis-cli 未安裝，開始安裝 redis...\"\n  if command -v apk >/dev/null 2>&1; then\n    apk add --no-cache redis\n  else\n    echo \"錯誤：找不到 apk，請手動安裝 redis-cli。\"\n    exit 1\n  fi\nfi\n\n# 再次確認是否安裝成功\nif ! command -v redis-cli >/dev/null 2>&1; then\n  echo \"安裝 redis 失敗，請檢查環境。\"\n  exit 1\nfi\n\n# 如果參數為 -h，顯示 pattern 範例速查表\nif [ \"$1\" = \"-h\" ]; then\n  echo \"常見 Redis key pattern 範例速查表：\"\n  echo \"-----------------------------------\"\n  echo \"rtp:*           → 查詢以 rtp: 開頭的 key (前綴)\"\n  echo \"*:blocked       → 查詢以 :blocked 結尾的 key (後綴)\"\n  echo \"*user*          → 查詢包含 user 的 key\"\n  echo \"session:??      → 查詢 session: 後接任意兩個字元的 key\"\n  echo \"log:[0-9]*      → 查詢 log: 開頭後面接數字的 key\"\n  echo \"\"\n  echo \"用法範例： ./delete_keys.sh   或   ./delete_keys.sh -h\"\n  exit 0\nfi\n\necho \"redis-cli 已安裝。\"\necho \"\"\n\n# 詢問 Redis Host\nread -p \"請輸入 Redis Host (預設: 127.0.0.1): \" REDIS_HOST\nREDIS_HOST=${REDIS_HOST:-127.0.0.1}\n\n# 詢問 Redis Port\nread -p \"請輸入 Redis Port (預設: 6379): \" REDIS_PORT\nREDIS_PORT=${REDIS_PORT:-6379}\n\n# 詢問 Redis DB\nread -p \"請輸入 Redis DB index (預設: 0): \" REDIS_DB\nREDIS_DB=${REDIS_DB:-0}\n\n# 詢問要掃描的 pattern\nread -p \"請輸入要掃描的 key pattern (前綴例: rtp:*，後綴例: *:blocked): \" KEY_PATTERN\n\necho \"\"\necho \"開始掃描符合 pattern [$KEY_PATTERN] 的 key (DB=$REDIS_DB)...\"\nKEYS=$(redis-cli -h \"$REDIS_HOST\" -p \"$REDIS_PORT\" -n \"$REDIS_DB\" --scan --pattern \"$KEY_PATTERN\")\n\nif [ -z \"$KEYS\" ]; then\n  echo \"沒有找到符合的 key。\"\n  exit 0\nfi\n\nCOUNT=$(echo \"$KEYS\" | wc -l | tr -d ' ')\necho \"總共找到 $COUNT 筆 key：\"\necho \"$KEYS\"\necho \"\"\n\n# 詢問刪除方式\nread -p \"請輸入刪除選項 (<y> 刪除全部, <n> 不刪除, <key> 刪除指定key): \" INPUT\n\nif [ \"$INPUT\" = \"y\" ] || [ \"$INPUT\" = \"Y\" ]; then\n  DELETED=$(echo \"$KEYS\" | xargs redis-cli -h \"$REDIS_HOST\" -p \"$REDIS_PORT\" -n \"$REDIS_DB\" del | tail -n1)\n  echo \"已刪除全部 $DELETED 筆 key。\"\nelif [ \"$INPUT\" = \"n\" ] || [ \"$INPUT\" = \"N\" ]; then\n  echo \"已取消刪除。\"\nelse\n  # 指定刪除單一 key\n  DELETED=$(redis-cli -h \"$REDIS_HOST\" -p \"$REDIS_PORT\" -n \"$REDIS_DB\" del \"$INPUT\")\n  if [ \"$DELETED\" -eq 1 ]; then\n    echo \"已刪除指定 key: $INPUT\"\n  else\n    echo \"未找到指定的 key: $INPUT\"\n  fi\nfi\n\n```\n\n## 資料類型\n\n- redis 支援五種資料類型：\n  - string 字串\n  - hash 雜湊\n  - list 列表\n  - set 集合\n  - zset 有序集合\n\n### string\n\n一個 key 對應一個 value。\n\n字串類型為二進制，因此 string 可包含任何資料，如 jpg 圖片，或是一個序列化的物件。\n\nstring 最大可以儲存 512MB\n\n```shell\n# SET key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX]\n> SET phone Note10 EX 10          # 10 秒過期\n> SET price 23900\n\n# SETNX key value\n# SET if Not Exist，如果該 key 不存在才儲存\n> SETNX frameworks \"react vue angular\" # 回傳 1 表示成功，0 表示失敗（該 key 已經存在）\n\n# SETEX key seconds value  # 設定過期時間\n\n# 增加或減少數值\n> INCR price               # 23901，一次增加 1\n> DECR price               # 23900，一次減少 1\n> INCRBY price 1000        # 24900，一次增加 1000\n> DECRBY price 1000        # 23900，一次減少 1000\n```\n\n### List\n\n由於 Lists 本質上是 linked-list 的緣故，它在新增和刪除元素的速度是快的，但搜尋速度是相對慢的。可以使用 RPUSH 和 LPUSH 來新增元素，如果該 key 尚不存在的話，會回傳新的 List，如果該 key 已經存在，或它不是 List 的話，則會回傳錯誤。\n\n- 有順序性\n- 新增刪除速度相對快：適合用在只要取出頭尾元素的情況(ex: Quene)\n- 搜尋速度相對慢\n- 適用時機\n  - Message Quene: 只需取出頭尾的元素，不需要搜尋\n\n```shell\n# 在 List 中新增元素\n# RPUSH <key> <element> [element ...] / LPUSH <key> <element> [element ...]\n> RPUSH frameworks react vue angular  # 3\n> LPUSH frameworks svelte             # 4\n\n# 檢視 List 中的元素\n# LRANGE <key> <start> <stop>\n> LRANGE frameworks 0 -1  # 列出所有元素，-1 表示 list 中的最後一個元素\n\n# 檢視 List 數目\n# LLEN <key>\n> LLEN frameworks\n\n# 移除 list 中的元素\n# RPOP <key> / LPOP <key>\n> RPOP frameworks         # 移除 list 最後一個元素\n> LPOP frameworks\n```\n\n### Set\n\n由多個 redis 中的 string 以無序的方式所組成，其保證內部不會有重複的元素，此外 Redis 提供了多個 Set 之間交集、差集與聯集的操作。\n\n- 使用時機：\n\n  - 記錄每一個造訪的 ip\n  - 商品標籤\n\n- Set 的基礎操作\n  - CRUD: SADD SREM SMEMBERS SCARD SPOP\n  - 集合操作: SDIFF SINTER SUNION\n\n```shell\n# SADD <key> <member> [member ...]   # 新增元素到 Set 中\n> SADD languages english             # 1，新增的元素數目\n> SADD languages frensh chinese      # 2，新增的元素數目\n> SADD languages english             # 0，如果元素已經在該 Sets 中，會回傳 0\n\n# SREM <key> <member> [member...]     # 從 Set 中移除元素\n> SREM languages english              # 1，移除的元素數目\n\n# SMEMBERS <key>                      # 檢視 Set 中所有元素\n> SMEMBERS languages                  # 回傳的元素沒有順序性\n\n# SISMEMBER <key> <member>            # 檢視元素是否存在該 Set 中\n> SISMEMBER languages chinese         # 1，存在的話回傳 1，不存在則回傳 0\n\n# SUNION <key> [key...]               # 合併多個 Sets\n> SUNION languages programming-languages\n127.0.0.1:6379> SMEMBERS bike\n1) \"green\"\n2) \"white\"\n3) \"black\"\n4) \"red\"\n127.0.0.1:6379> SUNION car\n1) \"green\"\n2) \"yellow\"\n3) \"red\"\n127.0.0.1:6379> SUNION car bike\n1) \"yellow\"\n2) \"red\"\n3) \"white\"\n4) \"black\"\n5) \"green\"\n```\n\n### Hash\n\n為 key-value 的資料類型，也是 Redis 的主結構，非常適合用於儲存物件型資料，例如 User 物件有姓名、年齡、信箱等。當物件非常小時，Hash 會將資料壓縮後儲存，因此單台 redis 可以儲存數百萬個小物件。\n\n- Hash 的基礎操作\n  - **Create**: HSET, HMSET, HSETNX\n  - **Read**: HGET, HMGET, HGETALL, HKEYS, HVALS, HEXISTS, HLEN\n  - **Update**: HSET (覆蓋), HINCRBY, HINCRBYFLOAT\n  - **Delete**: HDEL\n  - **多欄位操作**: HMSET, HMGET, HGETALL\n\n```shell\n# HSET <key> <field> <value> [field value...]   # 新增 field-value pairs 到 Hash 中\n> HSET phone name \"iphone\"       # 1，新增的數目\n> HSET phone price 22500     # 1，新增的數目\n> HSET phone name \"iphone mini\"  # 0，表示該 field 已經存在 hash 中，將會「更新」其 value\n\n# HGET <key> <field>             # 取得 field 的 value\n> HGET phone name                # \"iphone mini\"\n\n# HGETALL <key>                  # 取得該 hash 的所有值\n> HGETALL phone\n\n# HMSET <key> <field> <value> [field value...]  # 一次設定多個 field-value pairs\n> HMSET phone brand \"Apple\" model \"iPhone 15\"    # OK\n\n# HMGET <key> <field> [field...]    # 一次取出多個 field 的值\n> HMGET phone name price brand      # [\"iphone mini\", \"22500\", \"Apple\"]\n\n# HDEL <key> <field> [field...]     # 刪除指定的 field\n> HDEL phone brand model            # 2，刪除的 field 數目\n\n# HEXISTS <key> <field>             # 檢查 field 是否存在\n> HEXISTS phone name                # 1，存在\n> HEXISTS phone brand               # 0，不存在\n\n# HKEYS <key>                       # 取得所有 field 名稱\n> HKEYS phone                       # [\"name\", \"price\"]\n\n# HVALS <key>                       # 取得所有 value\n> HVALS phone                       # [\"iphone mini\", \"22500\"]\n\n# HLEN <key>                        # 取得 field 數量\n> HLEN phone                        # 2\n\n# HSETNX <key> <field> <value>     # 只在 field 不存在時才設定\n> HSETNX phone color \"black\"       # 1，成功設定\n> HSETNX phone name \"iPhone 16\"    # 0，field 已存在，不更新\n\n# HINCRBY <key> <field> <increment>    # 將 field 的數值增加指定值\n> HSET counter views 100              # 設定初始值\n> HINCRBY counter views 50            # 150，views 增加 50\n\n# HINCRBYFLOAT <key> <field> <increment>  # 將 field 的浮點數值增加指定值\n> HSET product rating 4.5             # 設定初始評分\n> HINCRBYFLOAT product rating 0.3     # 4.8，rating 增加 0.3\n\n# HSTRLEN <key> <field>              # 取得 field 值的字串長度\n> HSTRLEN phone name                  # 12，\"iphone mini\" 的長度\n\n# 實用範例：使用者資料管理\n> HSET user:1001 name \"小明\" age \"25\" email \"ming@example.com\" city \"台北\"\n> HSET user:1001 last_login \"2024-01-15\" login_count 0\n> HINCRBY user:1001 login_count 1    # 登入次數 +1\n> HMGET user:1001 name age city      # [\"小明\", \"25\", \"台北\"]\n> HGETALL user:1001                  # 取得完整使用者資料\n```\n\n#### HGETALL 指令詳細說明\n\n`HGETALL` 是 Redis 用於取得指定 Hash（雜湊）鍵下所有欄位（field）與對應值（value）的指令。回傳結果會依序列出所有欄位名稱與其值，適合用於一次取得整個 Hash 的所有資料。\n\n**語法：**\n\n```shell\nHGETALL <key>\n```\n\n- `<key>`：要查詢的 Hash 鍵名。\n\n**回傳格式：**\n\n- 若指定的 key 存在且為 Hash，回傳所有欄位與值，格式為陣列（field1, value1, field2, value2, ...）。\n- 若 key 不存在，回傳空陣列。\n\n**範例：**\n\nRedis CLI 範例：\n\n```shell\n127.0.0.1:6379> HSET user:1001 name \"小明\" age \"25\" city \"台北\"\n(integer) 3\n127.0.0.1:6379> HGETALL user:1001\n1) \"name\"\n2) \"小明\"\n3) \"age\"\n4) \"25\"\n5) \"city\"\n6) \"台北\"\n```\n\nLaravel phpredis 範例：\n\n```php\n<?php\n\nuse Illuminate\\Support\\Facades\\Redis;\n\n// 設定 Hash 資料\nRedis::hset('user:1001', 'name', '小明');\nRedis::hset('user:1001', 'age', '25');\nRedis::hset('user:1001', 'city', '台北');\n\n// 一次設定多個欄位\nRedis::hmset('user:1001', [\n    'email' => 'ming@example.com',\n    'last_login' => '2024-01-15',\n    'login_count' => 0\n]);\n\n// 取得單個欄位值\n$name = Redis::hget('user:1001', 'name'); // \"小明\"\n\n// 取得多個欄位值\n$userData = Redis::hmget('user:1001', ['name', 'age', 'city']);\n// [\"小明\", \"25\", \"台北\"]\n\n// 取得所有欄位和值\n$allData = Redis::hgetall('user:1001');\n// [\"name\" => \"小明\", \"age\" => \"25\", \"city\" => \"台北\", \"email\" => \"ming@example.com\", ...]\n\n// 檢查欄位是否存在\n$exists = Redis::hexists('user:1001', 'name'); // true\n\n// 取得所有欄位名稱\n$fields = Redis::hkeys('user:1001'); // [\"name\", \"age\", \"city\", \"email\", ...]\n\n// 取得所有值\n$values = Redis::hvals('user:1001'); // [\"小明\", \"25\", \"台北\", \"ming@example.com\", ...]\n\n// 取得欄位數量\n$count = Redis::hlen('user:1001'); // 5\n\n// 數值操作\nRedis::hincrby('user:1001', 'login_count', 1); // 登入次數 +1\n\n// 刪除欄位\nRedis::hdel('user:1001', 'last_login'); // 1\n\n// 使用 Laravel 的 Redis Facade 進行批量操作\nRedis::pipeline(function ($pipe) {\n    $pipe->hset('user:1001', 'status', 'active');\n    $pipe->hset('user:1001', 'updated_at', now()->toISOString());\n    $pipe->expire('user:1001', 3600); // 1小時過期\n});\n```\n\n**常見用途：**\n\n- 一次取得某個使用者、設定檔、會話等所有屬性\n- 檢查 Hash 內所有資料內容\n- 配合資料遷移、備份時導出完整 Hash\n- 快速檢查設定或狀態資訊\n\n**與 HGET 差異：**\n\n- `HGETALL`：一次取得 Hash 內所有欄位與值\n- `HGET`：僅取得指定欄位的值\n\n範例：\n\n```shell\n127.0.0.1:6379> HGET user:1001 name\n\"小明\"\n127.0.0.1:6379> HGETALL user:1001\n1) \"name\"\n2) \"小明\"\n3) \"age\"\n4) \"25\"\n3) \"city\"\n4) \"台北\"\n```\n\n**注意事項：**\n\n- 若 Hash 很大，`HGETALL` 可能回傳大量資料，請注意效能與網路流量。\n- 若 key 不存在，回傳空陣列，不會報錯。\n\n#### Laravel 更新 Hash 指定 Key 值的情境範例\n\n以下展示在 Laravel 專案中常見的 Hash 更新情境，包含簡單的 Redis 指令和操作流程：\n\n**1. 使用者資料更新流程：**\n\n```php\n// 設定使用者資料到 Hash\n$userId = 1001;\n$redisKey = \"user:{$userId}:profile\";\n\n// 流程 1: 單一欄位更新\nRedis::hset($redisKey, 'name', '小明');\nRedis::hset($redisKey, 'age', '25');\n\n// 流程 2: 批量更新多個欄位\nRedis::hmset($redisKey, [\n    'email' => 'ming@example.com',\n    'city' => '台北',\n    'last_login' => now()->toISOString()\n]);\n\n// 流程 3: 更新修改時間戳\nRedis::hset($redisKey, 'updated_at', now()->toISOString());\n\n// 流程 4: 設定過期時間（24小時）\nRedis::expire($redisKey, 86400);\n```\n\n**2. 計數器操作流程：**\n\n```php\n// 流程 1: 登入次數遞增\n$loginCount = Redis::hincrby($redisKey, 'login_count', 1);\n\n// 流程 2: 評分遞增（浮點數）\n$newRating = Redis::hincrbyfloat($redisKey, 'rating', 0.5);\n\n// 流程 3: 檢查欄位是否存在\nif (Redis::hexists($redisKey, 'login_count')) {\n    // 欄位存在，進行更新\n    Redis::hset($redisKey, 'last_activity', now()->toISOString());\n}\n```\n\n**3. 條件式更新流程：**\n\n```php\n<?php\n\n// 流程 1: 只在欄位不存在時設定（HSETNX）\n$result = Redis::hsetnx($redisKey, 'created_at', now()->toISOString());\nif ($result) {\n    echo \"新欄位已建立\";\n} else {\n    echo \"欄位已存在，未更新\";\n}\n\n// 流程 2: 檢查並更新受保護欄位\n$protectedFields = ['_system', '_version'];\n$field = 'status';\n\nif (!in_array($field, $protectedFields)) {\n    Redis::hset($redisKey, $field, 'active');\n    Redis::hset($redisKey, '_last_updated', now()->toISOString());\n}\n```\n\n**4. 批量操作流程（使用 Pipeline）：**\n\n```php\n<?php\n\n// 流程: 使用 Pipeline 進行多個操作\nRedis::pipeline(function ($pipe) use ($redisKey) {\n    // 更新使用者狀態\n    $pipe->hset($redisKey, 'status', 'online');\n\n    // 更新活動時間\n    $pipe->hset($redisKey, 'last_activity', now()->toISOString());\n\n    // 遞增活動計數\n    $pipe->hincrby($redisKey, 'activity_count', 1);\n\n    // 設定過期時間\n    $pipe->expire($redisKey, 3600);\n});\n```\n\n**5. 資料查詢和驗證流程：**\n\n```php\n<?php\n\n// 流程 1: 取得更新後的資料\n$userData = Redis::hgetall($redisKey);\n\n// 流程 2: 取得特定欄位值\n$name = Redis::hget($redisKey, 'name');\n$age = Redis::hget($redisKey, 'age');\n\n// 流程 3: 取得多個欄位值\n$profileFields = Redis::hmget($redisKey, ['name', 'age', 'city']);\n\n// 流程 4: 檢查欄位數量\n$fieldCount = Redis::hlen($redisKey);\n```\n\n**6. 快取管理流程：**\n\n```php\n<?php\n\n// 流程 1: 更新系統設定\n$settingsKey = 'settings:app';\nRedis::hset($settingsKey, 'maintenance_mode', 'false');\nRedis::hset($settingsKey, 'cache_ttl', '3600');\n\n// 流程 2: 批量更新設定\nRedis::hmset($settingsKey, [\n    'debug_mode' => 'true',\n    'log_level' => 'info',\n    'timezone' => 'Asia/Taipei'\n]);\n\n// 流程 3: 更新快取時間戳\nRedis::hset($settingsKey, '_last_updated', now()->toISOString());\n```\n\n**主要操作流程總結：**\n\n1. **單一更新**: 使用 `HSET` 更新個別欄位\n2. **批量更新**: 使用 `HMSET` 一次更新多個欄位\n3. **條件更新**: 使用 `HSETNX` 避免覆蓋現有資料\n4. **數值操作**: 使用 `HINCRBY` 和 `HINCRBYFLOAT` 進行計數\n5. **批量操作**: 使用 `Pipeline` 提升效能\n6. **資料驗證**: 使用 `HEXISTS` 檢查欄位存在性\n7. **過期管理**: 使用 `EXPIRE` 設定快取生命週期\n\n這些流程展示了在 Laravel 中如何有效地使用 Redis Hash 進行各種更新操作，適合用於使用者資料管理、計數器、系統設定等場景。\n\n### Sorted Set\n\n為有序的 Set，其順序會依照傳入的權重值排序，在查找資料時，可使用 binary search，因此查找效率高。由於 Sorted Set 的高效能查詢，Sorted Set 可當做一組 Hash 資料的 index，將物件 id 以及 index field 儲存在 Sort Set，單筆物件的完整資料儲存在 Hash。\n\n- 有順序性，透過 `score` 產生連結來達到排序的作用，`score` 本身會是 `float`\n- 元素值仍然是唯一，但 `score` 可以不是唯一\n- 不論是 Add, Remove 或是 update 速度都很快，可以同時快速搜學中間的項目\n- 可以視為 `set` 和 `hash` 的混合\n- 使用上指令和 `set` 相似，只要將最開頭的 `S` 改成 `Z`\n- 使用時機\n\n  - 遊戲的計分板\n\n- Sorted Set 的基礎操作\n\n  - CRUD: ZADD ZRANGE ZREM\n  - Rank 操作: ZRANK 找元素位置，ZSCORE 設定元素權重值\n\n- option\n  - XX: 只更新存在的成員，不添加新成員\n  - NX: 不更新存在的成員，只添加新成員\n  - CN: 修改返回值為發生變化的成員總數，原始是返回新添加成員的總數(CH 為 change 的縮寫)。更改的元素是新增加的成員，已經存在的成員更新分數。所以在命令中指定的成員有相同的分數將不被計算在內。一般而言，ZADD 只會返回新增成員的數量\n  - INCR: 當 ZADD 指定這個選項時，成員的做就等同 ZINCRBY 命令，對成員的分數進行遞增操作。\n\n```shell\n# ZADD <key> [NX|XX] [CH] [INCR] <score> <member> [score member ...]，新增 sorted Set\n> ZADD students 1 aaron                  # 1\n> ZADD students 2 allison         # 1\n> ZADD students 3 bruce 4 derek          # 2\n\n# XX：只更新已存在的 member 的 score，絕不新增 member\n# NX：不更新已存在的 member 的 score，總是新增 member\n> ZADD students XX 10 aaron    # 如果 aaron 存在，則將 score 更新為 10\n> ZADD students NX 777 jen     # 如果 jen 不存在，則新增且將 score 設為 777\n\n# ZRANGE <key> <start> <stop> [WITHSCORES]，檢視 sorted set\n> ZRANGE students 0 -1                   # 檢視 sorted set 中所有元素\n\n# ZCARD <key>，檢視該 set 中的元素數目\n> ZCARD students\n\n# ZCOUNT <key> <min> <max>     # 檢視分數介於 min ~ max 間的元素拭目\n> ZCOUNT students 0 10\n\n# ZSCORE <key> <member>        # 檢視某 member 的 score\n> ZSCORE students aaron\n\n# ZINCRBY <key> <increment> <member>    # 幫 member 的 score 分數增加\n> ZINCRBY students 10 aaron             # 幫 aaron 的 score 加 10\n```\n\n## Redis Pipeline\n\n### 簡介\n\nRedis Pipeline（管道）是一種將多個 Redis 指令打包在一起發送的技術，可以大幅提升 Redis 操作的效能。傳統的 Redis 操作模式是「請求-回應」的往返模式，而 Pipeline 允許客戶端將多個指令一次性發送到 Redis 伺服器，然後一次性接收所有回應。\n\n### 工作原理\n\n**傳統模式（無 Pipeline）：**\n\n```\nClient -> SET key1 value1 -> Server\nClient <- OK <- Server\nClient -> SET key2 value2 -> Server\nClient <- OK <- Server\nClient -> SET key3 value3 -> Server\nClient <- OK <- Server\n```\n\n**Pipeline 模式：**\n\n```\nClient -> SET key1 value1 -> Server\nClient -> SET key2 value2 -> Server\nClient -> SET key3 value3 -> Server\nClient <- OK <- Server\nClient <- OK <- Server\nClient <- OK <- Server\n```\n\n### 效能提升原理\n\n1. **減少網路往返次數**：將多個指令打包成一個批次發送\n2. **降低網路延遲影響**：減少 TCP 連接的開銷\n3. **提高吞吐量**：特別適合需要執行大量指令的場景\n\n### 使用場景\n\n- **批量資料操作**：一次性設定多個 key-value\n- **資料初始化**：大量資料的初始載入\n- **統計資料處理**：需要執行多個計數器操作\n- **快取預熱**：系統啟動時預先載入快取資料\n- **資料遷移**：大量資料的匯入匯出\n\n### 優缺點\n\n**優點：**\n\n- 大幅提升效能，特別是在高延遲網路環境下\n- 減少網路開銷\n- 提高系統吞吐量\n- 適合批量操作場景\n\n**缺點：**\n\n- 不支援原子性操作（與 Redis Transaction 不同）\n- 記憶體使用量可能增加\n- 錯誤處理較複雜\n- 不適合需要即時回應的場景\n\n### 程式語言範例\n\n#### Redis CLI 範例\n\n```shell\n# 使用 redis-cli 的 --pipe 選項\necho -en '*3\\r\\n$3\\r\\nSET\\r\\n$4\\r\\nkey1\\r\\n$5\\r\\nvalue1\\r\\n*3\\r\\n$3\\r\\nSET\\r\\n$4\\r\\nkey2\\r\\n$5\\r\\nvalue2\\r\\n' | redis-cli --pipe\n\n# 或者使用檔案方式\ncat commands.txt | redis-cli --pipe\n```\n\n#### Python 範例\n\n```python\nimport redis\n\n# 建立 Redis 連接\nr = redis.Redis(host='localhost', port=6379, db=0)\n\n# 使用 Pipeline\npipe = r.pipeline()\n\n# 將多個指令加入 Pipeline\npipe.set('user:1:name', '小明')\npipe.set('user:1:age', '25')\npipe.set('user:1:city', '台北')\npipe.incr('user:counter')\npipe.expire('user:1:name', 3600)\n\n# 執行所有指令\nresults = pipe.execute()\nprint(results)  # [True, True, True, 1, True]\n\n# 使用上下文管理器\nwith r.pipeline() as pipe:\n    pipe.set('key1', 'value1')\n    pipe.set('key2', 'value2')\n    pipe.set('key3', 'value3')\n    results = pipe.execute()\n```\n\n#### Node.js 範例\n\n```javascript\nconst { createClient } = require(\"redis\");\n\nasync function pipelineExample() {\n  const client = createClient();\n  await client.connect();\n\n  // 建立 Pipeline\n  const pipeline = client.multi();\n\n  // 加入多個指令\n  pipeline.set(\"user:1:name\", \"小明\");\n  pipeline.set(\"user:1:age\", \"25\");\n  pipeline.set(\"user:1:city\", \"台北\");\n  pipeline.incr(\"user:counter\");\n  pipeline.expire(\"user:1:name\", 3600);\n\n  // 執行 Pipeline\n  const results = await pipeline.exec();\n  console.log(results);\n\n  await client.quit();\n}\n\npipelineExample();\n```\n\n#### PHP 範例\n\n```php\n<?php\n$redis = new Redis();\n$redis->connect('127.0.0.1', 6379);\n\n// 開始 Pipeline\n$redis->multi();\n\n// 加入多個指令\n$redis->set('user:1:name', '小明');\n$redis->set('user:1:age', '25');\n$redis->set('user:1:city', '台北');\n$redis->incr('user:counter');\n$redis->expire('user:1:name', 3600);\n\n// 執行 Pipeline\n$results = $redis->exec();\nprint_r($results);\n?>\n```\n\n#### Laravel 範例\n\n```php\nuse Illuminate\\Support\\Facades\\Redis;\n\n// 使用 Laravel Redis Facade\n$pipeline = Redis::pipeline();\n\n$pipeline->set('user:1:name', '小明');\n$pipeline->set('user:1:age', '25');\n$pipeline->set('user:1:city', '台北');\n$pipeline->incr('user:counter');\n$pipeline->expire('user:1:name', 3600);\n\n$results = $pipeline->execute();\ndd($results);\n```\n\n### 效能測試範例\n\n```python\nimport redis\nimport time\n\nr = redis.Redis(host='localhost', port=6379, db=0)\n\n# 測試傳統模式\nstart_time = time.time()\nfor i in range(1000):\n    r.set(f'key{i}', f'value{i}')\ntraditional_time = time.time() - start_time\n\n# 測試 Pipeline 模式\nstart_time = time.time()\npipe = r.pipeline()\nfor i in range(1000):\n    pipe.set(f'key{i}', f'value{i}')\npipe.execute()\npipeline_time = time.time() - start_time\n\nprint(f'傳統模式耗時: {traditional_time:.4f} 秒')\nprint(f'Pipeline 模式耗時: {pipeline_time:.4f} 秒')\nprint(f'效能提升: {traditional_time/pipeline_time:.2f} 倍')\n```\n\n### 注意事項\n\n1. **記憶體使用**：Pipeline 會將所有指令暫存在記憶體中，大量指令時需注意記憶體使用量\n2. **錯誤處理**：Pipeline 中的某個指令失敗不會影響其他指令的執行\n3. **原子性**：Pipeline 不保證原子性，如需原子性操作請使用 Redis Transaction\n4. **網路延遲**：在低延遲網路環境下，Pipeline 的效能提升可能不明顯\n5. **指令順序**：Pipeline 中的指令會按順序執行，但回應順序可能不同\n\n### 最佳實踐\n\n1. **適當的批次大小**：建議每批次 100-1000 個指令\n2. **錯誤處理**：實作適當的錯誤處理機制\n3. **監控記憶體**：監控 Pipeline 的記憶體使用情況\n4. **測試效能**：在實際環境中測試 Pipeline 的效能提升\n5. **考慮替代方案**：對於簡單操作，考慮使用 Redis 的批量指令（如 MSET、MGET）\n\n## redis Key\n\n| 指令                                      | 描述                                      |\n| ----------------------------------------- | ----------------------------------------- |\n| DEL key                                   | 當 key 存在時，將其刪除                   |\n| DUMP key                                  | 序列化傳入的 key，並回傳被序列化的值      |\n| EXISTS key                                | 檢查傳入的 key 是否存在                   |\n| EXPIRE key seconds                        | 為傳入的 key 設定過期時間，以秒計         |\n| EXPIREAT key timestamp                    | 設定過期時間，接受 UNIX 時間戳 為時間參數 |\n| PEXPIRE key milliseconds                  | 設置過期時間以毫秒計                      |\n| PEXPIREAT key milliseconds-timestamp      | 設置過期時間的時間戳以毫秒計              |\n| KEYS pattern                              | 查找所有符合傳入模式 (pattem) 的 key      |\n| MOVE key db                               | 將目前資料庫中 key 移動到指定的資料庫中   |\n| PERSIST key                               | 移除 key 的過期時間，key 將永久保存       |\n| PTTL key                                  | 以毫秒為單位，回傳 key 剩餘的過期時間     |\n| TTL key                                   | 以秒為單位，回傳 key 剩餘的過期時間       |\n| RANDOMKEY                                 | 從資料庫中，隨機回傳一個 key              |\n| RENAME key newkey                         | 修改 key 的名稱                           |\n| RENAMENX key newkey                       | 當 newkey 不存在時，將 key 改名為 newkey  |\n| SCAN cursor [MATCH pattern] [COUNT count] | 迭代資料庫中的資料庫鍵                    |\n| TYPE key                                  | 返回 key 所儲存的值的類型                 |\n\n## 指令間聽\n\n在 redis-cli 中下 `monitor` 可監聽所有對 redis 的操作\n\n## Redis GUI\n\n> [Another Redis Desktop Manager](https://github.com/qishibo/AnotherRedisDesktopManager/)\n>\n> [[Tool] Redis 管理工具 - Another Redis Desktop Manager](https://marcus116.blogspot.com/2020/04/tool-redis-another-redis-desktop-manager.html)\n\n## windows 安裝 phpredis\n\n> 下載 phpredis 需要對應 php 的版本\n>\n> PHP Version `7.4.29`\n>\n> Architecture: `x64`\n>\n> PHP Extension Build: API20190902,`TS`,`VC15`\n\n[windows phpredis](https://windows.php.net/downloads/pecl/releases/redis/)\n\n5.3.7 -> php_redis-`5.3.7-7.4`-`ts-vc15`-`x64`.zip\n\n將下載的檔案解壓縮後，將資料夾內 `php_redis.dll` 和 `php_redis.pdb` 複製到 php 的擴充套件 `ext` 目錄之下\n\n最後在 php.ini 檔案中，加入兩行程式碼(注意順序)\n\n```txt\nextension=php_igbinary.dll\nextension=php_redis.dll\n```\n\n最後在 phpinfo 中檢查 php-redis 是否安裝成功\n\n## Redis 與 Memcached 的差異\n\n1. 資料結構： redis 提供多種資料結構，如字串、雜湊表、列表、集合、有序集合等。而 memcached 只有支援簡單的 key value。\n2. 持久化方式：redis 提供多種持久化方式：RDB、AOF，可以將資料儲存到硬碟中，而 memcached 不支援持久化。\n3. 資料分片方式： redis 使用 hash 槽分片方式，可以實現資料的自動分片和負載平衡，而 memcached 只能手動分片。\n4. 處理資料的方式：redis 使用單執行緒處理資料請求，支援事務、Lua 腳本等進階功能。而 memcached 使用多執行緒處理資料請求，只支援基本的 Get、Set 操作。\n5. 協議：Redis 使用自己的協議，支援多個資料庫，可以使用密碼進行認證。而 memcached 使用文字協議，只支援一個預設資料庫。\n6. 記憶體管理方式： redis 的記憶體管理比 memcached 更加複雜，支援更多的記憶體最佳化策略。\n","tocContent":"- [Redis 學習筆記](#redis-學習筆記)\n  - [redis-cil](#redis-cil)\n    - [scan keys tool](#scan-keys-tool)\n  - [資料類型](#資料類型)\n    - [string](#string)\n    - [List](#list)\n    - [Set](#set)\n    - [Hash](#hash)\n      - [HGETALL 指令詳細說明](#hgetall-指令詳細說明)\n      - [Laravel 更新 Hash 指定 Key 值的情境範例](#laravel-更新-hash-指定-key-值的情境範例)\n    - [Sorted Set](#sorted-set)\n  - [Redis Pipeline](#redis-pipeline)\n    - [簡介](#簡介)\n    - [工作原理](#工作原理)\n    - [效能提升原理](#效能提升原理)\n    - [使用場景](#使用場景)\n    - [優缺點](#優缺點)\n    - [程式語言範例](#程式語言範例)\n      - [Redis CLI 範例](#redis-cli-範例)\n      - [Python 範例](#python-範例)\n      - [Node.js 範例](#nodejs-範例)\n      - [PHP 範例](#php-範例)\n      - [Laravel 範例](#laravel-範例)\n    - [效能測試範例](#效能測試範例)\n    - [注意事項](#注意事項)\n    - [最佳實踐](#最佳實踐)\n  - [redis Key](#redis-key)\n  - [指令間聽](#指令間聽)\n  - [Redis GUI](#redis-gui)\n  - [windows 安裝 phpredis](#windows-安裝-phpredis)\n  - [Redis 與 Memcached 的差異](#redis-與-memcached-的差異)"}