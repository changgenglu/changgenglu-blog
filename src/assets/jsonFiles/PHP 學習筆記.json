{"name":"PHP 學習筆記.md","content":"# PHP 學習筆記\n\n>\n\n## 運算子、判斷\n\n- `+`: 算術相加\n\n- `.`: 字串相加\n\n- `gettype()`: 判斷變數的型態\n\n- `(int)($var1 + $var2)`: 只取商\n\n- `isset($var)`: 檢查變數是否有設置\n\n- `empty($var)`: 檢查變數是否為空值\n\n- `is_null($var)`: 檢查變數是否為 null\n\n  |                 | gettype() |   isset()   |   empty()   |  is_null()  |\n  | :-------------: | :-------: | :---------: | :---------: | :---------: |\n  | $x is undefined |   null    | **_false_** |  [true](#)  |  [true](#)  |\n  |    $x = null    |   null    | **_false_** |  [true](#)  |  [true](#)  |\n  |     $x = 0      |    int    |  [true](#)  |  [true](#)  | **_false_** |\n  |    $x = \"0\"     |    str    |  [true](#)  |  [true](#)  | **_false_** |\n  |     $x = 1      |    int    |  [true](#)  | **_false_** | **_false_** |\n  |     $x = \"\"     |    str    |  [true](#)  |  [true](#)  | **_false_** |\n  |   $x = \"PHP\"    |    str    |  [true](#)  | **_false_** | **_false_** |\n\n- `var_dump($var);`: 將變數的訊息印出於螢幕上\n\n- `instanceof` 型態運算子\n\n- 用於確定一個 php 物件是否屬於某一類別\n\n  ```php\n  class MyClass\n  {\n  }\n  class NotMyClass\n  {\n  }\n\n  $a = new MyClass;\n  var_dump($a instanceof MyClass);\n  var_dump($a instanceof NotMyClass);\n  ```\n\n  ```php\n  bool(true)\n  bool(false)\n  ```\n\n- 也可以用來確定一個物件是不是繼承自某一父類別的子類別\n\n  ```php\n  class ParentClass\n  {\n  }\n  class MyClass extends ParentClass\n  {\n  }\n\n  $a = new MyClass;\n  var_dump($a instanceof MyClass);\n  var_dump($a instanceof ParentClass);\n  ```\n\n  ```php\n  bool(true)\n  bool(true)\n  ```\n\n- 也可以用於確定一個變數是不是實現了某個接口的物件實例\n\n  ```php\n  interface A\n  {\n  }\n  class B implements A\n  {\n  }\n  $obj = new B;\n\n  var_dump($obj instanceof A);\n  echo \"<br>\";\n  var_dump($obj instanceof B);\n  ```\n\n  ```php\n  bool(true)\n  bool(true)\n  ```\n\n  雖然 instanceof 通常是直接與 class 名稱一起使用，但也可以使用字串來代替\n\n  ```php\n  interface A\n  {\n  }\n  class B implements A\n  {\n  }\n  $obj = new B;\n  $str1 = 'A';\n  $str2 = 'B';\n\n  var_dump($obj instanceof A);\n  echo \"<br>\";\n  var_dump($obj instanceof B);\n  echo \"<br>\";\n  var_dump($obj instanceof $str1);\n  echo \"<br>\";\n  var_dump($obj instanceof $str2);\n  ```\n\n  ```php\n  bool(true)\n  bool(true)\n  bool(true)\n  bool(true)\n  ```\n\n  若被檢測的變數不是物件，instanceof 並不會報錯，而是直接返回 false。另外，不能使用 instanceof 來檢測常數\n\n  ```php\n  $a = 1;\n  $b = NULL;\n  $c = imagecreate(5, 5);\n  var_dump($a instanceof stdClass);\n  echo '<br>';\n  var_dump($b instanceof stdClass);\n  echo '<br>';\n  var_dump($c instanceof stdClass);\n  echo '<br>';\n  var_dump(FALSE instanceof stdClass);\n  ```\n\n  ```php\n  bool(false)\n  bool(false)\n  bool(false)\n  bool(false)\n  ```\n\n### isset、!!、empty 差異比較\n\n這三個在 PHP 常見，但用意和判斷邏輯都不一樣。以下是詳細的差異說明：\n\n#### 差異比較\n\n|     寫法      | 用途                        | 判斷邏輯                                                   | 特點                         |\n| :-----------: | :-------------------------- | :--------------------------------------------------------- | :--------------------------- |\n| `isset($var)` | 檢查變數是否存在且不為 null | 變數沒宣告 / 為 null → false，其他都 true                  | 不會理會值是否為 0、空字串等 |\n|  `!!($var)`   | 把值強制轉成布林值          | 任何值轉換成 true 或 false（依 PHP 的「真值表」）          | 常用來判斷「是否有值」       |\n| `empty($var)` | 判斷變數是否為空值          | 下列情況回傳 true：\"\"、0、\"0\"、null、false、[]、未定義變數 | 判斷範圍最廣                 |\n\n#### 範例對照\n\n```php\n<?php\n\n$tests = [\n    '未宣告變數' => null,     // 模擬未宣告\n    'null' => null,\n    '空字串' => '',\n    '字串0' => '0',\n    '整數0' => 0,\n    '布林false' => false,\n    '空陣列' => [],\n    '正常字串' => 'hello',\n    '正整數' => 123,\n];\n\nforeach ($tests as $label => $val) {\n    echo \"=== {$label} ===\\n\";\n\n    // 用 isset 前要確認變數有宣告，不然會 warning\n    $isset = isset($val) ? 'true' : 'false';\n    $boolCast = (!!$val) ? 'true' : 'false';\n    $empty = empty($val) ? 'true' : 'false';\n\n    echo \"isset: {$isset}, !!: {$boolCast}, empty: {$empty}\\n\\n\";\n}\n```\n\n**部分輸出解釋：**\n\n```\n=== null ===\nisset: false, !!: false, empty: true\n\n=== 空字串 ===\nisset: true, !!: false, empty: true\n\n=== 字串0 ===\nisset: true, !!: false, empty: true\n\n=== 整數0 ===\nisset: true, !!: false, empty: true\n\n=== 布林false ===\nisset: true, !!: false, empty: true\n\n=== 空陣列 ===\nisset: true, !!: false, empty: true\n\n=== 正常字串 ===\nisset: true, !!: true, empty: false\n\n=== 正整數 ===\nisset: true, !!: true, empty: false\n```\n\n#### 總結\n\n- **`isset($var)`**：只在乎「變數有沒有存在、不是 null」\n- **`!!($var)`**：純粹轉成布林值，0、空字串、空陣列、null 都會變 false\n- **`empty($var)`**：判斷是否「沒有值」，判斷條件最嚴格，包含 \"0\" 也算空\n\n**如果你要判斷「變數有宣告而且有值」：**\n\n```php\nif (isset($var) && !empty($var)) {\n    // do something\n}\n```\n\n#### 常見坑與誤區\n\n**1. `isset()` 以為能判斷「有沒有值」**\n\n```php\n$var = '';\nif (isset($var)) {\n    echo '有值';\n}\n```\n\n**輸出：**\n\n```\n有值\n```\n\n很多人以為空字串應該算「沒值」，但 `isset` 只判斷是否存在且不是 null。所以 `''`、`0`、`false`、`[]` 都會被當成「有值」。\n\n**2. `empty()` 判斷太寬鬆**\n\n```php\n$var = '0';\nif (empty($var)) {\n    echo '空的';\n}\n```\n\n**輸出：**\n\n```\n空的\n```\n\n很多人以為字串 `'0'` 是「有內容」，但 `empty('0')` 卻會當成「空」。這是超常見的坑，在做表單驗證或使用者輸入檢查時尤其容易出問題。\n\n**3. `!!($var)` 以為能取代 `isset()`**\n\n```php\nif (!!$var) {\n    echo 'true';\n}\n```\n\n如果 `$var` 根本沒宣告，會噴 `Notice: Undefined variable`。所以 `!!` 不能用來判斷變數「是否存在」，只能判斷「已存在的變數是否為真值」。\n\n**4. 多層陣列判斷**\n\n```php\n$data = ['user' => ['name' => 'Ivan']];\n\nif (isset($data['user']['age'])) {\n    echo $data['user']['age'];\n}\n```\n\n`isset` 在判斷多層陣列 key 時，安全不會噴錯（會回傳 false）。但如果用 `!!` 或 `empty`，變數沒宣告或 key 不存在就會直接噴錯。\n\n**5. 表單輸入判斷**\n\n很多人會這樣：\n\n```php\nif (!empty($_POST['age'])) {\n    // 使用者有填 age\n}\n```\n\n**問題：** 如果使用者真的輸入 0，這裡會判斷成「沒填」。在做數值型輸入驗證時很容易踩坑。\n\n#### 實務建議\n\n- **要判斷變數是否存在（宣告過 & 不是 null）** → 用 `isset()`\n\n```php\nif (isset($user['name'])) { ... }\n```\n\n- **要判斷變數是否為「真值」** → 用 `!!`\n\n```php\nif (!!$isActive) { ... }   // 等價於 if ($isActive)\n```\n\n- **要判斷「是否為空值」但避免踩到 '0' 的坑** → 不建議直接用 `empty()`\n  → 改用更精準的條件，例如：\n\n```php\nif ($value === '' || $value === null) { ... }\n```\n\n- **處理表單輸入（特別是數字 0）**\n  建議用 `isset()` + 嚴格比較\n\n```php\nif (isset($_POST['age']) && $_POST['age'] !== '') {\n    $age = (int) $_POST['age'];\n}\n```\n\n#### 總結\n\n- **`isset`** → 判斷「有沒有宣告 & 不是 null」\n- **`!!`** → 判斷「布林真值」\n- **`empty`** → 判斷「是不是空」，但過度寬鬆，'0' 會踩坑\n\n**最常見坑點：**\n\n- `empty('0')` 會回傳 true\n- `!!` 不能用在「變數可能沒宣告」的情況\n- `isset` 不能用來判斷「變數有沒有值」\n\n## Autoload 自動載入\n\n一般可以透過 `include`, `include_once`, `require`, `require_once`，來將檔案引入到我們目前正在編寫的這個檔案。\n\n習慣上我們會將一個 class 存放在單一的 php 檔案中，例如 Member.php 相對於 Member class。\n\n但當程式需要引用到這個 class，就可以用上面的方法來引用此 class 以供後續操作。\n\n而 php autoload 機制可以讓我們在需要這個物件的時候，才去真正的引入這個 class，這個動作就是常聽到的 lazyload 延遲載入。\n\n- `__autoload`\n  php5 提供了 `__autoload()` 這個魔術方法實現上述 Autoload 機制，雖然這個方法效能及方便性並不是非常理想。\n\n## 魔術常數\n\n- 不分大小寫，但一般而言都會以大寫呈現\n\n### `__LINE__` 檔案中的當前行號\n\n```php\necho __LINE__ . PHP_EOL; // 1\necho __LINE__ . PHP_EOL; // 2\necho __LINE__ . PHP_EOL; // 3\n```\n\n### `__FILE__` 檔案的完整路徑和檔名\n\n- 若將其使用在 `include` 中，則返回包含檔案的名稱。\n- `__FILE__`總是包含一個絕對路徑(如果是符號連線，則是解析後的絕對路徑)。\n\n  ```php\n  echo __FILE__ . PHP_EOL; // D:\\phpproject\\php\\newblog\\php-magic-constant.php\n  ```\n\n### `__DIR__` 檔案所在的目錄\n\n- 如果用在被包括檔案中，則返回被包括的檔案所在目錄。\n- 其等同於 `dirname(__FILE__)`。\n- 除非是根目錄，否則目錄中名不包括末尾的斜線。\n\n  ```php\n  echo __DIR__ . PHP_EOL; // D:\\phpproject\\php\\newblog\n  ```\n\n### `__FUNCTION__` 返回該函數被定義時的名字\n\n```php\necho __FUNCTION__ . PHP_EOL; // 函數尚未被定義\n\nfunction testFunction()\n{\n  echo __FUNCTION__ . PHP_EOL; //  testFunction\n}\n\nclass TestClass\n{\n  function testFunctionButInClass()\n  {\n    echo __FUNCTION__ . PHP_EOL; // testFunctionButInClass\n  }\n}\n\ntestFunction();\n$test = new TestClass();\n$test->testFunctionButInClass();\n```\n\n### `__CLASS__` 返回類別名稱\n\n```php\necho __CLASS__ . PHP_EOL; // 類別尚未被宣\n\nfunction testClass()\n{\n    echo __CLASS__ . PHP_EOL; // 類別尚未被宣告\n}\n\ntrait TestClassTrait\n{\n    function testClass2()\n    {\n        echo __CLASS__ . PHP_EOL; // TestClassClass\n    }\n}\n\nclass TestClassClass\n{\n    use TestClassTrait;\n    function testClass1()\n    {\n        echo __CLASS__ . PHP_EOL; // TestClassClass\n    }\n}\n\ntestClass();\n$test = new TestClassClass();\n$test->testClass1();\n$test->testClass2();\n```\n\n### `__TRAIT__` Trait 的名字\n\n```php\necho __TRAIT__ . PHP_EOL; // 什麼也沒有\nfunction testTrait()\n{\n    echo __TRAIT__ . PHP_EOL; // 什麼也沒有\n}\n\ntrait TestTrait\n{\n    function testTrait2()\n    {\n        echo __TRAIT__ . PHP_EOL; // TestTrait\n    }\n}\n\nclass TestTraitClass\n{\n    use TestTrait;\n\n    function testTrait1()\n    {\n        echo __TRAIT__ . PHP_EOL; // 什麼也沒有\n    }\n}\n\ntestTrait();\n$test = new TestTraitClass();\n$test->testTrait1();\n$test->testTrait2();\n```\n\n### `__METHOD__` 類別的方法名稱，返回該方法被定義時的名字\n\n```php\necho __METHOD__ . PHP_EOL; // 尚無方法\n\nfunction testMethod() {\n  echo __METHOD__ . PHP_EOL; // testMethod\n}\n\nclass TestMethodClass\n{\n  function testMethodButinClass() {\n    echo __METHOD__ . PHP_EOL; // TestMethodClass::testMethodButinClass\n  }\n}\n\ntestMethod();\n$test = new TestClassClass();\n$test->testMethodButinClass();\n```\n\n### `__NAMESPACE__` 當前命名空間的名稱\n\n- 此常數是在編譯時定義的\n\n  ```php\n  echo __NAMESPACE__ . PHP_EOL; // test\\magic\\constant\n\n  class TestNameSpaceClass\n  {\n      function testNamespace() {\n          echo __NAMESPACE__ . PHP_EOL; // test\\magic\\constant\n      }\n  }\n\n  $test = new TestNameSpaceClass();\n  $test->testNamespace();\n  ```\n\n## 魔術方法\n\n> 參考資料：\n>\n> [PHP 之十六個魔術方法詳解](https://segmentfault.com/a/1190000007250604)\n\n### `__construct` 類別的構造函數\n\nphp 中構造方法是物件創建完成後，第一個被物件自動呼叫的方法。在每個類別中，都有一個構造方法，如果沒有宣告，那麼類別中會預設存在一個沒有參數且內容為空的構造方法。\n\n1. 作用：通常構造方法被用來執行一些初始化任務，如對成員屬性在創建對象時，賦予初始值\n2. 在類別中的聲明格式：\n\n   ```php\n   function __construct (params) {\n    // code\n    // 通常用來對成員屬性進行初始化賦值\n   }\n   ```\n\n3. 在類別中聲明構造方法需要注意的事項\n\n   1. 在同一個類別中只能宣告一個構造方法\n   2. 必定是以雙底線開始\n\n      ```php\n      class Person\n      {\n        public $name;\n        public $age;\n        public $sex;\n        /**\n         * 顯示宣告一個構造函數且帶參數\n         */\n        public function __construct($name = \"\", $age = 22, $sex = \"man\") {\n          $this->name = $name;\n          $this->sex = $sex;\n          $this->age = $age;\n        }\n        /**\n         * say 方法\n         */\n        public function say()\n        {\n          echo \"我叫：\" . $this->name . \"，性別：\" . $this->sex . \"，年齡：\" . $this->age;\n        }\n      }\n\n      /**\n       * $person1\n       */\n      $person1 = new Person()\n      echo $person1->say(); // 我叫：，性別：男，年齡：27\n      /**\n       * $person2\n       *\n       * @param $name 小明\n       */\n      $person2 = new Person('小明');\n      echo $person2->say(); // 我叫：小明，性別：男，年齡：27\n      /**\n       * $person3\n       *\n       * @param $name 李四\n       * @param $sex 男\n       * @param $age 25\n       */\n      $person3 = new Person('李四', '男', '25')\n      echo $person3->say(); // 我叫：李四，性別：男，年齡：25\n      ```\n\n### `__destruct` 類別的解構函數\n\n允許在銷毀一個類別之前，執行一些操作或完成一些功能，比如關閉文件，釋放結果集等\n\n1. 宣告格式\n\n   ```php\n   function __destruct()\n   {\n     // code\n   }\n   ```\n\n2. 解構函數的作用\n\n   ```php\n   class Person{\n       public $name;\n\n       public $age;\n\n       public $sex;\n\n       public function __construct($name=\"\", $sex=\"男\", $age=22)\n       {\n           $this->name = $name;\n           $this->sex  = $sex;\n           $this->age  = $age;\n       }\n\n       /**\n        * say\n        */\n       public function say()\n       {\n           echo \"我叫：\".$this->name.\"，性別：\".$this->sex.\"，年齡：\".$this->age;\n       }\n\n       /**\n        * 宣告一個解構函數\n        */\n       public function __destruct()\n       {\n           echo \"我覺得我還可以搶救一下，我的名字叫\".$this->name;\n       }\n   }\n\n   $Person = new Person(\"小明\");\n   unset($Person); // 銷毀上面建立的物件\n   ```\n\n### `__call` 在物件中呼叫一個不可訪問的方法時，呼叫此方法\n\n此方法接受兩參數，`$function_name` 會自動接收不存在的方法名，`$arguments` 則以陣列的方式接收不存在方法的多個參數。\n\n1. 宣告此方法的格式\n\n   ```php\n   function __call(string $function_name, array $arguments){\n     // code\n   }\n   ```\n\n2. 此方法的作用：為避免當呼叫的方法不存在而產生錯誤，導致意外的程序中止，可以使用 `__call()` 方法來避免。剛方法在呼叫的方法不存在時，會自動呼叫，程式仍會繼續執行下去。\n\n   ```php\n   class Person\n   {\n       function say()\n       {\n              echo \"Hello, world!<br>\";\n       }\n\n       /**\n        * 宣告此方法用來處理，當呼叫了此物件中不存在的方法\n        */\n       function __call($funName, $arguments)\n       {\n             echo \"你所呼叫的函數：\" . $funName . \"(參數：\" ;  // 輸出呼叫的不存在方法名稱\n             print_r($arguments); // 輸出呼叫不存在方法的參數列表\n             echo \")不存在！<br>\\n\"; // 結束換行\n       }\n   }\n\n   $Person = new Person();\n   $Person->run(\"teacher\"); // 呼叫物件中不存在的方法，此時會自動呼叫物件中的 __call() 方法\n   $Person->eat(\"小明\", \"蘋果\");\n   $Person->say();\n   ```\n\n   輸出\n\n   ```php\n   你所呼叫的函數：run(參數：Array ( [0] => teacher ) )不存在！\n\n   你所呼叫的函數：eat(參數：Array ( [0] => 小明 [1] => 蘋果 ) )不存在！\n\n   Hello, world!\n   ```\n\n### `__callStatic` 用靜態方式呼叫一個不可訪問的方法時，呼叫此方法\n\n```php\n<?php\nclass Person\n{\n    function say()\n    {\n        echo \"Hello, world!<br>\";\n    }\n\n    /**\n     * 宣告此方法用來處理當靜態呼叫了不存在的方法時\n     */\n    public static function __callStatic($funName, $arguments)\n    {\n        echo \"你所呼叫的靜態方法：\" . $funName . \"(參數：\" ;  // 輸出呼叫不存在的方法名稱\n        print_r($arguments); // 輸出呼叫不存在方法時傳入的參數\n        echo \")不存在！<br>\\n\"; // 結束換行\n    }\n}\n\n$Person = new Person();\n$Person::run(\"teacher\"); // 用於呼叫物件中不存在的靜態方法時，會自動呼叫物件中的__callStatic()方法\n$Person::eat(\"小明\", \"蘋果\");\n$Person->say();\n```\n\n### `__get` 獲取一個類別的成員變數時呼叫\n\n在 php 物件導向中，若類別成員被設定為 private 時，若我們在外面呼叫他則會出現\"無法訪問某個私有屬性\"的錯誤。\n\n- 此方法的作用：在程式運行中，透過他可以在物件外面獲取私有屬性成員的值\n\n  ```php\n  class Person\n  {\n      private $name;\n      private $age;\n\n      function __construct($name=\"\", $age=1)\n      {\n          $this->name = $name;\n          $this->age = $age;\n      }\n\n      /**\n       * 在類別中添加__get()方法，在直接獲取屬性時，自動呼叫一次，以屬性名作為參數傳入並處理\n       * @param $propertyName\n       *\n       * @return int\n       */\n      public function __get($propertyName)\n      {\n          if ($propertyName == \"age\") {\n              if ($this->age > 30) {\n                  return $this->age - 10;\n              } else {\n                  return $this->$propertyName;\n              }\n          } else {\n              return $this->$propertyName;\n          }\n      }\n  }\n\n  $Person = new Person(\"小明\", 60);   // 透過將 Persian 類別實例化的物件，並透過建構函示為屬性添加預設值\n  echo \"姓名：\" . $Person->name . \"<br>\";   // 直接呼叫私有屬性 $name，自動呼叫了__get()方法可以間接獲取\n  echo \"年齡：\" . $Person->age . \"<br>\";    // 自動呼叫 __get()方法，根據物件本身的情況會返回不同的值\n  ```\n\n  ```php\n  姓名：小明\n  年齡：50\n  ```\n\n### `__set` 設置一個類別的成員變數時呼叫\n\n- 作用：設置私有屬性，給一個未定義的屬性賦值，此方法會被觸發，傳入的參數是被設置的屬性名和值\n\n  ```php\n  class Person\n  {\n      private $name;\n\n      private $age;\n\n      public function __construct($name=\"\",  $age=25)\n      {\n          $this->name = $name;\n          $this->age  = $age;\n      }\n\n      /**\n       * 宣告此方法需兩個參數，直接為私有屬性賦值時自動呼叫，並可以排除非法賦值\n       *\n       * @param $property\n       * @param $value\n       */\n      public function __set($property, $value) {\n          if ($property==\"age\")\n          {\n              if ($value > 150 || $value < 0) {\n                  return;\n              }\n          }\n          $this->$property = $value;\n      }\n\n      /**\n       * 在類別中宣告 say()，將所有的私有屬性輸出\n       */\n      public function say(){\n          echo \"我叫\".$this->name.\"，今年\".$this->age.\"歲了\";\n      }\n  }\n\n  $Person= new Person(\"小明\", 25); // 注意，初始值將被下面所更改\n  // 自動呼叫 __set()，將屬性名稱 name 傳遞給第一個參數，將屬性值\"小紅\"傳遞給第二參數\n  $Person->name = \"小紅\";     // 賦值成功。若沒有 __set() 則會噴錯。\n  // 自動呼叫 __set() ，將屬性名稱 age 傳給第一個參數，將屬性值 16 傳給第二個參數\n  $Person->age = 16; //賦值成功\n  $Person->age = 160; //160是一个非法值，賦值失效\n  $Person->say();  //輸出：我叫小紅，今年 16 歲了\n  ```\n\n### `__isset()` 當私有屬性呼叫 isset() 或 empty() 時呼叫此方法\n\n## 方法\n\n### `in_array()` 檢查陣列中是否包含特定的數值\n\n- `bool in_array(mixed $needle, array $haystack, bool $strict = false)`\n  - `$needle` 要查找的值\n  - `$haystack` 要檢查的陣列\n  - `#strict` 可選，若為 `true`，則不僅檢查直是否相等，還要檢查型別是否相等。預設為 `false`\n\n```php\n$fruits = [\"apple\", \"banana\", \"cherry\", \"date\"];\n\n// 使用 in_array 檢查陣列中是否包含 \"cherry\"，不考慮數值型別\nif (in_array(\"cherry\", $fruits)) {\n    echo \"陣列中包含 'cherry'。\";\n} else {\n    echo \"陣列中不包含 'cherry'。\";\n}\n\n// 使用 in_array 檢查陣列中是否包含 2，考慮數值數值型別\nif (in_array(2, $fruits, true)) {\n    echo \"陣列中包含 2（考慮數值數值型別）\";\n} else {\n    echo \"陣列中不包含 2（考慮數值數值型別）\";\n}\n\n```\n\n### `foreach`\n\n- `foreach()` 尋訪陣列\n\n  ```php\n  foreach ($array as $value) {\n    // 每次尋訪會將陣列的值存到value中，直到陣列結束\n  }\n  foreach ($array as $key => $value) {\n   // 每次尋訪會將陣列的值以及key，存到value中  key => 流水號\n  }\n  ```\n\n- `continue` 跳出本次循環，繼續執行下向執行\n\n- `array_key_first()` 取得陣列中第一個 key 值\n- `array_key_last()` 取得陣列中最後一個 key 值\n\n  ```php\n  $array  = array(\"dog\", \"rabbit\", \"horse\", \"rat\", \"cat\");\n  foreach($array as $index => $animal) {\n      if ($index === array_key_first($array))\n          echo $animal; // output: dog\n      if ($index === array_key_last($array))\n          echo $animal; // output: cat\n  }\n  ```\n\n- `break` 跳出迴圈\n\n  ```php\n  <?php\n  foreach (array('1','2','3') as $first) {\n      echo \"$first \";\n      foreach (array('3','2','1') as $second) {\n          echo \"$second \";\n          if ($first == $second) {\n              break;  // this will break both foreach loops\n          }\n      }\n      echo \". \";  // never reached!\n  }\n  echo \"Loop Ended\";\n  ?>\n  ```\n\n- 輸出\n\n  ```php\n  1 3 2 1 . 2 3 2 . 3 3 . Loop Ended\n  ```\n\n### `scandir` 掃描指定的目錄，並返回為陣列\n\n- `scandir()` 掃描指定的目錄，並返回為陣列\n\n### `list` 宣告陣列中的值，使其成為變數\n\n- `list(var1, var2...)` 宣告陣列中的值，使其成為變數\n\n  ```php\n  $my_array = array('dog', 'cat', 'horse');\n  list($a, $b, $c) = $my_array;\n  echo \"i have several animals, a $a, a $b, a $c. \";\n  // i have several animals, a dog, a cat and a horse.\n  ```\n\n### `append` 將傳入的值附加進陣列\n\n- `append(var1, var2)`\n\n  ```php\n  // PHP function to illustrate the\n  // append() method\n  $arrObj = new ArrayObject(array('Geeks', 'for', 'Geeks'));\n  // Appending an array\n  $arrObj->append(array('welcomes', 'you'));\n  var_dump($arrObj);\n  ```\n\n- 輸出\n\n  ```php\n  object(ArrayObject)#1 (1) {\n    [\"storage\":\"ArrayObject\":private]=>\n    array(4) {\n      [0]=>\n      string(5) \"Geeks\"\n      [1]=>\n      string(3) \"for\"\n      [2]=>\n      string(5) \"Geeks\"\n      [3]=>\n      array(2) {\n        [0]=>\n        string(8) \"welcomes\"\n        [1]=>\n        string(3) \"you\"\n      }\n    }\n  }\n  ```\n\n### 在陣列中新增元素\n\n#### 直接賦值\n\n```php\n$array[] = $array;\n```\n\n```php\n$flower = array();\necho(\"The array is empty, as you can see. \\n\");\nprint_r($flowers);\necho(\"Now, we have added the values. \\n\");\n$flowers[] = \"Rose\";\n$flowers[] = \"Jasmine\";\n$flowers[] = \"Lili\";\n$flowers[] = \"Hibiscus\";\n$flowers[] = \"Tulip\";\nprint_r($flowers);\n```\n\n```php\nThe array is empty, as you can see.\nArray\n(\n)\nNow, we have added the values.\nArray\n(\n    [0] => Rose\n    [1] => Jasmine\n    [2] => Lili\n    [3] => Hibiscus\n    [4] => Tulip\n)\n```\n\n#### `array_push` 在陣列最後新增元素\n\n- `array_push($array, $value1, $value2, ..., $valueN);`\n- `$array` 必須，目標新增元素的陣列\n- `$value1`, `$value2` 必須，欲新增至陣列的元素，可以為字串、整數、浮點數等\n\n  ```php\n  $flowers = array();\n  echo(\"The array is empty, as you can see. \\n\");\n  print_r($flowers);\n  echo(\"Now, we have added the values. \\n\");\n  array_push($flowers, \"Rose\", \"Jasmine\", \"Lili\", \"Hibiscus\", \"Tulip\");\n  print_r($flowers);\n  ```\n\n  ```php\n  The array is empty, as you can see.\n  Array\n  (\n  )\n  Now, we have added the values.\n  Array\n  (\n      [0] => Rose\n      [1] => Jasmine\n      [2] => Lili\n      [3] => Hibiscus\n      [4] => Tulip\n  )\n  ```\n\n#### `array_unshift` 在陣列前端插入\n\n- `array_unshift($array, $value1, $value2, ..., $valueN)`\n- `$array` 必須，目標新增元素的陣列\n- `$value1`, `$value2` 必須，欲新增至陣列的元素，可以為字串、整數、浮點數等\n\n  ```php\n  $flowers = ['first', 'second'];\n  print_r($flowers);\n  echo(\"Now we have added the values. \\n\");\n  echo(array_unshift($flowers, \"Rose\", \"Jasmine\", \"Lili\", \"Hibiscus\", \"Tulip\"));\n  echo(\"\\n\");\n  print_r($flowers);\n  ```\n\n  ```php\n  Array\n  (\n    [0] => first\n    [1] => second\n  )\n  Now we have added the values.\n  7\n  Array\n  (\n    [0] => Rose\n    [1] => Jasmine\n    [2] => Lili\n    [3] => Hibiscus\n    [4] => Tulip\n    [5] => first\n    [6] => second\n  )\n  ```\n\n### `array_fill` 以填充數值的方式，建立新陣列\n\n- `array_fill(int $start_index, int $count, mixed $value): array` 將傳入的`$value`，加入`$count` 個值到陣列，開始的 key 值由`$start_index` 指定\n\n- `$start_index` 回傳陣列的第一個 key 值，如為負數，返回的第一個 key 將會是 start_index 的值，而後面的 key 值由 0 開始。\n\n- `$count` 插入值的數量，需大於等於 0 ，否則拋出 E_WARNING。\n\n- `$value` 傳入陣列的值。\n\n  ```php\n  $a = array_fill(5, 6, 'banana');\n  $b = array_fill(-2, 4, 'pear');\n  print_r($a);\n  print_r($b);\n  ```\n\n  ```php\n  Array\n  (\n    [5]  => banana\n    [6]  => banana\n    [7]  => banana\n    [8]  => banana\n    [9]  => banana\n    [10] => banana\n  )\n  Array\n  (\n    [-2] => pear\n    [0] => pear\n    [1] => pear\n    [2] => pear\n  )\n  ```\n\n### `array_combine` 將傳入的參數合併為陣列\n\n- `array_combine(array $keys, array $values): array` `$key`為 key 值，`$value` 為相對應的值。\n\n  ```php\n  $a = array('green', 'red', 'yellow');\n  $b = array('avocado', 'apple', 'banana');\n  $c = array_combine($a, $b);\n  print_r($c);\n  ```\n\n  ```PHP\n  Array\n  (\n    [green]  => avocado\n    [red]    => apple\n    [yellow] => banana\n  )\n  ```\n\n### `array_unique` 從陣列中刪除重複的值\n\n- `array_unique($array, $flags)`\n\n- `$array` 要刪除重複值的陣列\n- `$flags` 指定陣列的排序模式，有五種型別\n- `SORT_REGULAR` 正常常比較元素\n- `SORT_NUMERIC` 以數字方式比較元素\n- `SORT_STRING` 以字串方式比較元素\n- `SORT_LOCALE_STRING` 基於當前的語言環境，以字串方式比較元素。\n\n### `array_diff` 判斷陣列之間差異\n\n- `array_diff( $array1 , $array2 , $array3 , ... ):array` 後面每個陣列都跟第一個陣列做比較，此方法會回傳在第一陣列中有出現，但未出現在其他陣中的值，並會保留鍵名\n\n  ```php\n  $array1 = array('A','B','C','D');\n  $array2 = array('C','D','E','F');\n  $array3 = array('A','B','E','F');\n  $newArray1 = array_diff($array1,$array2);\n  print_r($newArray1);\n  $newArray2 = array_diff($array1,$array3);\n  print_r($newArray2);\n  ```\n\n  ```PHP\n  Array\n  (\n    [0] => A,\n    [1] => B\n  )\n  Array\n  (\n    [2] => C,\n    [3] => D\n  )\n  ```\n\n- 進階用法\n\n藉由其查詢兩個以上陣列之間的差異，並返回不存在陣列中的值之特性。\n\n因此可用來刪除陣列中多個值，而不影響其索引值。\n\n```php\n//Declare the array\n$flowers = [\n  \"Rose\",\n  \"Lili\",\n  \"Jasmine\",\n  \"Hibiscus\",\n  \"Tulip\",\n  \"Sun Flower\",\n  \"Daffodil\",\n  \"Daisy\"\n];\n\n$flowers = array_diff($flowers, array(\"Rose\",\"Lili\"));\necho \"The array is:\\n\";\nprint_r($flowers);\n```\n\n```php\nArray\n(\n[2] => Jasmine\n[3] => Hibiscus\n[4] => Tulip\n[5] => Sun Flower\n[6] => Daffodil\n[7] => Daisy\n)\n```\n\n### `array_slice` 從陣列中取得一段連續的元素\n\n此方法會返回一個新的陣列，包含從原陣列取得的元素，而原始陣列不會被修改。\n\n- `array_slice(array $array, int $offset, int $length = null, bool $preserve_keys = false);`\n  - `$array` 目標的陣列\n  - `$offset` 從陣列的哪一個位置開始取得元素\n  - `$length` 可選參數，指定取得的元素個數，若未設置，則從 $offset 開始擷取到陣列最後的所有元素。\n  - `$preserve_keys` 可選參數，若為 `true`，則保留原始陣列的 key 值，預設為 `false`\n\n```php\n$fruits = ['apple', 'banana', 'cherry', 'date','fig'];\n\n// 擷取陣列前三個元素\n$slice1 = array_slice($fruits, 0, 3);\nprint_r($slice1); // 输出：['apple', 'banana', 'cherry']\n\n// 擷取陣列的後兩個元素\n$slice2 = array_slice($fruits, -2);\nprint_r($slice2); // 输出：['date', 'fig']\n```\n\n### 日期/時間\n\n#### `date` 格式化 Unix timestamps\n\n- `date(string $format, ?int $timestamp = null)`\n\n- `$format` 指定的格式\n  - `Y` 年份，四位數\n  - `y` 年份二位數\n  - `F` 月份英文全名；如 'March'\n  - `M` 月份英文縮寫；如 'Mar'\n  - `m` 月份數字，不足二位前面補 0\n  - `n` 月份數字\n  - `D` 星期英文縮寫；如：'Fri'\n  - `l` 星期英文全稱；如：'Friday'\n  - `w` 星期數字\n  - `d` 幾日數字，不足二位前面補 0\n  - `j` 幾日數字\n  - `H` 24 小時制，不足二位前面補 0\n  - `h` 12 小時制，不足二位前面補 0\n  - `G` 24 小時制\n  - `g` 12 小時制\n  - `i` 分鐘\n  - `A` Am 或 Pm\n  - `a` am 或 pm\n  - `s` 秒\n  - `U` 總秒數\n  - `t` 指定月份的天數；如\"28\", \"31\"\n  - `z` 一年中的第幾天\n- `$timestamp` 時間戳(可選)\n\n#### `mktime` 取得指定日期的時間戳\n\n- `mktime($hour, $minute = null, $second = null, $month = null, $day = null, $year = null)`\n- 任何省略的變數，將依據本地時間設置\n\n#### `date_diff` 獲取以分鐘為單位的時間差\n\n- `date_diff($StartDateTimeObject, $EndDateTimeObject)`\n  - `$StartDateTimeObject1` 必須，為一個 DataTime 物件，表示開始日期。\n  - `$EndDateTimeObject1` 必須，為一個 DataTime 物件，表示結束日期。\n  - 若失敗返回 false\n\n```php\n$date_time_start = date_create('2019-06-19')\n$date_time_end = date_create('2020-06-19')\n\n$difference = date_diff($date_time_start, $date_time_end);\n```\n\n### `sort` 陣列排序\n\n#### 依 value 排序\n\n- 由小到大排序值\n- `sort` 刪除 key\n- `asort` 保留 key\n- 由大到小排序值\n- `rsort` 刪除 key\n- `arsort` 保留 key\n\n#### 依 key 排序\n\n- `ksort` 由小到大排索引值\n- `krsort` 由大到小排索引值\n\n#### 自訂排序\n\n加上一個前綴 `u` 在相對應的方法\n\n- 範例一：\n  今天有一個陣列如下\n\n  ```php\n  $unsorted = [\n      ['name'   => 'good',\n       'sorter' => '1',],\n\n      ['name'   => 'bad',\n       'sorter' => '3',],\n\n      ['name'   => 'normal',\n       'sorter' => '2',],\n  ];\n  ```\n\n  我要透過 sorter 這個 key 的 value 來做排序\n\n  ```php\n  usort($unsorted, function ($a, $b) {\n      return $a['sorter'] > $b['sorter'];\n      // 如果 a > b 的話 就會輸出 1，而因為 usort 的 根基是 sort\n      // 意即是照 value 由小到大排序，所以輸出 1 的就會往後排，進而達到目的\n  });\n  ```\n\n  ```php\n  array(3) {\n   [0]=>\n   array(2) {\n     [\"name\"]=>\n     string(4) \"good\"\n     [\"sorter\"]=>\n     string(1) \"1\"\n   }\n   [1]=>\n   array(2) {\n     [\"name\"]=>\n     string(6) \"normal\"\n     [\"sorter\"]=>\n     string(1) \"2\"\n   }\n   [2]=>\n   array(2) {\n     [\"name\"]=>\n     string(3) \"bad\"\n     [\"sorter\"]=>\n     string(1) \"3\"\n   }\n  }\n  ```\n\n- 範例二：\n\n  如果一樣的陣列，但要用來比對的數值是重複的\n\n  ```php\n  $unsorted = [\n      ['name'   => 'good', 'sorter' => '1',],\n      ['name'   => 'bad', 'sorter' => '3',],\n      ['name'   => 'normal', 'sorter' => '3',],\n  ];\n  ```\n\n  可以增加一個比對條件\n\n  ```php\n  $unsorted = [\n      [\n        'name'   => 'good',\n        'sorter' => '1',\n        'newSorter'=> '2'\n      ],\n      [\n        'name'   => 'bad',\n        'sorter' => '3',\n        'newSorter'=> '3'\n      ],\n      [\n        'name'   => 'normal',\n        'sorter' => '3',\n        'newSorter' => '1'\n      ],\n      [\n        'name'   => 'hahaha',\n        'sorter' => '2',\n        'newSorter' => '1'\n      ],\n  ];\n  ```\n\n  依照 sorter 來進行排序，但如果 sorter 數值相同，則使用 newSorter 來進行排序\n\n  ```php\n  usort($unsorted, function ($a, $b)) {\n      return $a['sorter'] > $b['sorter'] || ($a['sorter'] == $b['sorter'] && $a['newSorter'] > $b['newSorter']);\n  }\n\n  // 或這樣寫\n  if ($a['sorter'] > $b['sorter'] || ($a['sorter'] == $b['sorter'] && $a['newSorter'] > $b['newSorter'])) {\n      return 1;\n  } elseif ($a['sorter'] < $b['sorter']) {\n      return -1;\n  } else {\n      return 0;\n  }\n  ```\n\n  ```php\n  array(4) {\n    [0]=>\n    array(3) {\n      [\"name\"]=>\n      string(4) \"good\"\n      [\"sorter\"]=>\n      string(1) \"1\"\n      [\"newSorter\"]=>\n      string(1) \"2\"\n    }\n    [1]=>\n    array(3) {\n      [\"name\"]=>\n      string(6) \"hahaha\"\n      [\"sorter\"]=>\n      string(1) \"2\"\n      [\"newSorter\"]=>\n      string(1) \"1\"\n    }\n    [2]=>\n    array(3) {\n      [\"name\"]=>\n      string(6) \"normal\"\n      [\"sorter\"]=>\n      string(1) \"3\"\n      [\"newSorter\"]=>\n      string(1) \"1\"\n    }\n    [3]=>\n    array(3) {\n      [\"name\"]=>\n      string(3) \"bad\"\n      [\"sorter\"]=>\n      string(1) \"3\"\n      [\"newSorter\"]=>\n      string(1) \"3\"\n    }\n  }\n  ```\n\n### 分割字串\n\n#### `explode`\n\n- `explode( string $delimiter , string $string , int $limit )`\n\n- `$delimiter` - 字串的切割部位，請自行設定，字串形態，必填\n- `$string` - 被要處理的字串，字串形態，必填項目。\n- `$limit` - 設定字串切割後最多可輸出的數量，數字形態，可為正整數或負整數，如果填寫正整數，最後的的部份包含切割完剩下的所有部份，，如果填寫負整數，則倒數的部份若在負整數範圍 內將不會顯示，非必填項目\n\n  ```php\n  <?php\n    $str = 'Apple Dog Pig';\n    $str_sec = explode(\" \",$str);\n    print_r($str_sec);\n  ```\n\n  ```php\n  Array (\n  　[0] => Apple\n  　[1] => Dog\n  　[2] => Pig\n  )\n  ```\n\n- 加入`$limit` 參數\n\n  ```php\n  <?php\n    $str = 'Apple Dog Pig';\n    $str_sec_A = explode(\" \",$str,2);\n    $str_sec_B = explode(\" \",$str,-1);\n    print_r($str_sec_A);\n    print_r($str_sec_B);\n  ```\n\n  ```php\n  Array (\n  　[0] => Apple\n  　[1] => Dog Pig\n  )\n  Array (\n  　[0] => Apple\n  　[1] => Dog\n  )\n  ```\n\n#### `str_split`\n\n- `str_split($string, $length)`\n\n- `string` 必需。規定要分割的字符串。\n- `length` 可選。規定每個數組元素的長度。默認是 1。\n\n  ```php\n  <?php\n    $NewString = \"M'L2\";\n    $Arr2=str_split($NewString,3);//根據每三個字元切割\n    print_r($Arr2);\n  ```\n\n  ```php\n  Array(\n      [0] => \"M'L\"\n      [1] => 2\n  )\n  ```\n\n#### preg_split\n\n- `preg_split ( string $pattern , string $subject , int $limit , int $flags )`\n\n- `pattern` 用於搜索的模式，字串形式\n- `subject` 輸入字串\n- `limit` 可選，用來設定分割後的單位總數量，預設值為 -1\n- `flags` 可選\n  - `PREG_SPLIT_NO_EMPTY`只返回非空白部分\n  - `PREG_SPLIT_DELIM_CAPTURE`和字串中的正規表達式一起返回\n  - `PREG_SPLIT_OFFSET_CAPTURE`將每個返回增加字串的偏移量\n\n```php\n//根據空格切開\n$NewString1 = preg_split(\"/[\\s,]+/\", \"Welcome to Wibibi.Have a good day.\");\nprint_r($NewString1);\n\necho '<br>';\n\n//把每個英文字母切開\n$NewString2 = 'Welcome';\n$NewString2 = preg_split('//', $NewString2, -1, PREG_SPLIT_NO_EMPTY);\nprint_r($NewString2);\n```\n\n### `array_slice` 從陣列中取出想要的元素\n\n- `array_slice($array, $start, $length, $preserve)`\n\n- `array` 必填，傳入陣列。\n- `start` 必填，規定取出元素的開始位置，0 = 第一個元素，若傳入正數，則由前往後取值，若為負值由後往前取值。\n- `length` 選填，規定返回的陣列長度。\n- `preserve` 選填，`true` 保留 key 值，`false` 重置 key 值。\n\n  ```php\n  <?php\n  $a=array(\"red\",\"green\",\"blue\",\"yellow\",\"brown\");\n  print_r(array_slice($a,2));\n  ```\n\n  ```php\n  Array\n  (\n      [0] => blue\n      [1] => yellow\n      [2] => brown\n  )\n  ```\n\n### `implode` 將陣列轉為字串\n\n- `implode($separator, $array)`\n\n- `separator` 可選。規定數組元素之間放置的內容。默認是 \"\"（空字符串）。\n- `array` 必需。要結合為字符串的數組。\n\n  ```php\n  $arr = [1,2,3,4,5,6];\n  print_r(implode('=', $arr));\n  ```\n\n  ```php\n  \"1=2=3=4=5=6\"\n  ```\n\n### `array_filter` 過濾陣列元素(刪除陣列空值)\n\n- `array_filter($arrayName, $callbackFunction, $callbackParameter)`\n\n  - `$arrayName` 必須，目標陣列\n  - `$callbackFunction` 可選，指定刪除的參數，預設刪除陣列中等於 false 的值\n  - `$callbackParameter` 可選，引用傳遞給回傳函數的參數\n\n    - `ARRAY_FILTER_USE_KEY` 將 key 作為唯一參數傳遞給回調函數，而不是數組的值\n    - `ARRAY_FILTER_USE_BOTH` 將值和鍵都作為參數而不是值傳遞給回調\n\n      ```php\n      // PHP function to check for even elements in an array\n      function Even($array)\n      {\n          // returns if the input integer is even\n          if($array%2==0)\n             return TRUE;\n          else\n             return FALSE;\n      }\n      $array = array(12, 0, 0, 18, 27, 0, 46);\n      print_r(array_filter($array, \"Even\"));\n      ```\n\n      ```php\n        Array (\n            [0] => 12\n            [1] => 0\n            [2] => 0\n            [3] => 18\n            [5] => 0\n            [6] => 46\n        )\n      ```\n\n### `str_pad` 填充字串為指定長度\n\n- `str_pad($string, $length, $pad_string, $pad_type)`\n\n- string 必填，要填充的字串。\n- length 必填，規定新字串的長度，若小於傳入的字串長度，則不進行操作。\n- pad_string 可選，提供填充的字串，預設為空白。\n- pad_type 可選，字串填充的方向。\n\n  - STR_PAD_BOTH 填充字串的兩側，若不為偶數，則將額外的字串填充至右側。\n  - STR_PAD_LEFT 填充到字串的左側。\n  - STR_PAD_RIGHT 填充到字串的右側(預設)。\n\n    ```php\n    $str = \"Hello world\";\n    echo str_pad($str, 20, \".\", STR_PAD_LEFT);\n    ```\n\n    ```php\n    .........Hello World\n    ```\n\n    ```php\n    $str = \"Hello world\";\n    echo str_pad($str, 20, \".:\", STR_PAD_BOTH);\n    ```\n\n    ```php\n    .:.:Hello World.:.:.\n    ```\n\n### 資料序列化及反序列化\n\n#### `string serialize` 序列化\n\n- `string serialize( mixed $value )`\n\n- $value: 要序列化的對象或陣列\n\n  ```php\n  $sites = array('Google', 'Runoob', 'Facebook');\n  $serialized_data = serialize($sites);\n  echo  $serialized_data . PHP_EOL;\n  ```\n\n  ```php\n  a:3:{i:0;s:6:\"Google\";i:1;s:6:\"Runoob\";i:2;s:8:\"Facebook\";}\n  ```\n\n#### `mixed unserialize` 反序列化\n\n- `mixed unserialize( string $str )`\n\n- $str: 序列化後的字串\n\n  ```php\n  $str = 'a:3:{i:0;s:6:\"Google\";i:1;s:6:\"Runoob\";i:2;s:8:\"Facebook\";}';\n  $unserialized_data = unserialize($str);\n  print_r($unserialized_data);\n  ```\n\n  ```php\n  Array\n  (\n      [0] => Google\n      [1] => Runoob\n      [2] => Facebook\n  )\n  ```\n\n### `file_get_contents` 將本地文件存入一個變數中\n\n- `file_get_contents($path, $include_path, $context, $start, $max_length)`\n\n- path (必須) 文件的路徑\n- include_path (可選) 如果也想在 include_path 中搜尋文件，可以將該參數設為\"1\"\n- context (可選) 規定文件控制代碼的環境\n- start (可選) 指定在文件中開始讀取的位置。\n- max_length (可選) 規定讀取的位元組。\n\n### `str_pad` 補足字串\n\n- `str_pad($str, $pad_length , $pad_string, $pad_type)`\n\n- `$str` 來源字串\n- `$pad_length` 補完後字串長度\n- `$pad_string` 補入的字元\n- `$pad_type` 補入的規則\n\n  - `STR_PAD_BOTH` 左右都補\n  - `STR_PAD_LEFT` 從左邊開始\n  - `STR_PAD_RIGHT` 從右邊開始\n\n  把 id 由左邊開始補 0，補到五位數\n\n  ```php\n  $id=01;\n  $id=str_pad($id,5,\"0\",STR_PAD_LEFT);\n  echo $id;\n  //00001\n  ```\n\n### `str_replace` 替換字串\n\n### 將字串轉換為數值\n\n> 若字串開頭為 0，轉為數值後開頭的 0 會被省略\n\n- `number_format()` 若失敗則返回`E_WARNING`\n\n- 使用類型轉換\n\n  ```php\n  $num = \"1000.314\";\n  echo (int)$num\n  ```\n\n- 透過運算子將字串轉為數值，例如在字串中 + 0\n\n### `is_a` 檢查物件是該類別，或該類別是此物件的父類別(boolean)\n\n- `is_a( object $object , string $class_name )`\n\n- 此函數在 php 5 之後已廢棄，改用 `instanceof` 型態運算子\n\n### `substr` 取得部分字串，可設定字串長度\n\n- `substr( $string , $start , $length )`\n\n- $string 原始的字串\n- $start 要開始擷取的位置(須為數字，可為正數或負數)\n- $length 要擷取的字串長度(須為數字，可為正數或負數)\n\n```php\necho substr(\"abcde\", -1);       // 輸出 e，因為從字尾開始算一個字母。\necho substr(\"abcde\", -2);       // 輸出 de，因為從字尾開始算，共取兩個字母。\n\necho substr(\"abcd\", -3, 1);     // 輸出 b，因為從字尾開始算，先取三個字母為 bcd，接著長度在從 bcd 取 1 位。\necho substr(\"abcdef\", 0, -1);   // 輸出 abcde，因為程式先從零開始取整段字串，長度再由字串尾扣掉一個。\necho substr(\"abcdef\", 2, -1);   // 輸出 cde，因為程式先從第二個字元開始，取得 cdef 這幾個字，再由取得的字串尾扣掉一個。\necho substr(\"abcdef\", 5, -2);   // 回傳 false，因為程式一開始先取得 f，然後扣掉五個字元，就什麼都沒有囉！\necho substr(\"abcdef\", -4, -2);  // 輸出 cd，因為程式先取得 cdef 這四個字元，再從其中的字尾開始扣掉兩個字元。\n```\n\n### 轉換字母大小寫\n\n#### `ucfirst` 將字串的首字母轉為大寫\n\n```php\n$foo = 'hello world!';\n$foo = ucfirst($foo);             // Hello world!\n```\n\n#### `strtolower` 將字串換為小寫\n\n```php\n$str = \"Mary Had A Little Lamb and She LOVED It So\";\n$str = strtolower($str);\n// mary had a little lamb and she loved it so\n```\n\n#### `strtoupper` 將字串換為大寫\n\n```php\n$str = \"Mary Had A Little Lamb and She LOVED It So\";\n$str = strtoupper($str);\n//  MARY HAD A LITTLE LAMB AND SHE LOVED IT SO\n```\n\n### `define` 定義一個常數\n\n- `define(name,value,case_insensitive)`\n\n- name 必須，規定常數的名稱。通常為全大寫 + 下划線。\n- value 必須，規定常數的值。\n- case_insensitive 必須，規定常數是否大小寫敏感，預設為 false : 大小寫敏感。\n\n- 常數類似變數，但常數在設定之後，其值無法改變，常數名不用 `$` 開頭，作用域不影響對常數的存取，其值只能是字串或數值\n\n## 在 Linux 執行 php 檔\n\n### 方法一\n\n- 在程式的第一行加入路徑 -q\n\n  ```php\n  #! /usr/bin/php -q\n  $foo = 123;\n  ```\n\n- 將 php 檔賦予執行權限\n\n  ```bash\n  chmod +x testing.php\n  ```\n\n- d/n\n\n  ```bash\n  ./testing.php # 可以像其他 shell script 般執行\n  ```\n","tocContent":"- [PHP 學習筆記](#php-%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98)\n  - [運算子、判斷](#%E9%81%8B%E7%AE%97%E5%AD%90%E5%88%A4%E6%96%B7)\n    - [isset、!!、empty 差異比較](#issetempty-%E5%B7%AE%E7%95%B0%E6%AF%94%E8%BC%83)\n      - [差異比較](#%E5%B7%AE%E7%95%B0%E6%AF%94%E8%BC%83)\n      - [範例對照](#%E7%AF%84%E4%BE%8B%E5%B0%8D%E7%85%A7)\n      - [總結](#%E7%B8%BD%E7%B5%90)\n      - [常見坑與誤區](#%E5%B8%B8%E8%A6%8B%E5%9D%91%E8%88%87%E8%AA%A4%E5%8D%80)\n      - [實務建議](#%E5%AF%A6%E5%8B%99%E5%BB%BA%E8%AD%B0)\n      - [總結](#%E7%B8%BD%E7%B5%90)\n  - [Autoload 自動載入](#autoload-%E8%87%AA%E5%8B%95%E8%BC%89%E5%85%A5)\n  - [魔術常數](#%E9%AD%94%E8%A1%93%E5%B8%B8%E6%95%B8)\n    - [**LINE** 檔案中的當前行號](#__line__-%E6%AA%94%E6%A1%88%E4%B8%AD%E7%9A%84%E7%95%B6%E5%89%8D%E8%A1%8C%E8%99%9F)\n    - [**FILE** 檔案的完整路徑和檔名](#__file__-%E6%AA%94%E6%A1%88%E7%9A%84%E5%AE%8C%E6%95%B4%E8%B7%AF%E5%BE%91%E5%92%8C%E6%AA%94%E5%90%8D)\n    - [**DIR** 檔案所在的目錄](#__dir__-%E6%AA%94%E6%A1%88%E6%89%80%E5%9C%A8%E7%9A%84%E7%9B%AE%E9%8C%84)\n    - [**FUNCTION** 返回該函數被定義時的名字](#__function__-%E8%BF%94%E5%9B%9E%E8%A9%B2%E5%87%BD%E6%95%B8%E8%A2%AB%E5%AE%9A%E7%BE%A9%E6%99%82%E7%9A%84%E5%90%8D%E5%AD%97)\n    - [**CLASS** 返回類別名稱](#__class__-%E8%BF%94%E5%9B%9E%E9%A1%9E%E5%88%A5%E5%90%8D%E7%A8%B1)\n    - [**TRAIT** Trait 的名字](#__trait__-trait-%E7%9A%84%E5%90%8D%E5%AD%97)\n    - [**METHOD** 類別的方法名稱，返回該方法被定義時的名字](#__method__-%E9%A1%9E%E5%88%A5%E7%9A%84%E6%96%B9%E6%B3%95%E5%90%8D%E7%A8%B1%E8%BF%94%E5%9B%9E%E8%A9%B2%E6%96%B9%E6%B3%95%E8%A2%AB%E5%AE%9A%E7%BE%A9%E6%99%82%E7%9A%84%E5%90%8D%E5%AD%97)\n    - [**NAMESPACE** 當前命名空間的名稱](#__namespace__-%E7%95%B6%E5%89%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%96%93%E7%9A%84%E5%90%8D%E7%A8%B1)\n  - [魔術方法](#%E9%AD%94%E8%A1%93%E6%96%B9%E6%B3%95)\n    - [\\_\\_construct 類別的構造函數](#__construct-%E9%A1%9E%E5%88%A5%E7%9A%84%E6%A7%8B%E9%80%A0%E5%87%BD%E6%95%B8)\n    - [\\_\\_destruct 類別的解構函數](#__destruct-%E9%A1%9E%E5%88%A5%E7%9A%84%E8%A7%A3%E6%A7%8B%E5%87%BD%E6%95%B8)\n    - [\\_\\_call 在物件中呼叫一個不可訪問的方法時，呼叫此方法](#__call-%E5%9C%A8%E7%89%A9%E4%BB%B6%E4%B8%AD%E5%91%BC%E5%8F%AB%E4%B8%80%E5%80%8B%E4%B8%8D%E5%8F%AF%E8%A8%AA%E5%95%8F%E7%9A%84%E6%96%B9%E6%B3%95%E6%99%82%E5%91%BC%E5%8F%AB%E6%AD%A4%E6%96%B9%E6%B3%95)\n    - [\\_\\_callStatic 用靜態方式呼叫一個不可訪問的方法時，呼叫此方法](#__callstatic-%E7%94%A8%E9%9D%9C%E6%85%8B%E6%96%B9%E5%BC%8F%E5%91%BC%E5%8F%AB%E4%B8%80%E5%80%8B%E4%B8%8D%E5%8F%AF%E8%A8%AA%E5%95%8F%E7%9A%84%E6%96%B9%E6%B3%95%E6%99%82%E5%91%BC%E5%8F%AB%E6%AD%A4%E6%96%B9%E6%B3%95)\n    - [\\_\\_get 獲取一個類別的成員變數時呼叫](#__get-%E7%8D%B2%E5%8F%96%E4%B8%80%E5%80%8B%E9%A1%9E%E5%88%A5%E7%9A%84%E6%88%90%E5%93%A1%E8%AE%8A%E6%95%B8%E6%99%82%E5%91%BC%E5%8F%AB)\n    - [\\_\\_set 設置一個類別的成員變數時呼叫](#__set-%E8%A8%AD%E7%BD%AE%E4%B8%80%E5%80%8B%E9%A1%9E%E5%88%A5%E7%9A%84%E6%88%90%E5%93%A1%E8%AE%8A%E6%95%B8%E6%99%82%E5%91%BC%E5%8F%AB)\n    - [\\_\\_isset 當私有屬性呼叫 isset 或 empty 時呼叫此方法](#__isset-%E7%95%B6%E7%A7%81%E6%9C%89%E5%B1%AC%E6%80%A7%E5%91%BC%E5%8F%AB-isset-%E6%88%96-empty-%E6%99%82%E5%91%BC%E5%8F%AB%E6%AD%A4%E6%96%B9%E6%B3%95)\n  - [方法](#%E6%96%B9%E6%B3%95)\n    - [in_array 檢查陣列中是否包含特定的數值](#in_array-%E6%AA%A2%E6%9F%A5%E9%99%A3%E5%88%97%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%89%B9%E5%AE%9A%E7%9A%84%E6%95%B8%E5%80%BC)\n    - [foreach](#foreach)\n    - [scandir 掃描指定的目錄，並返回為陣列](#scandir-%E6%8E%83%E6%8F%8F%E6%8C%87%E5%AE%9A%E7%9A%84%E7%9B%AE%E9%8C%84%E4%B8%A6%E8%BF%94%E5%9B%9E%E7%82%BA%E9%99%A3%E5%88%97)\n    - [list 宣告陣列中的值，使其成為變數](#list-%E5%AE%A3%E5%91%8A%E9%99%A3%E5%88%97%E4%B8%AD%E7%9A%84%E5%80%BC%E4%BD%BF%E5%85%B6%E6%88%90%E7%82%BA%E8%AE%8A%E6%95%B8)\n    - [append 將傳入的值附加進陣列](#append-%E5%B0%87%E5%82%B3%E5%85%A5%E7%9A%84%E5%80%BC%E9%99%84%E5%8A%A0%E9%80%B2%E9%99%A3%E5%88%97)\n    - [在陣列中新增元素](#%E5%9C%A8%E9%99%A3%E5%88%97%E4%B8%AD%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0)\n      - [直接賦值](#%E7%9B%B4%E6%8E%A5%E8%B3%A6%E5%80%BC)\n      - [array_push 在陣列最後新增元素](#array_push-%E5%9C%A8%E9%99%A3%E5%88%97%E6%9C%80%E5%BE%8C%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0)\n      - [array_unshift 在陣列前端插入](#array_unshift-%E5%9C%A8%E9%99%A3%E5%88%97%E5%89%8D%E7%AB%AF%E6%8F%92%E5%85%A5)\n    - [array_fill 以填充數值的方式，建立新陣列](#array_fill-%E4%BB%A5%E5%A1%AB%E5%85%85%E6%95%B8%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BB%BA%E7%AB%8B%E6%96%B0%E9%99%A3%E5%88%97)\n    - [array_combine 將傳入的參數合併為陣列](#array_combine-%E5%B0%87%E5%82%B3%E5%85%A5%E7%9A%84%E5%8F%83%E6%95%B8%E5%90%88%E4%BD%B5%E7%82%BA%E9%99%A3%E5%88%97)\n    - [array_unique 從陣列中刪除重複的值](#array_unique-%E5%BE%9E%E9%99%A3%E5%88%97%E4%B8%AD%E5%88%AA%E9%99%A4%E9%87%8D%E8%A4%87%E7%9A%84%E5%80%BC)\n    - [array_diff 判斷陣列之間差異](#array_diff-%E5%88%A4%E6%96%B7%E9%99%A3%E5%88%97%E4%B9%8B%E9%96%93%E5%B7%AE%E7%95%B0)\n    - [array_slice 從陣列中取得一段連續的元素](#array_slice-%E5%BE%9E%E9%99%A3%E5%88%97%E4%B8%AD%E5%8F%96%E5%BE%97%E4%B8%80%E6%AE%B5%E9%80%A3%E7%BA%8C%E7%9A%84%E5%85%83%E7%B4%A0)\n    - [日期/時間](#%E6%97%A5%E6%9C%9F%E6%99%82%E9%96%93)\n      - [date 格式化 Unix timestamps](#date-%E6%A0%BC%E5%BC%8F%E5%8C%96-unix-timestamps)\n      - [mktime 取得指定日期的時間戳](#mktime-%E5%8F%96%E5%BE%97%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F%E7%9A%84%E6%99%82%E9%96%93%E6%88%B3)\n      - [date_diff 獲取以分鐘為單位的時間差](#date_diff-%E7%8D%B2%E5%8F%96%E4%BB%A5%E5%88%86%E9%90%98%E7%82%BA%E5%96%AE%E4%BD%8D%E7%9A%84%E6%99%82%E9%96%93%E5%B7%AE)\n    - [sort 陣列排序](#sort-%E9%99%A3%E5%88%97%E6%8E%92%E5%BA%8F)\n      - [依 value 排序](#%E4%BE%9D-value-%E6%8E%92%E5%BA%8F)\n      - [依 key 排序](#%E4%BE%9D-key-%E6%8E%92%E5%BA%8F)\n      - [自訂排序](#%E8%87%AA%E8%A8%82%E6%8E%92%E5%BA%8F)\n    - [分割字串](#%E5%88%86%E5%89%B2%E5%AD%97%E4%B8%B2)\n      - [explode](#explode)\n      - [str_split](#str_split)\n      - [preg_split](#preg_split)\n    - [array_slice 從陣列中取出想要的元素](#array_slice-%E5%BE%9E%E9%99%A3%E5%88%97%E4%B8%AD%E5%8F%96%E5%87%BA%E6%83%B3%E8%A6%81%E7%9A%84%E5%85%83%E7%B4%A0)\n    - [implode 將陣列轉為字串](#implode-%E5%B0%87%E9%99%A3%E5%88%97%E8%BD%89%E7%82%BA%E5%AD%97%E4%B8%B2)\n    - [array_filter 過濾陣列元素刪除陣列空值](#array_filter-%E9%81%8E%E6%BF%BE%E9%99%A3%E5%88%97%E5%85%83%E7%B4%A0%E5%88%AA%E9%99%A4%E9%99%A3%E5%88%97%E7%A9%BA%E5%80%BC)\n    - [str_pad 填充字串為指定長度](#str_pad-%E5%A1%AB%E5%85%85%E5%AD%97%E4%B8%B2%E7%82%BA%E6%8C%87%E5%AE%9A%E9%95%B7%E5%BA%A6)\n    - [資料序列化及反序列化](#%E8%B3%87%E6%96%99%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)\n      - [string serialize 序列化](#string-serialize-%E5%BA%8F%E5%88%97%E5%8C%96)\n      - [mixed unserialize 反序列化](#mixed-unserialize-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)\n    - [file_get_contents 將本地文件存入一個變數中](#file_get_contents-%E5%B0%87%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%AD%98%E5%85%A5%E4%B8%80%E5%80%8B%E8%AE%8A%E6%95%B8%E4%B8%AD)\n    - [str_pad 補足字串](#str_pad-%E8%A3%9C%E8%B6%B3%E5%AD%97%E4%B8%B2)\n    - [str_replace 替換字串](#str_replace-%E6%9B%BF%E6%8F%9B%E5%AD%97%E4%B8%B2)\n    - [將字串轉換為數值](#%E5%B0%87%E5%AD%97%E4%B8%B2%E8%BD%89%E6%8F%9B%E7%82%BA%E6%95%B8%E5%80%BC)\n    - [is_a 檢查物件是該類別，或該類別是此物件的父類別 boolean](#is_a-%E6%AA%A2%E6%9F%A5%E7%89%A9%E4%BB%B6%E6%98%AF%E8%A9%B2%E9%A1%9E%E5%88%A5%E6%88%96%E8%A9%B2%E9%A1%9E%E5%88%A5%E6%98%AF%E6%AD%A4%E7%89%A9%E4%BB%B6%E7%9A%84%E7%88%B6%E9%A1%9E%E5%88%A5boolean)\n    - [substr 取得部分字串，可設定字串長度](#substr-%E5%8F%96%E5%BE%97%E9%83%A8%E5%88%86%E5%AD%97%E4%B8%B2%E5%8F%AF%E8%A8%AD%E5%AE%9A%E5%AD%97%E4%B8%B2%E9%95%B7%E5%BA%A6)\n    - [轉換字母大小寫](#%E8%BD%89%E6%8F%9B%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%AF%AB)\n      - [ucfirst 將字串的首字母轉為大寫](#ucfirst-%E5%B0%87%E5%AD%97%E4%B8%B2%E7%9A%84%E9%A6%96%E5%AD%97%E6%AF%8D%E8%BD%89%E7%82%BA%E5%A4%A7%E5%AF%AB)\n      - [strtolower 將字串換為小寫](#strtolower-%E5%B0%87%E5%AD%97%E4%B8%B2%E6%8F%9B%E7%82%BA%E5%B0%8F%E5%AF%AB)\n      - [strtoupper 將字串換為大寫](#strtoupper-%E5%B0%87%E5%AD%97%E4%B8%B2%E6%8F%9B%E7%82%BA%E5%A4%A7%E5%AF%AB)\n    - [define 定義一個常數](#define-%E5%AE%9A%E7%BE%A9%E4%B8%80%E5%80%8B%E5%B8%B8%E6%95%B8)\n  - [在 Linux 執行 php 檔](#%E5%9C%A8-linux-%E5%9F%B7%E8%A1%8C-php-%E6%AA%94)\n    - [方法一](#%E6%96%B9%E6%B3%95%E4%B8%80)"}