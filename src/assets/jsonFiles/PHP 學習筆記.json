{"name":"PHP 學習筆記.md","content":"# PHP 學習筆記\r\n\r\n>\r\n\r\n## 運算子、判斷\r\n\r\n- `+`: 算術相加\r\n\r\n- `.`: 字串相加\r\n\r\n- `gettype()`: 判斷變數的型態\r\n\r\n- `(int)($var1 + $var2)`: 只取商\r\n\r\n- `isset($var)`: 檢查變數是否有設置\r\n\r\n- `empty($var)`: 檢查變數是否為空值\r\n\r\n- `is_null($var)`: 檢查變數是否為 null\r\n\r\n  |                 | gettype() |   isset()   |   empty()   |  is_null()  |\r\n  | :-------------: | :-------: | :---------: | :---------: | :---------: |\r\n  | $x is undefined |   null    | **_false_** |  [true](#)  |  [true](#)  |\r\n  |    $x = null    |   null    | **_false_** |  [true](#)  |  [true](#)  |\r\n  |     $x = 0      |    int    |  [true](#)  |  [true](#)  | **_false_** |\r\n  |    $x = \"0\"     |    str    |  [true](#)  |  [true](#)  | **_false_** |\r\n  |     $x = 1      |    int    |  [true](#)  | **_false_** | **_false_** |\r\n  |     $x = \"\"     |    str    |  [true](#)  |  [true](#)  | **_false_** |\r\n  |   $x = \"PHP\"    |    str    |  [true](#)  | **_false_** | **_false_** |\r\n\r\n- `var_dump($var);`: 將變數的訊息印出於螢幕上\r\n\r\n- `instanceof` 型態運算子\r\n\r\n- 用於確定一個 php 物件是否屬於某一類別\r\n\r\n  ```php\r\n  class MyClass\r\n  {\r\n  }\r\n  class NotMyClass\r\n  {\r\n  }\r\n\r\n  $a = new MyClass;\r\n  var_dump($a instanceof MyClass);\r\n  var_dump($a instanceof NotMyClass);\r\n  ```\r\n\r\n  ```php\r\n  bool(true)\r\n  bool(false)\r\n  ```\r\n\r\n- 也可以用來確定一個物件是不是繼承自某一父類別的子類別\r\n\r\n  ```php\r\n  class ParentClass\r\n  {\r\n  }\r\n  class MyClass extends ParentClass\r\n  {\r\n  }\r\n\r\n  $a = new MyClass;\r\n  var_dump($a instanceof MyClass);\r\n  var_dump($a instanceof ParentClass);\r\n  ```\r\n\r\n  ```php\r\n  bool(true)\r\n  bool(true)\r\n  ```\r\n\r\n- 也可以用於確定一個變數是不是實現了某個接口的物件實例\r\n\r\n  ```php\r\n  interface A\r\n  {\r\n  }\r\n  class B implements A\r\n  {\r\n  }\r\n  $obj = new B;\r\n\r\n  var_dump($obj instanceof A);\r\n  echo \"<br>\";\r\n  var_dump($obj instanceof B);\r\n  ```\r\n\r\n  ```php\r\n  bool(true)\r\n  bool(true)\r\n  ```\r\n\r\n  雖然 instanceof 通常是直接與 class 名稱一起使用，但也可以使用字串來代替\r\n\r\n  ```php\r\n  interface A\r\n  {\r\n  }\r\n  class B implements A\r\n  {\r\n  }\r\n  $obj = new B;\r\n  $str1 = 'A';\r\n  $str2 = 'B';\r\n\r\n  var_dump($obj instanceof A);\r\n  echo \"<br>\";\r\n  var_dump($obj instanceof B);\r\n  echo \"<br>\";\r\n  var_dump($obj instanceof $str1);\r\n  echo \"<br>\";\r\n  var_dump($obj instanceof $str2);\r\n  ```\r\n\r\n  ```php\r\n  bool(true)\r\n  bool(true)\r\n  bool(true)\r\n  bool(true)\r\n  ```\r\n\r\n  若被檢測的變數不是物件，instanceof 並不會報錯，而是直接返回 false。另外，不能使用 instanceof 來檢測常數\r\n\r\n  ```php\r\n  $a = 1;\r\n  $b = NULL;\r\n  $c = imagecreate(5, 5);\r\n  var_dump($a instanceof stdClass);\r\n  echo '<br>';\r\n  var_dump($b instanceof stdClass);\r\n  echo '<br>';\r\n  var_dump($c instanceof stdClass);\r\n  echo '<br>';\r\n  var_dump(FALSE instanceof stdClass);\r\n  ```\r\n\r\n  ```php\r\n  bool(false)\r\n  bool(false)\r\n  bool(false)\r\n  bool(false)\r\n  ```\r\n\r\n## Autoload 自動載入\r\n\r\n一般可以透過 `include`, `include_once`, `require`, `require_once`，來將檔案引入到我們目前正在編寫的這個檔案。\r\n\r\n習慣上我們會將一個 class 存放在單一的 php 檔案中，例如 Member.php 相對於 Member class。\r\n\r\n但當程式需要引用到這個 class，就可以用上面的方法來引用此 class 以供後續操作。\r\n\r\n而 php autoload 機制可以讓我們在需要這個物件的時候，才去真正的引入這個 class，這個動作就是常聽到的 lazyload 延遲載入。\r\n\r\n- `__autoload`\r\n  php5 提供了 `__autoload()` 這個魔術方法實現上述 Autoload 機制，雖然這個方法效能及方便性並不是非常理想。\r\n\r\n## 魔術常數\r\n\r\n- 不分大小寫，但一般而言都會以大寫呈現\r\n\r\n### `__LINE__` 檔案中的當前行號\r\n\r\n```php\r\necho __LINE__ . PHP_EOL; // 1\r\necho __LINE__ . PHP_EOL; // 2\r\necho __LINE__ . PHP_EOL; // 3\r\n```\r\n\r\n### `__FILE__` 檔案的完整路徑和檔名\r\n\r\n- 若將其使用在 `include` 中，則返回包含檔案的名稱。\r\n- `__FILE__`總是包含一個絕對路徑(如果是符號連線，則是解析後的絕對路徑)。\r\n\r\n  ```php\r\n  echo __FILE__ . PHP_EOL; // D:\\phpproject\\php\\newblog\\php-magic-constant.php\r\n  ```\r\n\r\n### `__DIR__` 檔案所在的目錄\r\n\r\n- 如果用在被包括檔案中，則返回被包括的檔案所在目錄。\r\n- 其等同於 `dirname(__FILE__)`。\r\n- 除非是根目錄，否則目錄中名不包括末尾的斜線。\r\n\r\n  ```php\r\n  echo __DIR__ . PHP_EOL; // D:\\phpproject\\php\\newblog\r\n  ```\r\n\r\n### `__FUNCTION__` 返回該函數被定義時的名字\r\n\r\n```php\r\necho __FUNCTION__ . PHP_EOL; // 函數尚未被定義\r\n\r\nfunction testFunction()\r\n{\r\n  echo __FUNCTION__ . PHP_EOL; //  testFunction\r\n}\r\n\r\nclass TestClass\r\n{\r\n  function testFunctionButInClass()\r\n  {\r\n    echo __FUNCTION__ . PHP_EOL; // testFunctionButInClass\r\n  }\r\n}\r\n\r\ntestFunction();\r\n$test = new TestClass();\r\n$test->testFunctionButInClass();\r\n```\r\n\r\n### `__CLASS__` 返回類別名稱\r\n\r\n```php\r\necho __CLASS__ . PHP_EOL; // 類別尚未被宣\r\n\r\nfunction testClass()\r\n{\r\n    echo __CLASS__ . PHP_EOL; // 類別尚未被宣告\r\n}\r\n\r\ntrait TestClassTrait\r\n{\r\n    function testClass2()\r\n    {\r\n        echo __CLASS__ . PHP_EOL; // TestClassClass\r\n    }\r\n}\r\n\r\nclass TestClassClass\r\n{\r\n    use TestClassTrait;\r\n    function testClass1()\r\n    {\r\n        echo __CLASS__ . PHP_EOL; // TestClassClass\r\n    }\r\n}\r\n\r\ntestClass();\r\n$test = new TestClassClass();\r\n$test->testClass1();\r\n$test->testClass2();\r\n```\r\n\r\n### `__TRAIT__` Trait 的名字\r\n\r\n```php\r\necho __TRAIT__ . PHP_EOL; // 什麼也沒有\r\nfunction testTrait()\r\n{\r\n    echo __TRAIT__ . PHP_EOL; // 什麼也沒有\r\n}\r\n\r\ntrait TestTrait\r\n{\r\n    function testTrait2()\r\n    {\r\n        echo __TRAIT__ . PHP_EOL; // TestTrait\r\n    }\r\n}\r\n\r\nclass TestTraitClass\r\n{\r\n    use TestTrait;\r\n\r\n    function testTrait1()\r\n    {\r\n        echo __TRAIT__ . PHP_EOL; // 什麼也沒有\r\n    }\r\n}\r\n\r\ntestTrait();\r\n$test = new TestTraitClass();\r\n$test->testTrait1();\r\n$test->testTrait2();\r\n```\r\n\r\n### `__METHOD__` 類別的方法名稱，返回該方法被定義時的名字\r\n\r\n```php\r\necho __METHOD__ . PHP_EOL; // 尚無方法\r\n\r\nfunction testMethod() {\r\n  echo __METHOD__ . PHP_EOL; // testMethod\r\n}\r\n\r\nclass TestMethodClass\r\n{\r\n  function testMethodButinClass() {\r\n    echo __METHOD__ . PHP_EOL; // TestMethodClass::testMethodButinClass\r\n  }\r\n}\r\n\r\ntestMethod();\r\n$test = new TestClassClass();\r\n$test->testMethodButinClass();\r\n```\r\n\r\n### `__NAMESPACE__` 當前命名空間的名稱\r\n\r\n- 此常數是在編譯時定義的\r\n\r\n  ```php\r\n  echo __NAMESPACE__ . PHP_EOL; // test\\magic\\constant\r\n\r\n  class TestNameSpaceClass\r\n  {\r\n      function testNamespace() {\r\n          echo __NAMESPACE__ . PHP_EOL; // test\\magic\\constant\r\n      }\r\n  }\r\n\r\n  $test = new TestNameSpaceClass();\r\n  $test->testNamespace();\r\n  ```\r\n\r\n## 魔術方法\r\n\r\n> 參考資料：\r\n>\r\n> [PHP 之十六個魔術方法詳解](https://segmentfault.com/a/1190000007250604)\r\n\r\n### `__construct` 類別的構造函數\r\n\r\nphp 中構造方法是物件創建完成後，第一個被物件自動呼叫的方法。在每個類別中，都有一個構造方法，如果沒有宣告，那麼類別中會預設存在一個沒有參數且內容為空的構造方法。\r\n\r\n1. 作用：通常構造方法被用來執行一些初始化任務，如對成員屬性在創建對象時，賦予初始值\r\n2. 在類別中的聲明格式：\r\n\r\n   ```php\r\n   function __construct (params) {\r\n    // code\r\n    // 通常用來對成員屬性進行初始化賦值\r\n   }\r\n   ```\r\n\r\n3. 在類別中聲明構造方法需要注意的事項\r\n\r\n   1. 在同一個類別中只能宣告一個構造方法\r\n   2. 必定是以雙底線開始\r\n\r\n      ```php\r\n      class Person\r\n      {\r\n        public $name;\r\n        public $age;\r\n        public $sex;\r\n        /**\r\n         * 顯示宣告一個構造函數且帶參數\r\n         */\r\n        public function __construct($name = \"\", $age = 22, $sex = \"man\") {\r\n          $this->name = $name;\r\n          $this->sex = $sex;\r\n          $this->age = $age;\r\n        }\r\n        /**\r\n         * say 方法\r\n         */\r\n        public function say()\r\n        {\r\n          echo \"我叫：\" . $this->name . \"，性別：\" . $this->sex . \"，年齡：\" . $this->age;\r\n        }\r\n      }\r\n\r\n      /**\r\n       * $person1\r\n       */\r\n      $person1 = new Person()\r\n      echo $person1->say(); // 我叫：，性別：男，年齡：27\r\n      /**\r\n       * $person2\r\n       *\r\n       * @param $name 小明\r\n       */\r\n      $person2 = new Person('小明');\r\n      echo $person2->say(); // 我叫：小明，性別：男，年齡：27\r\n      /**\r\n       * $person3\r\n       *\r\n       * @param $name 李四\r\n       * @param $sex 男\r\n       * @param $age 25\r\n       */\r\n      $person3 = new Person('李四', '男', '25')\r\n      echo $person3->say(); // 我叫：李四，性別：男，年齡：25\r\n      ```\r\n\r\n### `__destruct` 類別的解構函數\r\n\r\n允許在銷毀一個類別之前，執行一些操作或完成一些功能，比如關閉文件，釋放結果集等\r\n\r\n1. 宣告格式\r\n\r\n   ```php\r\n   function __destruct()\r\n   {\r\n     // code\r\n   }\r\n   ```\r\n\r\n2. 解構函數的作用\r\n\r\n   ```php\r\n   class Person{\r\n       public $name;\r\n\r\n       public $age;\r\n\r\n       public $sex;\r\n\r\n       public function __construct($name=\"\", $sex=\"男\", $age=22)\r\n       {\r\n           $this->name = $name;\r\n           $this->sex  = $sex;\r\n           $this->age  = $age;\r\n       }\r\n\r\n       /**\r\n        * say 说话方法\r\n        */\r\n       public function say()\r\n       {\r\n           echo \"我叫：\".$this->name.\"，性别：\".$this->sex.\"，年齡：\".$this->age;\r\n       }\r\n\r\n       /**\r\n        * 声明一个析构方法\r\n        */\r\n       public function __destruct()\r\n       {\r\n           echo \"我覺得我還可以搶救一下，我的名字叫\".$this->name;\r\n       }\r\n   }\r\n\r\n   $Person = new Person(\"小明\");\r\n   unset($Person); // 銷毀上面建立的物件\r\n   ```\r\n\r\n### `__call` 在物件中呼叫一個不可訪問的方法時，呼叫此方法\r\n\r\n此方法接受兩參數，`$function_name` 會自動接收不存在的方法名，`$arguments` 則以陣列的方式接收不存在方法的多個參數。\r\n\r\n1. 宣告此方法的格式\r\n\r\n   ```php\r\n   function __call(string $function_nama, array $arguments){\r\n     // code\r\n   }\r\n   ```\r\n\r\n2. 此方法的作用：為避免當呼叫的方法不存在而產生錯誤，導致意外的程序中止，可以使用 `__call()` 方法來避免。剛方法在呼叫的方法不存在時，會自動呼叫，程式仍會繼續執行下去。\r\n\r\n   ```php\r\n   class Person\r\n   {\r\n       function say()\r\n       {\r\n\r\n              echo \"Hello, world!<br>\";\r\n       }\r\n\r\n       /**\r\n        * 宣告此方法用來處理，當呼叫了此物件中不存在的方法\r\n        */\r\n       function __call($funName, $arguments)\r\n       {\r\n             echo \"你所呼叫的函数：\" . $funName . \"(參數：\" ;  // 輸出呼叫的不存在方法名稱\r\n             print_r($arguments); // 输出呼叫不存在方法的參數列表\r\n             echo \")不存在！<br>\\n\"; // 結束換行\r\n       }\r\n   }\r\n\r\n   $Person = new Person();\r\n   $Person->run(\"teacher\"); // 呼叫物件中不存在的方法，此時會自動呼叫物件中的 __call() 方法\r\n   $Person->eat(\"小明\", \"蘋果\");\r\n   $Person->say();\r\n   ```\r\n\r\n   輸出\r\n\r\n   ```php\r\n   你所调用的函数：run(参数：Array ( [0] => teacher ) )不存在！\r\n\r\n   你所调用的函数：eat(参数：Array ( [0] => 小明 [1] => 苹果 ) )不存在！\r\n\r\n   Hello, world!\r\n   ```\r\n\r\n### `__callStatic` 用靜態方式呼叫一個不可訪問的方法時，呼叫此方法\r\n\r\n```php\r\n<?php\r\nclass Person\r\n{\r\n    function say()\r\n    {\r\n        echo \"Hello, world!<br>\";\r\n    }\r\n\r\n    /**\r\n     * 宣告此方法用來處理當靜態呼叫了不存在的方法時\r\n     */\r\n    public static function __callStatic($funName, $arguments)\r\n    {\r\n        echo \"你所呼叫的靜態方法：\" . $funName . \"(參數：\" ;  // 輸出呼叫不存在的方法名稱\r\n        print_r($arguments); // 输出呼叫不存在方法時傳入的參數\r\n        echo \")不存在！<br>\\n\"; // 结束换行\r\n    }\r\n}\r\n\r\n$Person = new Person();\r\n$Person::run(\"teacher\"); // 用於呼叫物件中不存在的靜態方法時，會自動呼叫物件中的__callStatic()方法\r\n$Person::eat(\"小明\", \"蘋果\");\r\n$Person->say();\r\n```\r\n\r\n### `__get` 獲取一個類別的成員變數時呼叫\r\n\r\n在 php 物件導向中，若類別成員被設定為 private 時，若我們在外面呼叫他則會出現\"無法訪問某個私有屬性\"的錯誤。\r\n\r\n- 此方法的作用：在程式運行中，透過他可以在物件外面獲取私有屬性成員的值\r\n\r\n  ```php\r\n  class Person\r\n  {\r\n      private $name;\r\n      private $age;\r\n\r\n      function __construct($name=\"\", $age=1)\r\n      {\r\n          $this->name = $name;\r\n          $this->age = $age;\r\n      }\r\n\r\n      /**\r\n       * 在類別中添加__get()方法，在直接獲取屬性時，自動呼叫一次，以屬性名作為參數傳入並處理\r\n       * @param $propertyName\r\n       *\r\n       * @return int\r\n       */\r\n      public function __get($propertyName)\r\n      {\r\n          if ($propertyName == \"age\") {\r\n              if ($this->age > 30) {\r\n                  return $this->age - 10;\r\n              } else {\r\n                  return $this->$propertyName;\r\n              }\r\n          } else {\r\n              return $this->$propertyName;\r\n          }\r\n      }\r\n  }\r\n\r\n  $Person = new Person(\"小明\", 60);   // 透過將 Persian 類別實例化的物件，並透過建構函示為屬性添加預設值\r\n  echo \"姓名：\" . $Person->name . \"<br>\";   // 直接呼叫私有屬性 $name，自動呼叫了__get()方法可以間接獲取\r\n  echo \"年龄：\" . $Person->age . \"<br>\";    // 自動呼叫 __get()方法，根據物件本身的情況會返回不同的值\r\n  ```\r\n\r\n  ```php\r\n  姓名：小明\r\n  年齡：50\r\n  ```\r\n\r\n### `__set` 設置一個類別的成員變數時呼叫\r\n\r\n- 作用：設置私有屬性，給一個未定義的屬性賦值，此方法會被觸發，傳入的參數是被設置的屬性名和值\r\n\r\n  ```php\r\n  class Person\r\n  {\r\n      private $name;\r\n\r\n      private $age;\r\n\r\n      public function __construct($name=\"\",  $age=25)\r\n      {\r\n          $this->name = $name;\r\n          $this->age  = $age;\r\n      }\r\n\r\n      /**\r\n       * 宣告此方法需兩個參數，直接為私有屬性賦值時自動呼叫，並可以排除非法賦值\r\n       *\r\n       * @param $property\r\n       * @param $value\r\n       */\r\n      public function __set($property, $value) {\r\n          if ($property==\"age\")\r\n          {\r\n              if ($value > 150 || $value < 0) {\r\n                  return;\r\n              }\r\n          }\r\n          $this->$property = $value;\r\n      }\r\n\r\n      /**\r\n       * 在類別中宣告 say()，將所有的私有屬性輸出\r\n       */\r\n      public function say(){\r\n          echo \"我叫\".$this->name.\"，今年\".$this->age.\"歲了\";\r\n      }\r\n  }\r\n\r\n  $Person= new Person(\"小明\", 25); // 注意，初始值將被下面所更改\r\n  // 自動呼叫 __set()，將數系名稱name傳遞給第一個參數，將屬性值\"小明\"傳遞給第二參數\r\n  $Person->name = \"小红\";     // 赋值成功。如果没有__set()，則出錯。\r\n  // 自動呼叫 __set() 函数，將屬性名稱 age 傳給第一個參數，將屬性值 26 傳給第二個參數\r\n  $Person->age = 16; //赋值成功\r\n  $Person->age = 160; //160是一个非法值，赋值失效\r\n  $Person->say();  //输出：我叫小红，今年 16 歲了\r\n  ```\r\n\r\n### `__isset()` 當私有屬性呼叫 isset() 或 empty() 時呼叫此方法\r\n\r\n## 方法\r\n\r\n### `in_array()` 檢查陣列中是否包含特定的數值\r\n\r\n- `bool in_array(mixed $needle, array $haystack, bool $strict = false)`\r\n  - `$needle` 要查找的值\r\n  - `$haystack` 要檢查的陣列\r\n  - `#strict` 可選，若為 `true`，則不僅檢查直是否相等，還要檢查型別是否相等。預設為 `false`\r\n\r\n```php\r\n$fruits = [\"apple\", \"banana\", \"cherry\", \"date\"];\r\n\r\n// 使用 in_array 检查数组中是否包含 \"cherry\"，不考虑数据类型\r\nif (in_array(\"cherry\", $fruits)) {\r\n    echo \"数组中包含 'cherry'。\";\r\n} else {\r\n    echo \"数组中不包含 'cherry'。\";\r\n}\r\n\r\n// 使用 in_array 检查数组中是否包含 2，考虑数据类型\r\nif (in_array(2, $fruits, true)) {\r\n    echo \"数组中包含 2（考虑数据类型）。\";\r\n} else {\r\n    echo \"数组中不包含 2（考虑数据类型）。\";\r\n}\r\n\r\n```\r\n\r\n### `foreach`\r\n\r\n- `foreach()` 尋訪陣列\r\n\r\n  ```php\r\n  foreach ($array as $value) {\r\n    // 每次尋訪會將陣列的值存到value中，直到陣列結束\r\n  }\r\n  foreach ($array as $key => $value) {\r\n   // 每次尋訪會將陣列的值以及key，存到value中  key => 流水號\r\n  }\r\n  ```\r\n\r\n- `continue` 跳出本次循環，繼續執行下向執行\r\n\r\n- `array_key_first()` 取得陣列中第一個 key 值\r\n- `array_key_last()` 取得陣列中最後一個 key 值\r\n\r\n  ```php\r\n  $array  = array(\"dog\", \"rabbit\", \"horse\", \"rat\", \"cat\");\r\n  foreach($array as $index => $animal) {\r\n      if ($index === array_key_first($array))\r\n          echo $animal; // output: dog\r\n      if ($index === array_key_last($array))\r\n          echo $animal; // output: cat\r\n  }\r\n  ```\r\n\r\n- `break` 跳出迴圈\r\n\r\n  ```php\r\n  <?php\r\n  foreach (array('1','2','3') as $first) {\r\n      echo \"$first \";\r\n      foreach (array('3','2','1') as $second) {\r\n          echo \"$second \";\r\n          if ($first == $second) {\r\n              break;  // this will break both foreach loops\r\n          }\r\n      }\r\n      echo \". \";  // never reached!\r\n  }\r\n  echo \"Loop Ended\";\r\n  ?>\r\n  ```\r\n\r\n- 輸出\r\n\r\n  ```php\r\n  1 3 2 1 . 2 3 2 . 3 3 . Loop Ended\r\n  ```\r\n\r\n### `scandir` 掃描指定的目錄，並返回為陣列\r\n\r\n- `scandir()` 掃描指定的目錄，並返回為陣列\r\n\r\n### `list` 宣告陣列中的值，使其成為變數\r\n\r\n- `list(var1, var2...)` 宣告陣列中的值，使其成為變數\r\n\r\n  ```php\r\n  $my_array = array('dog', 'cat', 'horse');\r\n  list($a, $b, $c) = $my_array;\r\n  echo \"i have several animals, a $a, a $b, a $c. \";\r\n  // i have several animals, a dog, a cat and a horse.\r\n  ```\r\n\r\n### `append` 將傳入的值附加進陣列\r\n\r\n- `append(var1, var2)`\r\n\r\n  ```php\r\n  // PHP function to illustrate the\r\n  // append() method\r\n  $arrObj = new ArrayObject(array('Geeks', 'for', 'Geeks'));\r\n  // Appending an array\r\n  $arrObj->append(array('welcomes', 'you'));\r\n  var_dump($arrObj);\r\n  ```\r\n\r\n- 輸出\r\n\r\n  ```php\r\n  object(ArrayObject)#1 (1) {\r\n    [\"storage\":\"ArrayObject\":private]=>\r\n    array(4) {\r\n      [0]=>\r\n      string(5) \"Geeks\"\r\n      [1]=>\r\n      string(3) \"for\"\r\n      [2]=>\r\n      string(5) \"Geeks\"\r\n      [3]=>\r\n      array(2) {\r\n        [0]=>\r\n        string(8) \"welcomes\"\r\n        [1]=>\r\n        string(3) \"you\"\r\n      }\r\n    }\r\n  }\r\n  ```\r\n\r\n### 在陣列中新增元素\r\n\r\n#### 直接賦值\r\n\r\n```php\r\n$array[] = $array;\r\n```\r\n\r\n```php\r\n$flower = array();\r\necho(\"The array is empty, as you can see. \\n\");\r\nprint_r($flowers);\r\necho(\"Now, we have added the values. \\n\");\r\n$flowers[] = \"Rose\";\r\n$flowers[] = \"Jasmine\";\r\n$flowers[] = \"Lili\";\r\n$flowers[] = \"Hibiscus\";\r\n$flowers[] = \"Tulip\";\r\nprint_r($flowers);\r\n```\r\n\r\n```php\r\nThe array is empty, as you can see.\r\nArray\r\n(\r\n)\r\nNow, we have added the values.\r\nArray\r\n(\r\n    [0] => Rose\r\n    [1] => Jasmine\r\n    [2] => Lili\r\n    [3] => Hibiscus\r\n    [4] => Tulip\r\n)\r\n```\r\n\r\n#### `array_push` 在陣列最後新增元素\r\n\r\n- `array_push($array, $value1, $value2, ..., $valueN);`\r\n- `$array` 必須，目標新增元素的陣列\r\n- `$value1`, `$value2` 必須，欲新增至陣列的元素，可以為字串、整數、浮點數等\r\n\r\n  ```php\r\n  $flowers = array();\r\n  echo(\"The array is empty, as you can see. \\n\");\r\n  print_r($flowers);\r\n  echo(\"Now, we have added the values. \\n\");\r\n  array_push($flowers, \"Rose\", \"Jasmine\", \"Lili\", \"Hibiscus\", \"Tulip\");\r\n  print_r($flowers);\r\n  ```\r\n\r\n  ```php\r\n  The array is empty, as you can see.\r\n  Array\r\n  (\r\n  )\r\n  Now, we have added the values.\r\n  Array\r\n  (\r\n      [0] => Rose\r\n      [1] => Jasmine\r\n      [2] => Lili\r\n      [3] => Hibiscus\r\n      [4] => Tulip\r\n  )\r\n  ```\r\n\r\n#### `array_unshift` 在陣列前端插入\r\n\r\n- `array_unshift($array, $value1, $value2, ..., $valueN)`\r\n- `$array` 必須，目標新增元素的陣列\r\n- `$value1`, `$value2` 必須，欲新增至陣列的元素，可以為字串、整數、浮點數等\r\n\r\n  ```php\r\n  $flowers = ['first', 'second'];\r\n  print_r($flowers);\r\n  echo(\"Now we have added the values. \\n\");\r\n  echo(array_unshift($flowers, \"Rose\", \"Jasmine\", \"Lili\", \"Hibiscus\", \"Tulip\"));\r\n  echo(\"\\n\");\r\n  print_r($flowers);\r\n  ```\r\n\r\n  ```php\r\n  Array\r\n  (\r\n    [0] => first\r\n    [1] => second\r\n  )\r\n  Now we have added the values.\r\n  7\r\n  Array\r\n  (\r\n    [0] => Rose\r\n    [1] => Jasmine\r\n    [2] => Lili\r\n    [3] => Hibiscus\r\n    [4] => Tulip\r\n    [5] => first\r\n    [6] => second\r\n  )\r\n  ```\r\n\r\n### `array_fill` 以填充數值的方式，建立新陣列\r\n\r\n- `array_fill(int $start_index, int $count, mixed $value): array` 將傳入的`$value`，加入`$count` 個值到陣列，開始的 key 值由`$start_index` 指定\r\n\r\n- `$start_index` 回傳陣列的第一個 key 值，如為負數，返回的第一個 key 將會是 start_index 的值，而後面的 key 值由 0 開始。\r\n\r\n- `$count` 插入值的數量，需大於等於 0 ，否則拋出 E_WARNING。\r\n\r\n- `$value` 傳入陣列的值。\r\n\r\n  ```php\r\n  $a = array_fill(5, 6, 'banana');\r\n  $b = array_fill(-2, 4, 'pear');\r\n  print_r($a);\r\n  print_r($b);\r\n  ```\r\n\r\n  ```php\r\n  Array\r\n  (\r\n    [5]  => banana\r\n    [6]  => banana\r\n    [7]  => banana\r\n    [8]  => banana\r\n    [9]  => banana\r\n    [10] => banana\r\n  )\r\n  Array\r\n  (\r\n    [-2] => pear\r\n    [0] => pear\r\n    [1] => pear\r\n    [2] => pear\r\n  )\r\n  ```\r\n\r\n### `array_combine` 將傳入的參數合併為陣列\r\n\r\n- `array_combine(array $keys, array $values): array` `$key`為 key 值，`$value` 為相對應的值。\r\n\r\n  ```php\r\n  $a = array('green', 'red', 'yellow');\r\n  $b = array('avocado', 'apple', 'banana');\r\n  $c = array_combine($a, $b);\r\n  print_r($c);\r\n  ```\r\n\r\n  ```PHP\r\n  Array\r\n  (\r\n    [green]  => avocado\r\n    [red]    => apple\r\n    [yellow] => banana\r\n  )\r\n  ```\r\n\r\n### `array_unique` 從陣列中刪除重複的值\r\n\r\n- `array_unique($array, $flags)`\r\n\r\n- `$array` 要刪除重複值的陣列\r\n- `$flags` 指定陣列的排序模式，有五種型別\r\n- `SORT_REGULAR` 正常常比較元素\r\n- `SORT_NUMERIC` 以數字方式比較元素\r\n- `SORT_STRING` 以字串方式比較元素\r\n- `SORT_LOCALE_STRING` 基於當前的語言環境，以字串方式比較元素。\r\n\r\n### `array_diff` 判斷陣列之間差異\r\n\r\n- `array_diff( $array1 , $array2 , $array3 , ... ):array` 後面每個陣列都跟第一個陣列做比較，此方法會回傳在第一陣列中有出現，但未出現在其他陣中的值，並會保留鍵名\r\n\r\n  ```php\r\n  $array1 = array('A','B','C','D');\r\n  $array2 = array('C','D','E','F');\r\n  $array3 = array('A','B','E','F');\r\n  $newArray1 = array_diff($array1,$array2);\r\n  print_r($newArray1);\r\n  $newArray2 = array_diff($array1,$array3);\r\n  print_r($newArray2);\r\n  ```\r\n\r\n  ```PHP\r\n  Array\r\n  (\r\n    [0] => A,\r\n    [1] => B\r\n  )\r\n  Array\r\n  (\r\n    [2] => C,\r\n    [3] => D\r\n  )\r\n  ```\r\n\r\n- 進階用法\r\n\r\n藉由其查詢兩個以上陣列之間的差異，並返回不存在陣列中的值之特性。\r\n\r\n因此可用來刪除陣列中多個值，而不影響其索引值。\r\n\r\n```php\r\n//Declare the array\r\n$flowers = [\r\n  \"Rose\",\r\n  \"Lili\",\r\n  \"Jasmine\",\r\n  \"Hibiscus\",\r\n  \"Tulip\",\r\n  \"Sun Flower\",\r\n  \"Daffodil\",\r\n  \"Daisy\"\r\n];\r\n\r\n$flowers = array_diff($flowers, array(\"Rose\",\"Lili\"));\r\necho \"The array is:\\n\";\r\nprint_r($flowers);\r\n```\r\n\r\n```php\r\nArray\r\n(\r\n[2] => Jasmine\r\n[3] => Hibiscus\r\n[4] => Tulip\r\n[5] => Sun Flower\r\n[6] => Daffodil\r\n[7] => Daisy\r\n)\r\n```\r\n\r\n### `array_slice` 從陣列中取得一段連續的元素\r\n\r\n此方法會返回一個新的陣列，包含從原陣列取得的元素，而原始陣列不會被修改。\r\n\r\n- `array_slice(array $array, int $offset, int $length = null, bool $preserve_keys = false);`\r\n  - `$array` 目標的陣列\r\n  - `$offset` 從陣列的哪一個位置開始取得元素\r\n  - `$length` 可選參數，指定取得的元素個數，若未設置，則從 $offset 開始擷取到陣列最後的所有元素。\r\n  - `$preserve_keys` 可選參數，若為 `true`，則保留原始陣列的 key 值，預設為 `false`\r\n\r\n```php\r\n$fruits = ['apple', 'banana', 'cherry', 'date','fig'];\r\n\r\n// 擷取陣列前三個元素\r\n$slice1 = array_slice($fruits, 0, 3);\r\nprint_r($slice1); // 输出：['apple', 'banana', 'cherry']\r\n\r\n// 擷取陣列的後兩個元素\r\n$slice2 = array_slice($fruits, -2);\r\nprint_r($slice2); // 输出：['date', 'fig']\r\n```\r\n\r\n### 日期/時間\r\n\r\n#### `date` 格式化 Unix timestamps\r\n\r\n- `date(string $format, ?int $timestamp = null)`\r\n\r\n- `$format` 指定的格式\r\n  - `Y` 年份，四位數\r\n  - `y` 年份二位數\r\n  - `F` 月份英文全名；如 'March'\r\n  - `M` 月份英文縮寫；如 'Mar'\r\n  - `m` 月份數字，不足二位前面補 0\r\n  - `n` 月份數字\r\n  - `D` 星期英文縮寫；如：'Fri'\r\n  - `l` 星期英文全稱；如：'Friday'\r\n  - `w` 星期數字\r\n  - `d` 幾日數字，不足二位前面補 0\r\n  - `j` 幾日數字\r\n  - `H` 24 小時制，不足二位前面補 0\r\n  - `h` 12 小時制，不足二位前面補 0\r\n  - `G` 24 小時制\r\n  - `g` 12 小時制\r\n  - `i` 分鐘\r\n  - `A` Am 或 Pm\r\n  - `a` am 或 pm\r\n  - `s` 秒\r\n  - `U` 總秒數\r\n  - `t` 指定月份的天數；如\"28\", \"31\"\r\n  - `z` 一年中的第幾天\r\n- `$timestamp` 時間戳(可選)\r\n\r\n#### `mktime` 取得指定日期的時間戳\r\n\r\n- `mktime($hour, $minute = null, $second = null, $month = null, $day = null, $year = null)`\r\n- 任何省略的變數，將依據本地時間設置\r\n\r\n#### `date_diff` 獲取以分鐘為單位的時間差\r\n\r\n- `date_diff($StartDateTimeObject, $EndDateTimeObject)`\r\n  - `$StartDateTimeObject1` 必須，為一個 DataTime 物件，表示開始日期。\r\n  - `$EndDateTimeObject1` 必須，為一個 DataTime 物件，表示結束日期。\r\n  - 若失敗返回 false\r\n\r\n```php\r\n$date_time_start = date_create('2019-06-19')\r\n$date_time_end = date_create('2020-06-19')\r\n\r\n$difference = date_diff($date_time_start, $date_time_end);\r\n```\r\n\r\n### `sort` 陣列排序\r\n\r\n#### 依 value 排序\r\n\r\n- 由小到大排序值\r\n- `sort` 刪除 key\r\n- `asort` 保留 key\r\n- 由大到小排序值\r\n- `rsort` 刪除 key\r\n- `arsort` 保留 key\r\n\r\n#### 依 key 排序\r\n\r\n- `ksort` 由小到大排索引值\r\n- `krsort` 由大到小排索引值\r\n\r\n#### 自訂排序\r\n\r\n加上一個前綴 `u` 在相對應的方法\r\n\r\n- 範例一：\r\n  今天有一個陣列如下\r\n\r\n  ```php\r\n  $unsorted = [\r\n      ['name'   => 'good',\r\n       'sorter' => '1',],\r\n\r\n      ['name'   => 'bad',\r\n       'sorter' => '3',],\r\n\r\n      ['name'   => 'normal',\r\n       'sorter' => '2',],\r\n  ];\r\n  ```\r\n\r\n  我要透過 sorter 這個 key 的 value 來做排序\r\n\r\n  ```php\r\n  usort($unsorted, function ($a, $b) {\r\n      return $a['sorter'] > $b['sorter'];\r\n      // 如果 a > b 的話 就會輸出 1，而因為 usort 的 根基是 sort\r\n      // 意即是照 value 由小到大排序，所以輸出 1 的就會往後排，進而達到目的\r\n  });\r\n  ```\r\n\r\n  ```php\r\n  array(3) {\r\n   [0]=>\r\n   array(2) {\r\n     [\"name\"]=>\r\n     string(4) \"good\"\r\n     [\"sorter\"]=>\r\n     string(1) \"1\"\r\n   }\r\n   [1]=>\r\n   array(2) {\r\n     [\"name\"]=>\r\n     string(6) \"normal\"\r\n     [\"sorter\"]=>\r\n     string(1) \"2\"\r\n   }\r\n   [2]=>\r\n   array(2) {\r\n     [\"name\"]=>\r\n     string(3) \"bad\"\r\n     [\"sorter\"]=>\r\n     string(1) \"3\"\r\n   }\r\n  }\r\n  ```\r\n\r\n- 範例二：\r\n\r\n  如果一樣的陣列，但要用來比對的數值是重複的\r\n\r\n  ```php\r\n  $unsorted = [\r\n      ['name'   => 'good', 'sorter' => '1',],\r\n      ['name'   => 'bad', 'sorter' => '3',],\r\n      ['name'   => 'normal', 'sorter' => '3',],\r\n  ];\r\n  ```\r\n\r\n  可以增加一個比對條件\r\n\r\n  ```php\r\n  $unsorted = [\r\n      [\r\n        'name'   => 'good',\r\n        'sorter' => '1',\r\n        'newSorter'=> '2'\r\n      ],\r\n      [\r\n        'name'   => 'bad',\r\n        'sorter' => '3',\r\n        'newSorter'=> '3'\r\n      ],\r\n      [\r\n        'name'   => 'normal',\r\n        'sorter' => '3',\r\n        'newSorter' => '1'\r\n      ],\r\n      [\r\n        'name'   => 'hahaha',\r\n        'sorter' => '2',\r\n        'newSorter' => '1'\r\n      ],\r\n  ];\r\n  ```\r\n\r\n  依照 sorter 來進行排序，但如果 sorter 數值相同，則使用 newSorter 來進行排序\r\n\r\n  ```php\r\n  usort($unsorted, function ($a, $b)) {\r\n      return $a['sorter'] > $b['sorter'] || ($a['sorter'] == $b['sorter'] && $a['newSorter'] > $b['newSorter']);\r\n  }\r\n\r\n  // 或這樣寫\r\n  if ($a['sorter'] > $b['sorter'] || ($a['sorter'] == $b['sorter'] && $a['newSorter'] > $b['newSorter'])) {\r\n      return 1;\r\n  } elseif ($a['sorter'] < $b['sorter']) {\r\n      return -1;\r\n  } else {\r\n      return 0;\r\n  }\r\n  ```\r\n\r\n  ```php\r\n  array(4) {\r\n    [0]=>\r\n    array(3) {\r\n      [\"name\"]=>\r\n      string(4) \"good\"\r\n      [\"sorter\"]=>\r\n      string(1) \"1\"\r\n      [\"newSorter\"]=>\r\n      string(1) \"2\"\r\n    }\r\n    [1]=>\r\n    array(3) {\r\n      [\"name\"]=>\r\n      string(6) \"hahaha\"\r\n      [\"sorter\"]=>\r\n      string(1) \"2\"\r\n      [\"newSorter\"]=>\r\n      string(1) \"1\"\r\n    }\r\n    [2]=>\r\n    array(3) {\r\n      [\"name\"]=>\r\n      string(6) \"normal\"\r\n      [\"sorter\"]=>\r\n      string(1) \"3\"\r\n      [\"newSorter\"]=>\r\n      string(1) \"1\"\r\n    }\r\n    [3]=>\r\n    array(3) {\r\n      [\"name\"]=>\r\n      string(3) \"bad\"\r\n      [\"sorter\"]=>\r\n      string(1) \"3\"\r\n      [\"newSorter\"]=>\r\n      string(1) \"3\"\r\n    }\r\n  }\r\n  ```\r\n\r\n### 分割字串\r\n\r\n#### `explode`\r\n\r\n- `explode( string $delimiter , string $string , int $limit )`\r\n\r\n- `$delimiter` - 字串的切割部位，請自行設定，字串形態，必填\r\n- `$string` - 被要處理的字串，字串形態，必填項目。\r\n- `$limit` - 設定字串切割後最多可輸出的數量，數字形態，可為正整數或負整數，如果填寫正整數，最後的的部份包含切割完剩下的所有部份，，如果填寫負整數，則倒數的部份若在負整數範圍 內將不會顯示，非必填項目\r\n\r\n  ```php\r\n  <?php\r\n    $str = 'Apple Dog Pig';\r\n    $str_sec = explode(\" \",$str);\r\n    print_r($str_sec);\r\n  ```\r\n\r\n  ```php\r\n  Array (\r\n  　[0] => Apple\r\n  　[1] => Dog\r\n  　[2] => Pig\r\n  )\r\n  ```\r\n\r\n- 加入`$limit` 參數\r\n\r\n  ```php\r\n  <?php\r\n    $str = 'Apple Dog Pig';\r\n    $str_sec_A = explode(\" \",$str,2);\r\n    $str_sec_B = explode(\" \",$str,-1);\r\n    print_r($str_sec_A);\r\n    print_r($str_sec_B);\r\n  ```\r\n\r\n  ```php\r\n  Array (\r\n  　[0] => Apple\r\n  　[1] => Dog Pig\r\n  )\r\n  Array (\r\n  　[0] => Apple\r\n  　[1] => Dog\r\n  )\r\n  ```\r\n\r\n#### `str_split`\r\n\r\n- `str_split($string, $length)`\r\n\r\n- `string` 必需。規定要分割的字符串。\r\n- `length` 可選。規定每個數組元素的長度。默認是 1。\r\n\r\n  ```php\r\n  <?php\r\n    $NewString = \"M'L2\";\r\n    $Arr2=str_split($NewString,3);//根據每三個字元切割\r\n    print_r($Arr2);\r\n  ```\r\n\r\n  ```php\r\n  Array(\r\n      [0] => \"M'L\"\r\n      [1] => 2\r\n  )\r\n  ```\r\n\r\n#### preg_split\r\n\r\n- `preg_split ( string $pattern , string $subject , int $limit , int $flags )`\r\n\r\n- `pattern` 用於搜索的模式，字串形式\r\n- `subject` 輸入字串\r\n- `limit` 可選，用來設定分割後的單位總數量，預設值為 -1\r\n- `flags` 可選\r\n  - `PREG_SPLIT_NO_EMPTY`只返回非空白部分\r\n  - `PREG_SPLIT_DELIM_CAPTURE`和字串中的正規表達式一起返回\r\n  - `PREG_SPLIT_OFFSET_CAPTURE`將每個返回增加字串的偏移量\r\n\r\n```php\r\n//根據空格切開\r\n$NewString1 = preg_split(\"/[\\s,]+/\", \"Welcome to Wibibi.Have a good day.\");\r\nprint_r($NewString1);\r\n\r\necho '<br>';\r\n\r\n//把每個英文字母切開\r\n$NewString2 = 'Welcome';\r\n$NewString2 = preg_split('//', $NewString2, -1, PREG_SPLIT_NO_EMPTY);\r\nprint_r($NewString2);\r\n```\r\n\r\n### `array_slice` 從陣列中取出想要的元素\r\n\r\n- `array_slice($array, $start, $length, $preserve)`\r\n\r\n- `array` 必填，傳入陣列。\r\n- `start` 必填，規定取出元素的開始位置，0 = 第一個元素，若傳入正數，則由前往後取值，若為負值由後往前取值。\r\n- `length` 選填，規定返回的陣列長度。\r\n- `preserve` 選填，`true` 保留 key 值，`false` 重置 key 值。\r\n\r\n  ```php\r\n  <?php\r\n  $a=array(\"red\",\"green\",\"blue\",\"yellow\",\"brown\");\r\n  print_r(array_slice($a,2));\r\n  ```\r\n\r\n  ```php\r\n  Array\r\n  (\r\n      [0] => blue\r\n      [1] => yellow\r\n      [2] => brown\r\n  )\r\n  ```\r\n\r\n### `implode` 將陣列轉為字串\r\n\r\n- `implode($separator, $array)`\r\n\r\n- `separator` 可選。規定數組元素之間放置的內容。默認是 \"\"（空字符串）。\r\n- `array` 必需。要結合為字符串的數組。\r\n\r\n  ```php\r\n  $arr = [1,2,3,4,5,6];\r\n  print_r(implode('=', $arr));\r\n  ```\r\n\r\n  ```php\r\n  \"1=2=3=4=5=6\"\r\n  ```\r\n\r\n### `array_filter` 過濾陣列元素(刪除陣列空值)\r\n\r\n- `array_filter($arrayName, $callbackFunction, $callbackParameter)`\r\n\r\n  - `$arrayName` 必須，目標陣列\r\n  - `$callbackFunction` 可選，指定刪除的參數，預設刪除陣列中等於 false 的值\r\n  - `$callbackParameter` 可選，引用傳遞給回傳函數的參數\r\n\r\n    - `ARRAY_FILTER_USE_KEY` 將 key 作為唯一參數傳遞給回調函數，而不是數組的值\r\n    - `ARRAY_FILTER_USE_BOTH` 將值和鍵都作為參數而不是值傳遞給回調\r\n\r\n      ```php\r\n      // PHP function to check for even elements in an array\r\n      function Even($array)\r\n      {\r\n          // returns if the input integer is even\r\n          if($array%2==0)\r\n             return TRUE;\r\n          else\r\n             return FALSE;\r\n      }\r\n      $array = array(12, 0, 0, 18, 27, 0, 46);\r\n      print_r(array_filter($array, \"Even\"));\r\n      ```\r\n\r\n      ```php\r\n        Array (\r\n            [0] => 12\r\n            [1] => 0\r\n            [2] => 0\r\n            [3] => 18\r\n            [5] => 0\r\n            [6] => 46\r\n        )\r\n      ```\r\n\r\n### `str_pad` 填充字串為指定長度\r\n\r\n- `str_pad($string, $length, $pad_string, $pad_type)`\r\n\r\n- string 必填，要填充的字串。\r\n- length 必填，規定新字串的長度，若小於傳入的字串長度，則不進行操作。\r\n- pad_string 可選，提供填充的字串，預設為空白。\r\n- pad_type 可選，字串填充的方向。\r\n\r\n  - STR_PAD_BOTH 填充字串的兩側，若不為偶數，則將額外的字串填充至右側。\r\n  - STR_PAD_LEFT 填充到字串的左側。\r\n  - STR_PAD_RIGHT 填充到字串的右側(預設)。\r\n\r\n    ```php\r\n    $str = \"Hello world\";\r\n    echo str_pad($str, 20, \".\", STR_PAD_LEFT);\r\n    ```\r\n\r\n    ```php\r\n    .........Hello World\r\n    ```\r\n\r\n    ```php\r\n    $str = \"Hello world\";\r\n    echo str_pad($str, 20, \".:\", STR_PAD_BOTH);\r\n    ```\r\n\r\n    ```php\r\n    .:.:Hello World.:.:.\r\n    ```\r\n\r\n### 資料序列化及反序列化\r\n\r\n#### `string serialize` 序列化\r\n\r\n- `string serialize( mixed $value )`\r\n\r\n- $value: 要序列化的對象或陣列\r\n\r\n  ```php\r\n  $sites = array('Google', 'Runoob', 'Facebook');\r\n  $serialized_data = serialize($sites);\r\n  echo  $serialized_data . PHP_EOL;\r\n  ```\r\n\r\n  ```php\r\n  a:3:{i:0;s:6:\"Google\";i:1;s:6:\"Runoob\";i:2;s:8:\"Facebook\";}\r\n  ```\r\n\r\n#### `mixed unserialize` 反序列化\r\n\r\n- `mixed unserialize( string $str )`\r\n\r\n- $str: 序列化後的字串\r\n\r\n  ```php\r\n  $str = 'a:3:{i:0;s:6:\"Google\";i:1;s:6:\"Runoob\";i:2;s:8:\"Facebook\";}';\r\n  $unserialized_data = unserialize($str);\r\n  print_r($unserialized_data);\r\n  ```\r\n\r\n  ```php\r\n  Array\r\n  (\r\n      [0] => Google\r\n      [1] => Runoob\r\n      [2] => Facebook\r\n  )\r\n  ```\r\n\r\n### `file_get_contents` 將本地文件存入一個變數中\r\n\r\n- `file_get_contents($path, $include_path, $context, $start, $max_length)`\r\n\r\n- path (必須) 文件的路徑\r\n- include_path (可選) 如果也想在 include_path 中搜尋文件，可以將該參數設為\"1\"\r\n- context (可選) 規定文件控制代碼的環境\r\n- start (可選) 指定在文件中開始讀取的位置。\r\n- max_length (可選) 規定讀取的位元組。\r\n\r\n### `str_pad` 補足字串\r\n\r\n- `str_pad($str, $pad_length , $pad_string, $pad_type)`\r\n\r\n- `$str` 來源字串\r\n- `$pad_length` 補完後字串長度\r\n- `$pad_string` 補入的字元\r\n- `$pad_type` 補入的規則\r\n\r\n  - `STR_PAD_BOTH` 左右都補\r\n  - `STR_PAD_LEFT` 從左邊開始\r\n  - `STR_PAD_RIGHT` 從右邊開始\r\n\r\n  把 id 由左邊開始補 0，補到五位數\r\n\r\n  ```php\r\n  $id=01;\r\n  $id=str_pad($id,5,\"0\",STR_PAD_LEFT);\r\n  echo $id;\r\n  //00001\r\n  ```\r\n\r\n### `str_replace` 替換字串\r\n\r\n### 將字串轉換為數值\r\n\r\n> 若字串開頭為 0，轉為數值後開頭的 0 會被省略\r\n\r\n- `number_format()` 若失敗則返回`E_WARNING`\r\n\r\n- 使用類型轉換\r\n\r\n  ```php\r\n  $num = \"1000.314\";\r\n  echo (int)$num\r\n  ```\r\n\r\n- 透過運算子將字串轉為數值，例如在字串中 + 0\r\n\r\n### `is_a` 檢查物件是該類別，或該類別是此物件的父類別(boolean)\r\n\r\n- `is_a( object $object , string $class_name )`\r\n\r\n- 此函數在 php 5 之後已廢棄，改用 `instanceof` 型態運算子\r\n\r\n### `substr` 取得部分字串，可設定字串長度\r\n\r\n- `substr( $string , $start , $length )`\r\n\r\n- $string 原始的字串\r\n- $start 要開始擷取的位置(須為數字，可為正數或負數)\r\n- $length 要擷取的字串長度(須為數字，可為正數或負數)\r\n\r\n```php\r\necho substr(\"abcde\", -1);       // 輸出 e，因為從字尾開始算一個字母。\r\necho substr(\"abcde\", -2);       // 輸出 de，因為從字尾開始算，共取兩個字母。\r\n\r\necho substr(\"abcd\", -3, 1);     // 輸出 b，因為從字尾開始算，先取三個字母為 bcd，接著長度在從 bcd 取 1 位。\r\necho substr(\"abcdef\", 0, -1);   // 輸出 abcde，因為程式先從零開始取整段字串，長度再由字串尾扣掉一個。\r\necho substr(\"abcdef\", 2, -1);   // 輸出 cde，因為程式先從第二個字元開始，取得 cdef 這幾個字，再由取得的字串尾扣掉一個。\r\necho substr(\"abcdef\", 5, -2);   // 回傳 false，因為程式一開始先取得 f，然後扣掉五個字元，就什麼都沒有囉！\r\necho substr(\"abcdef\", -4, -2);  // 輸出 cd，因為程式先取得 cdef 這四個字元，再從其中的字尾開始扣掉兩個字元。\r\n```\r\n\r\n### 轉換字母大小寫\r\n\r\n#### `ucfirst` 將字串的首字母轉為大寫\r\n\r\n```php\r\n$foo = 'hello world!';\r\n$foo = ucfirst($foo);             // Hello world!\r\n```\r\n\r\n#### `strtolower` 將字串換為小寫\r\n\r\n```php\r\n$str = \"Mary Had A Little Lamb and She LOVED It So\";\r\n$str = strtolower($str);\r\n// mary had a little lamb and she loved it so\r\n```\r\n\r\n#### `strtoupper` 將字串換為大寫\r\n\r\n```php\r\n$str = \"Mary Had A Little Lamb and She LOVED It So\";\r\n$str = strtoupper($str);\r\n//  MARY HAD A LITTLE LAMB AND SHE LOVED IT SO\r\n```\r\n\r\n### `define` 定義一個常數\r\n\r\n- `define(name,value,case_insensitive)`\r\n\r\n- name 必須，規定常數的名稱。通常為全大寫 + 下划線。\r\n- value 必須，規定常數的值。\r\n- case_insensitive 必須，規定常數是否大小寫敏感，預設為 false : 大小寫敏感。\r\n\r\n- 常數類似變數，但常數在設定之後，其值無法改變，常數名不用 `$` 開頭，作用域不影響對常數的存取，其值只能是字串或數值\r\n\r\n## 在 Linux 執行 php 檔\r\n\r\n### 方法一\r\n\r\n- 在程式的第一行加入路徑 -q\r\n\r\n  ```php\r\n  #! /usr/bin/php -q\r\n  $foo = 123;\r\n  ```\r\n\r\n- 將 php 檔賦予執行權限\r\n\r\n  ```bash\r\n  chmod +x testing.php\r\n  ```\r\n\r\n- d/n\r\n\r\n  ```bash\r\n  ./testing.php # 可以像其他 shell script 般執行\r\n  ```\r\n","tocContent":"- [PHP 學習筆記](#php-學習筆記)\r\n  - [運算子、判斷](#運算子判斷)\r\n  - [Autoload 自動載入](#autoload-自動載入)\r\n  - [魔術常數](#魔術常數)\r\n    - [`__LINE__` 檔案中的當前行號](#__line__-檔案中的當前行號)\r\n    - [`__FILE__` 檔案的完整路徑和檔名](#__file__-檔案的完整路徑和檔名)\r\n    - [`__DIR__` 檔案所在的目錄](#__dir__-檔案所在的目錄)\r\n    - [`__FUNCTION__` 返回該函數被定義時的名字](#__function__-返回該函數被定義時的名字)\r\n    - [`__CLASS__` 返回類別名稱](#__class__-返回類別名稱)\r\n    - [`__TRAIT__` Trait 的名字](#__trait__-trait-的名字)\r\n    - [`__METHOD__` 類別的方法名稱，返回該方法被定義時的名字](#__method__-類別的方法名稱返回該方法被定義時的名字)\r\n    - [`__NAMESPACE__` 當前命名空間的名稱](#__namespace__-當前命名空間的名稱)\r\n  - [魔術方法](#魔術方法)\r\n    - [`__construct` 類別的構造函數](#__construct-類別的構造函數)\r\n    - [`__destruct` 類別的解構函數](#__destruct-類別的解構函數)\r\n    - [`__call` 在物件中呼叫一個不可訪問的方法時，呼叫此方法](#__call-在物件中呼叫一個不可訪問的方法時呼叫此方法)\r\n    - [`__callStatic` 用靜態方式呼叫一個不可訪問的方法時，呼叫此方法](#__callstatic-用靜態方式呼叫一個不可訪問的方法時呼叫此方法)\r\n    - [`__get` 獲取一個類別的成員變數時呼叫](#__get-獲取一個類別的成員變數時呼叫)\r\n    - [`__set` 設置一個類別的成員變數時呼叫](#__set-設置一個類別的成員變數時呼叫)\r\n    - [`__isset()` 當私有屬性呼叫 isset() 或 empty() 時呼叫此方法](#__isset-當私有屬性呼叫-isset-或-empty-時呼叫此方法)\r\n  - [方法](#方法)\r\n    - [`in_array()` 檢查陣列中是否包含特定的數值](#in_array-檢查陣列中是否包含特定的數值)\r\n    - [`foreach`](#foreach)\r\n    - [`scandir` 掃描指定的目錄，並返回為陣列](#scandir-掃描指定的目錄並返回為陣列)\r\n    - [`list` 宣告陣列中的值，使其成為變數](#list-宣告陣列中的值使其成為變數)\r\n    - [`append` 將傳入的值附加進陣列](#append-將傳入的值附加進陣列)\r\n    - [在陣列中新增元素](#在陣列中新增元素)\r\n      - [直接賦值](#直接賦值)\r\n      - [`array_push` 在陣列最後新增元素](#array_push-在陣列最後新增元素)\r\n      - [`array_unshift` 在陣列前端插入](#array_unshift-在陣列前端插入)\r\n    - [`array_fill` 以填充數值的方式，建立新陣列](#array_fill-以填充數值的方式建立新陣列)\r\n    - [`array_combine` 將傳入的參數合併為陣列](#array_combine-將傳入的參數合併為陣列)\r\n    - [`array_unique` 從陣列中刪除重複的值](#array_unique-從陣列中刪除重複的值)\r\n    - [`array_diff` 判斷陣列之間差異](#array_diff-判斷陣列之間差異)\r\n    - [`array_slice` 從陣列中取得一段連續的元素](#array_slice-從陣列中取得一段連續的元素)\r\n    - [日期/時間](#日期時間)\r\n      - [`date` 格式化 Unix timestamps](#date-格式化-unix-timestamps)\r\n      - [`mktime` 取得指定日期的時間戳](#mktime-取得指定日期的時間戳)\r\n      - [`date_diff` 獲取以分鐘為單位的時間差](#date_diff-獲取以分鐘為單位的時間差)\r\n    - [`sort` 陣列排序](#sort-陣列排序)\r\n      - [依 value 排序](#依-value-排序)\r\n      - [依 key 排序](#依-key-排序)\r\n      - [自訂排序](#自訂排序)\r\n    - [分割字串](#分割字串)\r\n      - [`explode`](#explode)\r\n      - [`str_split`](#str_split)\r\n      - [preg\\_split](#preg_split)\r\n    - [`array_slice` 從陣列中取出想要的元素](#array_slice-從陣列中取出想要的元素)\r\n    - [`implode` 將陣列轉為字串](#implode-將陣列轉為字串)\r\n    - [`array_filter` 過濾陣列元素(刪除陣列空值)](#array_filter-過濾陣列元素刪除陣列空值)\r\n    - [`str_pad` 填充字串為指定長度](#str_pad-填充字串為指定長度)\r\n    - [資料序列化及反序列化](#資料序列化及反序列化)\r\n      - [`string serialize` 序列化](#string-serialize-序列化)\r\n      - [`mixed unserialize` 反序列化](#mixed-unserialize-反序列化)\r\n    - [`file_get_contents` 將本地文件存入一個變數中](#file_get_contents-將本地文件存入一個變數中)\r\n    - [`str_pad` 補足字串](#str_pad-補足字串)\r\n    - [`str_replace` 替換字串](#str_replace-替換字串)\r\n    - [將字串轉換為數值](#將字串轉換為數值)\r\n    - [`is_a` 檢查物件是該類別，或該類別是此物件的父類別(boolean)](#is_a-檢查物件是該類別或該類別是此物件的父類別boolean)\r\n    - [`substr` 取得部分字串，可設定字串長度](#substr-取得部分字串可設定字串長度)\r\n    - [轉換字母大小寫](#轉換字母大小寫)\r\n      - [`ucfirst` 將字串的首字母轉為大寫](#ucfirst-將字串的首字母轉為大寫)\r\n      - [`strtolower` 將字串換為小寫](#strtolower-將字串換為小寫)\r\n      - [`strtoupper` 將字串換為大寫](#strtoupper-將字串換為大寫)\r\n    - [`define` 定義一個常數](#define-定義一個常數)\r\n  - [在 Linux 執行 php 檔](#在-linux-執行-php-檔)\r\n    - [方法一](#方法一)"}