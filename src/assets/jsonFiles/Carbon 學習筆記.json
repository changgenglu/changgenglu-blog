{"name":"Carbon 學習筆記.md","content":"# Carbon 學習筆記\r\n\r\n>\r\n\r\n> php 常用處理時間格式的套件\r\n>\r\n> 在 laravel 5.0 之後為預設套件\r\n>\r\n> 底層是使用 PHP `Datetime` 的 `strtotime` 方法\r\n>\r\n> ---\r\n>\r\n> 參考資料：\r\n>\r\n> [Carbon 使用技巧整理 (上)](https://reurl.cc/eWWbLm)\r\n>\r\n> [Carbon 使用技巧整理 (下)](https://reurl.cc/X55rGD)\r\n>\r\n> [Laravel 5 學習筆記 - Carbon 時間套件](https://www.kancloud.cn/kancloud/laravel-5-learning-notes/50163)\r\n\r\n## 物件建立\r\n\r\n### 建立當下時間\r\n\r\n```php\r\n$now = new Carbon();\r\n$now = Carbon::now();\r\n$now = new Carbon('first day of January 2022', 'America/Vancouver');  //  2022-01-01 00:00:00.0 America/Vancouver (-08:00)\r\n```\r\n\r\n- 直接建立可以解析文字，且指定時區\r\n\r\n### 解析並產生時間物件\r\n\r\n```php\r\nCarbon::parse('first day of December 2022');    // 2022-12-01 00:00:00.0 UTC (+00:00)\r\nCarbon::parse('2022/4/01');                     // 2022-04-01\r\nCarbon::parse('2022/04/01');                    // 2022-04-01\r\nCarbon::parse('2022-04-01');                    // 2022-04-01\r\n```\r\n\r\n### 依規則建立\r\n\r\n```php\r\nCarbon::create($year, $month, $day, $hour, $minute, $second, $tz);  // 通用變數順序\r\nCarbon::createFromDate($year, $month, $day, $tz);\r\nCarbon::createFromTime($hour, $minute, $second, $tz);\r\nCarbon::createFromTimeStamp('1601735792.198956');                   // 2020-10-03 14:36:32.198956\r\n```\r\n\r\n- 若傳入的資料不完整，亦能產生時間物件，預設為最小值\r\n- 也可以用 `parse` 的方式操作 `create`\r\n- 若不帶值，則會產生 `0001-01-01`\r\n\r\n```php\r\nCarbon::create($year, $month);  // 2020-10-03 00:00:00\r\nCarbon::create('2022/4/01');    // 2022-04-01 00:00:00.0\r\nCarbon::create();               // 0000-01-01\r\n```\r\n\r\n### Bug 與安全模式\r\n\r\n- `createFrom()` 其預設帶值的特性是取的當下時間，因此若在大月的月底使用，容易有跨月的問題\r\n\r\n```php\r\nCarbon::createFromDate(2022, 4);    // 未帶入的參數，會預設為當下的時間\r\n// 當下為 30 號：2022-04-30\r\n// 若為 31 號：2022-05-01\r\n```\r\n\r\n- 使用 `createSafe()` 安全模式建立，會幫忙檢查其合理性。若傳入不合法的數值，會回傳 Exception。\r\n\r\n```php\r\nCarbon::create(2022, 1, 35);        // 2022-02-04\r\nCarbon::createSafe(2022, 1, 35);    //  throw InvalidDateException\r\n```\r\n\r\n## 時間格式 時區、本地化\r\n\r\n|         單位          | 縮寫 |\r\n| :-------------------: | :--: |\r\n|      年(四位數)       |  Y   |\r\n|      年(二位數)       |  y   |\r\n|       月(英文)        |  F   |\r\n|     月(英文縮寫)      |  M   |\r\n|   月(補 0 至二位數)   |  m   |\r\n|   日(補 0 至二位數)   |  d   |\r\n|          日           |  j   |\r\n|      星期(英文)       |  l   |\r\n|    星期(英文縮寫)     |  D   |\r\n| 星期(英文縮寫 + 逗號) |  r   |\r\n|      星期(數字)       |  w   |\r\n|        時(24)         |  G   |\r\n|        時(12)         |  g   |\r\n| 時(24, 補 0 至二位數) |  H   |\r\n| 時(12, 補 0 至二位數) |  h   |\r\n|          分           |  i   |\r\n|          秒           |  s   |\r\n|         毫秒          |  S   |\r\n|         時區          |  e   |\r\n|         時區          |  T   |\r\n|         時差          |  P   |\r\n|        時間戳         |  U   |\r\n\r\n### 本地語系\r\n\r\n- Laravel 程式預設\r\n\r\n```php\r\n$date = Carbon::now()->locale('zh-tw');\r\n$date->diffForHumans();     // 1 秒前\r\n$date->monthName;           // 十一月\r\n$date->isoFormat('LLLL');   // 2022年11月17日星期四 02:01\r\n```\r\n\r\n- 手動設定\r\n\r\n```php\r\n// 通用設定\r\n$factory = new Factory([\r\n    'locale' => 'zh-tw',\r\n    'timezone' => 'Asia/Taipei'\r\n]);\r\n$factory->now();\r\n\r\n// 暫時設定\r\nCarbon:now()->settings([\r\n    'locale' => 'fr-FR',\r\n    'timezone' => 'Europe/Paris'\r\n]);\r\n```\r\n\r\n### Format\r\n\r\n```php\r\nCarbon::now()->format('Y-m-d H:m:s l');             // 2022-11-17 02:11:55 Thursday\r\nCarbon::now()->translatedFormat('Y-m-d H:m:s l');   // 2022-11-17 02:11:55 星期四\r\n```\r\n\r\n- 除了利用 `format()` 輸出時間格式，也可以使用 `toDateString()`, `toTimeString()`, `toISOString()` 等方法，將時間物件轉換成字串，亦有提供 `toArray()`, `toObject()` 方法。\r\n\r\n```php\r\nCarbon::hasFormat('2022-11-11', 'Y-m-d')                // true\r\nCarbon::hasFormat('2022~11~11', 'Y~m~d')                // true\r\nCarbon::hasFormatWithModifiers('2022-11-11', 'Y#m#d')   // true\r\nCarbon::hasFormatWithModifiers('2022/11/11', 'Y#m#d')   // true\r\nCarbon::hasFormatWithModifiers('2022~11~11', 'Y#m#d')   // false\r\n```\r\n\r\n- 利用 `hasFormat()` 來判斷 `format` 格式\r\n- `hasFormatWithModifiers()` 為模糊比對，可以用 `#` 區隔時間縮碼，可以同時判斷 `/`, `-`\r\n\r\n## Getter & Setter\r\n\r\n### 時間屬性\r\n\r\n```php\r\n$date = Carbon::parse('2022-02-28');\r\n$date->year;        // 2022\r\n$date->month;       // 2\r\n$date->dayOfYear;   // 59\r\n$date->dayOfMonth;  // 28\r\n```\r\n\r\n### 時間與語系\r\n\r\n- 判斷時間事件的語系有沒有符合應用程式，及有沒有使用 UTC 國際標準時區\r\n\r\n```php\r\nCarbon::now()->local;                       // bool(true)，檢查時區符合應用程式\r\nCarbon::now('America/Vancouver')->local;    // bool(false)\r\nCarbon::now()->utc;                         // bool(false)，檢查標準時區\r\n```\r\n\r\n### Setter\r\n\r\n- 直接依單位設定時間\r\n\r\n```php\r\n$date = Carbon::now();\r\n$date->setYear(2005);\r\n$date->year;           // 2005\r\n```\r\n\r\n```php\r\n$sourcel = new Carbon('2010-05-16 22:40:10.1');\r\n$date-> new Carbon('2001-01-01 01:01:01.2');\r\n$date->setTimeFrom($sourcel);   // 2001-01-01 22:40:10\r\n```\r\n\r\n- `setTimeFrom()` 保持日期，只設定時分秒\r\n- `setDateFrom()`\r\n- `setDateTimeFrom()`\r\n- **注意！以上作法不會改變時區**\r\n\r\n## 比較\r\n\r\n### 大於、小於和等於\r\n\r\n```php\r\n$first = Carbon::create(2022, 11, 11, 0, 0, 0);\r\n$second = Carbon::create(2022, 11, 11, 0, 0, 0, 'America/Vancouver'); // 時區設定\r\n\r\n$first->equalTo($second); // false\r\n$first->notEqualTo($second); // true\r\n```\r\n\r\n```php\r\n$first = Carbon::parse('2022-11-11 00:00:00');\r\n$second = Carbon::parse('2022-11-11 12:00:00');\r\n\r\n$first->greaterThan($second);           // false  大於\r\n$first->greaterThanOrEqualTo($second);  // false 大於等於\r\n$first->gt($second);                    // 可以使用縮寫\r\n$first->gte($second);\r\n$first >= $second;                      // 也可以使用運算式\r\n\r\n$first->lessThan($second);              // true  小於\r\n$first->lessThanOrEqualTo($second);     // true 小於等於\r\n$first->lt($second);\r\n$first->lte($second);\r\n$first <= $second;\r\n\r\n$first>equalTo($second);                // false 等於\r\n$first>notEqualTo($second);             // true 不等於\r\n```\r\n\r\n### 之間、最小最大與最近最遠\r\n\r\n```php\r\n$first = Carbon::parse('2022-11-11');\r\n$second = Carbon::parse('2022-11-15');\r\n$data = Carbon::parse('2022-11-15');\r\n$data->between($first, $second);        // true\r\n$data->between($first, $second, false); // 嚴格模式 false\r\n```\r\n\r\n```php\r\n$first = Carbon::parse('2022-11-11');\r\n$second = Carbon::parse('2022-11-15');\r\n\r\n$first->min($second);   // '2022-11-11'\r\n$first->max($second);   // '2022-11-15'\r\n\r\n$data = Carbon::parse('2022-11-14');\r\n$data->closest($first, $second);    // 2022-11-15\r\n$data->farthest($first, $second);   // 2022-11-11\r\n```\r\n\r\n- `closest` 和 `farthest` 函式可以找出兩個時間物件中，與特定時間物件最接近或最遙遠的物件\r\n\r\n### 和今天比較\r\n\r\n```php\r\n// 假設今天是 2022-11-10\r\n$date = Carbon::parse('2022-11-11');\r\n\r\n$date->isSameWeek();    // true\r\n$date->isSameMonth();   // true\r\n$date->isCurrentDay();  // false\r\n```\r\n\r\n- 另外還有 `isMonday()` `isTomorrow()` `isToday()`，`isBirthday()` 可以判斷是否為不同年的同一天\r\n\r\n## 時間運算\r\n\r\n**重要觀念**：carbon 物件在運算過程中會改變原始物件，因此在運算之前要加上 `copy()` 語法。\r\n\r\n```php\r\n$date = Carbon::create(2022, 11, 11);\r\n$date->copy()->addDay();    // 2022-11-12\r\n// 複數運算，時間單位要加上 s\r\n$date->addDays(2);          // 2022-11-13\r\nprint_r($date);             // 2022-11-13\r\n\r\n$date->copy()->subDay(); // 2022-11-12\r\n```\r\n\r\n### Overflow 溢出\r\n\r\n```php\r\n$date = Carbon::create(2022, 1, 31);\r\n$date->copy()->addMonth(); // 2022-03-03\r\n```\r\n\r\n- 一般而言，加上一個月後應該要是二月底(2/28 或 2/29)，為避免不合理的狀況發生，須加上 `NoOverflow` 關鍵字，讓運算結果不會溢出\r\n\r\n```php\r\n$date = Carbon::create(2022, 1, 31);\r\n$date->copy()->addMonthNoOverflow(); // 2022-02-28\r\n$date->copy()->subMonthNoOverflow(2); // 2022-11-30\r\n```\r\n\r\n另外亦可以使用 `addUnitNoOverflow` 針對溢出的單位做控管，也可以在設定值，規定不可以溢出\r\n\r\n```php\r\n$date = Carbon::parse('2022-01-31');\r\n\r\n// UnitNoOverflow(運算單位，值，限制防溢出單位)\r\n$date->copy()->addUnitNoOverflow('hour', 7, 'day') // 07:00\r\n$date->copy()->addUnitNoOverflow('hour', 48, 'day') // 23:59\r\n\r\nCarbon::parse('2022-02-01')->copy()->setUnitNoOverflow('day', 31, 'month'); // 2022-02-28\r\n```\r\n\r\n## 差異\r\n\r\n### 一般差異\r\n\r\n- 無條件捨去，滿一個時間單位，才會回傳 1\r\n\r\n```php\r\n$date->diffInMinths($date->copy()->addMonthNoOverflow()); // 1\r\n```\r\n\r\n- 除了整數的差異，也可以比對到小數點單位的時間差\r\n\r\n```php\r\nCarbon::parse('06:01:23')->floatDiffInminutes('06:02:34');              // 1.1833\r\nCarbon::parse('2022-01-01 12:00')->floatDiffInDays('2022-02-11 06:00')  // 40.75\r\n```\r\n\r\n- 不建議用做計算月份，會有 bug\r\n\r\n```php\r\nCarbon::parse('2022-01-31')->floatDiffInmonthss('2022-03-01');\r\n// 一般而言應回傳 1.xx，但實際回傳 0.9xx 因為跨到二月不足三十天\r\n```\r\n\r\n### Real Difference\r\n\r\n```php\r\n$date = new Carbon('2014-03-30 00:00:00', 'Europe/London');]\r\n$date->addRealHours(25);      // 2014-03-31 02:00:00.0 Europe/London (+01:00)\r\n\r\n$date->diffInRealHours('2014-03-30 00:00:00');  // 25\r\n$date->diffInHours('2014-03-30 00:00:00');      // 26\r\n```\r\n\r\n- 運算時，若出現跨日的情形，時間物件的時區會自動針對該值做增減，而在比較兩個時間點的差異時，若未用 `real` 則會計算出表面的時間差。\r\n\r\n## 口語化修改器\r\n\r\n```php\r\n$date = Carbon::parse('2022-11-11 12:00:00');\r\n$date->startOfDay();    // 2022-11-11 00:00:00\r\n$date->endOfDay();      // 2022-11-11 23:59:59\r\n\r\n$date->startOfMonth();  // 2022-11-01 00:00:00\r\n$date->endOfMonth();    // 2022-11-30 23:59:59\r\n```\r\n\r\n- 亦支援 `today()`, `yesterday()`, `next()`\r\n","tocContent":"- [Carbon 學習筆記](#carbon-學習筆記)\r\n  - [物件建立](#物件建立)\r\n    - [建立當下時間](#建立當下時間)\r\n    - [解析並產生時間物件](#解析並產生時間物件)\r\n    - [依規則建立](#依規則建立)\r\n    - [Bug 與安全模式](#bug-與安全模式)\r\n  - [時間格式 時區、本地化](#時間格式-時區本地化)\r\n    - [本地語系](#本地語系)\r\n    - [Format](#format)\r\n  - [Getter \\& Setter](#getter--setter)\r\n    - [時間屬性](#時間屬性)\r\n    - [時間與語系](#時間與語系)\r\n    - [Setter](#setter)\r\n  - [比較](#比較)\r\n    - [大於、小於和等於](#大於小於和等於)\r\n    - [之間、最小最大與最近最遠](#之間最小最大與最近最遠)\r\n    - [和今天比較](#和今天比較)\r\n  - [時間運算](#時間運算)\r\n    - [Overflow 溢出](#overflow-溢出)\r\n  - [差異](#差異)\r\n    - [一般差異](#一般差異)\r\n    - [Real Difference](#real-difference)\r\n  - [口語化修改器](#口語化修改器)"}