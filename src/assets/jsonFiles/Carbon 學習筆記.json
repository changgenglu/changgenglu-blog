{"name":"Carbon 學習筆記.md","content":"# Carbon 學習筆記\n\n>\n\n> php 常用處理時間格式的套件\n>\n> 在 laravel 5.0 之後為預設套件\n>\n> 底層是使用 PHP `Datetime` 的 `strtotime` 方法\n>\n> ---\n>\n> 參考資料：\n>\n> [Carbon 使用技巧整理 (上)](https://reurl.cc/eWWbLm)\n>\n> [Carbon 使用技巧整理 (下)](https://reurl.cc/X55rGD)\n>\n> [Laravel 5 學習筆記 - Carbon 時間套件](https://www.kancloud.cn/kancloud/laravel-5-learning-notes/50163)\n\n## 物件建立\n\n### 建立當下時間\n\n```php\n$now = new Carbon();\n$now = Carbon::now();\n$now = new Carbon('first day of January 2022', 'America/Vancouver');  //  2022-01-01 00:00:00.0 America/Vancouver (-08:00)\n```\n\n- 直接建立可以解析文字，且指定時區\n\n### 解析並產生時間物件\n\n```php\nCarbon::parse('first day of December 2022');    // 2022-12-01 00:00:00.0 UTC (+00:00)\nCarbon::parse('2022/4/01');                     // 2022-04-01\nCarbon::parse('2022/04/01');                    // 2022-04-01\nCarbon::parse('2022-04-01');                    // 2022-04-01\n```\n\n### 依規則建立\n\n```php\nCarbon::create($year, $month, $day, $hour, $minute, $second, $tz);  // 通用變數順序\nCarbon::createFromDate($year, $month, $day, $tz);\nCarbon::createFromTime($hour, $minute, $second, $tz);\nCarbon::createFromTimeStamp('1601735792.198956');                   // 2020-10-03 14:36:32.198956\n```\n\n- 若傳入的資料不完整，亦能產生時間物件，預設為最小值\n- 也可以用 `parse` 的方式操作 `create`\n- 若不帶值，則會產生 `0001-01-01`\n\n```php\nCarbon::create($year, $month);  // 2020-10-03 00:00:00\nCarbon::create('2022/4/01');    // 2022-04-01 00:00:00.0\nCarbon::create();               // 0000-01-01\n```\n\n### Bug 與安全模式\n\n- `createFrom()` 其預設帶值的特性是取的當下時間，因此若在大月的月底使用，容易有跨月的問題\n\n```php\nCarbon::createFromDate(2022, 4);    // 未帶入的參數，會預設為當下的時間\n// 當下為 30 號：2022-04-30\n// 若為 31 號：2022-05-01\n```\n\n- 使用 `createSafe()` 安全模式建立，會幫忙檢查其合理性。若傳入不合法的數值，會回傳 Exception。\n\n```php\nCarbon::create(2022, 1, 35);        // 2022-02-04\nCarbon::createSafe(2022, 1, 35);    //  throw InvalidDateException\n```\n\n## 時間格式 時區、本地化\n\n|         單位          | 縮寫 |\n| :-------------------: | :--: |\n|      年(四位數)       |  Y   |\n|      年(二位數)       |  y   |\n|       月(英文)        |  F   |\n|     月(英文縮寫)      |  M   |\n|   月(補 0 至二位數)   |  m   |\n|   日(補 0 至二位數)   |  d   |\n|          日           |  j   |\n|      星期(英文)       |  l   |\n|    星期(英文縮寫)     |  D   |\n| 星期(英文縮寫 + 逗號) |  r   |\n|      星期(數字)       |  w   |\n|        時(24)         |  G   |\n|        時(12)         |  g   |\n| 時(24, 補 0 至二位數) |  H   |\n| 時(12, 補 0 至二位數) |  h   |\n|          分           |  i   |\n|          秒           |  s   |\n|         毫秒          |  S   |\n|         時區          |  e   |\n|         時區          |  T   |\n|         時差          |  P   |\n|        時間戳         |  U   |\n\n### 本地語系\n\n- Laravel 程式預設\n\n```php\n$date = Carbon::now()->locale('zh-tw');\n$date->diffForHumans();     // 1 秒前\n$date->monthName;           // 十一月\n$date->isoFormat('LLLL');   // 2022年11月17日星期四 02:01\n```\n\n- 手動設定\n\n```php\n// 通用設定\n$factory = new Factory([\n    'locale' => 'zh-tw',\n    'timezone' => 'Asia/Taipei'\n]);\n$factory->now();\n\n// 暫時設定\nCarbon:now()->settings([\n    'locale' => 'fr-FR',\n    'timezone' => 'Europe/Paris'\n]);\n```\n\n### Format\n\n```php\nCarbon::now()->format('Y-m-d H:m:s l');             // 2022-11-17 02:11:55 Thursday\nCarbon::now()->translatedFormat('Y-m-d H:m:s l');   // 2022-11-17 02:11:55 星期四\n```\n\n- 除了利用 `format()` 輸出時間格式，也可以使用 `toDateString()`, `toTimeString()`, `toISOString()` 等方法，將時間物件轉換成字串，亦有提供 `toArray()`, `toObject()` 方法。\n\n```php\nCarbon::hasFormat('2022-11-11', 'Y-m-d')                // true\nCarbon::hasFormat('2022~11~11', 'Y~m~d')                // true\nCarbon::hasFormatWithModifiers('2022-11-11', 'Y#m#d')   // true\nCarbon::hasFormatWithModifiers('2022/11/11', 'Y#m#d')   // true\nCarbon::hasFormatWithModifiers('2022~11~11', 'Y#m#d')   // false\n```\n\n- 利用 `hasFormat()` 來判斷 `format` 格式\n- `hasFormatWithModifiers()` 為模糊比對，可以用 `#` 區隔時間縮碼，可以同時判斷 `/`, `-`\n\n## Getter & Setter\n\n### 時間屬性\n\n```php\n$date = Carbon::parse('2022-02-28');\n$date->year;        // 2022\n$date->month;       // 2\n$date->dayOfYear;   // 59\n$date->dayOfMonth;  // 28\n```\n\n### 時間與語系\n\n- 判斷時間事件的語系有沒有符合應用程式，及有沒有使用 UTC 國際標準時區\n\n```php\nCarbon::now()->local;                       // bool(true)，檢查時區符合應用程式\nCarbon::now('America/Vancouver')->local;    // bool(false)\nCarbon::now()->utc;                         // bool(false)，檢查標準時區\n```\n\n### Setter\n\n- 直接依單位設定時間\n\n```php\n$date = Carbon::now();\n$date->setYear(2005);\n$date->year;           // 2005\n```\n\n```php\n$sourcel = new Carbon('2010-05-16 22:40:10.1');\n$date-> new Carbon('2001-01-01 01:01:01.2');\n$date->setTimeFrom($sourcel);   // 2001-01-01 22:40:10\n```\n\n- `setTimeFrom()` 保持日期，只設定時分秒\n- `setDateFrom()`\n- `setDateTimeFrom()`\n- **注意！以上作法不會改變時區**\n\n## 比較\n\n### 大於、小於和等於\n\n```php\n$first = Carbon::create(2022, 11, 11, 0, 0, 0);\n$second = Carbon::create(2022, 11, 11, 0, 0, 0, 'America/Vancouver'); // 時區設定\n\n$first->equalTo($second); // false\n$first->notEqualTo($second); // true\n```\n\n```php\n$first = Carbon::parse('2022-11-11 00:00:00');\n$second = Carbon::parse('2022-11-11 12:00:00');\n\n$first->greaterThan($second);           // false  大於\n$first->greaterThanOrEqualTo($second);  // false 大於等於\n$first->gt($second);                    // 可以使用縮寫\n$first->gte($second);\n$first >= $second;                      // 也可以使用運算式\n\n$first->lessThan($second);              // true  小於\n$first->lessThanOrEqualTo($second);     // true 小於等於\n$first->lt($second);\n$first->lte($second);\n$first <= $second;\n\n$first>equalTo($second);                // false 等於\n$first>notEqualTo($second);             // true 不等於\n```\n\n### 之間、最小最大與最近最遠\n\n```php\n$first = Carbon::parse('2022-11-11');\n$second = Carbon::parse('2022-11-15');\n$data = Carbon::parse('2022-11-15');\n$data->between($first, $second);        // true\n$data->between($first, $second, false); // 嚴格模式 false\n```\n\n```php\n$first = Carbon::parse('2022-11-11');\n$second = Carbon::parse('2022-11-15');\n\n$first->min($second);   // '2022-11-11'\n$first->max($second);   // '2022-11-15'\n\n$data = Carbon::parse('2022-11-14');\n$data->closest($first, $second);    // 2022-11-15\n$data->farthest($first, $second);   // 2022-11-11\n```\n\n- `closest` 和 `farthest` 函式可以找出兩個時間物件中，與特定時間物件最接近或最遙遠的物件\n\n### 和今天比較\n\n```php\n// 假設今天是 2022-11-10\n$date = Carbon::parse('2022-11-11');\n\n$date->isSameWeek();    // true\n$date->isSameMonth();   // true\n$date->isCurrentDay();  // false\n```\n\n- 另外還有 `isMonday()` `isTomorrow()` `isToday()`，`isBirthday()` 可以判斷是否為不同年的同一天\n\n## 時間運算\n\n**重要觀念**：carbon 物件在運算過程中會改變原始物件，因此在運算之前要加上 `copy()` 語法。\n\n```php\n$date = Carbon::create(2022, 11, 11);\n$date->copy()->addDay();    // 2022-11-12\n// 複數運算，時間單位要加上 s\n$date->addDays(2);          // 2022-11-13\nprint_r($date);             // 2022-11-13\n\n$date->copy()->subDay(); // 2022-11-12\n```\n\n### Overflow 溢出\n\n```php\n$date = Carbon::create(2022, 1, 31);\n$date->copy()->addMonth(); // 2022-03-03\n```\n\n- 一般而言，加上一個月後應該要是二月底(2/28 或 2/29)，為避免不合理的狀況發生，須加上 `NoOverflow` 關鍵字，讓運算結果不會溢出\n\n```php\n$date = Carbon::create(2022, 1, 31);\n$date->copy()->addMonthNoOverflow(); // 2022-02-28\n$date->copy()->subMonthNoOverflow(2); // 2022-11-30\n```\n\n另外亦可以使用 `addUnitNoOverflow` 針對溢出的單位做控管，也可以在設定值，規定不可以溢出\n\n```php\n$date = Carbon::parse('2022-01-31');\n\n// UnitNoOverflow(運算單位，值，限制防溢出單位)\n$date->copy()->addUnitNoOverflow('hour', 7, 'day') // 07:00\n$date->copy()->addUnitNoOverflow('hour', 48, 'day') // 23:59\n\nCarbon::parse('2022-02-01')->copy()->setUnitNoOverflow('day', 31, 'month'); // 2022-02-28\n```\n\n## 差異\n\n### 一般差異\n\n- 無條件捨去，滿一個時間單位，才會回傳 1\n\n```php\n$date->diffInMinths($date->copy()->addMonthNoOverflow()); // 1\n```\n\n- 除了整數的差異，也可以比對到小數點單位的時間差\n\n```php\nCarbon::parse('06:01:23')->floatDiffInminutes('06:02:34');              // 1.1833\nCarbon::parse('2022-01-01 12:00')->floatDiffInDays('2022-02-11 06:00')  // 40.75\n```\n\n- 不建議用做計算月份，會有 bug\n\n```php\nCarbon::parse('2022-01-31')->floatDiffInmonthss('2022-03-01');\n// 一般而言應回傳 1.xx，但實際回傳 0.9xx 因為跨到二月不足三十天\n```\n\n### Real Difference\n\n```php\n$date = new Carbon('2014-03-30 00:00:00', 'Europe/London');]\n$date->addRealHours(25);      // 2014-03-31 02:00:00.0 Europe/London (+01:00)\n\n$date->diffInRealHours('2014-03-30 00:00:00');  // 25\n$date->diffInHours('2014-03-30 00:00:00');      // 26\n```\n\n- 運算時，若出現跨日的情形，時間物件的時區會自動針對該值做增減，而在比較兩個時間點的差異時，若未用 `real` 則會計算出表面的時間差。\n\n## 口語化修改器\n\n```php\n$date = Carbon::parse('2022-11-11 12:00:00');\n$date->startOfDay();    // 2022-11-11 00:00:00\n$date->endOfDay();      // 2022-11-11 23:59:59\n\n$date->startOfMonth();  // 2022-11-01 00:00:00\n$date->endOfMonth();    // 2022-11-30 23:59:59\n```\n\n- 亦支援 `today()`, `yesterday()`, `next()`\n","tocContent":"- [Carbon 學習筆記](#carbon-學習筆記)\n  - [物件建立](#物件建立)\n    - [建立當下時間](#建立當下時間)\n    - [解析並產生時間物件](#解析並產生時間物件)\n    - [依規則建立](#依規則建立)\n    - [Bug 與安全模式](#bug-與安全模式)\n  - [時間格式 時區、本地化](#時間格式-時區本地化)\n    - [本地語系](#本地語系)\n    - [Format](#format)\n  - [Getter \\& Setter](#getter--setter)\n    - [時間屬性](#時間屬性)\n    - [時間與語系](#時間與語系)\n    - [Setter](#setter)\n  - [比較](#比較)\n    - [大於、小於和等於](#大於小於和等於)\n    - [之間、最小最大與最近最遠](#之間最小最大與最近最遠)\n    - [和今天比較](#和今天比較)\n  - [時間運算](#時間運算)\n    - [Overflow 溢出](#overflow-溢出)\n  - [差異](#差異)\n    - [一般差異](#一般差異)\n    - [Real Difference](#real-difference)\n  - [口語化修改器](#口語化修改器)"}